<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="gs-app-id" content="labelkeeper">
<meta name="version" content="1.0.0">
<title>LabelKeeper</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>

  * { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #e4e4de; --surface: #eeeee8; --surface-alt: #e8e8e2;
    --text: #2a2a2a; --text-secondary: #4a4a4a; --text-muted: #777; --text-faint: #aaa;
    --border: #c8c8c0; --border-light: #d8d8d0;
    --input-bg: #f4f4ee; --input-border: #b8b8b0;
    --heading: #141414;
    --accent: #2563eb; --accent-hover: #1d4ed8; --accent-bg: #dce6f8; --accent-text: #1e52c0;
    --accent-soft: #c8d8f0;
    --success-bg: #d8f0e6; --success-text: #047a56; --success-border: #90dbb8;
    --warning-bg: #f0e8d0; --warning-text: #b86b00; --warning-border: #e0c878;
    --error-bg: #f0dada; --error-text: #c02020; --error-border: #e0a8a8;
    --danger: #dc2626; --danger-hover: #b91c1c; --danger-bg: #f0dada;
    --queue-item-bg: #e6eaf4;
    --cell-bg: #eeeee8; --cell-queued-bg: #dce6f8;
    --cell-printed-bg: #dcdcd6; --cell-printed-border: #c0c0b8; --cell-printed-text: #999;
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.10);
    --shadow: 0 2px 8px rgba(0,0,0,0.10);
    --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
    --tab-inactive: #777; --tab-hover-bg: rgba(0,0,0,0.06);
    --card-hover: #e6e6e0;
    --preview-bg: #f6f6f0; --preview-border: #aaa; --preview-text: #000;
    --align-btn-bg: #e4e4de; --align-btn-active: #2563eb; --align-btn-active-text: #fff; --align-btn-text: #555;
    --saved-card-bg: #e8e8e2; --saved-card-border: #c8c8c0; --saved-card-hover: #e0e0da;
    --type-card-bg: #e8e8e2; --type-card-border: #c8c8c0; --type-card-active: #2563eb;
    --banner-plenty-bg: #d8f0e6; --banner-plenty-text: #047a56;
    --banner-low-bg: #f0e8d0; --banner-low-text: #b86b00;
    --banner-empty-bg: #f0dada; --banner-empty-text: #c02020;
    --toggle-bg: #b8b8b0; --toggle-active: #2563eb;
    --mono: 'JetBrains Mono', monospace;
  }

  [data-theme="dark"] {
    --bg: #0c0c10; --surface: #1e1e26; --surface-alt: #171720;
    --text: #eaeaee; --text-secondary: #c4c4cc; --text-muted: #9e9eac; --text-faint: #747484;
    --border: #52526a; --border-light: #44445a;
    --input-bg: #262630; --input-border: #5e5e72;
    --heading: #f8f8fc;
    --accent: #6c9eff; --accent-hover: #90b8ff; --accent-bg: #1c2c52; --accent-text: #90b8ff;
    --accent-soft: #283c68;
    --success-bg: #14302a; --success-text: #5cf0c0; --success-border: #208868;
    --warning-bg: #382e14; --warning-text: #ffd85c; --warning-border: #c07820;
    --error-bg: #3a1c1c; --error-text: #ffa0a0; --error-border: #dd3838;
    --danger: #ffa0a0; --danger-hover: #ffc8c8; --danger-bg: rgba(255,120,120,0.18);
    --queue-item-bg: #262630;
    --cell-bg: #2e2e3c; --cell-queued-bg: #1c2c52;
    --cell-printed-bg: #16161e; --cell-printed-border: #42425a; --cell-printed-text: #606078;
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.5);
    --shadow: 0 3px 12px rgba(0,0,0,0.5);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.6);
    --tab-inactive: #9e9eac; --tab-hover-bg: rgba(255,255,255,0.08);
    --card-hover: #2c2c3a;
    --preview-bg: #fff; --preview-border: #888; --preview-text: #000;
    --align-btn-bg: #2e2e3c; --align-btn-active: #6c9eff; --align-btn-active-text: #fff; --align-btn-text: #c4c4cc;
    --saved-card-bg: #1e1e26; --saved-card-border: #52526a; --saved-card-hover: #32323e;
    --type-card-bg: #2e2e3c; --type-card-border: #52526a; --type-card-active: #6c9eff;
    --banner-plenty-bg: #14302a; --banner-plenty-text: #5cf0c0;
    --banner-low-bg: #382e14; --banner-low-text: #ffd85c;
    --banner-empty-bg: #3a1c1c; --banner-empty-text: #ffa0a0;
    --toggle-bg: #52526a; --toggle-active: #6c9eff;
  }

  body {
    font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg); color: var(--text);
    transition: background 0.3s, color 0.3s;
    min-height: 100vh;
  }

  /* ===== APP SHELL ===== */
  .app-shell { max-width: 1060px; margin: 0 auto; padding: 16px 20px; }

  .app-topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 0 16px; margin-bottom: 0;
  }
  .app-title {
    font-size: 20px; font-weight: 700; color: var(--heading);
    display: flex; align-items: center; gap: 8px; letter-spacing: -0.02em;
  }
  .app-title .version { font-size: 12px; font-weight: 500; color: var(--text-muted); font-family: var(--mono); }

  .topbar-actions { display: flex; align-items: center; gap: 12px; }

  /* Hamburger menu */
  .hamburger-menu { position: relative; }
  .hamburger-btn {
    background: none; border: 2px solid var(--border); border-radius: 8px;
    width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center;
    justify-content: center; font-size: 20px; color: var(--text-secondary);
    transition: all 0.15s;
  }
  .hamburger-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
  .hamburger-dropdown {
    display: none; position: absolute; top: 100%; right: 0; margin-top: 6px;
    background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
    box-shadow: var(--shadow-lg); min-width: 220px; z-index: 200; overflow: hidden;
  }
  .hamburger-dropdown.visible { display: block; }
  .hamburger-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; cursor: pointer; font-size: 14px; font-weight: 500;
    color: var(--text); transition: background 0.1s; border: none; background: none;
    width: 100%; font-family: inherit; text-align: left; gap: 10px;
  }
  .hamburger-item:hover { background: var(--accent-bg); color: var(--accent-text); }
  .hamburger-item + .hamburger-item { border-top: 1px solid var(--border-light); }
  .hamburger-item-label { display: flex; align-items: center; gap: 8px; }
  .hamburger-item .toggle-track {
    width: 38px; height: 22px; background: var(--toggle-bg); border-radius: 11px;
    position: relative; transition: background 0.3s; flex-shrink: 0;
  }
  .hamburger-item .toggle-track.active { background: var(--toggle-active); }
  .hamburger-item .toggle-track .toggle-thumb {
    width: 16px; height: 16px; background: #fff; border-radius: 50%;
    position: absolute; top: 3px; left: 3px; transition: transform 0.3s;
    display: flex; align-items: center; justify-content: center; font-size: 10px;
  }
  .hamburger-item .toggle-track.active .toggle-thumb { transform: translateX(16px); }

  /* ===== TAB BAR ===== */
  .tab-bar {
    display: flex; gap: 0; border-bottom: 2px solid var(--border);
    margin-bottom: 24px; position: relative;
  }
  .tab-btn {
    padding: 14px 22px; border: none; background: none;
    font-family: inherit; font-size: 16px; font-weight: 600;
    color: var(--tab-inactive); cursor: pointer;
    position: relative; transition: color 0.2s, background 0.2s;
    display: flex; align-items: center; gap: 8px;
    border-radius: 8px 8px 0 0;
  }
  .tab-btn:hover { color: var(--text); background: var(--tab-hover-bg); }
  .tab-btn.active { color: var(--accent); }
  .tab-btn.active::after {
    content: ''; position: absolute; bottom: -2px; left: 0; right: 0;
    height: 2px; background: var(--accent); border-radius: 1px 1px 0 0;
  }
  .tab-meta {
    font-size: 13px; font-weight: 600; color: var(--text-muted);
    max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .tab-btn.active .tab-meta { color: var(--accent-text); opacity: 0.7; }
  .tab-badge {
    background: var(--accent); color: #fff; font-size: 12px; font-weight: 700;
    min-width: 22px; height: 22px; border-radius: 11px;
    display: inline-flex; align-items: center; justify-content: center; padding: 0 6px;
  }
  .tab-badge.empty { background: var(--text-faint); }
  .tab-badge.pulse { animation: badgePulse 0.4s ease; }
  @keyframes badgePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); }
    100% { transform: scale(1); }
  }

  /* ===== TAB PANELS ===== */
  .tab-panel { display: none; animation: fadeIn 0.25s ease; }
  .tab-panel.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  /* ===== SHEETS TAB ===== */
  .sheets-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .sheets-col-header {
    font-size: 15px; font-weight: 700; color: var(--heading);
    text-transform: uppercase; letter-spacing: 0.06em;
    margin-bottom: 14px; display: flex; align-items: center; justify-content: space-between;
  }

  .sheet-cards { display: flex; flex-direction: column; gap: 10px; }
  .sheet-card {
    padding: 16px 18px; border: 2px solid var(--border); border-radius: 10px;
    background: var(--surface); cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; gap: 14px;
    box-shadow: var(--shadow);
  }
  .sheet-card:hover { background: var(--card-hover); border-color: var(--accent); }
  .sheet-card.active { border-color: var(--accent); background: var(--accent-bg); box-shadow: 0 0 0 2px var(--accent); }
  .sheet-card-info { flex: 1; min-width: 0; }
  .sheet-card-name {
    font-size: 17px; font-weight: 700; color: var(--heading);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .sheet-card-detail { font-size: 14px; color: var(--text-secondary); margin-top: 4px; }
  .sheet-card-detail strong { color: var(--heading); font-weight: 700; }
  .sheet-card-progress {
    width: 48px; height: 48px; flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  .sheet-card-progress svg { transform: rotate(-90deg); }
  .sheet-card-progress .progress-text {
    position: absolute; font-size: 12px; font-weight: 700; color: var(--heading);
    font-family: var(--mono);
  }
  .sheet-card-actions {
    display: flex; flex-direction: column; gap: 2px; flex-shrink: 0; opacity: 0;
    transition: opacity 0.15s;
  }
  .sheet-card:hover .sheet-card-actions { opacity: 1; }
  .sheet-card-action {
    background: none; border: none; font-size: 12px; cursor: pointer;
    padding: 3px 6px; border-radius: 4px; color: var(--text-muted);
    transition: all 0.15s;
  }
  .sheet-card-action:hover { background: var(--accent-bg); color: var(--accent); }
  .sheet-card-action.danger:hover { background: var(--danger-bg); color: var(--danger); }

  .new-sheet-card {
    padding: 16px; border: 3px dashed var(--border); border-radius: 10px;
    background: none; cursor: pointer; transition: all 0.15s;
    font-family: inherit; font-size: 15px; font-weight: 600;
    color: var(--accent-text); display: flex; align-items: center;
    justify-content: center; gap: 6px; width: 100%;
  }
  .new-sheet-card:hover { border-color: var(--accent); background: var(--accent-bg); }
  .new-text-card {
    padding: 14px; border: 3px dashed var(--border); border-radius: 10px;
    background: none; cursor: pointer; transition: all 0.15s;
    font-family: inherit; font-size: 14px; font-weight: 600;
    color: var(--accent-text); display: flex; align-items: center;
    justify-content: center; gap: 6px; width: 100%; margin-top: 8px;
  }
  .new-text-card:hover { border-color: var(--accent); background: var(--accent-bg); }

  .sheet-map-container {
    background: var(--surface); border-radius: 12px; padding: 18px;
    border: 2px solid var(--border); transition: background 0.3s;
    box-shadow: var(--shadow);
  }
  .sheet-map-header {
    font-size: 15px; font-weight: 700; color: var(--heading);
    margin-bottom: 4px; display: flex; align-items: center; justify-content: space-between;
  }
  .sheet-map-sub { font-size: 13px; color: var(--text-secondary); margin-bottom: 14px; }

  /* Shared grid + cell styles (used in sheets & print tabs) */
  .label-grid { display: grid; gap: 5px; }
  .label-cell {
    background: var(--cell-bg); border: 2px solid var(--border);
    border-radius: 5px; display: flex; flex-direction: column;
    align-items: center; justify-content: center; position: relative;
    overflow: hidden; font-size: 9px; transition: all 0.15s; min-height: 22px;
    box-shadow: var(--shadow-sm);
  }
  .label-cell.printed {
    background: var(--cell-printed-bg); border-color: var(--cell-printed-border);
    color: var(--cell-printed-text); opacity: 0.6; box-shadow: none;
    cursor: pointer;
  }
  .label-cell.printed:hover {
    opacity: 0.85; border-color: var(--accent); border-style: dashed;
  }
  .label-cell.queued {
    background: var(--cell-queued-bg); border: 2.5px dashed var(--accent);
  }
  .label-number { font-size: 9px; font-weight: 700; color: var(--text-secondary); font-family: var(--mono); }
  .printed-badge { font-size: 10px; color: var(--cell-printed-text); font-weight: 700; }
  .label-text { font-size: 9px; color: inherit; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90%; }
  .empty-state { font-size: 8px; color: var(--text-muted); font-weight: 600; }
  [class*="cell-color-"] .label-number { color: inherit; opacity: 0.7; }
  [class*="cell-color-"] .label-text { color: inherit; }

  .remaining-bar {
    margin-top: 16px; padding: 14px 18px; border-radius: 8px;
    font-size: 16px; font-weight: 700; display: flex; align-items: center; gap: 10px;
    border: 2px solid transparent;
  }
  .remaining-bar.plenty { background: var(--banner-plenty-bg); color: var(--banner-plenty-text); border-color: var(--success-border); }
  .remaining-bar.low { background: var(--banner-low-bg); color: var(--banner-low-text); border-color: var(--warning-border); }
  .remaining-bar.empty { background: var(--banner-empty-bg); color: var(--banner-empty-text); border-color: var(--error-border); }
  .remaining-bar .count { font-size: 24px; font-family: var(--mono); }

  .legend { display: flex; gap: 16px; margin-top: 14px; }
  .legend-item { display: flex; align-items: center; gap: 6px; font-size: 13px; font-weight: 600; color: var(--text-secondary); }
  .legend-swatch { width: 18px; height: 12px; border-radius: 3px; border: 2px solid var(--border); }
  .legend-swatch.available { background: var(--cell-bg); }
  .legend-swatch.queued { background: var(--cell-queued-bg); border: 2px dashed var(--accent); }
  .legend-swatch.printed { background: var(--cell-printed-bg); border-color: var(--cell-printed-border); opacity: 0.55; }

  .no-sheet-selected {
    text-align: center; padding: 40px 20px; color: var(--text-muted); font-size: 15px;
  }
  .no-sheet-selected .icon { font-size: 36px; margin-bottom: 10px; display: block; }

  /* ===== LABELS TAB ===== */
  .labels-layout { display: grid; grid-template-columns: 3fr 2fr; gap: 20px; }

  .compose-panel { display: flex; flex-direction: column; gap: 12px; }
  .panel-section {
    background: var(--surface); border-radius: 12px; padding: 20px;
    border: 2px solid var(--border); transition: all 0.3s;
    box-shadow: var(--shadow);
  }
  .panel-section-title {
    font-size: 16px; font-weight: 700; color: var(--heading);
    margin-bottom: 12px; display: flex; align-items: center; gap: 6px;
  }

  /* Emoji picker */
  .emoji-picker-section { position: relative; margin-bottom: 4px; }
  .emoji-toggle-btn {
    padding: 5px 10px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--surface-alt); color: var(--text); font-size: 14px;
    cursor: pointer; transition: all 0.15s; display: inline-flex; align-items: center; gap: 5px;
    font-family: inherit;
  }
  .emoji-toggle-btn:hover { border-color: var(--accent); }
  .emoji-toggle-btn.active { border-color: var(--accent); background: var(--accent-bg); }
  .emoji-panel {
    display: none; position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
    box-shadow: var(--shadow-lg); padding: 8px; width: 290px; z-index: 100;
  }
  .emoji-panel.visible { display: block; }
  .emoji-panel-search {
    width: 100%; padding: 6px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    background: var(--input-bg); color: var(--text); font-size: 12px; font-family: inherit;
    margin-bottom: 6px;
  }
  .emoji-panel-search:focus { outline: none; border-color: var(--accent); }
  .emoji-panel-search::placeholder { color: var(--text-faint); }
  .emoji-category { margin-bottom: 4px; }
  .emoji-category-label {
    font-size: 10px; font-weight: 700; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.5px; padding: 2px 4px;
  }
  .emoji-grid { display: flex; flex-wrap: wrap; gap: 2px; }
  .emoji-btn {
    width: 30px; height: 30px; border: none; border-radius: 6px;
    background: transparent; font-size: 17px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transition: background 0.1s;
  }
  .emoji-btn:hover { background: var(--accent-bg); }
  .emoji-scroll { max-height: 200px; overflow-y: auto; }

  /* Line inputs */
  .line-input-row { display: flex; align-items: center; gap: 4px; margin-bottom: 4px; }
  .line-input-row .line-num {
    font-size: 11px; font-weight: 700; color: var(--text-faint);
    width: 14px; text-align: center; flex-shrink: 0; font-family: var(--mono);
  }
  .line-input-row input[type="text"] {
    flex: 1; padding: 8px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 15px; font-family: inherit; background: var(--input-bg); color: var(--text);
    transition: border-color 0.2s; min-width: 0;
  }
  .line-input-row input[type="text"]:focus { outline: none; border-color: var(--accent); }
  .line-input-row input[type="text"]::placeholder { color: var(--text-faint); font-size: 13px; }
  .line-align-btn {
    width: 28px; height: 28px; border: 2px solid var(--border); border-radius: 5px;
    background: var(--align-btn-bg); color: var(--align-btn-text); font-size: 13px;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; flex-shrink: 0; padding: 0;
  }
  .line-align-btn:hover { border-color: var(--accent); }
  .line-align-btn.active { background: var(--align-btn-active); color: var(--align-btn-active-text); border-color: var(--align-btn-active); }
  .line-size-stepper { display: flex; align-items: center; gap: 0; flex-shrink: 0; margin-left: 2px; }
  .line-size-stepper .size-btn {
    width: 22px; height: 28px; border: 2px solid var(--border);
    background: var(--align-btn-bg); color: var(--align-btn-text);
    font-size: 14px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .line-size-stepper .size-btn:first-child { border-radius: 5px 0 0 5px; }
  .line-size-stepper .size-btn:last-child { border-radius: 0 5px 5px 0; }
  .line-size-stepper .size-btn:hover { border-color: var(--accent); color: var(--accent); }
  .line-size-stepper .size-val {
    width: 28px; height: 28px; border-top: 2px solid var(--border); border-bottom: 2px solid var(--border);
    background: var(--input-bg); color: var(--text); font-size: 11px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-family: var(--mono);
  }
  .line-inputs-hint {
    font-size: 12px; color: var(--text-faint); margin-top: 2px; line-height: 1.4;
  }
  .line-inputs-hint code {
    background: var(--surface-alt); border: 1px solid var(--border); border-radius: 3px;
    padding: 0 3px; font-size: 11px; font-family: var(--mono);
  }
  .line-style-btn {
    width: 28px; height: 28px; border: 2px solid var(--border); border-radius: 5px;
    background: var(--align-btn-bg); color: var(--text-muted); font-size: 14px; font-weight: 700;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; flex-shrink: 0; padding: 0; position: relative; letter-spacing: 1px;
  }
  .line-style-btn:hover { border-color: var(--accent); }
  .line-style-btn.has-styles { color: var(--accent); border-color: var(--accent); }
  .line-style-btn.popover-open { background: var(--accent); color: #fff; border-color: var(--accent); }
  .style-popover {
    display: none; position: absolute; top: 100%; right: 0; z-index: 100;
    background: var(--surface); border: 2px solid var(--border); border-radius: 8px;
    padding: 8px; margin-top: 4px; box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    min-width: 200px;
  }
  .style-popover.open { display: block; }
  .style-popover-section { margin-bottom: 6px; }
  .style-popover-section:last-child { margin-bottom: 0; }
  .style-popover-label { font-size: 10px; font-weight: 700; color: var(--text-faint); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .style-toggles { display: flex; gap: 4px; }
  .style-toggle-btn {
    width: 32px; height: 30px; border: 2px solid var(--border); border-radius: 5px;
    background: var(--align-btn-bg); color: var(--text); font-size: 14px;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0;
  }
  .style-toggle-btn:hover { border-color: var(--accent); }
  .style-toggle-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .style-toggle-btn .btn-label-b { font-weight: 800; }
  .style-toggle-btn .btn-label-i { font-style: italic; font-family: Georgia, serif; }
  .style-toggle-btn .btn-label-u { text-decoration: underline; }
  .style-toggle-btn .btn-label-s { text-decoration: line-through; }
  .color-palette { display: flex; gap: 4px; flex-wrap: wrap; }
  .color-swatch {
    width: 24px; height: 24px; border-radius: 5px; cursor: pointer;
    border: 2px solid var(--border); transition: all 0.15s; flex-shrink: 0;
  }
  .color-swatch:hover { border-color: var(--accent); transform: scale(1.1); }
  .color-swatch.active { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent); }
  .color-swatch.swatch-none {
    background: var(--surface); position: relative;
  }
  .color-swatch.swatch-none::after {
    content: ''; position: absolute; top: 2px; left: 50%; width: 2px; height: calc(100% - 4px);
    background: var(--danger); transform: rotate(45deg);
  }
  .border-toggle { font-size: 12px; font-weight: 600; }

  /* Vertical alignment + quantity row */
  .controls-row { display: flex; align-items: center; gap: 14px; flex-wrap: wrap; }
  .control-group { display: flex; align-items: center; gap: 5px; }
  .control-group-label { font-size: 13px; font-weight: 600; color: var(--text-muted); white-space: nowrap; }
  .align-btn {
    min-width: 34px; height: 30px; padding: 0 6px; border: 2px solid var(--border);
    border-radius: 5px; background: var(--align-btn-bg); color: var(--align-btn-text);
    font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; white-space: nowrap; gap: 2px; font-family: inherit;
  }
  .align-btn:hover { border-color: var(--accent); }
  .align-btn.active { background: var(--align-btn-active); color: var(--align-btn-active-text); border-color: var(--align-btn-active); }

  .qty-input {
    width: 56px; padding: 5px 8px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-weight: 600; text-align: center; font-family: var(--mono);
    background: var(--input-bg); color: var(--text);
  }
  .qty-input:focus { outline: none; border-color: var(--accent); }
  .qty-hint { font-size: 11px; color: var(--text-muted); }

  /* Preview */
  .preview-container {
    background: repeating-conic-gradient(#d8d8d2 0% 25%, #e4e4de 0% 50%) 50% / 12px 12px;
    border: 2px solid var(--border); border-radius: 8px;
    padding: 10px; display: flex; justify-content: center; align-items: center; min-height: 60px;
  }
  .preview-label {
    background: var(--preview-bg); border: 2px solid var(--preview-border); border-radius: 4px;
    padding: 6px 8px; font-family: Arial, sans-serif; color: var(--preview-text);
    overflow: hidden; word-break: break-word; display: flex; flex-direction: column; transition: all 0.15s;
  }
  .preview-label .preview-line { width: 100%; display: flex; white-space: nowrap; overflow: hidden; line-height: 1.3; }
  .preview-label .preview-line.align-left { justify-content: flex-start; }
  .preview-label .preview-line.align-center { justify-content: center; }
  .preview-label .preview-line.align-right { justify-content: flex-end; }
  .preview-label .preview-line.align-split { justify-content: space-between; }
  .preview-label .preview-line.fill-line { display: flex; align-items: flex-end; gap: 4px; }
  .preview-label .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .preview-label .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 12px; margin-bottom: 1px; }
  .preview-label.empty-preview { align-items: center; justify-content: center; color: #bbb; font-size: 12px; font-style: italic; }
  .preview-dimensions { text-align: center; font-size: 10px; color: var(--text-faint); margin-top: 4px; font-family: var(--mono); }

  /* Action buttons in compose */
  .compose-actions { display: flex; gap: 8px; margin-top: 4px; }
  .btn {
    padding: 10px 18px; border: 2px solid transparent; border-radius: 8px;
    font-family: inherit; font-size: 14px; font-weight: 600;
    cursor: pointer; transition: all 0.15s; display: inline-flex; align-items: center; gap: 6px;
  }
  .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-primary:disabled { background: var(--text-faint); border-color: var(--text-faint); cursor: not-allowed; }
  .btn-secondary { background: var(--surface); color: var(--text); border-color: var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn-danger { background: none; color: var(--danger); border-color: var(--danger); }
  .btn-danger:hover { background: var(--danger-bg); }
  .btn-sm { padding: 6px 12px; font-size: 12px; }
  .btn-full { width: 100%; justify-content: center; }

  /* Queue nudge bar on labels tab */
  .queue-nudge {
    margin-top: 8px; padding: 10px 14px; border-radius: 8px;
    background: var(--accent-bg); border: 2px solid var(--accent-soft);
    display: flex; align-items: center; justify-content: space-between;
    animation: fadeIn 0.25s ease;
  }
  .queue-nudge-text { font-size: 14px; font-weight: 600; color: var(--accent-text); }
  .queue-nudge-btn {
    padding: 6px 14px; border: 2px solid var(--accent); border-radius: 6px;
    background: var(--accent); color: #fff; font-family: inherit;
    font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s;
  }
  .queue-nudge-btn:hover { background: var(--accent-hover); }

  /* Editing indicator */
  .editing-indicator {
    padding: 8px 12px; border-radius: 8px; background: var(--warning-bg);
    border: 2px solid var(--warning-border); font-size: 13px; font-weight: 600;
    color: var(--warning-text); display: flex; align-items: center; justify-content: space-between;
  }
  .editing-indicator .cancel-edit {
    background: none; border: none; color: var(--warning-text); cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 600; text-decoration: underline;
    padding: 2px 4px;
  }

  /* Status messages */
  .status-msg {
    padding: 9px 12px; border-radius: 8px; font-size: 13px; font-weight: 600;
    text-align: center; transition: all 0.3s; min-height: 0;
  }
  .status-msg.info { background: var(--accent-bg); color: var(--accent-text); }
  .status-msg.success { background: var(--success-bg); color: var(--success-text); }
  .status-msg.warning { background: var(--warning-bg); color: var(--warning-text); }
  .status-msg.error { background: var(--error-bg); color: var(--error-text); }
  .status-msg:empty { display: none; }
  .undo-paste-btn {
    display: inline-block; margin-left: 8px; padding: 2px 10px; border: 1px solid currentColor;
    border-radius: 4px; background: transparent; color: inherit; font-size: 12px;
    font-weight: 700; font-family: inherit; cursor: pointer; vertical-align: middle;
  }
  .undo-paste-btn:hover { opacity: 0.8; }

  /* ===== SAVED TEXTS (right column of Labels tab) ===== */
  .saved-texts-panel { display: flex; flex-direction: column; gap: 8px; }
  .saved-text-card {
    padding: 12px 14px; border: 2px solid var(--saved-card-border); border-radius: 8px;
    background: var(--saved-card-bg); cursor: pointer; transition: all 0.15s;
    box-shadow: var(--shadow);
  }
  .saved-text-card:hover { background: var(--saved-card-hover); border-color: var(--accent); }
  .saved-text-card-header {
    display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;
  }
  .saved-text-card-name { font-size: 14px; font-weight: 700; color: var(--heading); }
  .saved-text-card-actions { display: flex; gap: 2px; opacity: 0; transition: opacity 0.15s; }
  .saved-text-card:hover .saved-text-card-actions { opacity: 1; }
  .st-action-btn {
    background: none; border: none; font-size: 11px; cursor: pointer;
    padding: 2px 5px; color: var(--text-secondary); border-radius: 4px; transition: all 0.15s;
  }
  .st-action-btn:hover { color: var(--danger); background: var(--danger-bg); }
  .st-action-btn.edit:hover { color: var(--accent); background: var(--accent-bg); }
  .st-action-btn.rename:hover { color: var(--accent); background: var(--accent-bg); }

  .saved-text-card-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 4px 6px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    max-height: 48px;
  }
  .saved-text-card-preview .preview-line { font-size: 9px; line-height: 1.3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; }
  .saved-text-card-preview .preview-line.align-left { justify-content: flex-start; }
  .saved-text-card-preview .preview-line.align-center { justify-content: center; }
  .saved-text-card-preview .preview-line.align-right { justify-content: flex-end; }
  .saved-text-card-preview .preview-line.align-split { justify-content: space-between; }
  .saved-text-card-preview .preview-line.fill-line { display: flex; align-items: flex-end; gap: 2px; }
  .saved-text-card-preview .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .saved-text-card-preview .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 8px; margin-bottom: 1px; }

  .saved-texts-empty { padding: 24px 16px; text-align: center; color: var(--text-faint); font-size: 14px; }
  .saved-texts-empty .icon { font-size: 28px; display: block; margin-bottom: 6px; }

  /* ===== SUB-TAB PILLS (Texts ↔ Templates) ===== */
  .sub-tab-pills { display: flex; gap: 2px; background: var(--surface-alt); border-radius: 8px; padding: 2px; }
  .sub-tab-pill {
    padding: 5px 14px; border-radius: 6px; border: none; cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 600;
    background: transparent; color: var(--text-muted); transition: all 0.15s;
  }
  .sub-tab-pill:hover { color: var(--text); }
  .sub-tab-pill.active { background: var(--accent); color: #fff; box-shadow: var(--shadow-sm); }

  /* ===== TOKEN PICKER ===== */
  .token-panel {
    position: absolute; z-index: 90; top: 100%; left: 0; right: 0;
    background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
    box-shadow: var(--shadow-lg); padding: 12px; max-height: 300px; overflow-y: auto;
    display: none;
  }
  .token-panel.visible { display: block; }
  .token-category-label {
    font-size: 11px; font-weight: 700; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.05em;
    margin: 8px 0 4px 0; padding: 0 2px;
  }
  .token-category-label:first-child { margin-top: 0; }
  .token-grid { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 4px; }
  .token-chip {
    padding: 3px 10px; border-radius: 12px; border: 1.5px solid var(--border);
    background: var(--surface-alt); cursor: pointer; font-family: var(--mono);
    font-size: 11px; font-weight: 500; color: var(--accent-text); transition: all 0.15s;
    white-space: nowrap;
  }
  .token-chip:hover { border-color: var(--accent); background: var(--accent-bg); }
  .token-custom-row {
    display: flex; gap: 6px; margin-top: 8px; padding-top: 8px;
    border-top: 1px solid var(--border-light);
  }
  .token-custom-row input {
    flex: 1; padding: 5px 8px; border: 1.5px solid var(--input-border);
    border-radius: 6px; font-family: var(--mono); font-size: 12px;
    background: var(--input-bg); color: var(--text);
  }
  .token-custom-row button {
    padding: 5px 12px; border: 1.5px solid var(--accent); border-radius: 6px;
    background: var(--accent-bg); color: var(--accent-text); cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 600;
  }
  .token-custom-row button:hover { background: var(--accent); color: #fff; }

  /* ===== TOKEN RENDERING IN PREVIEWS ===== */
  .token-pill {
    display: inline-block; padding: 0px 4px; border-radius: 3px;
    background: var(--accent-bg); color: var(--accent-text);
    font-family: var(--mono); font-size: inherit; font-weight: 600;
    border: 1px solid var(--accent-soft);
  }

  /* ===== TEMPLATE LABEL TYPE ADVISORY ===== */
  .template-label-notice {
    font-size: 11px; color: var(--text-muted); margin-top: 2px;
    display: flex; align-items: center; gap: 4px;
  }
  .template-label-notice .notice-icon { font-size: 12px; }
  .template-label-mismatch {
    font-size: 11px; color: var(--warning-text); margin-top: 1px;
    display: flex; align-items: center; gap: 4px;
  }

  /* ===== BUILT-IN TEMPLATE BADGE ===== */
  .builtin-badge {
    display: inline-block; padding: 1px 6px; border-radius: 4px;
    font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em;
    background: var(--accent-bg); color: var(--accent-text); border: 1px solid var(--accent-soft);
    margin-left: 6px; vertical-align: middle;
  }

  /* ===== LABEL GRAPHICS (v1.7.0) ===== */
  .graphics-panel {
    display: none; padding: 10px 12px; margin-bottom: 8px;
    border: 1.5px solid var(--border-light); border-radius: 8px;
    background: var(--surface-alt);
  }
  .graphics-panel.open { display: block; }
  .graphics-panel-title {
    font-size: 11px; font-weight: 700; color: var(--text-faint);
    text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;
  }
  .graphics-row {
    display: flex; align-items: center; gap: 8px;
    margin-bottom: 6px; min-height: 36px;
  }
  .graphics-row:last-child { margin-bottom: 0; }
  .graphics-row-label {
    font-size: 12px; font-weight: 600; color: var(--text-secondary);
    min-width: 40px;
  }
  .graphic-add-btn {
    padding: 4px 12px; border: 1.5px dashed var(--border);
    border-radius: 6px; background: transparent;
    color: var(--text-muted); cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 500;
    transition: all 0.15s;
  }
  .graphic-add-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
  .graphic-thumb {
    width: 40px; height: 40px; border-radius: 4px;
    border: 1.5px solid var(--border); overflow: hidden;
    display: flex; align-items: center; justify-content: center;
    background: #fff; flex-shrink: 0;
  }
  .graphic-thumb img { max-width: 100%; max-height: 100%; object-fit: contain; }
  .graphic-size-pills { display: flex; gap: 2px; }
  .graphic-size-pill {
    padding: 3px 10px; border: 1.5px solid var(--border);
    border-radius: 4px; background: transparent;
    color: var(--text-secondary); cursor: pointer;
    font-family: inherit; font-size: 11px; font-weight: 600;
    transition: all 0.15s;
  }
  .graphic-size-pill:hover { border-color: var(--accent); color: var(--accent); }
  .graphic-size-pill.active { border-color: var(--accent); background: var(--accent-bg); color: var(--accent-text); }
  .graphic-remove-btn {
    padding: 3px 8px; border: 1.5px solid var(--border);
    border-radius: 4px; background: transparent;
    color: var(--text-faint); cursor: pointer;
    font-family: inherit; font-size: 13px; font-weight: 500;
    transition: all 0.15s;
  }
  .graphic-remove-btn:hover { border-color: var(--danger); color: var(--danger); background: var(--danger-bg); }
  .graphic-swap-btn {
    padding: 3px 8px; border: 1.5px solid var(--border);
    border-radius: 4px; background: transparent;
    color: var(--text-faint); cursor: pointer;
    font-family: inherit; font-size: 13px; font-weight: 500;
    transition: all 0.15s;
  }
  .graphic-swap-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
  .graphic-thumb:hover { border-color: var(--accent); }

  /* Graphic Picker Popover */
  .graphic-picker {
    display: none; margin-top: 6px; padding: 0;
    border: 1.5px solid var(--border); border-radius: 8px;
    background: var(--surface); box-shadow: var(--shadow);
    overflow: hidden;
  }
  .graphic-picker.open { display: block; }
  .graphic-picker-tabs {
    display: flex; border-bottom: 1.5px solid var(--border-light);
    background: var(--surface-alt);
  }
  .graphic-picker-tab {
    flex: 1; padding: 7px 6px; border: none; background: transparent;
    color: var(--text-muted); cursor: pointer;
    font-family: inherit; font-size: 11px; font-weight: 600;
    text-align: center; transition: all 0.15s;
    border-bottom: 2px solid transparent;
  }
  .graphic-picker-tab:hover { color: var(--text-secondary); background: var(--input-bg); }
  .graphic-picker-tab.active {
    color: var(--accent); border-bottom-color: var(--accent);
    background: var(--surface);
  }
  .graphic-picker-body { padding: 8px; max-height: 220px; overflow-y: auto; }

  /* Upload tab */
  .graphic-upload-area {
    text-align: center; padding: 18px 12px;
  }
  .graphic-upload-btn {
    padding: 8px 20px; border: 1.5px dashed var(--border);
    border-radius: 6px; background: transparent;
    color: var(--text-secondary); cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 500;
    transition: all 0.15s;
  }
  .graphic-upload-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }

  /* Library tab */
  .graphic-lib-controls {
    display: flex; gap: 6px; margin-bottom: 8px;
  }
  .graphic-lib-cat-select {
    padding: 4px 6px; border: 1.5px solid var(--input-border);
    border-radius: 5px; background: var(--input-bg);
    color: var(--text); font-family: inherit; font-size: 11px;
    min-width: 90px; cursor: pointer;
  }
  .graphic-lib-search {
    flex: 1; padding: 4px 8px; border: 1.5px solid var(--input-border);
    border-radius: 5px; background: var(--input-bg);
    color: var(--text); font-family: inherit; font-size: 11px;
  }
  .graphic-lib-search::placeholder { color: var(--text-faint); }
  .graphic-lib-section {
    font-size: 10px; font-weight: 700; color: var(--text-faint);
    text-transform: uppercase; letter-spacing: 0.4px;
    margin: 8px 0 4px; padding: 0 2px;
  }
  .graphic-lib-section:first-child { margin-top: 0; }
  .graphic-lib-grid {
    display: flex; flex-wrap: wrap; gap: 4px;
    margin-bottom: 4px;
  }
  .graphic-lib-icon {
    width: 38px; height: 38px; border: 1.5px solid var(--border-light);
    border-radius: 5px; background: #fff; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    padding: 3px; transition: all 0.15s; position: relative;
  }
  .graphic-lib-icon:hover {
    border-color: var(--accent); background: var(--accent-bg);
    transform: scale(1.08); box-shadow: var(--shadow-sm);
  }
  .graphic-lib-icon img { max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none; }
  .graphic-lib-icon svg { width: 100%; height: 100%; pointer-events: none; }
  .graphic-lib-empty {
    padding: 12px; text-align: center;
    color: var(--text-faint); font-size: 11px;
  }

  /* Iconify Search tab */
  .graphic-search-row {
    display: flex; gap: 6px; margin-bottom: 8px;
  }
  .graphic-search-input {
    flex: 1; padding: 5px 8px; border: 1.5px solid var(--input-border);
    border-radius: 5px; background: var(--input-bg);
    color: var(--text); font-family: inherit; font-size: 11px;
  }
  .graphic-search-input::placeholder { color: var(--text-faint); }
  .graphic-search-grid {
    display: flex; flex-wrap: wrap; gap: 4px;
    margin-bottom: 4px;
  }
  .graphic-search-icon {
    width: 42px; height: 42px; border: 1.5px solid var(--border-light);
    border-radius: 5px; background: #fff; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    padding: 4px; transition: all 0.15s; position: relative;
  }
  .graphic-search-icon:hover {
    border-color: var(--accent); background: var(--accent-bg);
    transform: scale(1.08); box-shadow: var(--shadow-sm);
  }
  .graphic-search-icon img {
    max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none;
  }
  .graphic-search-icon[title]:hover::after {
    content: attr(title); position: absolute; bottom: -22px; left: 50%;
    transform: translateX(-50%); padding: 2px 6px;
    background: var(--text); color: #fff; border-radius: 3px;
    font-size: 9px; white-space: nowrap; z-index: 10;
    pointer-events: none;
  }
  .graphic-search-empty {
    padding: 16px 12px; text-align: center;
    color: var(--text-faint); font-size: 11px;
  }
  .graphic-search-attr {
    padding: 4px 2px 0; text-align: right;
    font-size: 9px; color: var(--text-faint);
  }
  .graphic-search-attr a { color: var(--text-faint); text-decoration: underline; }
  .graphic-search-loading {
    padding: 16px; text-align: center; color: var(--text-faint); font-size: 11px;
  }
  @keyframes gp-spin { to { transform: rotate(360deg); } }
  .graphic-search-spinner {
    display: inline-block; width: 16px; height: 16px;
    border: 2px solid var(--border); border-top-color: var(--accent);
    border-radius: 50%; animation: gp-spin 0.6s linear infinite;
    vertical-align: middle; margin-right: 6px;
  }

  /* Graphics zones in previews */
  .preview-graphic {
    display: flex; align-items: center; justify-content: center;
    overflow: hidden; flex-shrink: 0; padding: 2px;
  }
  .preview-graphic img { max-width: 100%; max-height: 100%; object-fit: contain; }
  .preview-text-zone { flex: 1; display: flex; flex-direction: column; min-width: 0; overflow: hidden; }

  /* Mini-preview graphics in cards */
  .queue-item-preview .preview-graphic { padding: 1px; }
  .queue-item-preview .preview-graphic img { max-width: 100%; max-height: 100%; object-fit: contain; }

  /* ===== QUEUE ITEMS (used in print manifest within sheets tab) ===== */
  .queue-item {
    padding: 12px 14px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--queue-item-bg); display: flex; align-items: center; gap: 12px;
    transition: all 0.15s; box-shadow: var(--shadow);
  }
  .queue-item:hover { border-color: var(--accent); }
  .queue-item-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 3px 5px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    min-width: 80px; max-width: 120px; flex-shrink: 0;
  }
  .queue-item-preview .preview-line { font-size: 8px; line-height: 1.3; white-space: nowrap; overflow: hidden; display: flex; }
  .queue-item-preview .preview-line.align-left { justify-content: flex-start; }
  .queue-item-preview .preview-line.align-center { justify-content: center; }
  .queue-item-preview .preview-line.align-right { justify-content: flex-end; }
  .queue-item-preview .preview-line.align-split { justify-content: space-between; }
  .queue-item-preview .preview-line.fill-line { display: flex; align-items: flex-end; gap: 2px; }
  .queue-item-preview .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .queue-item-preview .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 8px; margin-bottom: 1px; }
  .queue-item-info { flex: 1; min-width: 0; }
  .queue-item-positions { font-size: 13px; color: var(--heading); font-weight: 600; font-family: var(--mono); }
  .queue-item-count { font-size: 12px; color: var(--text-secondary); font-weight: 600; }
  .queue-item-remove {
    background: none; border: none; font-size: 14px; color: var(--text-faint);
    cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: all 0.15s;
  }
  .queue-item-remove:hover { color: var(--danger); background: var(--danger-bg); }

  .queue-empty-state { padding: 32px 16px; text-align: center; color: var(--text-faint); font-size: 14px; }
  .queue-empty-state .icon { font-size: 32px; display: block; margin-bottom: 8px; }

  .print-actions { display: flex; gap: 8px; margin-top: 4px; }

  /* ===== NEW SHEET MODAL ===== */
  .modal-overlay {
    display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.45); z-index: 1000;
    align-items: center; justify-content: center;
  }
  .modal-overlay.visible { display: flex; }
  #dialogModal { z-index: 1200; } /* Always on top — used for prompts/confirms from other modals */
  .modal {
    background: var(--surface); border-radius: 14px; padding: 24px;
    width: 520px; max-width: 92vw; box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    max-height: 90vh; overflow-y: auto;
  }
  .modal h3 { font-size: 18px; color: var(--heading); margin-bottom: 14px; font-weight: 700; }
  .modal input[type="text"], .modal textarea {
    width: 100%; padding: 11px 14px; border: 2px solid var(--input-border); border-radius: 8px;
    background: var(--input-bg); color: var(--text); font-size: 15px;
    font-family: inherit; margin-bottom: 10px;
  }
  .modal textarea { height: 76px; resize: vertical; }
  .modal input:focus, .modal textarea:focus { outline: none; border-color: var(--accent); }
  .modal input::placeholder { color: var(--text-faint); }
  .modal-hint { font-size: 13px; color: var(--text-muted); margin: -6px 0 12px; }
  .modal-btns { display: flex; gap: 8px; }
  .modal-btns .btn { flex: 1; justify-content: center; }
  .modal-message { font-size: 15px; color: var(--text); margin-bottom: 16px; line-height: 1.5; }

  .label-type-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 14px; max-height: 280px; overflow-y: auto; }
  .label-type-card {
    padding: 10px 12px; border: 2px solid var(--type-card-border); border-radius: 8px;
    background: var(--type-card-bg); cursor: pointer; transition: all 0.15s;
  }
  .label-type-card:hover { border-color: var(--accent); }
  .label-type-card.selected { border-color: var(--type-card-active); background: var(--accent-bg); }
  .label-type-card .ltc-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
  .label-type-card .ltc-name { font-size: 14px; font-weight: 700; color: var(--heading); }
  .label-type-card .ltc-count { font-size: 12px; font-weight: 700; color: var(--accent-text); font-family: var(--mono); }
  .label-type-card .ltc-desc { font-size: 11px; color: var(--text-muted); }
  .label-type-card .ltc-dims { font-size: 12px; color: var(--text-secondary); margin-top: 2px; font-family: var(--mono); }
  .label-type-card .ltc-mini-grid { display: inline-grid; gap: 1px; margin-top: 4px; }
  .label-type-card .ltc-mini-cell { background: var(--accent); border-radius: 1px; opacity: 0.4; }
  .label-type-card.selected .ltc-mini-cell { opacity: 0.7; }

  /* Label type in compose header */
  .label-type-chip {
    font-size: 11px; font-weight: 500; color: var(--text-muted);
    background: var(--surface-alt); border: 1px solid var(--border);
    padding: 2px 8px; border-radius: 4px; font-family: var(--mono);
  }

  /* ===== INVENTORY (v1.9.0) ===== */
  .inventory-modal { width: 560px; max-width: 95vw; }
  .inventory-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
  .inventory-header h3 { margin-bottom: 0; }
  .inventory-back-btn { background: none; border: none; color: var(--accent); font-size: 14px; cursor: pointer; padding: 4px 8px; border-radius: 6px; font-family: inherit; }
  .inventory-back-btn:hover { background: var(--accent-bg); }
  .inventory-card {
    padding: 14px 16px; border: 2px solid var(--saved-card-border); border-radius: 10px;
    background: var(--saved-card-bg); margin-bottom: 10px; transition: border-color 0.15s;
  }
  .inventory-card.low-stock { border-color: var(--warning-border); }
  .inventory-card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px; }
  .inventory-card-type { font-size: 15px; font-weight: 700; color: var(--heading); }
  .inventory-badge { font-size: 11px; font-weight: 600; color: var(--warning-text); background: var(--warning-bg); border: 1px solid var(--warning-border); padding: 1px 8px; border-radius: 10px; }
  .inventory-card-desc { font-size: 12px; color: var(--text-muted); margin-bottom: 8px; }
  .inventory-card-stats { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }
  .inventory-card-stats .inv-total { font-weight: 600; color: var(--heading); }
  .inventory-card-btns { display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; }
  .inventory-card-btns .btn { font-size: 12px; padding: 5px 10px; }
  .inventory-new-card {
    display: block; width: 100%; padding: 14px; border: 2px dashed var(--border);
    border-radius: 10px; background: none; color: var(--text-muted); cursor: pointer;
    font-size: 14px; font-family: inherit; text-align: center; transition: all 0.15s;
  }
  .inventory-new-card:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
  .inventory-empty { text-align: center; padding: 30px 20px; color: var(--text-muted); line-height: 1.7; }
  .inventory-empty .icon { font-size: 32px; display: block; margin-bottom: 8px; }

  /* Inventory history */
  .inv-history-summary { font-size: 13px; color: var(--text-secondary); line-height: 1.8; margin-bottom: 14px; padding: 12px 14px; background: var(--surface-alt); border-radius: 8px; }
  .inv-history-summary .inv-total { font-weight: 600; color: var(--heading); }
  .inv-threshold-row { display: flex; align-items: center; gap: 8px; margin-top: 6px; padding-top: 8px; border-top: 1px solid var(--border-light); }
  .inv-threshold-row label { font-size: 12px; color: var(--text-muted); }
  .inv-threshold-input { width: 52px; padding: 3px 6px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); color: var(--text); font-size: 13px; font-family: var(--mono); text-align: center; }
  .inv-threshold-input:focus { outline: none; border-color: var(--accent); }
  .inv-history-list { display: flex; flex-direction: column; gap: 6px; max-height: 360px; overflow-y: auto; }
  .inv-history-entry { display: flex; align-items: flex-start; gap: 10px; padding: 8px 10px; border-radius: 8px; background: var(--surface-alt); font-size: 13px; }
  .inv-history-icon { font-size: 16px; flex-shrink: 0; margin-top: 1px; }
  .inv-history-body { flex: 1; min-width: 0; }
  .inv-history-note { color: var(--text); line-height: 1.4; }
  .inv-history-meta { font-size: 11px; color: var(--text-muted); margin-top: 2px; }
  .inv-history-delta { flex-shrink: 0; font-family: var(--mono); font-size: 13px; font-weight: 600; text-align: right; min-width: 48px; }
  .inv-delta-pos { color: var(--success-text); }
  .inv-delta-neg { color: var(--error-text); }
  .inv-delta-zero { color: var(--text-faint); }
  .inv-history-empty { text-align: center; padding: 20px; color: var(--text-faint); font-size: 13px; }

  /* Stock indicator on sheet cards */
  .sheet-stock-indicator { font-size: 11px; color: var(--text-muted); font-family: var(--mono); margin-top: 1px; }
  .sheet-stock-indicator.low { color: var(--warning-text); font-weight: 600; }

  /* Delete inventory type button */
  .inv-delete-btn { background: none; border: none; color: var(--text-faint); cursor: pointer; font-size: 13px; padding: 2px 4px; border-radius: 4px; }
  .inv-delete-btn:hover { color: var(--danger); background: var(--danger-bg); }

  /* ===== SAVE NAME INPUT ===== */
  .save-name-row {
    display: flex; gap: 6px; align-items: center; margin-top: 8px;
    animation: fadeIn 0.2s ease;
  }
  .save-name-row input {
    flex: 1; padding: 7px 10px; border: 2px solid var(--input-border);
    border-radius: 6px; font-size: 14px; font-family: inherit;
    background: var(--input-bg); color: var(--text);
  }
  .save-name-row input:focus { outline: none; border-color: var(--accent); }
  .save-name-row input::placeholder { color: var(--text-faint); }

  /* ===== PRINT CSS ===== */
  @media print {
    @page { size: letter; margin: 0; }
    html, body { height: 11in !important; width: 8.5in !important; margin: 0 !important; padding: 0 !important; overflow: hidden !important; background: #fff !important; color: #000 !important; }
    body > *:not(.print-sheet) { display: none !important; height: 0 !important; width: 0 !important; overflow: hidden !important; position: absolute !important; visibility: hidden !important; }
    .print-sheet { display: block !important; visibility: visible !important; position: relative !important; width: 8.5in; height: 11in; margin: 0; padding: 0; overflow: hidden; box-sizing: border-box; }
    .print-label {
      position: absolute; overflow: hidden; font-family: Arial, sans-serif;
      line-height: 1.3; color: #000; display: flex; flex-direction: column;
      box-sizing: border-box;
    }
    .print-label .print-line { width: 100%; display: flex; white-space: nowrap; overflow: hidden; }
    .print-label .print-line.align-left { justify-content: flex-start; text-align: left; }
    .print-label .print-line.align-center { justify-content: center; text-align: center; }
    .print-label .print-line.align-right { justify-content: flex-end; text-align: right; }
    .print-label .print-line.align-split { justify-content: space-between; text-align: left; }
    .print-label .print-line.fill-line { display: flex; align-items: flex-end; gap: 3px; }
    .print-label .print-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
    .print-label .print-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid #000; min-width: 0.25in; margin-bottom: 1px; }
    .print-label.empty { color: transparent; }
  }
  .print-sheet { display: none; }


  /* ===== ASSIGNED TEXTS ON SHEETS TAB ===== */
  .assigned-texts-section { margin-top: 16px; }
  .assigned-texts-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid var(--border);
  }
  .assigned-texts-title { font-size: 15px; font-weight: 700; color: var(--heading); }
  .assigned-texts-list { display: flex; flex-direction: column; gap: 8px; }
  .assigned-text-row {
    padding: 10px 12px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--surface); display: flex; align-items: center; gap: 10px;
    transition: all 0.15s; box-shadow: var(--shadow-sm); cursor: default;
  }
  .assigned-text-row:hover { border-color: var(--accent); }
  .assigned-text-row.has-error { border-color: var(--danger); background: var(--danger-bg); }
  .assigned-text-color {
    width: 8px; height: 36px; border-radius: 4px; flex-shrink: 0;
  }
  .assigned-text-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 3px 5px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    min-width: 70px; max-width: 100px; flex-shrink: 0;
  }
  .assigned-text-preview .preview-line { font-size: 7px; line-height: 1.3; white-space: nowrap; overflow: hidden; display: flex; }
  .assigned-text-preview .preview-line.align-left { justify-content: flex-start; }
  .assigned-text-preview .preview-line.align-center { justify-content: center; }
  .assigned-text-preview .preview-line.align-right { justify-content: flex-end; }
  .assigned-text-preview .preview-line.align-split { justify-content: space-between; }
  .assigned-text-info { flex: 1; min-width: 0; }
  .assigned-text-name {
    font-size: 14px; font-weight: 700; color: var(--heading);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .assigned-text-spots { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
  .assigned-text-controls { display: flex; align-items: center; gap: 8px; flex-shrink: 0; flex-wrap: wrap; }
  .assigned-text-placement {
    padding: 4px 8px; border: 2px solid var(--input-border); border-radius: 5px;
    font-size: 12px; font-family: inherit; background: var(--input-bg); color: var(--text);
    cursor: pointer;
  }
  .assigned-text-placement:focus { outline: none; border-color: var(--accent); }
  .assigned-text-qty {
    display: flex; align-items: center; gap: 0; flex-shrink: 0;
  }
  .assigned-text-qty .qty-btn {
    width: 28px; height: 28px; border: 2px solid var(--border);
    background: var(--align-btn-bg); color: var(--text-secondary);
    font-size: 16px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .assigned-text-qty .qty-btn:first-child { border-radius: 5px 0 0 5px; }
  .assigned-text-qty .qty-btn:last-child { border-radius: 0 5px 5px 0; }
  .assigned-text-qty .qty-btn:hover { border-color: var(--accent); color: var(--accent); }
  .assigned-text-qty .qty-val {
    width: 36px; height: 28px; border-top: 2px solid var(--border); border-bottom: 2px solid var(--border);
    background: var(--input-bg); color: var(--heading); font-size: 14px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-family: var(--mono);
  }
  .assigned-text-remove {
    background: none; border: none; font-size: 14px; color: var(--text-faint);
    cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: all 0.15s; flex-shrink: 0;
  }
  .assigned-text-remove:hover { color: var(--danger); background: var(--danger-bg); }
  .assigned-texts-empty {
    padding: 16px; text-align: center; color: var(--text-muted); font-size: 14px;
    border: 2px dashed var(--border); border-radius: 8px;
  }

  /* Print actions on sheets tab */
  .sheet-print-actions {
    margin-bottom: 16px; padding: 14px; border-radius: 10px;
    background: var(--surface); border: 2px solid var(--accent-soft); box-shadow: var(--shadow);
  }
  .sheet-print-error {
    margin-top: 8px; padding: 10px 14px; border-radius: 8px;
    background: var(--error-bg); border: 2px solid var(--error-border);
    font-size: 13px; font-weight: 600; color: var(--error-text); line-height: 1.5;
  }

  /* Text color palette for grid visualization */
  .cell-color-0 { background: #2a4a7a; border-color: #3a6aaa; color: #fff; }
  .cell-color-1 { background: #4a2a6a; border-color: #6a3a8a; color: #fff; }
  .cell-color-2 { background: #2a5a4a; border-color: #3a7a6a; color: #fff; }
  .cell-color-3 { background: #6a3a2a; border-color: #8a5a3a; color: #fff; }
  .cell-color-4 { background: #5a5a2a; border-color: #7a7a3a; color: #fff; }
  .cell-color-5 { background: #2a4a5a; border-color: #3a6a7a; color: #fff; }
  [data-theme="dark"] .cell-color-0 { background: #1e3a5e; border-color: #3a6090; color: #dde8ff; }
  [data-theme="dark"] .cell-color-1 { background: #3e1e5a; border-color: #5a3a80; color: #e8d8ff; }
  [data-theme="dark"] .cell-color-2 { background: #1e4a3a; border-color: #3a7060; color: #d0f0e0; }
  [data-theme="dark"] .cell-color-3 { background: #5a2e1e; border-color: #804838; color: #ffe0d0; }
  [data-theme="dark"] .cell-color-4 { background: #4a4a1e; border-color: #707038; color: #f0f0d0; }
  [data-theme="dark"] .cell-color-5 { background: #1e3a4a; border-color: #386070; color: #d0e8f0; }
  .color-swatch-0 { background: #3a6aaa; }
  .color-swatch-1 { background: #6a3a8a; }
  .color-swatch-2 { background: #3a7a6a; }
  .color-swatch-3 { background: #8a5a3a; }
  .color-swatch-4 { background: #7a7a3a; }
  .color-swatch-5 { background: #386070; }

  /* Sheet selector dropdown on texts tab */
  .sheet-selector {
    display: flex; align-items: center; gap: 8px; margin-bottom: 12px;
  }
  .sheet-selector label { font-size: 13px; font-weight: 600; color: var(--text-muted); white-space: nowrap; }
  .sheet-selector select {
    flex: 1; padding: 7px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-family: inherit; background: var(--input-bg); color: var(--text);
    cursor: pointer;
  }
  .sheet-selector select:focus { outline: none; border-color: var(--accent); }

  /* Grid dynamic styles injected here */

  /* ===== SHEET COUNT IN NEW SHEET MODAL ===== */
  .sheet-count-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 14px; padding: 10px 14px; border-radius: 8px;
    background: var(--surface-alt); border: 2px solid var(--border);
  }
  .sheet-count-control {
    display: flex; align-items: center; gap: 0;
  }
  .sheet-count-label {
    font-size: 14px; font-weight: 600; color: var(--text-secondary); margin-right: 10px;
  }
  .sheet-count-capacity {
    font-size: 13px; font-weight: 600; color: var(--accent-text); font-family: var(--mono);
  }

  /* ===== SHEET COUNT STEPPER IN DETAIL VIEW ===== */
  .detail-sheet-count {
    display: flex; align-items: center; gap: 0; margin-left: 8px;
  }
  .detail-sheet-count .qty-btn {
    width: 24px; height: 24px; border: 2px solid var(--border);
    background: var(--align-btn-bg); color: var(--text-secondary);
    font-size: 14px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .detail-sheet-count .qty-btn:first-child { border-radius: 4px 0 0 4px; }
  .detail-sheet-count .qty-btn:last-child { border-radius: 0 4px 4px 0; }
  .detail-sheet-count .qty-btn:hover { border-color: var(--accent); color: var(--accent); }
  .detail-sheet-count .qty-val {
    width: 30px; height: 24px; border-top: 2px solid var(--border); border-bottom: 2px solid var(--border);
    background: var(--input-bg); color: var(--heading); font-size: 13px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-family: var(--mono);
  }

  /* ===== PAGINATED GRID MAP ===== */
  .grid-pagination {
    display: flex; align-items: center; justify-content: center; gap: 12px;
    margin: 10px 0 6px;
  }
  .grid-page-btn {
    width: 30px; height: 30px; border: 2px solid var(--border); border-radius: 6px;
    background: var(--align-btn-bg); color: var(--text-secondary);
    font-size: 14px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .grid-page-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
  .grid-page-btn:disabled { opacity: 0.3; cursor: default; }
  .grid-page-label {
    font-size: 13px; font-weight: 600; color: var(--text-secondary); font-family: var(--mono);
    min-width: 100px; text-align: center;
  }

  /* ===== FEED INSTRUCTIONS ===== */
  .feed-instructions {
    margin-top: 10px; padding: 10px 14px; border-radius: 8px;
    background: var(--accent-bg); border: 2px solid var(--accent-soft);
    font-size: 13px; color: var(--accent-text); line-height: 1.6;
  }
  .feed-instructions .feed-page {
    display: flex; gap: 6px; align-items: baseline; padding: 2px 0;
  }
  .feed-instructions .feed-page-num { font-weight: 700; font-family: var(--mono); }
  .feed-instructions .feed-sheet-name { font-weight: 600; }
  .feed-instructions .feed-count { font-family: var(--mono); font-weight: 600; }

  /* ===== PHYSICAL SHEET LABEL HINT ===== */
  .sheet-label-hint {
    margin-top: 10px; padding: 10px 14px; border-radius: 8px;
    background: var(--success-bg); border: 2px solid var(--success-border);
    font-size: 13px; color: var(--success-text); line-height: 1.5;
  }

  /* ===== SPLIT REMAINING ===== */
  .split-section {
    margin-top: 12px; padding-top: 12px; border-top: 2px dashed var(--border);
  }
  .split-form { display: flex; flex-direction: column; gap: 12px; }
  .split-form label { font-size: 14px; color: var(--text); display: flex; align-items: center; gap: 8px; cursor: pointer; }
  .split-form label input[type="radio"] { margin: 0; accent-color: var(--accent); }
  .split-form .split-group-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; }
  .split-form input[type="text"] {
    padding: 8px 12px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-family: inherit; background: var(--input-bg); color: var(--text);
  }
  .split-form input[type="text"]:focus { outline: none; border-color: var(--accent); }
  .split-summary {
    font-size: 13px; color: var(--text-muted); font-weight: 600; margin-bottom: 4px;
  }

  /* ===== IMPORT MODAL ===== */
  .import-summary {
    font-size: 13px; color: var(--text-muted); font-weight: 600; margin-bottom: 12px;
  }
  .import-form { display: flex; flex-direction: column; gap: 14px; }
  .import-form label { font-size: 14px; color: var(--text); display: flex; align-items: center; gap: 8px; cursor: pointer; }
  .import-form .import-group-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; }
  .import-form input[type="text"], .import-form select {
    padding: 8px 12px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-family: inherit; background: var(--input-bg); color: var(--text);
  }
  .import-form input[type="text"]:focus, .import-form select:focus { outline: none; border-color: var(--accent); }
  .import-stepper {
    display: inline-flex; align-items: center; gap: 0; border: 2px solid var(--input-border); border-radius: 6px; overflow: hidden;
  }
  .import-stepper button {
    width: 32px; height: 32px; border: none; background: var(--surface-alt); color: var(--text);
    font-size: 16px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center;
  }
  .import-stepper button:hover { background: var(--accent-bg); color: var(--accent); }
  .import-stepper span {
    width: 36px; text-align: center; font-size: 14px; font-weight: 700;
    font-family: var(--mono); color: var(--heading); background: var(--input-bg);
  }
  .import-col-mapping { display: flex; flex-direction: column; gap: 6px; }
  .import-col-row {
    display: flex; align-items: center; gap: 8px; font-size: 13px;
    padding: 6px 10px; background: var(--surface-alt); border-radius: 6px;
  }
  .import-col-row .col-sample {
    flex: 1; color: var(--text-secondary); white-space: nowrap; overflow: hidden;
    text-overflow: ellipsis; font-family: var(--mono); font-size: 12px;
  }
  .import-col-row select {
    padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px;
    font-size: 12px; font-family: inherit; background: var(--input-bg); color: var(--text);
    min-width: 80px;
  }
  .import-col-row select:focus { outline: none; border-color: var(--accent); }
  .import-preview-area {
    display: flex; gap: 8px; overflow-x: auto; padding: 8px 0;
  }
  .import-preview-card {
    flex-shrink: 0; width: 140px; padding: 8px 10px;
    border: 1px solid var(--border); border-radius: 6px;
    background: var(--surface); font-size: 10px; line-height: 1.4; color: var(--text);
    overflow: hidden;
  }
  .import-preview-card .card-title {
    font-size: 9px; font-weight: 700; color: var(--text-muted);
    margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;
  }
  .import-preview-card .card-line {
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .import-preview-more {
    flex-shrink: 0; width: 60px; display: flex; align-items: center; justify-content: center;
    font-size: 12px; color: var(--text-muted); font-weight: 600;
  }

  /* OCR Scan Modal */
  .ocr-image-area {
    display: flex; align-items: center; justify-content: center;
    border: 2px dashed var(--border); border-radius: 8px;
    min-height: 120px; padding: 16px; margin-bottom: 12px;
    background: var(--surface-alt); cursor: pointer; transition: border-color 0.15s;
    flex-direction: column; gap: 8px;
  }
  .ocr-image-area:hover { border-color: var(--accent); }
  .ocr-image-area.has-image { cursor: default; border-style: solid; padding: 8px; }
  .ocr-image-area img {
    max-width: 100%; max-height: 200px; border-radius: 4px; object-fit: contain;
  }
  .ocr-image-area .ocr-placeholder {
    text-align: center; color: var(--text-muted); font-size: 13px; line-height: 1.5;
  }
  .ocr-progress {
    display: flex; align-items: center; gap: 10px; padding: 10px 0;
  }
  .ocr-progress-bar {
    flex: 1; height: 6px; background: var(--surface-alt); border-radius: 3px; overflow: hidden;
  }
  .ocr-progress-fill {
    height: 100%; background: var(--accent); border-radius: 3px;
    transition: width 0.3s ease;
  }
  .ocr-progress-text {
    font-size: 12px; color: var(--text-secondary); min-width: 80px; text-align: right;
    font-family: var(--mono);
  }
  .ocr-results-area {
    display: flex; flex-direction: column; gap: 4px; margin-bottom: 12px;
  }
  .ocr-result-line {
    display: flex; align-items: center; gap: 6px;
  }
  .ocr-result-line input {
    flex: 1; padding: 6px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 13px; font-family: inherit; background: var(--input-bg); color: var(--text);
  }
  .ocr-result-line input:focus { outline: none; border-color: var(--accent); }
  .ocr-result-line input.low-confidence { border-color: var(--warning-text); background: var(--warning-bg); }
  .ocr-result-line .ocr-conf {
    font-size: 10px; font-family: var(--mono); color: var(--text-muted);
    min-width: 32px; text-align: right;
  }
  .ocr-result-line .ocr-conf.low { color: var(--warning-text); font-weight: 700; }
  .ocr-result-line .ocr-line-remove {
    width: 24px; height: 24px; border: none; background: none; color: var(--text-muted);
    cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center;
    border-radius: 4px; flex-shrink: 0;
  }
  .ocr-result-line .ocr-line-remove:hover { background: var(--danger-bg); color: var(--danger); }
  .ocr-hint {
    font-size: 11px; color: var(--text-muted); margin-top: 2px; font-style: italic;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .sheets-layout, .labels-layout {
      grid-template-columns: 1fr;
    }
    .tab-meta { display: none; }
    .tab-btn { padding: 10px 14px; font-size: 14px; }
  }

</style>
<style id="dynamicGridStyle"></style>
</head>
<body>

<div class="app-shell">
  <div class="app-topbar">
    <div class="app-title">
      🏷️ LabelKeeper <span class="version">v1.0.0</span>
    </div>
    <div class="topbar-actions">
      <div class="hamburger-menu" id="hamburgerMenu">
        <button class="hamburger-btn" onclick="toggleHamburger()" title="Menu">☰</button>
        <div class="hamburger-dropdown" id="hamburgerDropdown">
          <button class="hamburger-item" onclick="toggleTheme()">
            <span class="hamburger-item-label" id="themeMenuLabel">🌙 Dark Mode</span>
            <div class="toggle-track" id="themeToggleTrack"><div class="toggle-thumb"><span id="toggleIcon">☀️</span></div></div>
          </button>
          <button class="hamburger-item" onclick="showInventoryPanel()">
            <span class="hamburger-item-label">📦 Label Inventory</span>
          </button>
          <button class="hamburger-item" onclick="exportData()">
            <span class="hamburger-item-label">📤 Export Data</span>
          </button>
          <button class="hamburger-item" onclick="importData()">
            <span class="hamburger-item-label">📥 Import Data</span>
          </button>
          <button class="hamburger-item" onclick="showAboutModal()">
            <span class="hamburger-item-label">ℹ️ About</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-bar">
    <button class="tab-btn active" data-tab="sheets" onclick="switchTab('sheets')">
      Sheets <span class="tab-meta" id="tabMetaSheets"></span>
    </button>
    <button class="tab-btn" data-tab="texts" onclick="switchTab('texts')">
      Texts <span class="tab-meta" id="tabMetaTexts"></span>
    </button>
  </div>

  <!-- ==================== SHEETS TAB ==================== -->
  <div class="tab-panel active" id="panelSheets">
    <div class="sheets-layout">
      <div>
        <div class="sheets-col-header">
          Your Sheets
          <button class="btn btn-primary btn-sm" onclick="showNewSheetModal()">+ New Sheet</button>
        </div>
        <div class="sheet-cards" id="sheetCardsList"></div>
        <div id="sheetAssignedArea"></div>
      </div>
      <div>
        <div class="sheets-col-header">Sheet Map</div>
        <div id="sheetDetailArea"></div>
      </div>
    </div>
  </div>

  <!-- ==================== TEXTS TAB ==================== -->
  <div class="tab-panel" id="panelTexts">
    <div class="labels-layout">
      <div class="compose-panel">
        <div class="panel-section">
          <div class="panel-section-title">
            Compose Text
            <span class="label-type-chip" id="composeTypeChip"></span>
          </div>

          <div id="editingIndicator" style="display:none"></div>

          <div class="sheet-selector">
            <label>Preview on:</label>
            <select id="previewSheetSelect" onchange="onPreviewSheetChange()"></select>
          </div>

          <div class="emoji-picker-section">
            <button class="emoji-toggle-btn" id="emojiToggle" onclick="toggleEmojiPanel()">😀 Emoji</button>
            <button class="emoji-toggle-btn" onclick="pasteData()" title="Paste text from clipboard">📋 Paste</button>
            <button class="emoji-toggle-btn" onclick="scanImage()" title="Scan text from image (OCR)">📷 Scan</button>
            <button class="emoji-toggle-btn" id="tokenToggle" onclick="toggleTokenPanel()" title="Insert field token">{T} Token</button>
            <button class="emoji-toggle-btn" id="graphicToggle" onclick="toggleGraphicsPanel()" title="Add graphic to label">🖼️ Graphic</button>
            <input type="file" id="ocrFileInput" accept="image/*" style="display:none" onchange="handleOcrFile(event)">
            <input type="file" id="graphicFileInput" accept="image/*" style="display:none" onchange="handleGraphicFile(event)">
            <div class="emoji-panel" id="emojiPanel">
              <input type="text" class="emoji-panel-search" id="emojiSearch" placeholder="Search emoji…" oninput="filterEmojis()">
              <div class="emoji-scroll" id="emojiScroll"></div>
            </div>
            <div class="token-panel" id="tokenPanel"></div>
          </div>

          <div class="graphics-panel" id="graphicsPanel">
            <div class="graphics-panel-title">Label Graphics</div>
            <div class="graphics-row" id="graphicsRowLeft">
              <span class="graphics-row-label">Left:</span>
              <span id="graphicLeftContent">
                <button class="graphic-add-btn" onclick="openGraphicPicker('left')">🖼 Add</button>
              </span>
            </div>
            <div class="graphic-picker" id="graphicPickerLeft"></div>
            <div class="graphics-row" id="graphicsRowRight">
              <span class="graphics-row-label">Right:</span>
              <span id="graphicRightContent">
                <button class="graphic-add-btn" onclick="openGraphicPicker('right')">🖼 Add</button>
              </span>
            </div>
            <div class="graphic-picker" id="graphicPickerRight"></div>
          </div>

          <div id="lineInputsArea">
            <div class="line-input-row">
              <span class="line-num">1</span>
              <input type="text" id="line1" placeholder="Line 1 — use || to split, __ for fill line" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align1_left" onclick="setLineAlign(1,'left')" title="Left">←</button>
              <button class="line-align-btn" id="align1_center" onclick="setLineAlign(1,'center')" title="Center">•</button>
              <button class="line-align-btn" id="align1_right" onclick="setLineAlign(1,'right')" title="Right">→</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(1,-1)">−</button><span class="size-val" id="size1">11</span><button class="size-btn" onclick="stepSize(1,1)">+</button></div>
              <div style="position:relative"><button class="line-style-btn" id="styleBtn1" onclick="toggleStylePopover(1)" title="More styling">⋯</button><div class="style-popover" id="stylePopover1"></div></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">2</span>
              <input type="text" id="line2" placeholder="Line 2" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align2_left" onclick="setLineAlign(2,'left')" title="Left">←</button>
              <button class="line-align-btn" id="align2_center" onclick="setLineAlign(2,'center')" title="Center">•</button>
              <button class="line-align-btn" id="align2_right" onclick="setLineAlign(2,'right')" title="Right">→</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(2,-1)">−</button><span class="size-val" id="size2">11</span><button class="size-btn" onclick="stepSize(2,1)">+</button></div>
              <div style="position:relative"><button class="line-style-btn" id="styleBtn2" onclick="toggleStylePopover(2)" title="More styling">⋯</button><div class="style-popover" id="stylePopover2"></div></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">3</span>
              <input type="text" id="line3" placeholder="Line 3" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align3_left" onclick="setLineAlign(3,'left')" title="Left">←</button>
              <button class="line-align-btn" id="align3_center" onclick="setLineAlign(3,'center')" title="Center">•</button>
              <button class="line-align-btn" id="align3_right" onclick="setLineAlign(3,'right')" title="Right">→</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(3,-1)">−</button><span class="size-val" id="size3">11</span><button class="size-btn" onclick="stepSize(3,1)">+</button></div>
              <div style="position:relative"><button class="line-style-btn" id="styleBtn3" onclick="toggleStylePopover(3)" title="More styling">⋯</button><div class="style-popover" id="stylePopover3"></div></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">4</span>
              <input type="text" id="line4" placeholder="Line 4" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align4_left" onclick="setLineAlign(4,'left')" title="Left">←</button>
              <button class="line-align-btn" id="align4_center" onclick="setLineAlign(4,'center')" title="Center">•</button>
              <button class="line-align-btn" id="align4_right" onclick="setLineAlign(4,'right')" title="Right">→</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(4,-1)">−</button><span class="size-val" id="size4">11</span><button class="size-btn" onclick="stepSize(4,1)">+</button></div>
              <div style="position:relative"><button class="line-style-btn" id="styleBtn4" onclick="toggleStylePopover(4)" title="More styling">⋯</button><div class="style-popover" id="stylePopover4"></div></div>
            </div>
            <div class="line-inputs-hint">Use <code>||</code> to split a line &nbsp;·&nbsp; Use <code>__</code> for a fill line, e.g. <code>Name__</code></div>
          </div>

          <div class="controls-row" style="margin-top: 10px;">
            <div class="control-group">
              <span class="control-group-label">Vertical:</span>
              <button class="align-btn" data-align-v="top" onclick="setAlignV('top')">↑</button>
              <button class="align-btn active" data-align-v="center" onclick="setAlignV('center')">—</button>
              <button class="align-btn" data-align-v="bottom" onclick="setAlignV('bottom')">↓</button>
              <button class="align-btn" data-align-v="spread" onclick="setAlignV('spread')">↕</button>
            </div>
          </div>

          <div class="preview-container" style="margin-top: 10px;">
            <div class="preview-label empty-preview" id="previewLabel"><span>Type above to preview</span></div>
          </div>
          <div class="preview-dimensions" id="previewDimensions"></div>
          <div id="previewFitWarning" style="display:none;font-size:12px;color:var(--warning-text);margin-top:4px;font-weight:600"></div>

          <div class="compose-actions">
            <button class="btn btn-primary" style="flex:1;display:none" onclick="saveCurrentText()" id="saveTextBtn">💾 Save Text</button>
          </div>

          <div id="saveNameRow" style="display:none"></div>
          <div id="statusMsg" class="status-msg" style="margin-top:8px"></div>

          <div id="addToSheetRow" style="display:none"></div>
        </div>
      </div>

      <div>
        <div class="sheets-col-header">
          <span>
            <span id="savedTextsTitle">Saved Texts</span>
            <span style="font-size:11px;font-weight:500;color:var(--text-faint)" id="savedTextsCount"></span>
          </span>
          <div class="sub-tab-pills">
            <button class="sub-tab-pill active" id="subTabTexts" onclick="switchSubTab('texts')">Texts</button>
            <button class="sub-tab-pill" id="subTabTemplates" onclick="switchSubTab('templates')">Templates</button>
          </div>
        </div>
        <div class="saved-texts-panel" id="savedTextsList"></div>
      </div>
    </div>
  </div>

  <!-- Print tab removed in v10 — printing is now on Sheets tab -->
</div>

<div class="print-sheet" id="printSheet"></div>

<!-- New Sheet Modal -->
<div class="modal-overlay" id="newSheetModal">
  <div class="modal">
    <h3 id="newSheetModalTitle">📄 New Label Sheet</h3>
    <input type="text" id="newSheetName" placeholder="Sheet name (e.g., Science Class, Holiday Cards)">
    <div class="modal-hint">Choose a label type:</div>
    <div class="label-type-grid" id="labelTypeGrid"></div>
    <div class="sheet-count-row" id="sheetCountRow">
      <div class="sheet-count-control">
        <span class="sheet-count-label">Sheets:</span>
        <button class="qty-btn" onclick="stepNewSheetCount(-1)">−</button>
        <span class="qty-val" id="newSheetCountVal" style="min-width:28px;text-align:center">1</span>
        <button class="qty-btn" onclick="stepNewSheetCount(1)">+</button>
      </div>
      <span class="sheet-count-capacity" id="newSheetCapacity"></span>
    </div>
    <div class="modal-btns">
      <button class="btn btn-secondary" id="newSheetCancelBtn" onclick="closeModal('newSheetModal')">Cancel</button>
      <button class="btn btn-primary" onclick="createNewSheet()">Create Sheet</button>
    </div>
  </div>
</div>

<!-- Add Text to Sheet Modal -->
<div class="modal-overlay" id="addTextModal">
  <div class="modal">
    <h3 id="addTextModalTitle">📎 Add Text to Sheet</h3>
    <div class="modal-message" id="addTextModalMsg"></div>
    <div id="addTextPickerList" style="max-height:300px;overflow-y:auto;margin-bottom:14px"></div>
    <div class="modal-btns">
      <button class="btn btn-secondary" onclick="closeModal('addTextModal')">Cancel</button>
    </div>
  </div>
</div>

<!-- Generic Dialog -->
<div class="modal-overlay" id="dialogModal">
  <div class="modal">
    <h3 id="dialogTitle">Confirm</h3>
    <div class="modal-message" id="dialogMessage"></div>
    <input type="text" id="dialogInput" style="display:none">
    <div class="modal-btns">
      <button class="btn btn-secondary" id="dialogCancelBtn" onclick="dialogResolve(false)">Cancel</button>
      <button class="btn btn-primary" id="dialogOkBtn" onclick="dialogResolve(true)">OK</button>
    </div>
  </div>
</div>

<!-- Split Remaining Modal -->
<div class="modal-overlay" id="splitModal">
  <div class="modal" style="max-width:460px">
    <h3>✂️ Split Remaining Labels</h3>
    <div class="split-summary" id="splitSummary"></div>
    <div class="split-form">
      <div>
        <label for="splitName" style="font-size:13px;font-weight:700;color:var(--text-secondary);margin-bottom:4px;display:block;cursor:default">New sheet name:</label>
        <input type="text" id="splitName" placeholder="Leftover 5160 - Feb" maxlength="40">
      </div>
      <div>
        <div class="split-group-title">Physical sheets:</div>
        <label><input type="radio" name="splitMode" value="separate" checked> Split into separate sheets</label>
        <label><input type="radio" name="splitMode" value="together"> Keep together as one pool</label>
      </div>
      <div>
        <div class="split-group-title">Text associations:</div>
        <label><input type="radio" name="splitTexts" value="remove" checked> Remove texts (clean slate)</label>
        <label><input type="radio" name="splitTexts" value="keep"> Keep texts (qty set to 0)</label>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeModal('splitModal')">Cancel</button>
      <button class="btn btn-primary" onclick="executeSplit()">Split</button>
    </div>
  </div>
</div>

<!-- Import Data Modal -->
<div class="modal-overlay" id="importTextModal">
  <div class="modal" style="max-width:560px">
    <h3>📋 Import from Clipboard</h3>
    <div class="import-summary" id="importSummary"></div>
    <div class="import-form">
      <!-- Template selection -->
      <div id="importTemplateRow">
        <label for="importTemplateSelect" style="font-size:13px;font-weight:700;color:var(--text-secondary);margin-bottom:4px;display:block;cursor:default">Apply template:</label>
        <select id="importTemplateSelect" onchange="onImportTemplateChange()">
          <option value="">No Template (manual)</option>
        </select>
      </div>
      <!-- Plain list mode: lines per label -->
      <div id="importPlainControls" style="display:none">
        <div class="import-group-title">Lines per label:</div>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="import-stepper">
            <button onclick="stepLinesPerLabel(-1)">−</button>
            <span id="linesPerLabelVal">1</span>
            <button onclick="stepLinesPerLabel(1)">+</button>
          </div>
          <span style="font-size:13px;color:var(--text-secondary)" id="importRecordCount"></span>
        </div>
      </div>
      <!-- Tabular mode: column mapping -->
      <div id="importTabularControls" style="display:none">
        <div class="import-group-title" id="importColMappingTitle">Map columns to label lines:</div>
        <div class="import-col-mapping" id="importColMapping"></div>
      </div>
      <!-- Preview -->
      <div>
        <div class="import-group-title">Preview:</div>
        <div class="import-preview-area" id="importPreviewArea"></div>
      </div>
      <!-- Base name -->
      <div>
        <label for="importBaseName" style="font-size:13px;font-weight:700;color:var(--text-secondary);margin-bottom:4px;display:block;cursor:default">Base name:</label>
        <input type="text" id="importBaseName" placeholder="e.g. Student" maxlength="40">
        <div style="font-size:12px;color:var(--text-muted);margin-top:2px" id="importNamePreview"></div>
      </div>
      <!-- Sheet assignment -->
      <div>
        <label for="importSheetAssign" style="font-size:13px;font-weight:700;color:var(--text-secondary);margin-bottom:4px;display:block;cursor:default">Assign to sheet (optional):</label>
        <select id="importSheetAssign">
          <option value="">— Don't assign —</option>
        </select>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeModal('importTextModal')">Cancel</button>
      <button class="btn btn-primary" id="importExecuteBtn" onclick="executeImport()">Import</button>
    </div>
  </div>
</div>

<!-- OCR Scan Modal -->
<div class="modal-overlay" id="ocrModal">
  <div class="modal" style="max-width:520px">
    <h3>📷 Scan Image</h3>

    <!-- Image area: shows preview, click to pick new file -->
    <div class="ocr-image-area" id="ocrImageArea" onclick="ocrImageAreaClick()">
      <div class="ocr-placeholder" id="ocrPlaceholder">
        <div style="font-size:28px;margin-bottom:4px">📷</div>
        <div>Scanning your image…</div>
        <div style="font-size:11px;margin-top:4px;color:var(--text-faint)">or paste a screenshot here (Ctrl+V / ⌘V)</div>
      </div>
      <img id="ocrPreviewImg" style="display:none" alt="Scanned image">
    </div>

    <!-- Rotation controls (shown after image loads) -->
    <div id="ocrRotationBar" style="display:none;margin-bottom:10px">
      <div style="display:flex;align-items:center;gap:8px;justify-content:center">
        <button class="emoji-toggle-btn" onclick="rotateOcrImage(-90)" title="Rotate left" style="padding:4px 10px;font-size:16px">↶</button>
        <span style="font-size:12px;color:var(--text-muted);min-width:50px;text-align:center" id="ocrRotationLabel"></span>
        <button class="emoji-toggle-btn" onclick="rotateOcrImage(90)" title="Rotate right" style="padding:4px 10px;font-size:16px">↷</button>
      </div>
    </div>

    <!-- Progress bar (hidden until scanning) -->
    <div id="ocrProgressArea" style="display:none">
      <div class="ocr-progress">
        <div class="ocr-progress-bar"><div class="ocr-progress-fill" id="ocrProgressFill" style="width:0%"></div></div>
        <div class="ocr-progress-text" id="ocrProgressText">Loading…</div>
      </div>
    </div>

    <!-- Editable results (hidden until scan complete) -->
    <div id="ocrResultsArea" style="display:none">
      <div style="font-size:13px;font-weight:700;color:var(--text-secondary);margin-bottom:6px">Extracted text — edit as needed:</div>
      <div class="ocr-results-area" id="ocrResultLines"></div>
      <div class="ocr-hint" id="ocrHint"></div>
    </div>

    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeOcrModal()">Cancel</button>
      <button class="btn btn-secondary" id="ocrNewImageBtn" style="display:none" onclick="ocrNewImage()">📷 New Image</button>
      <button class="btn btn-secondary" id="ocrRescanBtn" style="display:none" onclick="ocrRescan()">🔄 Rescan</button>
      <button class="btn btn-primary" id="ocrConfirmBtn" style="display:none" onclick="confirmOcr()">Use Text</button>
    </div>
  </div>
</div>

<!-- About Modal -->
<!-- ==================== INVENTORY MODAL ==================== -->
<div class="modal-overlay" id="inventoryModal">
  <div class="modal inventory-modal">
    <div id="inventoryContent"></div>
  </div>
</div>

<div class="modal-overlay" id="aboutModal">
  <div class="modal" style="max-width:420px">
    <h3>🏷️ LabelKeeper</h3>
    <div style="font-size:14px;color:var(--text-secondary);line-height:1.7">
      <div style="margin-bottom:12px"><strong style="color:var(--heading)">Version 1.0.0</strong></div>
      <p>A tool for printing labels on Avery-compatible label sheets. Tracks partially-used sheets so no labels are wasted.</p>
      <p style="margin-top:10px">Supports 9 Avery formats, multi-sheet pools, reusable text templates, label graphics, per-line formatting, column-based placement control, label inventory tracking, and data import/export.</p>
      <p style="margin-top:10px;font-size:13px;color:var(--text-muted)">All data is stored locally in your browser. Nothing is sent to any server.</p>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-primary" onclick="closeModal('aboutModal')">Close</button>
    </div>
  </div>
</div>

<script>
// ========== LABEL TYPE SPECIFICATIONS ==========
const LABEL_TYPES = {
  '5160': { name: '5160 / 8160', desc: 'Standard Address', labelW: 2.625, labelH: 1, cols: 3, rows: 10, topMargin: 0.5, leftMargin: 0.1875, hGutter: 0.125, vGutter: 0, sizeDisplay: '1″ × 2⅝″', layoutDisplay: '3 × 10' },
  '5161': { name: '5161 / 8161', desc: 'Address + Logo', labelW: 4, labelH: 1, cols: 2, rows: 10, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1″ × 4″', layoutDisplay: '2 × 10' },
  '5162': { name: '5162 / 8162', desc: 'Large Address', labelW: 4, labelH: 1.333, cols: 2, rows: 7, topMargin: 0.8335, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1⅓″ × 4″', layoutDisplay: '2 × 7' },
  '5163': { name: '5163 / 8163', desc: 'Shipping', labelW: 4, labelH: 2, cols: 2, rows: 5, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '2″ × 4″', layoutDisplay: '2 × 5' },
  '5164': { name: '5164 / 8164', desc: 'Large Shipping', labelW: 4, labelH: 3.333, cols: 2, rows: 3, topMargin: 0.5005, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '3⅓″ × 4″', layoutDisplay: '2 × 3' },
  '5167': { name: '5167 / 8167', desc: 'Return Address (tiny)', labelW: 1.75, labelH: 0.5, cols: 4, rows: 20, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: '½″ × 1¾″', layoutDisplay: '4 × 20' },
  '5168': { name: '5168 / 8168', desc: 'Extra Large Shipping', labelW: 3.5, labelH: 5, cols: 2, rows: 2, topMargin: 0.5, leftMargin: 0.5, hGutter: 0.5, vGutter: 0, sizeDisplay: '3½″ × 5″', layoutDisplay: '2 × 2' },
  '5195': { name: '5195 / 8195', desc: 'Small Return Address', labelW: 1.75, labelH: 0.667, cols: 4, rows: 15, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: '⅔″ × 1¾″', layoutDisplay: '4 × 15' },
  '5165': { name: '5165', desc: 'Full Sheet', labelW: 8.5, labelH: 11, cols: 1, rows: 1, topMargin: 0, leftMargin: 0, hGutter: 0, vGutter: 0, sizeDisplay: '8½″ × 11″', layoutDisplay: '1 × 1' }
};
const TYPE_ORDER = ['5160','5163','5164','5161','5162','5167','5195','5168','5165'];
const TEXT_COLORS = ['#3a6aaa','#6a3a8a','#3a7a6a','#8a5a3a','#7a7a3a','#386070'];

const SHEETS_KEY = 'avery_sheets_v6';
const ACTIVE_KEY = 'avery_active_v6';
const THEME_KEY = 'avery5160_theme';
const TEXTS_KEY = 'avery5160_saved_texts';

let sheets = {};
let activeSheetId = null;
let alignV = 'center';
let lineAligns = ['left','left','left','left'];
let lineFontSizes = [11,11,11,11];
let lineStyles = [
  { bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
];
let activeStylePopover = null; // Which line's popover is open (1-4 or null)
let savedTexts = [];
let editingTextId = null;
let newSheetLabelType = '5160';
let firstRunRequired = false;
let currentTab = 'sheets';
let previewSheetId = null; // which sheet the texts tab previews against
let lastPrintJob = null;  // { sheetId, indices, textQtys } for undo
let currentMapPage = 0;  // 0-based index of visible physical sheet in grid
let newSheetCount = 1;   // sheet count in new sheet modal
let textsSubTab = 'texts';        // 'texts' | 'templates' — right column sub-tab
let templateLabelType = '5160';    // Avery label type for template preview (templates sub-tab)
let customTokens = [];             // User-defined custom tokens (persisted in localStorage)
let lastImportTemplate = null;     // Last-used template ID for import (session only)
let lastFocusedLineInput = null;   // Track which line input was last focused (for token insertion)
let composeGraphics = { left: null, right: null }; // { data: 'data:image/...', widthPct: 25 } per side
let graphicFileSide = null;        // Which side ('left'|'right') the file input is for

const CUSTOM_TOKENS_KEY = 'avery5160_custom_tokens';
const INVENTORY_KEY = 'avery_inventory';

const DEFAULT_LOW_THRESHOLD = 5;

let inventory = {};            // Persisted inventory data keyed by Avery type
let inventoryView = 'list';    // 'list' | 'history'
let inventoryDetailType = null; // Avery type for history view

// ========== HELPERS ==========
function getSpec(typeId) { return LABEL_TYPES[typeId || '5160']; }
function getSheet(id) { return sheets[id] || null; }
function getActiveSheet() { return sheets[activeSheetId] || { name: 'Unknown', printed: [], labelType: '5160', texts: {} }; }
function getActiveSpec() { return getSpec(getActiveSheet().labelType); }
function getLabelsPerSheet(sh) { sh = sh || getActiveSheet(); const s = getSpec(sh.labelType); return s.cols * s.rows; }
function getPoolSize(sh) { sh = sh || getActiveSheet(); return getLabelsPerSheet(sh) * (sh.sheetCount || 1); }
function getTotal(sh) { return getPoolSize(sh); }
function getPrinted(sh) { sh = sh || getActiveSheet(); return sh.printed || []; }
function getRemaining(sh) { return getTotal(sh) - getPrinted(sh).length; }
function getSavedText(id) { return savedTexts.find(t => t.id === id) || null; }
function getPhysicalSheet(index, sh) {
  sh = sh || getActiveSheet();
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const physicalSheet = Math.floor(index / lps);
  const localIndex = index % lps;
  const localRow = Math.floor(localIndex / spec.cols);
  const localCol = localIndex % spec.cols;
  return { physicalSheet, localIndex, row: localRow, col: localCol };
}

// Get total qty assigned to a sheet across all its texts
function getAssignedCount(sh) {
  sh = sh || getActiveSheet();
  if (!sh.texts) return 0;
  return Object.values(sh.texts).reduce((sum, t) => sum + (t.qty || 0), 0);
}

// Get available spots on a sheet (remaining - already assigned)
function getAvailableSpots(sh) {
  return Math.max(0, getRemaining(sh) - getAssignedCount(sh));
}

// Build position assignments for a sheet: derive which indices each text gets
// Returns { assignments: { textId: [indices] }, errors: [{ textId, message }] }
function buildAssignments(sh) {
  sh = sh || getActiveSheet();
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const total = lps * (sh.sheetCount || 1);
  const printed = new Set(sh.printed || []);
  const assignments = {};
  const errors = [];
  const used = new Set();

  if (!sh.texts) return { assignments, errors };

  const textIds = Object.keys(sh.texts);

  // First pass: place column-specific texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0 || placement === 'next') { continue; }

    // placement is 'col:N' (1-indexed)
    const colNum = parseInt(placement.split(':')[1]) - 1;
    if (colNum < 0 || colNum >= spec.cols) {
      assignments[textId] = [];
      errors.push({ textId, message: 'Column ' + (colNum+1) + ' does not exist on this sheet type' });
      continue;
    }
    const indices = [];
    // Iterate across all physical sheets, filling column positions
    for (let p = 0; p < (sh.sheetCount || 1) && indices.length < qty; p++) {
      for (let r = 0; r < spec.rows && indices.length < qty; r++) {
        const idx = p * lps + r * spec.cols + colNum;
        if (!printed.has(idx) && !used.has(idx)) {
          indices.push(idx);
          used.add(idx);
        }
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' in Column ' + (colNum+1) + ' but only ' + indices.length + ' available' });
    }
  }

  // Second pass: place "next available" texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0) { assignments[textId] = assignments[textId] || []; continue; }
    if (placement !== 'next') continue;

    const indices = [];
    for (let i = 0; i < total && indices.length < qty; i++) {
      if (!printed.has(i) && !used.has(i)) {
        indices.push(i);
        used.add(i);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' spots but only ' + indices.length + ' available' });
    }
  }

  // Ensure all textIds have an entry
  for (const textId of textIds) {
    if (!assignments[textId]) assignments[textId] = [];
  }

  return { assignments, errors };
}

function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
function escapeAttr(t) { return t.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' '); }
function generateId(prefix) { return (prefix || 'sh') + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5); }
function getFlexAlign(v) { return v === 'spread' ? 'space-between' : v === 'top' || v === 'left' ? 'flex-start' : v === 'bottom' || v === 'right' ? 'flex-end' : 'center'; }

// ========== TOKEN SYSTEM & TEMPLATES ==========
const BUILTIN_TOKENS = {
  'Name': ['name', 'first_name', 'last_name', 'prefix', 'suffix'],
  'Address': ['street', 'street2', 'city', 'state', 'zip', 'country'],
  'School': ['student_name', 'room', 'teacher', 'grade', 'level', 'student_id'],
  'General': ['title', 'company', 'department', 'phone', 'email']
};

const BUILTIN_TEMPLATES = [
  { id: '__builtin_mailing', name: 'Mailing Address', text: 'left,11:{first_name} {last_name}\nleft,11:{street}\nleft,11:{city}, {state} {zip}\nleft,10:{country}', alignV: 'center', type: 'template', tokens: ['first_name','last_name','street','city','state','zip','country'], builtin: true, labelType: '5160' },
  { id: '__builtin_return', name: 'Return Address', text: 'left,9:{name}\nleft,9:{street}\nleft,9:{city}, {state} {zip}', alignV: 'center', type: 'template', tokens: ['name','street','city','state','zip'], builtin: true, labelType: '5167' },
  { id: '__builtin_classroom', name: 'Classroom Label', text: 'left,14:{student_name}\ncenter,11:Room {room} || {teacher}\ncenter,10:Level: {level}', alignV: 'center', type: 'template', tokens: ['student_name','room','teacher','level'], builtin: true, labelType: '5160' },
  { id: '__builtin_namebadge', name: 'Name Badge', text: 'center,16:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5163' }
];

// Token alias map for auto-mapping columns during import
const TOKEN_ALIASES = {
  'first_name': ['first name', 'first', 'fname', 'given name', 'given_name'],
  'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name'],
  'name': ['full name', 'fullname', 'full_name', 'student name', 'student_name'],
  'student_name': ['student name', 'student', 'pupil', 'child name'],
  'street': ['street address', 'address', 'address1', 'address_1', 'street_address', 'addr'],
  'street2': ['address 2', 'address2', 'address_2', 'apt', 'suite', 'unit'],
  'city': ['town', 'municipality'],
  'state': ['province', 'region', 'st'],
  'zip': ['zip code', 'zipcode', 'postal code', 'postal_code', 'postcode', 'zip_code'],
  'country': ['nation'],
  'room': ['room number', 'room_number', 'classroom', 'rm'],
  'teacher': ['instructor', 'prof', 'professor'],
  'grade': ['grade level', 'grade_level', 'yr', 'year'],
  'level': ['reading level', 'reading_level', 'skill level', 'skill_level'],
  'student_id': ['student id', 'id', 'student_id', 'sid'],
  'title': ['job title', 'position', 'role'],
  'company': ['organization', 'org', 'employer', 'firm'],
  'department': ['dept', 'division', 'group'],
  'phone': ['telephone', 'tel', 'mobile', 'cell'],
  'email': ['e-mail', 'email address', 'email_address']
};

function loadCustomTokens() {
  try { const s = localStorage.getItem(CUSTOM_TOKENS_KEY); if (s) customTokens = JSON.parse(s); } catch(e) {}
}
function saveCustomTokens() {
  try { localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(customTokens)); } catch(e) {}
}

function extractTokens(serializedText) {
  const re = /\{([a-z][a-z0-9_]*)\}/gi;
  const tokens = [];
  const seen = new Set();
  let m;
  while ((m = re.exec(serializedText)) !== null) {
    const name = m[1].toLowerCase();
    if (!seen.has(name)) { seen.add(name); tokens.push(name); }
  }
  return tokens;
}

function getTexts() {
  return savedTexts.filter(s => s.type !== 'template');
}

function getTemplates() {
  return savedTexts.filter(s => s.type === 'template');
}

function getBuiltinTemplate(id) {
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getAllTemplates() {
  // Built-ins + user templates, sorted: built-ins first then user alpha
  const user = getTemplates().sort((a, b) => a.name.localeCompare(b.name));
  return [...BUILTIN_TEMPLATES, ...user];
}

function toggleTokenPanel() {
  const panel = document.getElementById('tokenPanel');
  const emojiPanel = document.getElementById('emojiPanel');
  const toggle = document.getElementById('tokenToggle');
  // Close emoji if open
  if (emojiPanel.classList.contains('visible')) {
    emojiPanel.classList.remove('visible');
    document.getElementById('emojiToggle').classList.remove('active');
  }
  if (panel.classList.contains('visible')) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  } else {
    renderTokenPanel();
    panel.classList.add('visible');
    toggle.classList.add('active');
  }
}

function renderTokenPanel() {
  const panel = document.getElementById('tokenPanel');
  let html = '';
  // Built-in categories
  for (const [cat, tokens] of Object.entries(BUILTIN_TOKENS)) {
    html += '<div class="token-category-label">' + escapeHtml(cat) + '</div>';
    html += '<div class="token-grid">';
    tokens.forEach(t => {
      html += '<span class="token-chip" onclick="insertToken(\'' + t + '\')">{' + t + '}</span>';
    });
    html += '</div>';
  }
  // Custom tokens
  if (customTokens.length) {
    html += '<div class="token-category-label">Custom</div>';
    html += '<div class="token-grid">';
    customTokens.forEach(t => {
      html += '<span class="token-chip" onclick="insertToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  // Add custom token row
  html += '<div class="token-custom-row">';
  html += '<input type="text" id="customTokenInput" placeholder="custom_field" maxlength="30" onkeydown="if(event.key===\'Enter\')addCustomToken()">';
  html += '<button onclick="addCustomToken()">+ Add</button>';
  html += '</div>';
  panel.innerHTML = html;
}

function insertToken(tokenName) {
  const input = lastFocusedLineInput || document.getElementById('line1');
  if (!input) return;
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const val = input.value;
  const insert = '{' + tokenName + '}';
  input.value = val.substring(0, start) + insert + val.substring(end);
  input.selectionStart = input.selectionEnd = start + insert.length;
  input.focus();
  updatePreview();
  updateDirtyIndicator();
}

function addCustomToken() {
  const inp = document.getElementById('customTokenInput');
  if (!inp) return;
  let name = inp.value.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/^_+|_+$/g, '');
  if (!name || !/^[a-z]/.test(name)) {
    inp.style.borderColor = 'var(--danger)';
    return;
  }
  // Check for duplicates across builtins and custom
  const allBuiltin = Object.values(BUILTIN_TOKENS).flat();
  if (allBuiltin.includes(name) || customTokens.includes(name)) {
    // Already exists - just insert it
    insertToken(name);
    inp.value = '';
    return;
  }
  customTokens.push(name);
  saveCustomTokens();
  renderTokenPanel();
  insertToken(name);
  inp.value = '';
}

function autoMapColumns(columns, tokens) {
  // columns: array of column header strings
  // tokens: array of token names from template
  // Returns: array of token names (or null for skip) per column
  const mapping = new Array(columns.length).fill(null);
  const usedTokens = new Set();

  for (let c = 0; c < columns.length; c++) {
    const colLower = columns[c].toLowerCase().trim();
    // Try exact match first
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      if (colLower === token || colLower === token.replace(/_/g, ' ')) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
    if (mapping[c]) continue;
    // Try alias match
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      const aliases = TOKEN_ALIASES[token] || [];
      if (aliases.some(a => a === colLower)) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
  }
  return mapping;
}

function applyTemplate(template, record) {
  // template: a saved template object
  // record: object mapping token_name → value
  // Returns: serialized text string with tokens replaced by values
  const lines = template.text.split('\n');
  return lines.map(line => {
    // Each line: align,size:content
    const colonIdx = line.indexOf(':');
    if (colonIdx === -1) return line;
    const prefix = line.substring(0, colonIdx + 1);
    let content = line.substring(colonIdx + 1);
    // Replace tokens
    content = content.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, tokenName) => {
      const val = record[tokenName.toLowerCase()];
      return val !== undefined && val !== null ? val : '';
    });
    return prefix + content;
  }).join('\n');
}

function initBuiltinTemplates() {
  // Add built-in templates if not already present (first run)
  // Built-ins are NOT stored in savedTexts — they exist as constants
  // and are merged at display time. No migration needed.
}

// Sub-tab switching
function switchSubTab(tab) {
  if (tab === textsSubTab) return;
  // Dirty check when switching sub-tabs
  if (isComposeDirty()) {
    showDirtyNavigationDialog(!!editingTextId).then(action => {
      if (action === 'stay') return;
      if (action === 'save') {
        saveCurrentText();
        doSwitchSubTab(tab);
      } else {
        doSwitchSubTab(tab);
      }
    });
    return;
  }
  doSwitchSubTab(tab);
}

function doSwitchSubTab(tab) {
  textsSubTab = tab;
  document.getElementById('subTabTexts').classList.toggle('active', tab === 'texts');
  document.getElementById('subTabTemplates').classList.toggle('active', tab === 'templates');
  const title = document.getElementById('savedTextsTitle');
  title.textContent = tab === 'texts' ? 'Saved Texts' : 'Templates';
  // Clear compose when switching to template mode if currently editing a text (and vice versa)
  const editingItem = editingTextId ? savedTexts.find(s => s.id === editingTextId) : null;
  if (editingItem) {
    const editingIsTemplate = editingItem.type === 'template';
    if ((tab === 'templates' && !editingIsTemplate) || (tab === 'texts' && editingIsTemplate)) {
      cancelEdit();
    }
  }
  // Rebuild preview dropdown for the new mode
  buildPreviewSheetSelect();
  renderSavedTexts();
  updatePreview();
  updateTabMeta();
}

// ========== CUSTOM DIALOGS ==========
let _dialogResolveFn = null;
let _dialogMode = 'confirm';

function showDialog({ title, message, okText, cancelText, mode, inputValue, inputPlaceholder, maxLength, danger }) {
  _dialogMode = mode || 'confirm';
  const modal = document.getElementById('dialogModal');
  document.getElementById('dialogTitle').textContent = title || 'Confirm';
  document.getElementById('dialogMessage').textContent = message || '';
  const okBtn = document.getElementById('dialogOkBtn');
  const cancelBtn = document.getElementById('dialogCancelBtn');
  const input = document.getElementById('dialogInput');
  okBtn.textContent = okText || 'OK';
  if (danger) { okBtn.style.background = 'var(--danger)'; okBtn.style.borderColor = 'var(--danger)'; }
  else { okBtn.style.background = ''; okBtn.style.borderColor = ''; }
  cancelBtn.textContent = cancelText || 'Cancel';
  cancelBtn.style.display = mode === 'alert' ? 'none' : '';
  if (mode === 'prompt') {
    input.style.display = ''; input.value = inputValue || ''; input.placeholder = inputPlaceholder || '';
    if (maxLength) input.maxLength = maxLength; else input.removeAttribute('maxlength');
  }
  else { input.style.display = 'none'; input.removeAttribute('maxlength'); }
  modal.classList.add('visible');
  if (mode === 'prompt') input.focus(); else okBtn.focus();
  return new Promise(resolve => { _dialogResolveFn = resolve; });
}
function dialogResolve(confirmed) {
  const input = document.getElementById('dialogInput');
  document.getElementById('dialogModal').classList.remove('visible');
  if (!_dialogResolveFn) return;
  const fn = _dialogResolveFn; _dialogResolveFn = null;
  if (_dialogMode === 'prompt') fn(confirmed ? input.value : null);
  else fn(confirmed);
}
document.addEventListener('keydown', e => {
  if (!document.getElementById('dialogModal').classList.contains('visible')) return;
  if (e.key === 'Enter') { e.preventDefault(); dialogResolve(true); }
  if (e.key === 'Escape') { dialogResolve(_dialogMode === 'alert'); }
});
function showConfirm(message, opts = {}) { return showDialog({ title: opts.title || 'Confirm', message, okText: opts.okText || 'Yes', cancelText: opts.cancelText || 'Cancel', mode: 'confirm', danger: opts.danger }); }
function showPrompt(message, defaultVal, opts = {}) { return showDialog({ title: opts.title || 'Input', message, mode: 'prompt', inputValue: defaultVal, inputPlaceholder: opts.placeholder || '', maxLength: opts.maxLength || null, okText: opts.okText || 'OK' }); }
function showAlert(message, opts = {}) { return showDialog({ title: opts.title || 'Notice', message, mode: 'alert', okText: opts.okText || 'OK' }); }

// ========== TAB NAVIGATION ==========
function switchTab(tab) {
  if (!activeSheetId && tab !== 'sheets') return;
  // If leaving texts tab with unsaved changes, offer 3 choices
  if (currentTab === 'texts' && tab !== 'texts' && isComposeDirty()) {
    showDirtyNavigationDialog(editingTextId).then(choice => {
      if (choice === 'save') {
        // Save changes then navigate
        if (editingTextId) {
          const existing = savedTexts.find(s => s.id === editingTextId);
          if (existing) {
            existing.text = serializeLines(getLines());
            existing.alignV = alignV;
            saveSavedTexts(); renderSavedTexts();
            setStatus('Saved "' + existing.name + '" and switched tabs', 'success');
          }
        }
        // For new unsaved text, we can't auto-save (no name yet) — just navigate
        doSwitchTab(tab);
      } else if (choice === 'discard') {
        doSwitchTab(tab);
      }
      // 'stay' — do nothing
    });
    return;
  }
  doSwitchTab(tab);
}

function showDirtyNavigationDialog(isEditing) {
  return new Promise(resolve => {
    const name = isEditing ? (savedTexts.find(s => s.id === isEditing)?.name || 'text') : null;
    const title = '⚠️ Unsaved Changes';
    const message = isEditing
      ? 'You have unsaved changes to "' + name + '".'
      : 'You have unsaved text in the compose area.';

    const modal = document.getElementById('dialogModal');
    document.getElementById('dialogTitle').textContent = title;
    document.getElementById('dialogMessage').textContent = message;
    document.getElementById('dialogInput').style.display = 'none';

    const btnsDiv = modal.querySelector('.modal-btns');
    const originalHtml = btnsDiv.innerHTML;
    btnsDiv.innerHTML = '';

    function finish(choice) { closeModal('dialogModal'); btnsDiv.innerHTML = originalHtml; resolve(choice); }

    const stayBtn = document.createElement('button');
    stayBtn.className = 'btn btn-secondary';
    stayBtn.textContent = 'Stay';
    stayBtn.onclick = () => finish('stay');
    btnsDiv.appendChild(stayBtn);

    if (isEditing) {
      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn btn-primary';
      saveBtn.textContent = '💾 Save & Go';
      saveBtn.onclick = () => finish('save');
      btnsDiv.appendChild(saveBtn);
    }

    const discardBtn = document.createElement('button');
    discardBtn.className = 'btn btn-danger';
    discardBtn.textContent = 'Discard & Go';
    discardBtn.onclick = () => finish('discard');
    btnsDiv.appendChild(discardBtn);

    modal.classList.add('visible');
  });
}

function doSwitchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  document.getElementById('panel' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
  updateTabMeta();

  if (tab === 'texts') { buildPreviewSheetSelect(); updatePreview(); }
  if (tab === 'sheets') { buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); }
}

function updateTabMeta() {
  const sheetsMeta = document.getElementById('tabMetaSheets');
  if (activeSheetId) {
    const sh = getActiveSheet();
    sheetsMeta.textContent = '· ' + sh.name + ' (' + getRemaining() + ' left)';
  } else {
    sheetsMeta.textContent = '· No sheet selected';
  }
  const textsMeta = document.getElementById('tabMetaTexts');
  const textCount = getTexts().length;
  const tplCount = getTemplates().length;
  let meta = '';
  if (textCount) meta += textCount + ' saved';
  if (tplCount) meta += (meta ? ' · ' : '') + tplCount + ' template' + (tplCount !== 1 ? 's' : '');
  textsMeta.textContent = meta ? '· ' + meta : '';
}

// ========== THEME ==========
function initTheme() {
  const s = localStorage.getItem(THEME_KEY);
  if (s === 'dark') document.documentElement.setAttribute('data-theme','dark');
  else if (s === 'light') document.documentElement.removeAttribute('data-theme');
  else if (matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('data-theme','dark');
  updateThemeUI();
}
function toggleTheme() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  if (d) { document.documentElement.removeAttribute('data-theme'); localStorage.setItem(THEME_KEY,'light'); }
  else { document.documentElement.setAttribute('data-theme','dark'); localStorage.setItem(THEME_KEY,'dark'); }
  updateThemeUI();
}
function updateThemeUI() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  const track = document.getElementById('themeToggleTrack');
  const label = document.getElementById('themeMenuLabel');
  const icon = document.getElementById('toggleIcon');
  if (track) track.classList.toggle('active', d);
  if (label) label.innerHTML = (d ? '☀️' : '🌙') + ' ' + (d ? 'Light Mode' : 'Dark Mode');
  if (icon) icon.textContent = d ? '🌙' : '☀️';
}

// ========== HAMBURGER MENU ==========
function toggleHamburger() {
  document.getElementById('hamburgerDropdown').classList.toggle('visible');
}
document.addEventListener('click', function(e) {
  const menu = document.getElementById('hamburgerMenu');
  if (menu && !menu.contains(e.target)) {
    document.getElementById('hamburgerDropdown').classList.remove('visible');
  }
  // Close style popovers only on click outside the popover AND outside the trigger button
  if (activeStylePopover && !e.target.closest('.style-popover') && !e.target.closest('.line-style-btn')) {
    closeStylePopovers();
  }
});
function showAboutModal() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  document.getElementById('aboutModal').classList.add('visible');
}

// ========== IMPORT / EXPORT ==========
function exportData() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  const data = {
    version: 11,
    exportedAt: new Date().toISOString(),
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    theme: localStorage.getItem(THEME_KEY) || 'light',
    inventory: Object.keys(inventory).length ? inventory : undefined
  };
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'labelkeeper-backup-' + new Date().toISOString().slice(0, 10) + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus('Data exported successfully', 'success');
}

function importData() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      // Validate structure
      if (!data.sheets || !data.savedTexts) {
        showAlert('Invalid backup file — missing sheets or saved texts data.', { title: '⚠️ Import Failed' });
        return;
      }
      const sheetCount = Object.keys(data.sheets).length;
      const textCount = data.savedTexts.length;
      const invCount = data.inventory ? Object.keys(data.inventory).length : 0;
      const invMsg = invCount > 0 ? ', ' + invCount + ' inventory type' + (invCount !== 1 ? 's' : '') : '';
      const ok = await showConfirm(
        'Import ' + sheetCount + ' sheet' + (sheetCount !== 1 ? 's' : '') + ' and ' + textCount + ' saved text' + (textCount !== 1 ? 's' : '') + invMsg + '? This will replace all current data.',
        { title: '📥 Import Data', okText: 'Import', danger: true }
      );
      if (!ok) return;
      // Apply data
      sheets = data.sheets || {};
      savedTexts = data.savedTexts || [];
      activeSheetId = data.activeSheetId || Object.keys(sheets)[0] || null;
      if (data.inventory) { inventory = data.inventory; saveInventory(); }
      // Run migrations on imported data
      for (const sh of Object.values(sheets)) {
        if (!sh.labelType) sh.labelType = '5160';
        if (!sh.texts) sh.texts = {};
        if (!sh.sheetCount) sh.sheetCount = 1;
        for (const entry of Object.values(sh.texts)) {
          if (!entry.placement) entry.placement = 'next';
        }
      }
      if (data.theme) localStorage.setItem(THEME_KEY, data.theme);
      saveSheets();
      saveSavedTexts();
      initTheme();
      lastPrintJob = null;
      currentMapPage = 0;
      // Rebuild everything
      if (Object.keys(sheets).length) {
        buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); renderSavedTexts(); updateTabMeta();
        setStatus('Imported ' + sheetCount + ' sheet' + (sheetCount !== 1 ? 's' : '') + ' and ' + textCount + ' text' + (textCount !== 1 ? 's' : ''), 'success');
      } else {
        firstRunRequired = true;
        buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); renderSavedTexts(); updateTabMeta();
        showNewSheetModal();
      }
    } catch (err) {
      showAlert('Could not read file: ' + err.message, { title: '⚠️ Import Failed' });
    }
  };
  input.click();
}

// ========== LINE INPUT SYSTEM ==========
function getLines() {
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const val = document.getElementById('line' + i).value;
    if (val.trim()) {
      const line = { text: val.trim(), align: lineAligns[i - 1], fontSize: lineFontSizes[i - 1] };
      const s = lineStyles[i - 1];
      if (s.bold) line.bold = true;
      if (s.italic) line.italic = true;
      if (s.underline) line.underline = true;
      if (s.strikethrough) line.strikethrough = true;
      if (s.color) line.color = s.color;
      if (s.fillColor) line.fillColor = s.fillColor;
      if (s.borders) line.borders = s.borders;
      lines.push(line);
    }
  }
  return lines;
}
function parseLine(text) {
  if (text.includes('||')) {
    const parts = text.split('||').map(s => s.trim());
    return { type: 'split', left: parts[0], right: parts.slice(1).join(' ').trim() };
  }
  if (text.includes('__')) {
    const idx = text.indexOf('__');
    return { type: 'fill', label: text.substring(0, idx), trailing: text.substring(idx + 2).trim() };
  }
  return { type: 'normal', text };
}
function serializeLines(lines) {
  return lines.map(l => {
    let meta = l.align + ',' + (l.fontSize || 11);
    // Encode styles compactly: flags string + color values + borders
    const flags = (l.bold ? 'b' : '') + (l.italic ? 'i' : '') + (l.underline ? 'u' : '') + (l.strikethrough ? 's' : '');
    const color = l.color || '';
    const fill = l.fillColor || '';
    const borders = l.borders || '';
    if (flags || color || fill || borders) {
      meta += ',' + flags + ',' + color + ',' + fill + ',' + borders;
    }
    return meta + ':' + l.text;
  }).join('\n');
}
function deserializeLines(str) {
  if (!str) return [];
  return str.split('\n').filter(s => s.trim()).map(s => {
    // Extended format: align,fontSize,flags,color,fillColor[,borders]:text
    const m3 = s.match(/^(left|center|right),(\d+),([\s\S]*?):(.*)$/);
    if (m3) {
      const parts = m3[3].split(',');
      const flags = parts[0] || '';
      const color = parts[1] || '';
      const fill = parts[2] || '';
      const borders = parts[3] || '';
      const line = { text: m3[4], align: m3[1], fontSize: parseInt(m3[2]) || 11 };
      if (flags.includes('b')) line.bold = true;
      if (flags.includes('i')) line.italic = true;
      if (flags.includes('u')) line.underline = true;
      if (flags.includes('s')) line.strikethrough = true;
      if (color) line.color = color;
      if (fill) line.fillColor = fill;
      if (borders) line.borders = borders;
      return line;
    }
    // Legacy format: align,fontSize:text
    const m2 = s.match(/^(left|center|right),(\d+):(.*)$/);
    if (m2) return { text: m2[3], align: m2[1], fontSize: parseInt(m2[2]) || 11 };
    const m = s.match(/^(left|center|right):(.*)$/);
    if (m) return { text: m[2], align: m[1], fontSize: 11 };
    return { text: s, align: 'left', fontSize: 11 };
  });
}
function getFlatText(lines) { return lines.map(l => l.text).join(' / '); }

function loadLinesIntoInputs(lines) {
  for (let i = 1; i <= 4; i++) { document.getElementById('line' + i).value = ''; setLineAlign(i, 'left'); setLineSize(i, 11); setLineStyle(i, {}); }
  lines.forEach((l, idx) => {
    if (idx < 4) {
      document.getElementById('line' + (idx + 1)).value = l.text;
      setLineAlign(idx + 1, l.align || 'left');
      setLineSize(idx + 1, l.fontSize || 11);
      setLineStyle(idx + 1, { bold: l.bold, italic: l.italic, underline: l.underline, strikethrough: l.strikethrough, color: l.color, fillColor: l.fillColor, borders: l.borders });
    }
  });
  updatePreview();
}
function clearInputs() {
  for (let i = 1; i <= 4; i++) { document.getElementById('line' + i).value = ''; setLineAlign(i, 'left'); setLineSize(i, 11); setLineStyle(i, {}); }
  editingTextId = null;
  document.getElementById('editingIndicator').style.display = 'none';
  closeStylePopovers();
  clearGraphics();
  updatePreview();
}
function clearInputsOnly() {
  // Clear line fields without resetting editing state or indicator
  for (let i = 1; i <= 4; i++) { document.getElementById('line' + i).value = ''; setLineAlign(i, 'left'); setLineSize(i, 11); setLineStyle(i, {}); }
  closeStylePopovers();
  clearGraphics();
  updatePreview();
}
function buildEditingIndicatorHtml(id, name, opts) {
  // opts: { prefix: 'Editing'|'Editing template'|'Viewing', builtin: bool, closeLabel: 'Cancel'|'Close' }
  const prefix = (opts && opts.prefix) || 'Editing';
  const closeLabel = (opts && opts.closeLabel) || 'Cancel';
  const isBuiltin = opts && opts.builtin;
  let html = '<span>' + prefix + ': <strong>' + escapeHtml(name) + '</strong>';
  if (isBuiltin) html += ' <em style="color:var(--text-muted);font-size:12px">(built-in — clone to customize)</em>';
  html += '</span><span>';
  if (!isBuiltin && id) {
    html += '<button class="cancel-edit" onclick="renameSavedItem(\'' + id + '\')" style="margin-right:8px;text-decoration:none" title="Rename">Aa</button>';
  }
  html += '<button class="cancel-edit" onclick="cancelEdit()">' + closeLabel + '</button></span>';
  return html;
}
function hasAnyInput() {
  for (let i = 1; i <= 4; i++) { if (document.getElementById('line' + i).value.trim()) return true; }
  if (hasAnyGraphic()) return true;
  return false;
}
function setLineAlign(lineNum, align) {
  lineAligns[lineNum - 1] = align;
  ['left','center','right'].forEach(a => { document.getElementById('align' + lineNum + '_' + a).classList.toggle('active', a === align); });
  updatePreview();
}
function stepSize(lineNum, delta) {
  let val = lineFontSizes[lineNum - 1] + delta;
  val = Math.max(7, Math.min(16, val));
  lineFontSizes[lineNum - 1] = val;
  document.getElementById('size' + lineNum).textContent = val;
  updatePreview();
}
function setLineSize(lineNum, size) {
  lineFontSizes[lineNum - 1] = Math.max(7, Math.min(16, size));
  document.getElementById('size' + lineNum).textContent = lineFontSizes[lineNum - 1];
}

// ========== LINE STYLE POPOVER ==========
const STYLE_COLORS = [
  { id: '', label: 'None' },
  { id: '#000000', label: 'Black' },
  { id: '#CC0000', label: 'Red' },
  { id: '#0055CC', label: 'Blue' },
  { id: '#007A33', label: 'Green' },
  { id: '#DD6600', label: 'Orange' },
  { id: '#7B2D8E', label: 'Purple' },
  { id: '#8B4513', label: 'Brown' },
  { id: '#555555', label: 'Grey' }
];
const FILL_COLORS = [
  { id: '', label: 'None' },
  { id: '#FFDDDD', label: 'Light Red' },
  { id: '#DDEEFF', label: 'Light Blue' },
  { id: '#DDFFDD', label: 'Light Green' },
  { id: '#FFF3CC', label: 'Light Yellow' },
  { id: '#F3E5FF', label: 'Light Purple' },
  { id: '#FFE8CC', label: 'Light Orange' },
  { id: '#E8E8E8', label: 'Light Grey' },
  { id: '#000000', label: 'Black' }
];

function getDefaultLineStyle() {
  return { bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' };
}

function hasLineStyle(lineNum) {
  const s = lineStyles[lineNum - 1];
  return s.bold || s.italic || s.underline || s.strikethrough || s.color || s.fillColor || s.borders;
}

function updateStyleBtnIndicator(lineNum) {
  const btn = document.getElementById('styleBtn' + lineNum);
  btn.classList.toggle('has-styles', hasLineStyle(lineNum));
}

function toggleStylePopover(lineNum) {
  const popover = document.getElementById('stylePopover' + lineNum);
  const btn = document.getElementById('styleBtn' + lineNum);
  if (activeStylePopover === lineNum) {
    popover.classList.remove('open');
    btn.classList.remove('popover-open');
    activeStylePopover = null;
    return;
  }
  // Close any other open popover
  if (activeStylePopover) {
    document.getElementById('stylePopover' + activeStylePopover).classList.remove('open');
    document.getElementById('styleBtn' + activeStylePopover).classList.remove('popover-open');
  }
  // Build and show this popover
  popover.innerHTML = buildStylePopoverHtml(lineNum);
  popover.classList.add('open');
  btn.classList.add('popover-open');
  activeStylePopover = lineNum;
}

function closeStylePopovers() {
  if (activeStylePopover) {
    document.getElementById('stylePopover' + activeStylePopover).classList.remove('open');
    document.getElementById('styleBtn' + activeStylePopover).classList.remove('popover-open');
    activeStylePopover = null;
  }
}

function buildStylePopoverHtml(lineNum) {
  const s = lineStyles[lineNum - 1];
  const bord = s.borders || '';
  const stop = 'event.stopPropagation();';
  let html = '<div class="style-popover-section"><div class="style-popover-label">Format</div><div class="style-toggles">';
  html += '<button class="style-toggle-btn' + (s.bold ? ' active' : '') + '" onclick="' + stop + 'toggleLineStyle(' + lineNum + ',\'bold\')" title="Bold"><span class="btn-label-b">B</span></button>';
  html += '<button class="style-toggle-btn' + (s.italic ? ' active' : '') + '" onclick="' + stop + 'toggleLineStyle(' + lineNum + ',\'italic\')" title="Italic"><span class="btn-label-i">I</span></button>';
  html += '<button class="style-toggle-btn' + (s.underline ? ' active' : '') + '" onclick="' + stop + 'toggleLineStyle(' + lineNum + ',\'underline\')" title="Underline"><span class="btn-label-u">U</span></button>';
  html += '<button class="style-toggle-btn' + (s.strikethrough ? ' active' : '') + '" onclick="' + stop + 'toggleLineStyle(' + lineNum + ',\'strikethrough\')" title="Strikethrough"><span class="btn-label-s">S</span></button>';
  html += '</div></div>';
  // Borders
  html += '<div class="style-popover-section"><div class="style-popover-label">Borders</div><div class="style-toggles">';
  html += '<button class="style-toggle-btn border-toggle' + (bord.includes('t') ? ' active' : '') + '" onclick="' + stop + 'toggleLineBorder(' + lineNum + ',\'t\')" title="Top">T</button>';
  html += '<button class="style-toggle-btn border-toggle' + (bord.includes('b') ? ' active' : '') + '" onclick="' + stop + 'toggleLineBorder(' + lineNum + ',\'b\')" title="Bottom">B</button>';
  html += '<button class="style-toggle-btn border-toggle' + (bord.includes('l') ? ' active' : '') + '" onclick="' + stop + 'toggleLineBorder(' + lineNum + ',\'l\')" title="Left">L</button>';
  html += '<button class="style-toggle-btn border-toggle' + (bord.includes('r') ? ' active' : '') + '" onclick="' + stop + 'toggleLineBorder(' + lineNum + ',\'r\')" title="Right">R</button>';
  html += '<button class="style-toggle-btn border-toggle' + (bord === 'tblr' ? ' active' : '') + '" onclick="' + stop + 'toggleLineBorder(' + lineNum + ',\'all\')" title="All borders" style="font-size:11px">All</button>';
  html += '</div></div>';
  // Text color
  html += '<div class="style-popover-section"><div class="style-popover-label">Text Color</div><div class="color-palette">';
  STYLE_COLORS.forEach(c => {
    const isActive = (s.color || '') === c.id;
    if (!c.id) {
      html += '<div class="color-swatch swatch-none' + (isActive ? ' active' : '') + '" onclick="' + stop + 'setLineColor(' + lineNum + ',\'\')" title="Default"></div>';
    } else {
      html += '<div class="color-swatch' + (isActive ? ' active' : '') + '" style="background:' + c.id + '" onclick="' + stop + 'setLineColor(' + lineNum + ',\'' + c.id + '\')" title="' + c.label + '"></div>';
    }
  });
  html += '</div></div>';
  // Fill color
  html += '<div class="style-popover-section"><div class="style-popover-label">Fill Color</div><div class="color-palette">';
  FILL_COLORS.forEach(c => {
    const isActive = (s.fillColor || '') === c.id;
    if (!c.id) {
      html += '<div class="color-swatch swatch-none' + (isActive ? ' active' : '') + '" onclick="' + stop + 'setLineFillColor(' + lineNum + ',\'\')" title="None"></div>';
    } else {
      html += '<div class="color-swatch' + (isActive ? ' active' : '') + '" style="background:' + c.id + '" onclick="' + stop + 'setLineFillColor(' + lineNum + ',\'' + c.id + '\')" title="' + c.label + '"></div>';
    }
  });
  html += '</div></div>';
  return html;
}

function toggleLineStyle(lineNum, prop) {
  const s = lineStyles[lineNum - 1];
  // Underline and strikethrough are mutually exclusive
  if (prop === 'underline' && !s.underline) s.strikethrough = false;
  if (prop === 'strikethrough' && !s.strikethrough) s.underline = false;
  s[prop] = !s[prop];
  // Refresh popover to reflect state
  document.getElementById('stylePopover' + lineNum).innerHTML = buildStylePopoverHtml(lineNum);
  updateStyleBtnIndicator(lineNum);
  updatePreview();
}

function setLineColor(lineNum, color) {
  lineStyles[lineNum - 1].color = color;
  document.getElementById('stylePopover' + lineNum).innerHTML = buildStylePopoverHtml(lineNum);
  updateStyleBtnIndicator(lineNum);
  updatePreview();
}

function setLineFillColor(lineNum, color) {
  lineStyles[lineNum - 1].fillColor = color;
  document.getElementById('stylePopover' + lineNum).innerHTML = buildStylePopoverHtml(lineNum);
  updateStyleBtnIndicator(lineNum);
  updatePreview();
}

function toggleLineBorder(lineNum, side) {
  const s = lineStyles[lineNum - 1];
  let bord = s.borders || '';
  if (side === 'all') {
    // Toggle all: if all four are on, clear them; otherwise set all
    bord = bord === 'tblr' ? '' : 'tblr';
  } else {
    bord = bord.includes(side) ? bord.replace(side, '') : bord + side;
    // Normalize order to tblr
    bord = ['t','b','l','r'].filter(c => bord.includes(c)).join('');
  }
  s.borders = bord;
  document.getElementById('stylePopover' + lineNum).innerHTML = buildStylePopoverHtml(lineNum);
  updateStyleBtnIndicator(lineNum);
  updatePreview();
}

function setLineStyle(lineNum, style) {
  lineStyles[lineNum - 1] = { ...getDefaultLineStyle(), ...style };
  updateStyleBtnIndicator(lineNum);
}
function setAlignV(v) { alignV = v; document.querySelectorAll('[data-align-v]').forEach(b => b.classList.toggle('active', b.dataset.alignV === v)); updatePreview(); }

// ========== EMOJI PICKER ==========
const EMOJI_DATA = [
  { cat: 'Common', emojis: [
    { e: '⭐', n: 'star' }, { e: '❤️', n: 'heart love' }, { e: '✅', n: 'check done' }, { e: '❌', n: 'x cross no' },
    { e: '⚠️', n: 'warning caution' }, { e: '📌', n: 'pin pushpin' }, { e: '🔴', n: 'red circle' }, { e: '🟢', n: 'green circle' },
    { e: '🔵', n: 'blue circle' }, { e: '🟡', n: 'yellow circle' }, { e: '⬛', n: 'black square' }, { e: '⬜', n: 'white square' },
    { e: '▶️', n: 'play arrow right' }, { e: '◀️', n: 'left arrow' }, { e: '🔹', n: 'diamond blue' }, { e: '🔸', n: 'diamond orange' },
  ]},
  { cat: 'School', emojis: [
    { e: '📚', n: 'books reading' }, { e: '📖', n: 'open book reading' }, { e: '🎒', n: 'backpack school bag' }, { e: '✂️', n: 'scissors craft' },
    { e: '📐', n: 'triangle ruler math' }, { e: '📏', n: 'ruler measure' }, { e: '🖍️', n: 'crayon color draw' }, { e: '🖌️', n: 'paintbrush art' },
    { e: '🎨', n: 'art palette paint color' }, { e: '🔬', n: 'microscope science' }, { e: '🧪', n: 'test tube science lab' }, { e: '🧮', n: 'abacus math count' },
    { e: '🎵', n: 'music note' }, { e: '🎶', n: 'music notes' }, { e: '🏅', n: 'medal award' }, { e: '🏆', n: 'trophy winner award' },
    { e: '📓', n: 'notebook journal' }, { e: '🖊️', n: 'pen write' }, { e: '✏️', n: 'pencil write' }, { e: '📝', n: 'memo note write' },
    { e: '🧩', n: 'puzzle piece' }, { e: '🎲', n: 'dice game' }, { e: '🧸', n: 'teddy bear toy' }, { e: '🪁', n: 'kite play' },
    { e: '🍎', n: 'apple teacher' }, { e: '🐛', n: 'caterpillar bug insect' }, { e: '🐸', n: 'frog animal' }, { e: '🐢', n: 'turtle animal slow' },
    { e: '🦕', n: 'dinosaur dino' }, { e: '🐝', n: 'bee honeybee insect' }, { e: '🐞', n: 'ladybug insect' }, { e: '🦁', n: 'lion animal' },
  ]},
  { cat: 'People', emojis: [
    { e: '😀', n: 'smile happy' }, { e: '😊', n: 'blush smile' }, { e: '👋', n: 'wave hello' }, { e: '👍', n: 'thumbs up' },
    { e: '👎', n: 'thumbs down' }, { e: '👏', n: 'clap hands' }, { e: '🙏', n: 'pray thanks' }, { e: '💪', n: 'strong muscle' },
    { e: '🎉', n: 'party celebrate' }, { e: '🎂', n: 'birthday cake' }, { e: '👤', n: 'person silhouette' }, { e: '👥', n: 'people group' },
  ]},
  { cat: 'Office', emojis: [
    { e: '📁', n: 'folder file' }, { e: '📂', n: 'open folder' }, { e: '📋', n: 'clipboard' }, { e: '📎', n: 'paperclip' },
    { e: '✏️', n: 'pencil edit' }, { e: '🖊️', n: 'pen' }, { e: '📝', n: 'memo note' }, { e: '📊', n: 'chart graph' },
    { e: '📅', n: 'calendar date' }, { e: '🗓️', n: 'calendar spiral' }, { e: '📇', n: 'card index' }, { e: '🏷️', n: 'label tag' },
    { e: '📦', n: 'box package' }, { e: '🗂️', n: 'dividers tabs' }, { e: '🔑', n: 'key' }, { e: '🔒', n: 'lock' },
  ]},
  { cat: 'Places', emojis: [
    { e: '🏠', n: 'home house' }, { e: '🏢', n: 'office building' }, { e: '🏫', n: 'school' }, { e: '🏥', n: 'hospital' },
    { e: '⛪', n: 'church' }, { e: '🏛️', n: 'classical building' }, { e: '📍', n: 'location pin' }, { e: '🚗', n: 'car' },
    { e: '✈️', n: 'airplane travel' }, { e: '🌎', n: 'earth globe' }, { e: '🏪', n: 'store shop' }, { e: '🅿️', n: 'parking' },
  ]},
  { cat: 'Nature', emojis: [
    { e: '🌟', n: 'glowing star' }, { e: '☀️', n: 'sun' }, { e: '🌙', n: 'moon' }, { e: '🌈', n: 'rainbow' },
    { e: '🔥', n: 'fire hot' }, { e: '💧', n: 'water drop' }, { e: '❄️', n: 'snowflake cold' }, { e: '🌺', n: 'flower' },
    { e: '🌲', n: 'tree pine' }, { e: '🍀', n: 'clover luck' }, { e: '🐾', n: 'paw prints animal' }, { e: '🦋', n: 'butterfly' },
  ]},
  { cat: 'Arrows & Numbers', emojis: [
    { e: '➡️', n: 'right arrow' }, { e: '⬅️', n: 'left arrow' }, { e: '⬆️', n: 'up arrow' }, { e: '⬇️', n: 'down arrow' },
    { e: '↩️', n: 'return back' }, { e: '🔄', n: 'refresh cycle' }, { e: '①', n: 'one 1' }, { e: '②', n: 'two 2' },
    { e: '③', n: 'three 3' }, { e: '④', n: 'four 4' }, { e: '⑤', n: 'five 5' }, { e: 'Ⓐ', n: 'letter a' },
    { e: 'Ⓑ', n: 'letter b' }, { e: 'Ⓒ', n: 'letter c' }, { e: '™', n: 'trademark' }, { e: '©', n: 'copyright' },
  ]},
];
let lastFocusedLine = 'line1';
document.addEventListener('focusin', e => {
  if (e.target.id && e.target.id.match(/^line[1-4]$/)) {
    lastFocusedLine = e.target.id;
    lastFocusedLineInput = e.target;
  }
});

function toggleEmojiPanel() {
  const panel = document.getElementById('emojiPanel'), btn = document.getElementById('emojiToggle');
  // Close token panel if open
  const tokenPanel = document.getElementById('tokenPanel');
  if (tokenPanel.classList.contains('visible')) {
    tokenPanel.classList.remove('visible');
    document.getElementById('tokenToggle').classList.remove('active');
  }
  const show = !panel.classList.contains('visible');
  panel.classList.toggle('visible', show); btn.classList.toggle('active', show);
  if (show) { renderEmojiPanel(); document.getElementById('emojiSearch').value = ''; document.getElementById('emojiSearch').focus(); }
}
function renderEmojiPanel(filter) {
  const scroll = document.getElementById('emojiScroll');
  const q = (filter || '').toLowerCase().trim();
  let html = '';
  EMOJI_DATA.forEach(cat => {
    const filtered = q ? cat.emojis.filter(em => em.n.includes(q) || em.e === q) : cat.emojis;
    if (!filtered.length) return;
    html += '<div class="emoji-category"><div class="emoji-category-label">' + cat.cat + '</div><div class="emoji-grid">';
    filtered.forEach(em => { html += '<button class="emoji-btn" onclick="insertEmoji(\'' + em.e + '\')" title="' + em.n + '">' + em.e + '</button>'; });
    html += '</div></div>';
  });
  if (!html) html = '<div style="padding:12px;text-align:center;font-size:12px;color:var(--text-muted)">No matches</div>';
  scroll.innerHTML = html;
}
function filterEmojis() { renderEmojiPanel(document.getElementById('emojiSearch').value); }
function insertEmoji(emoji) {
  const input = document.getElementById(lastFocusedLine);
  const start = input.selectionStart || input.value.length, end = input.selectionEnd || start;
  input.value = input.value.slice(0, start) + emoji + input.value.slice(end);
  input.focus(); const pos = start + emoji.length; input.setSelectionRange(pos, pos); updatePreview();
}
document.addEventListener('click', e => {
  const panel = document.getElementById('emojiPanel'), btn = document.getElementById('emojiToggle');
  if (panel && panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== btn && !btn.contains(e.target)) {
    panel.classList.remove('visible'); btn.classList.remove('active');
  }
});

// Close graphic picker on click outside
document.addEventListener('click', e => {
  if (!graphicPickerSide) return;
  const target = e.target;
  // If the target was removed from DOM (tab re-render), don't close
  if (!document.contains(target)) return;
  // Check if click is inside any picker, on an add/swap button, or on a thumbnail
  if (target.closest('.graphic-picker') || target.closest('.graphic-add-btn') || target.closest('.graphic-swap-btn') || target.closest('.graphic-thumb')) return;
  closeGraphicPicker();
});

// Close graphic picker on Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && graphicPickerSide) {
    closeGraphicPicker();
  }
});

// ========== RENDERING HELPERS ==========
function buildLineStyleStr(lineObj) {
  let style = 'font-size:' + (lineObj.fontSize || 11) + 'px';
  if (lineObj.bold) style += ';font-weight:bold';
  if (lineObj.italic) style += ';font-style:italic';
  const deco = lineObj.underline ? 'underline' : lineObj.strikethrough ? 'line-through' : '';
  if (deco) style += ';text-decoration:' + deco;
  if (lineObj.color) style += ';color:' + lineObj.color;
  if (lineObj.fillColor) style += ';background-color:' + lineObj.fillColor;
  const bord = lineObj.borders || '';
  if (bord) {
    const sides = [];
    if (bord.includes('t')) sides.push('border-top:1px solid #000');
    if (bord.includes('b')) sides.push('border-bottom:1px solid #000');
    if (bord.includes('l')) sides.push('border-left:1px solid #000');
    if (bord.includes('r')) sides.push('border-right:1px solid #000');
    style += ';' + sides.join(';');
  }
  if (lineObj.fillColor || bord) style += ';padding:1px 3px';
  return style;
}
function renderLineHtml(lineObj, escaped) {
  const parsed = parseLine(lineObj.text);
  // Show token pills in live preview when in template sub-tab
  const useTokenPills = escaped && textsSubTab === 'templates';
  const txt = useTokenPills ? (t => escapeHtmlWithTokenPills(t)) : escaped ? (t => escapeHtml(t)) : (t => t);
  const style = buildLineStyleStr(lineObj);
  if (parsed.type === 'split') return '<div class="preview-line align-split" style="' + style + '"><span>' + txt(parsed.left) + '</span><span>' + txt(parsed.right) + '</span></div>';
  if (parsed.type === 'fill') return '<div class="preview-line fill-line" style="' + style + '"><span class="fill-label">' + txt(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + txt(parsed.trailing) + '</span>' : '') + '</div>';
  return '<div class="preview-line align-' + lineObj.align + '" style="' + style + '">' + txt(parsed.text) + '</div>';
}
function renderPrintLineHtml(lineObj) {
  const parsed = parseLine(lineObj.text);
  const style = buildLineStyleStr(lineObj);
  if (parsed.type === 'split') return '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
  if (parsed.type === 'fill') return '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
  return '<div class="print-line align-' + lineObj.align + '" style="' + style + '">' + escapeHtml(parsed.text) + '</div>';
}
function renderMiniPreview(lines, showTokenPills, graphics) {
  const linesHtml = lines.map(l => {
    const parsed = parseLine(l.text);
    const miniLine = { ...l, fontSize: Math.min(l.fontSize || 11, 10) };
    const style = buildLineStyleStr(miniLine);
    const esc = showTokenPills ? escapeHtmlWithTokenPills : escapeHtml;
    if (parsed.type === 'split') return '<div class="preview-line align-split" style="' + style + '"><span>' + esc(parsed.left) + '</span><span>' + esc(parsed.right) + '</span></div>';
    if (parsed.type === 'fill') return '<div class="preview-line fill-line" style="' + style + '"><span class="fill-label">' + esc(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + esc(parsed.trailing) + '</span>' : '') + '</div>';
    return '<div class="preview-line align-' + l.align + '" style="' + style + '">' + esc(parsed.text) + '</div>';
  }).join('');

  const hasGfx = graphics && (graphics.left || graphics.right);
  if (!hasGfx) return linesHtml;

  // Wrap in flex row with graphic thumbnails
  let html = '<div style="display:flex;flex-direction:row;align-items:stretch;width:100%;height:100%;">';
  if (graphics.left) html += '<div class="preview-graphic" style="width:' + graphics.left.widthPct + '%;flex-shrink:0;"><img src="' + graphics.left.data + '" alt=""></div>';
  html += '<div style="flex:1;display:flex;flex-direction:column;min-width:0;overflow:hidden;">' + linesHtml + '</div>';
  if (graphics.right) html += '<div class="preview-graphic" style="width:' + graphics.right.widthPct + '%;flex-shrink:0;"><img src="' + graphics.right.data + '" alt=""></div>';
  html += '</div>';
  return html;
}

function escapeHtmlWithTokenPills(text) {
  // Escape HTML but render {token_name} as styled pills
  return text.replace(/(\{[a-z][a-z0-9_]*\})|([^{]+|\{)/gi, (match, token, plain) => {
    if (token) return '<span class="token-pill">' + escapeHtml(token) + '</span>';
    return escapeHtml(plain || match);
  });
}

// ========== LABEL GRAPHICS (v1.7.0) ==========
const GRAPHIC_SIZES = { S: 20, M: 25, L: 30 };
const GRAPHIC_SIZE_LABELS = { 20: 'S', 25: 'M', 30: 'L' };
const GRAPHIC_MAX_DIM = 200;    // Max pixel dimension for processed images
const GRAPHIC_JPEG_QUALITY = 0.8;
const GRAPHIC_WARN_BYTES = 50000; // Warn if processed image exceeds 50KB

// ========== GRAPHIC REPOSITORY (v1.8.0) ==========
const ICONIFY_API = 'https://api.iconify.design';
const ICONIFY_SEARCH_LIMIT = 24;
const ICONIFY_COLORED_PREFIXES = 'fluent-emoji-flat,noto,twemoji,emojione,fxemoji,openmoji';
const ICONIFY_DEBOUNCE_MS = 400;
const ICONIFY_TIMEOUT_MS = 5000;

const GRAPHIC_CATEGORIES = {
  school:   { label: '📚 School', order: 1 },
  mailing:  { label: '✉️ Mailing', order: 2 },
  winter:   { label: '❄️ Winter', order: 3 },
  spring:   { label: '🌷 Spring', order: 4 },
  summer:   { label: '☀️ Summer/Fall', order: 5 },
  occasion: { label: '🎉 Occasions', order: 6 },
  symbol:   { label: '⚡ Symbols', order: 7 }
};

const GRAPHIC_LIBRARY = [
  // ---- School & Education ----
  {id:'apple',name:'Apple',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M35 6c0-2-2-4-4-4s-3 2-3 4c0 1 1 3 3 4h1c2-1 3-3 3-4z" fill="#4a7c3f"/><path d="M30 10c-1 0-2 0-3 1-6 2-13 10-13 22 0 14 8 23 18 23s18-9 18-23c0-12-7-20-13-22-1-1-2-1-3-1h-4z" fill="#e74c3c"/><path d="M34 10c6 2 13 10 13 22 0 14-8 23-18 23-3 0-5-1-7-3 3 2 6 3 9 3 10 0 16-9 16-23 0-10-5-17-10-20-1-1-2-2-3-2z" fill="#c0392b"/></svg>'},
  {id:'book',name:'Book',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="10" y="8" width="44" height="48" rx="3" fill="#3498db"/><rect x="14" y="8" width="40" height="48" rx="2" fill="#ecf0f1"/><rect x="14" y="8" width="4" height="48" fill="#bdc3c7"/><line x1="22" y1="18" x2="48" y2="18" stroke="#bdc3c7" stroke-width="2"/><line x1="22" y1="26" x2="48" y2="26" stroke="#bdc3c7" stroke-width="2"/><line x1="22" y1="34" x2="40" y2="34" stroke="#bdc3c7" stroke-width="2"/></svg>'},
  {id:'pencil',name:'Pencil',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="10,54 8,60 14,58" fill="#f0c27a"/><rect x="12" y="14" width="8" height="40" rx="1" transform="rotate(-45 16 34)" fill="#f1c40f"/><rect x="12" y="10" width="8" height="8" rx="1" transform="rotate(-45 16 14)" fill="#e74c3c"/><polygon points="6,52 10,48 12,50 8,54" fill="#2c3e50"/></svg>'},
  {id:'ruler',name:'Ruler',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="22" width="48" height="20" rx="2" fill="#f39c12" stroke="#e67e22" stroke-width="1"/><g stroke="#fff" stroke-width="1.5"><line x1="16" y1="22" x2="16" y2="30"/><line x1="24" y1="22" x2="24" y2="34"/><line x1="32" y1="22" x2="32" y2="30"/><line x1="40" y1="22" x2="40" y2="34"/><line x1="48" y1="22" x2="48" y2="30"/></g></svg>'},
  {id:'scissors',name:'Scissors',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="18" cy="46" r="8" fill="none" stroke="#e74c3c" stroke-width="3"/><circle cx="46" cy="46" r="8" fill="none" stroke="#e74c3c" stroke-width="3"/><line x1="24" y1="40" x2="46" y2="10" stroke="#e74c3c" stroke-width="3" stroke-linecap="round"/><line x1="40" y1="40" x2="18" y2="10" stroke="#e74c3c" stroke-width="3" stroke-linecap="round"/></svg>'},
  {id:'crayon',name:'Crayon',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="18" y="16" width="16" height="36" rx="2" fill="#e74c3c"/><rect x="18" y="16" width="16" height="8" fill="#c0392b"/><polygon points="22,52 26,62 30,52" fill="#e74c3c"/><rect x="20" y="20" width="12" height="2" fill="#fff" opacity="0.3"/></svg>'},
  {id:'globe',name:'Globe',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="30" r="22" fill="#5dade2"/><ellipse cx="32" cy="30" rx="10" ry="22" fill="none" stroke="#2e86c1" stroke-width="1.5"/><line x1="10" y1="30" x2="54" y2="30" stroke="#2e86c1" stroke-width="1.5"/><ellipse cx="32" cy="20" rx="18" ry="6" fill="none" stroke="#2e86c1" stroke-width="1"/><path d="M16 48 L24 56 L40 56 L48 48" fill="none" stroke="#7f8c8d" stroke-width="2.5"/><line x1="32" y1="52" x2="32" y2="58" stroke="#7f8c8d" stroke-width="2.5"/><line x1="22" y1="58" x2="42" y2="58" stroke="#7f8c8d" stroke-width="2.5"/></svg>'},
  {id:'backpack',name:'Backpack',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="14" y="18" width="36" height="38" rx="6" fill="#e74c3c"/><rect x="20" y="30" width="24" height="14" rx="3" fill="#c0392b"/><rect x="22" y="8" width="20" height="14" rx="4" fill="#e74c3c"/><path d="M24 18v-6a8 8 0 0 1 16 0v6" fill="none" stroke="#c0392b" stroke-width="2"/><rect x="29" y="34" width="6" height="6" rx="1" fill="#f39c12"/></svg>'},
  {id:'schoolbus',name:'School Bus',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="4" y="20" width="56" height="24" rx="4" fill="#f1c40f"/><rect x="4" y="20" width="56" height="8" fill="#f39c12"/><rect x="10" y="24" width="10" height="10" rx="2" fill="#ecf0f1"/><rect x="27" y="24" width="10" height="10" rx="2" fill="#ecf0f1"/><rect x="44" y="24" width="10" height="10" rx="2" fill="#ecf0f1"/><circle cx="16" cy="48" r="5" fill="#2c3e50"/><circle cx="48" cy="48" r="5" fill="#2c3e50"/><rect x="4" y="44" width="56" height="4" fill="#e67e22"/></svg>'},
  {id:'gradcap',name:'Graduation Cap',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,12 4,28 32,44 60,28" fill="#2c3e50"/><polygon points="32,44 16,36 16,48 32,56 48,48 48,36" fill="#34495e"/><line x1="56" y1="28" x2="56" y2="50" stroke="#f1c40f" stroke-width="2"/><circle cx="56" cy="52" r="3" fill="#f1c40f"/></svg>'},
  {id:'star',name:'Star',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,4 40,24 60,26 45,40 49,60 32,50 15,60 19,40 4,26 24,24" fill="#f1c40f"/></svg>'},
  {id:'microscope',name:'Microscope',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="16" y="52" width="32" height="6" rx="2" fill="#7f8c8d"/><rect x="28" y="14" width="8" height="38" rx="2" fill="#95a5a6"/><circle cx="32" cy="14" r="8" fill="none" stroke="#3498db" stroke-width="3"/><rect x="22" y="44" width="20" height="4" rx="1" fill="#7f8c8d"/><circle cx="32" cy="14" r="3" fill="#3498db" opacity="0.3"/></svg>'},
  {id:'palette',name:'Art Palette',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 8C18 8 6 20 6 34c0 10 6 18 16 22 2 0 4-2 4-4 0-3-4-4-4-8 0-4 4-6 8-6 14 0 28-8 28-18C58 12 46 8 32 8z" fill="#f0e0c0"/><circle cx="20" cy="24" r="5" fill="#e74c3c"/><circle cx="34" cy="18" r="4" fill="#f1c40f"/><circle cx="46" cy="24" r="4" fill="#3498db"/><circle cx="44" cy="36" r="3" fill="#2ecc71"/><circle cx="26" cy="34" r="3" fill="#9b59b6"/></svg>'},
  {id:'musicnote',name:'Music Note',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="22" cy="48" rx="10" ry="8" fill="#2c3e50"/><rect x="30" y="12" width="4" height="36" fill="#2c3e50"/><path d="M34 12 L52 6 L52 20 L34 26z" fill="#e74c3c"/></svg>'},
  {id:'abc',name:'ABC Blocks',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="4" y="30" width="24" height="24" rx="3" fill="#e74c3c"/><rect x="20" y="18" width="24" height="24" rx="3" fill="#3498db"/><rect x="36" y="30" width="24" height="24" rx="3" fill="#2ecc71"/><text x="16" y="48" text-anchor="middle" fill="#fff" font-family="Arial" font-weight="bold" font-size="14">A</text><text x="32" y="36" text-anchor="middle" fill="#fff" font-family="Arial" font-weight="bold" font-size="14">B</text><text x="48" y="48" text-anchor="middle" fill="#fff" font-family="Arial" font-weight="bold" font-size="14">C</text></svg>'},
  {id:'bell',name:'School Bell',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 8a4 4 0 0 0-4 4v2c-8 2-14 10-14 20v6h36v-6c0-10-6-18-14-20v-2a4 4 0 0 0-4-4z" fill="#f1c40f"/><rect x="12" y="40" width="40" height="6" rx="3" fill="#f39c12"/><circle cx="32" cy="52" r="5" fill="#f39c12"/></svg>'},
  {id:'owl',name:'Owl',cat:'school',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="36" rx="20" ry="22" fill="#8B6914"/><circle cx="24" cy="30" r="9" fill="#fff"/><circle cx="40" cy="30" r="9" fill="#fff"/><circle cx="24" cy="30" r="5" fill="#2c3e50"/><circle cx="40" cy="30" r="5" fill="#2c3e50"/><polygon points="32,34 28,42 36,42" fill="#f39c12"/><path d="M12 20 L22 26" stroke="#8B6914" stroke-width="3" stroke-linecap="round"/><path d="M52 20 L42 26" stroke="#8B6914" stroke-width="3" stroke-linecap="round"/></svg>'},
  // ---- Mailing & Address ----
  {id:'envelope',name:'Envelope',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="4" y="14" width="56" height="36" rx="3" fill="#5dade2"/><path d="M4 14l28 20 28-20" fill="#3498db"/><path d="M4 50l20-16M60 50l-20-16" stroke="#2e86c1" stroke-width="1.5" fill="none"/></svg>'},
  {id:'mailbox',name:'Mailbox',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="10" y="16" width="36" height="24" rx="12" fill="#3498db"/><rect x="26" y="40" width="4" height="16" fill="#7f8c8d"/><rect x="18" y="52" width="20" height="4" rx="1" fill="#95a5a6"/><rect x="46" y="16" width="8" height="20" rx="2" fill="#e74c3c"/><path d="M46 22h8" stroke="#c0392b" stroke-width="2"/></svg>'},
  {id:'stamp',name:'Stamp',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="8" width="48" height="48" rx="2" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="2" stroke-dasharray="4 3"/><rect x="14" y="14" width="36" height="36" rx="1" fill="#e8d5e0"/><circle cx="32" cy="28" r="10" fill="#9b59b6"/><text x="32" y="48" text-anchor="middle" fill="#7f8c8d" font-family="Arial" font-size="8" font-weight="bold">STAMP</text></svg>'},
  {id:'house',name:'House',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,8 6,32 14,32 14,56 50,56 50,32 58,32" fill="#e74c3c"/><rect x="14" y="32" width="36" height="24" fill="#ecf0f1"/><rect x="26" y="38" width="12" height="18" fill="#8B6914"/><circle cx="36" cy="48" r="1.5" fill="#f1c40f"/><polygon points="32,8 6,32 58,32" fill="#c0392b"/></svg>'},
  {id:'locpin',name:'Location Pin',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 4C20 4 12 13 12 24c0 16 20 36 20 36s20-20 20-36C52 13 44 4 32 4z" fill="#e74c3c"/><circle cx="32" cy="24" r="8" fill="#fff"/></svg>'},
  {id:'airplane',name:'Airplane',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 4L28 24 8 32l20 4 4 24 4-24 20-4-20-8z" fill="#3498db"/><circle cx="32" cy="32" r="4" fill="#2e86c1"/></svg>'},
  {id:'package',name:'Package',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="16" width="48" height="36" rx="2" fill="#e67e22"/><rect x="8" y="16" width="48" height="10" fill="#d35400"/><line x1="32" y1="16" x2="32" y2="52" stroke="#d35400" stroke-width="2"/><rect x="24" y="20" width="16" height="6" rx="1" fill="#f1c40f"/></svg>'},
  {id:'heartmail',name:'Love Letter',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="6" y="16" width="52" height="34" rx="3" fill="#f5e6e0"/><path d="M6 16l26 18 26-18" fill="#ecd5cc"/><path d="M32 26c-2-6-10-8-14-4s-2 12 14 22c16-10 18-18 14-22s-12-2-14 4z" fill="#e74c3c"/></svg>'},
  {id:'pawprint',name:'Paw Print',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="40" rx="12" ry="10" fill="#8B6914"/><ellipse cx="20" cy="24" rx="6" ry="8" fill="#8B6914" transform="rotate(-15 20 24)"/><ellipse cx="44" cy="24" rx="6" ry="8" fill="#8B6914" transform="rotate(15 44 24)"/><ellipse cx="14" cy="34" rx="5" ry="6" fill="#8B6914" transform="rotate(-20 14 34)"/><ellipse cx="50" cy="34" rx="5" ry="6" fill="#8B6914" transform="rotate(20 50 34)"/></svg>'},
  {id:'quill',name:'Quill Pen',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M48 4C36 10 24 26 16 44l4 2c10-14 22-26 34-30" fill="#3498db"/><path d="M16 44l-6 16 8-4 2-10" fill="#f1c40f"/><path d="M10 60l2-4" stroke="#2c3e50" stroke-width="2" stroke-linecap="round"/></svg>'},
  {id:'fragile',name:'Fragile Glass',cat:'mailing',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M20 8h24v20l-6 8h-12l-6-8z" fill="none" stroke="#e74c3c" stroke-width="3"/><rect x="26" y="36" width="12" height="12" fill="none" stroke="#e74c3c" stroke-width="3"/><line x1="20" y1="48" x2="44" y2="48" stroke="#e74c3c" stroke-width="3"/><line x1="32" y1="8" x2="28" y2="28" stroke="#e74c3c" stroke-width="1.5"/><line x1="28" y1="28" x2="36" y2="20" stroke="#e74c3c" stroke-width="1.5"/></svg>'},
  // ---- Winter Holidays ----
  {id:'snowflake',name:'Snowflake',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><g fill="none" stroke="#5dade2" stroke-width="3" stroke-linecap="round"><line x1="32" y1="4" x2="32" y2="60"/><line x1="8" y1="18" x2="56" y2="46"/><line x1="8" y1="46" x2="56" y2="18"/><line x1="32" y1="4" x2="26" y2="12"/><line x1="32" y1="4" x2="38" y2="12"/><line x1="32" y1="60" x2="26" y2="52"/><line x1="32" y1="60" x2="38" y2="52"/><line x1="8" y1="18" x2="16" y2="22"/><line x1="56" y1="46" x2="48" y2="42"/><line x1="8" y1="46" x2="16" y2="42"/><line x1="56" y1="18" x2="48" y2="22"/></g></svg>'},
  {id:'xmastree',name:'Christmas Tree',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,6 14,28 20,28 10,46 22,46 18,56 46,56 42,46 54,46 44,28 50,28" fill="#27ae60"/><rect x="28" y="56" width="8" height="6" fill="#8B6914"/><circle cx="28" cy="22" r="2.5" fill="#e74c3c"/><circle cx="36" cy="34" r="2.5" fill="#f1c40f"/><circle cx="26" cy="42" r="2.5" fill="#3498db"/><polygon points="32,2 34,8 30,8" fill="#f1c40f"/></svg>'},
  {id:'candycane',name:'Candy Cane',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M36 60V20a12 12 0 0 0-24 0" fill="none" stroke="#fff" stroke-width="8" stroke-linecap="round"/><path d="M36 60V20a12 12 0 0 0-24 0" fill="none" stroke="#e74c3c" stroke-width="8" stroke-linecap="round" stroke-dasharray="6 6"/></svg>'},
  {id:'giftbox',name:'Gift Box',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="24" width="48" height="32" rx="3" fill="#e74c3c"/><rect x="8" y="24" width="48" height="10" fill="#c0392b"/><rect x="29" y="24" width="6" height="32" fill="#f1c40f"/><rect x="8" y="28" width="48" height="4" fill="#f1c40f" opacity="0.8"/><path d="M32 24c-4-8-14-10-14-4s10 4 14 4" fill="none" stroke="#f1c40f" stroke-width="2"/><path d="M32 24c4-8 14-10 14-4s-10 4-14 4" fill="none" stroke="#f1c40f" stroke-width="2"/></svg>'},
  {id:'ornament',name:'Ornament',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="36" r="20" fill="#e74c3c"/><rect x="28" y="12" width="8" height="8" rx="2" fill="#f1c40f"/><circle cx="32" cy="36" r="20" fill="none" stroke="#c0392b" stroke-width="1"/><path d="M20 28c8 4 16 4 24 0" fill="none" stroke="#f1c40f" stroke-width="1.5" opacity="0.6"/><path d="M18 38c10 6 18 6 28 0" fill="none" stroke="#f1c40f" stroke-width="1.5" opacity="0.4"/></svg>'},
  {id:'stocking',name:'Stocking',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 6h20v30l10 14a6 6 0 0 1-5 10H28a6 6 0 0 1-6-6V36z" fill="#e74c3c"/><rect x="22" y="6" width="20" height="10" rx="2" fill="#ecf0f1"/><path d="M22 6h20v10h-20z" fill="#fff" opacity="0.3"/></svg>'},
  {id:'gingerbread',name:'Gingerbread Man',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="14" r="10" fill="#d4882b"/><rect x="24" y="22" width="16" height="20" rx="4" fill="#d4882b"/><rect x="8" y="26" width="20" height="6" rx="3" fill="#d4882b"/><rect x="36" y="26" width="20" height="6" rx="3" fill="#d4882b"/><rect x="22" y="40" width="8" height="18" rx="3" fill="#d4882b"/><rect x="34" y="40" width="8" height="18" rx="3" fill="#d4882b"/><circle cx="28" cy="12" r="2" fill="#2c3e50"/><circle cx="36" cy="12" r="2" fill="#2c3e50"/><path d="M28 18c2 2 6 2 8 0" fill="none" stroke="#2c3e50" stroke-width="1.5"/><circle cx="32" cy="28" r="2" fill="#e74c3c"/><circle cx="32" cy="36" r="2" fill="#2ecc71"/></svg>'},
  {id:'menorah',name:'Menorah',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="30" y="20" width="4" height="32" fill="#f1c40f"/><rect x="20" y="52" width="24" height="6" rx="2" fill="#f1c40f"/><g fill="#f1c40f"><rect x="10" y="28" width="3" height="16"/><rect x="18" y="24" width="3" height="20"/><rect x="26" y="20" width="3" height="24"/><rect x="35" y="20" width="3" height="24"/><rect x="43" y="24" width="3" height="20"/><rect x="51" y="28" width="3" height="16"/></g><g fill="#ff8c00"><ellipse cx="11.5" cy="26" rx="3" ry="4"/><ellipse cx="19.5" cy="22" rx="3" ry="4"/><ellipse cx="27.5" cy="18" rx="3" ry="4"/><ellipse cx="32" cy="16" rx="3" ry="4"/><ellipse cx="36.5" cy="18" rx="3" ry="4"/><ellipse cx="44.5" cy="22" rx="3" ry="4"/><ellipse cx="52.5" cy="26" rx="3" ry="4"/></g></svg>'},
  {id:'snowman',name:'Snowman',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="46" r="16" fill="#ecf0f1"/><circle cx="32" cy="24" r="12" fill="#ecf0f1"/><circle cx="28" cy="22" r="2" fill="#2c3e50"/><circle cx="36" cy="22" r="2" fill="#2c3e50"/><path d="M30 28h4" stroke="#e67e22" stroke-width="2" stroke-linecap="round"/><rect x="24" y="12" width="16" height="6" rx="2" fill="#2c3e50"/><rect x="22" y="16" width="20" height="3" fill="#2c3e50"/><line x1="8" y1="26" x2="20" y2="24" stroke="#8B6914" stroke-width="2" stroke-linecap="round"/><line x1="56" y1="26" x2="44" y2="24" stroke="#8B6914" stroke-width="2" stroke-linecap="round"/><rect x="22" y="34" width="20" height="4" rx="1" fill="#e74c3c"/></svg>'},
  {id:'wreath',name:'Wreath',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="20" fill="none" stroke="#27ae60" stroke-width="10"/><circle cx="22" cy="16" r="3" fill="#e74c3c"/><circle cx="42" cy="16" r="3" fill="#e74c3c"/><circle cx="14" cy="30" r="3" fill="#e74c3c"/><circle cx="50" cy="30" r="3" fill="#e74c3c"/><circle cx="20" cy="48" r="3" fill="#e74c3c"/><circle cx="44" cy="48" r="3" fill="#e74c3c"/><path d="M26 10c2-4 6-6 6-6s4 2 6 6" fill="none" stroke="#e74c3c" stroke-width="3" stroke-linecap="round"/></svg>'},
  {id:'santahat',name:'Santa Hat',cat:'winter',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M8 48c0 0 6-36 24-36s28 36 28 36z" fill="#e74c3c"/><ellipse cx="32" cy="48" rx="28" ry="8" fill="#ecf0f1"/><circle cx="50" cy="14" r="6" fill="#ecf0f1"/></svg>'},
  // ---- Spring ----
  {id:'egg',name:'Easter Egg',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="36" rx="18" ry="24" fill="#5dade2"/><path d="M14 30h36" stroke="#f1c40f" stroke-width="3"/><path d="M16 38h32" stroke="#e74c3c" stroke-width="3"/><path d="M20 22c4 4 8-4 12 0s8-4 12 0" fill="none" stroke="#2ecc71" stroke-width="2"/></svg>'},
  {id:'bunny',name:'Bunny',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="42" rx="16" ry="18" fill="#ecf0f1"/><ellipse cx="22" cy="14" rx="6" ry="16" fill="#ecf0f1"/><ellipse cx="42" cy="14" rx="6" ry="16" fill="#ecf0f1"/><ellipse cx="22" cy="14" rx="3" ry="12" fill="#f8c8d4"/><ellipse cx="42" cy="14" rx="3" ry="12" fill="#f8c8d4"/><circle cx="26" cy="38" r="3" fill="#2c3e50"/><circle cx="38" cy="38" r="3" fill="#2c3e50"/><ellipse cx="32" cy="44" rx="3" ry="2" fill="#f8c8d4"/><path d="M29 46c2 2 4 2 6 0" fill="none" stroke="#bdc3c7" stroke-width="1"/></svg>'},
  {id:'flower',name:'Flower',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><line x1="32" y1="34" x2="32" y2="58" stroke="#27ae60" stroke-width="3"/><path d="M32 46c-8 0-14-4-14-4" stroke="#27ae60" stroke-width="2" fill="none"/><circle cx="32" cy="20" r="8" fill="#e74c3c"/><circle cx="22" cy="26" r="8" fill="#e74c3c"/><circle cx="42" cy="26" r="8" fill="#e74c3c"/><circle cx="24" cy="16" r="8" fill="#e74c3c"/><circle cx="40" cy="16" r="8" fill="#e74c3c"/><circle cx="32" cy="22" r="6" fill="#f1c40f"/></svg>'},
  {id:'butterfly',name:'Butterfly',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="22" cy="22" rx="14" ry="12" fill="#9b59b6" transform="rotate(-20 22 22)"/><ellipse cx="42" cy="22" rx="14" ry="12" fill="#9b59b6" transform="rotate(20 42 22)"/><ellipse cx="20" cy="38" rx="10" ry="8" fill="#e74c3c" transform="rotate(-15 20 38)"/><ellipse cx="44" cy="38" rx="10" ry="8" fill="#e74c3c" transform="rotate(15 44 38)"/><rect x="31" y="14" width="2" height="34" rx="1" fill="#2c3e50"/><path d="M32 14c-4-8-8-10-8-10" stroke="#2c3e50" stroke-width="1.5" fill="none"/><path d="M32 14c4-8 8-10 8-10" stroke="#2c3e50" stroke-width="1.5" fill="none"/></svg>'},
  {id:'chick',name:'Chick',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="34" r="18" fill="#f1c40f"/><circle cx="32" cy="20" r="12" fill="#f1c40f"/><circle cx="27" cy="18" r="2.5" fill="#2c3e50"/><circle cx="37" cy="18" r="2.5" fill="#2c3e50"/><polygon points="32,22 28,26 36,26" fill="#e67e22"/><path d="M22 50l-4 8h8z" fill="#e67e22"/><path d="M42 50l-4 8h8z" fill="#e67e22"/><path d="M28 10c-2-6 0-8 2-8" stroke="#f1c40f" stroke-width="2" fill="none"/><path d="M36 10c2-6 0-8-2-8" stroke="#f1c40f" stroke-width="2" fill="none"/></svg>'},
  {id:'shamrock',name:'Shamrock',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 28c-4-10-18-14-18-4s14 8 18 4z" fill="#27ae60"/><path d="M32 28c4-10 18-14 18-4s-14 8-18 4z" fill="#27ae60"/><path d="M32 28c-10-4-14-18-4-18s8 14 4 18z" fill="#27ae60"/><path d="M32 28c4 4 6 22 2 28" stroke="#27ae60" stroke-width="3" fill="none"/></svg>'},
  {id:'rainbow',name:'Rainbow',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M6 48a26 26 0 0 1 52 0" fill="none" stroke="#e74c3c" stroke-width="4"/><path d="M10 48a22 22 0 0 1 44 0" fill="none" stroke="#f39c12" stroke-width="4"/><path d="M14 48a18 18 0 0 1 36 0" fill="none" stroke="#f1c40f" stroke-width="4"/><path d="M18 48a14 14 0 0 1 28 0" fill="none" stroke="#2ecc71" stroke-width="4"/><path d="M22 48a10 10 0 0 1 20 0" fill="none" stroke="#3498db" stroke-width="4"/><path d="M26 48a6 6 0 0 1 12 0" fill="none" stroke="#9b59b6" stroke-width="4"/></svg>'},
  {id:'umbrella',name:'Umbrella',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M6 32c0-16 12-26 26-26s26 10 26 26z" fill="#e74c3c"/><line x1="32" y1="6" x2="32" y2="52" stroke="#8B6914" stroke-width="3"/><path d="M32 52c0 4-4 8-8 6" fill="none" stroke="#8B6914" stroke-width="3" stroke-linecap="round"/><path d="M6 32c4-8 10-8 14 0s10-8 12 0 8-8 12 0 10-8 14 0" fill="none" stroke="#c0392b" stroke-width="1.5"/></svg>'},
  {id:'ladybug',name:'Ladybug',cat:'spring',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="36" rx="20" ry="22" fill="#e74c3c"/><line x1="32" y1="14" x2="32" y2="58" stroke="#2c3e50" stroke-width="2"/><circle cx="32" cy="16" r="10" fill="#2c3e50"/><circle cx="24" cy="28" r="4" fill="#2c3e50"/><circle cx="40" cy="32" r="3" fill="#2c3e50"/><circle cx="22" cy="42" r="3.5" fill="#2c3e50"/><circle cx="42" cy="44" r="4" fill="#2c3e50"/><circle cx="28" cy="14" r="2" fill="#fff"/><circle cx="36" cy="14" r="2" fill="#fff"/></svg>'},
  // ---- Summer / Fall ----
  {id:'sun',name:'Sun',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="#f1c40f"/><g stroke="#f1c40f" stroke-width="3" stroke-linecap="round"><line x1="32" y1="4" x2="32" y2="14"/><line x1="32" y1="50" x2="32" y2="60"/><line x1="4" y1="32" x2="14" y2="32"/><line x1="50" y1="32" x2="60" y2="32"/><line x1="12" y1="12" x2="19" y2="19"/><line x1="45" y1="45" x2="52" y2="52"/><line x1="12" y1="52" x2="19" y2="45"/><line x1="45" y1="19" x2="52" y2="12"/></g></svg>'},
  {id:'palmtree',name:'Palm Tree',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="28" y="24" width="8" height="36" rx="2" fill="#8B6914"/><path d="M32 24c-20-2-24-10-20-16" stroke="#27ae60" stroke-width="4" fill="none" stroke-linecap="round"/><path d="M32 24c20-2 24-10 20-16" stroke="#27ae60" stroke-width="4" fill="none" stroke-linecap="round"/><path d="M32 24c-14 8-22 4-22-2" stroke="#2ecc71" stroke-width="3" fill="none" stroke-linecap="round"/><path d="M32 24c14 8 22 4 22-2" stroke="#2ecc71" stroke-width="3" fill="none" stroke-linecap="round"/></svg>'},
  {id:'fireworks',name:'Fireworks',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><g stroke-width="2" stroke-linecap="round" fill="none"><line x1="32" y1="32" x2="32" y2="16" stroke="#e74c3c"/><line x1="32" y1="32" x2="44" y2="20" stroke="#f1c40f"/><line x1="32" y1="32" x2="48" y2="32" stroke="#3498db"/><line x1="32" y1="32" x2="44" y2="44" stroke="#2ecc71"/><line x1="32" y1="32" x2="32" y2="48" stroke="#9b59b6"/><line x1="32" y1="32" x2="20" y2="44" stroke="#e67e22"/><line x1="32" y1="32" x2="16" y2="32" stroke="#e74c3c"/><line x1="32" y1="32" x2="20" y2="20" stroke="#f1c40f"/></g><g fill="none" stroke-width="1"><circle cx="32" cy="14" r="2" stroke="#e74c3c"/><circle cx="46" cy="18" r="2" stroke="#f1c40f"/><circle cx="50" cy="32" r="2" stroke="#3498db"/><circle cx="46" cy="46" r="2" stroke="#2ecc71"/></g></svg>'},
  {id:'usflag',name:'US Flag',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="4" y="10" width="56" height="44" fill="#fff"/><g fill="#e74c3c"><rect x="4" y="10" width="56" height="4"/><rect x="4" y="17" width="56" height="4"/><rect x="4" y="24" width="56" height="4"/><rect x="4" y="31" width="56" height="4"/><rect x="4" y="38" width="56" height="4"/><rect x="4" y="45" width="56" height="4"/><rect x="4" y="52" width="56" height="2"/></g><rect x="4" y="10" width="24" height="24" fill="#2c3e50"/><g fill="#fff"><circle cx="10" cy="14" r="1"/><circle cx="18" cy="14" r="1"/><circle cx="14" cy="18" r="1"/><circle cx="22" cy="18" r="1"/><circle cx="10" cy="22" r="1"/><circle cx="18" cy="22" r="1"/><circle cx="14" cy="26" r="1"/><circle cx="22" cy="26" r="1"/><circle cx="10" cy="30" r="1"/><circle cx="18" cy="30" r="1"/></g></svg>'},
  {id:'pumpkin',name:'Pumpkin',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="38" rx="22" ry="20" fill="#e67e22"/><ellipse cx="22" cy="38" rx="12" ry="20" fill="#f39c12"/><ellipse cx="42" cy="38" rx="12" ry="20" fill="#d35400" opacity="0.4"/><path d="M30 18c0-6 2-12 2-12s2 6 2 12" fill="#27ae60"/><polygon points="24,30 28,36 20,36" fill="#2c3e50"/><polygon points="40,30 44,36 36,36" fill="#2c3e50"/><path d="M26 44c3 4 9 4 12 0" fill="#2c3e50"/></svg>'},
  {id:'ghost',name:'Ghost',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M16 30c0-10 8-22 16-22s16 12 16 22v24l-6-6-5 6-5-6-5 6-5-6-6 6z" fill="#ecf0f1"/><circle cx="26" cy="28" r="4" fill="#2c3e50"/><circle cx="38" cy="28" r="4" fill="#2c3e50"/><ellipse cx="32" cy="38" rx="4" ry="5" fill="#2c3e50"/></svg>'},
  {id:'bat',name:'Bat',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 24c-8 0-14 4-18 10-2-6-8-12-12-10 6 4 8 12 8 18 4-4 10-8 16-8h12c6 0 12 4 16 8 0-6 2-14 8-18-4-2-10 4-12 10-4-6-10-10-18-10z" fill="#2c3e50"/><circle cx="28" cy="28" r="2" fill="#e74c3c"/><circle cx="36" cy="28" r="2" fill="#e74c3c"/><polygon points="30,32 32,36 34,32" fill="#fff"/></svg>'},
  {id:'witchhat',name:'Witch Hat',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="52" rx="26" ry="6" fill="#2c3e50"/><polygon points="32,4 14,52 50,52" fill="#2c3e50"/><path d="M32 4c4 2 8 10 6 16" stroke="#2c3e50" stroke-width="2" fill="none"/><rect x="14" y="46" width="36" height="6" fill="#f39c12"/><rect x="28" y="44" width="8" height="10" rx="1" fill="#f1c40f"/></svg>'},
  {id:'leaf',name:'Maple Leaf',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 8l-4 10-10-2 6 10-10 4 12 4-2 12 8-8 8 8-2-12 12-4-10-4 6-10-10 2z" fill="#e67e22"/><line x1="32" y1="38" x2="32" y2="58" stroke="#8B6914" stroke-width="2.5" stroke-linecap="round"/></svg>'},
  {id:'turkey',name:'Turkey',cat:'summer',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 16c-10-8-22-4-22 4s10 6 22 6" fill="#e74c3c"/><path d="M32 16c0-12 10-14 16-8s-4 14-16 18" fill="#f39c12"/><path d="M32 16c10-8 22-4 22 4s-10 6-22 6" fill="#f1c40f"/><circle cx="32" cy="34" r="14" fill="#8B6914"/><circle cx="32" cy="26" r="8" fill="#d4882b"/><circle cx="30" cy="24" r="2" fill="#2c3e50"/><path d="M32 28c2 4 4 4 4 8" fill="#e74c3c"/></svg>'},
  // ---- Occasions ----
  {id:'cake',name:'Birthday Cake',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="10" y="30" width="44" height="24" rx="4" fill="#f8c8d4"/><rect x="10" y="30" width="44" height="8" fill="#e74c3c"/><rect x="10" y="46" width="44" height="8" rx="4" fill="#f39c12"/><rect x="20" y="20" width="4" height="12" fill="#f1c40f"/><rect x="30" y="16" width="4" height="16" fill="#f1c40f"/><rect x="40" y="20" width="4" height="12" fill="#f1c40f"/><ellipse cx="22" cy="18" rx="3" ry="4" fill="#ff8c00"/><ellipse cx="32" cy="14" rx="3" ry="4" fill="#ff8c00"/><ellipse cx="42" cy="18" rx="3" ry="4" fill="#ff8c00"/></svg>'},
  {id:'balloon',name:'Balloon',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="24" cy="24" rx="12" ry="16" fill="#e74c3c"/><ellipse cx="40" cy="20" rx="10" ry="14" fill="#3498db"/><path d="M24 40c-1 2 0 4 0 4l4 14" stroke="#e74c3c" stroke-width="1" fill="none"/><path d="M40 34c1 2 0 4 0 4l-4 14" stroke="#3498db" stroke-width="1" fill="none"/><path d="M22 18c-2-2-1-6 2-6" stroke="#fff" stroke-width="1.5" fill="none" opacity="0.4"/></svg>'},
  {id:'partyhat',name:'Party Hat',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,4 12,56 52,56" fill="#9b59b6"/><ellipse cx="32" cy="56" rx="20" ry="4" fill="#8e44ad"/><path d="M18 40h28" stroke="#f1c40f" stroke-width="3"/><path d="M22 28h20" stroke="#2ecc71" stroke-width="3"/><circle cx="32" cy="4" r="4" fill="#f1c40f"/><circle cx="26" cy="46" r="2" fill="#e74c3c"/><circle cx="38" cy="34" r="2" fill="#3498db"/></svg>'},
  {id:'heart',name:'Heart',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 56C16 42 4 32 4 20c0-8 6-14 14-14 6 0 10 4 14 10 4-6 8-10 14-10 8 0 14 6 14 14 0 12-12 22-28 36z" fill="#e74c3c"/></svg>'},
  {id:'ribbon',name:'Ribbon Bow',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 30c-8-4-22-10-22 0s14 8 22 0z" fill="#e74c3c"/><path d="M32 30c8-4 22-10 22 0s-14 8-22 0z" fill="#c0392b"/><circle cx="32" cy="30" r="6" fill="#e74c3c"/><path d="M28 36l-8 22" stroke="#e74c3c" stroke-width="3" fill="none"/><path d="M36 36l8 22" stroke="#c0392b" stroke-width="3" fill="none"/></svg>'},
  {id:'trophy',name:'Trophy',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M18 10h28v18c0 10-6 16-14 16s-14-6-14-16z" fill="#f1c40f"/><path d="M18 14H8c0 10 4 14 10 14v-6c-4 0-6-4-6-8z" fill="#f39c12"/><path d="M46 14h10c0 10-4 14-10 14v-6c4 0 6-4 6-8z" fill="#f39c12"/><rect x="28" y="44" width="8" height="8" fill="#f39c12"/><rect x="22" y="52" width="20" height="4" rx="1" fill="#f39c12"/></svg>'},
  {id:'medal',name:'Medal',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 4l10 24-10 0z" fill="#3498db"/><path d="M42 4l-10 24 10 0z" fill="#e74c3c"/><circle cx="32" cy="40" r="16" fill="#f1c40f"/><circle cx="32" cy="40" r="12" fill="#f39c12"/><text x="32" y="46" text-anchor="middle" fill="#fff" font-family="Arial" font-weight="bold" font-size="16">★</text></svg>'},
  {id:'babyrattle',name:'Baby Rattle',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="22" r="16" fill="#5dade2"/><rect x="29" y="38" width="6" height="18" rx="3" fill="#f1c40f"/><circle cx="26" cy="18" r="3" fill="#fff" opacity="0.3"/><circle cx="36" cy="16" r="2" fill="#fff" opacity="0.3"/><circle cx="28" cy="26" r="2" fill="#fff" opacity="0.2"/></svg>'},
  {id:'diploma',name:'Diploma',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="14" width="48" height="36" rx="2" fill="#f5e6c8"/><rect x="8" y="14" width="48" height="36" rx="2" fill="none" stroke="#d4a76a" stroke-width="2"/><line x1="18" y1="24" x2="46" y2="24" stroke="#bdc3c7" stroke-width="1.5"/><line x1="18" y1="30" x2="46" y2="30" stroke="#bdc3c7" stroke-width="1.5"/><line x1="18" y1="36" x2="38" y2="36" stroke="#bdc3c7" stroke-width="1.5"/><circle cx="36" cy="44" r="6" fill="#e74c3c"/><path d="M34 50l-2 8 4-4 4 4-2-8" fill="#e74c3c"/></svg>'},
  {id:'confetti',name:'Confetti',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="10" width="6" height="6" fill="#e74c3c" transform="rotate(30 11 13)"/><rect x="50" y="8" width="6" height="6" fill="#3498db" transform="rotate(-20 53 11)"/><rect x="28" y="6" width="5" height="5" fill="#f1c40f" transform="rotate(45 30 8)"/><circle cx="16" cy="30" r="3" fill="#2ecc71"/><circle cx="48" cy="28" r="3" fill="#9b59b6"/><circle cx="12" cy="50" r="3" fill="#f39c12"/><rect x="38" y="44" width="5" height="5" fill="#e74c3c" transform="rotate(15 40 46)"/><rect x="22" y="40" width="4" height="4" fill="#3498db" transform="rotate(-30 24 42)"/><circle cx="42" cy="16" r="2" fill="#e67e22"/><circle cx="32" cy="52" r="2.5" fill="#9b59b6"/><path d="M18 18l4 4" stroke="#f1c40f" stroke-width="2" stroke-linecap="round"/><path d="M46 38l4 4" stroke="#2ecc71" stroke-width="2" stroke-linecap="round"/></svg>'},
  {id:'thumbsup',name:'Thumbs Up',cat:'occasion',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M24 28c0-8 4-20 10-20 4 0 4 6 2 14h14c4 0 6 4 6 8l-2 16c0 4-4 6-8 6H24z" fill="#f1c40f"/><rect x="6" y="28" width="18" height="28" rx="3" fill="#f39c12"/></svg>'},
  // ---- Symbols & Decorative ----
  {id:'checkmark',name:'Checkmark',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="28" fill="#2ecc71"/><polyline points="18,34 28,44 46,22" fill="none" stroke="#fff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'warning',name:'Warning',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="32,6 4,58 60,58" fill="#f1c40f" stroke="#e67e22" stroke-width="2" stroke-linejoin="round"/><rect x="29" y="22" width="6" height="18" rx="2" fill="#2c3e50"/><circle cx="32" cy="48" r="3.5" fill="#2c3e50"/></svg>'},
  {id:'info',name:'Info Circle',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="28" fill="#3498db"/><circle cx="32" cy="18" r="4" fill="#fff"/><rect x="28" y="26" width="8" height="22" rx="2" fill="#fff"/></svg>'},
  {id:'phone',name:'Phone',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M14 8c-2 0-4 2-4 4 0 24 20 44 44 44 2 0 4-2 4-4v-8l-12-6-4 4c-6-2-14-10-16-16l4-4-6-12z" fill="#2ecc71"/></svg>'},
  {id:'emailat',name:'Email @',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="26" fill="none" stroke="#3498db" stroke-width="4"/><circle cx="32" cy="32" r="10" fill="none" stroke="#3498db" stroke-width="3"/><path d="M42 32v6c0 4 4 6 8 4" fill="none" stroke="#3498db" stroke-width="3" stroke-linecap="round"/></svg>'},
  {id:'webglobe',name:'Web Globe',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="26" fill="none" stroke="#3498db" stroke-width="3"/><ellipse cx="32" cy="32" rx="12" ry="26" fill="none" stroke="#3498db" stroke-width="2"/><line x1="6" y1="32" x2="58" y2="32" stroke="#3498db" stroke-width="2"/><line x1="32" y1="6" x2="32" y2="58" stroke="#3498db" stroke-width="2"/></svg>'},
  {id:'clock',name:'Clock',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="26" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="3"/><line x1="32" y1="32" x2="32" y2="16" stroke="#2c3e50" stroke-width="3" stroke-linecap="round"/><line x1="32" y1="32" x2="44" y2="36" stroke="#2c3e50" stroke-width="2.5" stroke-linecap="round"/><circle cx="32" cy="32" r="2.5" fill="#e74c3c"/></svg>'},
  {id:'camera',name:'Camera',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="6" y="18" width="52" height="36" rx="4" fill="#7f8c8d"/><path d="M22 18l4-8h12l4 8" fill="#95a5a6"/><circle cx="32" cy="36" r="12" fill="#2c3e50"/><circle cx="32" cy="36" r="8" fill="#3498db"/><circle cx="36" cy="32" r="3" fill="#5dade2" opacity="0.5"/></svg>'},
  {id:'key',name:'Key',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="20" cy="24" r="14" fill="none" stroke="#f1c40f" stroke-width="4"/><circle cx="20" cy="24" r="6" fill="#f1c40f"/><line x1="30" y1="30" x2="56" y2="56" stroke="#f1c40f" stroke-width="4" stroke-linecap="round"/><line x1="46" y1="56" x2="56" y2="46" stroke="#f1c40f" stroke-width="3" stroke-linecap="round"/><line x1="40" y1="50" x2="50" y2="40" stroke="#f1c40f" stroke-width="3" stroke-linecap="round"/></svg>'},
  {id:'lightning',name:'Lightning Bolt',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><polygon points="36,4 16,34 30,34 24,60 48,26 34,26" fill="#f1c40f"/></svg>'},
  {id:'peace',name:'Peace Sign',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="26" fill="none" stroke="#9b59b6" stroke-width="4"/><line x1="32" y1="6" x2="32" y2="58" stroke="#9b59b6" stroke-width="4"/><line x1="32" y1="32" x2="14" y2="50" stroke="#9b59b6" stroke-width="4" stroke-linecap="round"/><line x1="32" y1="32" x2="50" y2="50" stroke="#9b59b6" stroke-width="4" stroke-linecap="round"/></svg>'},
  {id:'recycle',name:'Recycle',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 10l-8 14h6l-10 18" fill="none" stroke="#27ae60" stroke-width="3" stroke-linecap="round"/><path d="M44 44h-16l8-14" fill="none" stroke="#27ae60" stroke-width="3" stroke-linecap="round"/><path d="M20 44l10-18 8 14" fill="none" stroke="#27ae60" stroke-width="3" stroke-linecap="round"/><polygon points="18,44 24,40 22,48" fill="#27ae60"/><polygon points="44,44 40,48 42,38" fill="#27ae60"/><polygon points="32,10 28,16 36,16" fill="#27ae60"/></svg>'},
  {id:'arrowright',name:'Arrow Right',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><line x1="8" y1="32" x2="52" y2="32" stroke="#3498db" stroke-width="5" stroke-linecap="round"/><polyline points="40,20 54,32 40,44" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'crossplus',name:'Cross / Plus',cat:'symbol',svg:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="24" y="8" width="16" height="48" rx="3" fill="#e74c3c"/><rect x="8" y="24" width="48" height="16" rx="3" fill="#e74c3c"/></svg>'}
];

let graphicPickerSide = null;
let graphicPickerTab = 'library';
let graphicSearchTimer = null;
let graphicLibraryFilter = 'all';
let graphicSearchAbort = null;

function toggleGraphicsPanel() {
  const panel = document.getElementById('graphicsPanel');
  const btn = document.getElementById('graphicToggle');
  const isOpen = panel.classList.contains('open');
  if (isOpen) {
    panel.classList.remove('open');
    btn.classList.toggle('active', hasAnyGraphic());
  } else {
    panel.classList.add('open');
    btn.classList.add('active');
  }
}

function hasAnyGraphic() {
  return !!(composeGraphics.left || composeGraphics.right);
}

function addGraphic(side) {
  openGraphicPicker(side);
}

// ========== GRAPHIC PICKER (v1.8.0) ==========

function svgToDataUrl(svgText) {
  return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgText)));
}

function selectGraphicForSide(side, dataUrl) {
  composeGraphics[side] = { data: dataUrl, widthPct: 25 };
  closeGraphicPicker();
  renderGraphicsPanel();
  updateGraphicToggleState();
  updatePreview();
  updateDirtyIndicator();
}

function openGraphicPicker(side) {
  // Close any other open picker
  closeGraphicPicker();
  graphicPickerSide = side;
  const pickerId = 'graphicPicker' + side.charAt(0).toUpperCase() + side.slice(1);
  const picker = document.getElementById(pickerId);
  if (!picker) return;
  renderGraphicPicker(picker, side);
  picker.classList.add('open');
}

function closeGraphicPicker() {
  graphicPickerSide = null;
  document.querySelectorAll('.graphic-picker').forEach(p => p.classList.remove('open'));
  if (graphicSearchAbort) { graphicSearchAbort.abort(); graphicSearchAbort = null; }
  if (graphicSearchTimer) { clearTimeout(graphicSearchTimer); graphicSearchTimer = null; }
}

function renderGraphicPicker(picker, side) {
  const tab = graphicPickerTab || 'library';
  let html = '<div class="graphic-picker-tabs">';
  html += '<button class="graphic-picker-tab' + (tab === 'upload' ? ' active' : '') + '" onclick="switchGraphicTab(\'upload\')">📁 Upload</button>';
  html += '<button class="graphic-picker-tab' + (tab === 'library' ? ' active' : '') + '" onclick="switchGraphicTab(\'library\')">📚 Library</button>';
  html += '<button class="graphic-picker-tab' + (tab === 'search' ? ' active' : '') + '" onclick="switchGraphicTab(\'search\')">🔍 Search</button>';
  html += '</div>';
  html += '<div class="graphic-picker-body" id="graphicPickerBody">';
  if (tab === 'upload') {
    html += renderUploadTab(side);
  } else if (tab === 'library') {
    html += renderLibraryTab();
  } else if (tab === 'search') {
    html += renderSearchTab();
  }
  html += '</div>';
  picker.innerHTML = html;
  // Auto-focus search input
  if (tab === 'search') {
    const si = picker.querySelector('.graphic-search-input');
    if (si) setTimeout(() => si.focus(), 50);
  }
  if (tab === 'library') {
    const li = picker.querySelector('.graphic-lib-search');
    if (li) setTimeout(() => li.focus(), 50);
  }
}

function switchGraphicTab(tab) {
  graphicPickerTab = tab;
  if (graphicSearchTimer) { clearTimeout(graphicSearchTimer); graphicSearchTimer = null; }
  if (graphicSearchAbort) { graphicSearchAbort.abort(); graphicSearchAbort = null; }
  const side = graphicPickerSide;
  if (!side) return;
  const pickerId = 'graphicPicker' + side.charAt(0).toUpperCase() + side.slice(1);
  const picker = document.getElementById(pickerId);
  if (picker) renderGraphicPicker(picker, side);
}

function renderUploadTab(side) {
  return '<div class="graphic-upload-area">' +
    '<button class="graphic-upload-btn" onclick="triggerGraphicUpload()">📁 Choose Image File…</button>' +
    '<div style="margin-top:8px;color:var(--text-faint);font-size:10px;">JPG, PNG, GIF, SVG</div>' +
    '</div>';
}

function triggerGraphicUpload() {
  const side = graphicPickerSide;
  if (!side) return;
  graphicFileSide = side;
  const input = document.getElementById('graphicFileInput');
  input.value = '';
  input.click();
}

function renderLibraryTab() {
  const filter = graphicLibraryFilter || 'all';
  let html = '<div class="graphic-lib-controls">';
  html += '<select class="graphic-lib-cat-select" onchange="filterLibraryCategory(this.value)">';
  html += '<option value="all"' + (filter === 'all' ? ' selected' : '') + '>All</option>';
  const cats = Object.entries(GRAPHIC_CATEGORIES).sort((a,b) => a[1].order - b[1].order);
  cats.forEach(([key, cat]) => {
    html += '<option value="' + key + '"' + (filter === key ? ' selected' : '') + '>' + cat.label + '</option>';
  });
  html += '</select>';
  html += '<input type="text" class="graphic-lib-search" id="libSearchInput" placeholder="Filter icons…" oninput="filterLibraryText(this.value)">';
  html += '</div>';
  html += renderLibraryGrid(filter, '');
  return html;
}

function renderLibraryGrid(catFilter, textFilter) {
  const tf = (textFilter || '').toLowerCase().trim();
  const cats = Object.entries(GRAPHIC_CATEGORIES).sort((a,b) => a[1].order - b[1].order);
  let html = '';
  let anyVisible = false;
  cats.forEach(([catKey, catMeta]) => {
    if (catFilter !== 'all' && catFilter !== catKey) return;
    const icons = GRAPHIC_LIBRARY.filter(ic => ic.cat === catKey && (!tf || ic.name.toLowerCase().includes(tf) || ic.id.toLowerCase().includes(tf)));
    if (icons.length === 0) return;
    anyVisible = true;
    if (catFilter === 'all') {
      html += '<div class="graphic-lib-section">' + catMeta.label + '</div>';
    }
    html += '<div class="graphic-lib-grid">';
    icons.forEach(ic => {
      const du = svgToDataUrl(ic.svg);
      html += '<div class="graphic-lib-icon" title="' + ic.name + '" onclick="selectLibraryIcon(\'' + ic.id + '\')">';
      html += '<img src="' + du + '" alt="' + ic.name + '">';
      html += '</div>';
    });
    html += '</div>';
  });
  if (!anyVisible) {
    html = '<div class="graphic-lib-empty">No icons match your filter</div>';
  }
  return html;
}

function filterLibraryCategory(val) {
  graphicLibraryFilter = val;
  const body = document.getElementById('graphicPickerBody');
  if (!body) return;
  const textInput = document.getElementById('libSearchInput');
  const textVal = textInput ? textInput.value : '';
  // Re-render just the grid portion
  const side = graphicPickerSide;
  if (!side) return;
  const pickerId = 'graphicPicker' + side.charAt(0).toUpperCase() + side.slice(1);
  const picker = document.getElementById(pickerId);
  if (picker) renderGraphicPicker(picker, side);
}

function filterLibraryText(val) {
  const filter = graphicLibraryFilter || 'all';
  const body = document.getElementById('graphicPickerBody');
  if (!body) return;
  // Find the grid containers and replace them
  const controls = body.querySelector('.graphic-lib-controls');
  if (!controls) return;
  // Remove everything after controls
  let sib = controls.nextSibling;
  while (sib) { const next = sib.nextSibling; sib.remove(); sib = next; }
  const tmp = document.createElement('div');
  tmp.innerHTML = renderLibraryGrid(filter, val);
  while (tmp.firstChild) body.appendChild(tmp.firstChild);
}

function selectLibraryIcon(iconId) {
  const side = graphicPickerSide;
  if (!side) return;
  const icon = GRAPHIC_LIBRARY.find(ic => ic.id === iconId);
  if (!icon) return;
  const dataUrl = svgToDataUrl(icon.svg);
  selectGraphicForSide(side, dataUrl);
}

function renderSearchTab() {
  let html = '<div class="graphic-search-row">';
  html += '<input type="text" class="graphic-search-input" id="iconifySearchInput" placeholder="Search 200k+ icons…" oninput="onIconifySearchInput(this.value)">';
  html += '</div>';
  html += '<div id="iconifyResults">';
  html += '<div class="graphic-search-empty">Type to search open source icons</div>';
  html += '</div>';
  return html;
}

function onIconifySearchInput(val) {
  if (graphicSearchTimer) clearTimeout(graphicSearchTimer);
  if (graphicSearchAbort) { graphicSearchAbort.abort(); graphicSearchAbort = null; }
  const q = val.trim();
  if (q.length < 2) {
    const res = document.getElementById('iconifyResults');
    if (res) res.innerHTML = '<div class="graphic-search-empty">Type to search open source icons</div>';
    return;
  }
  graphicSearchTimer = setTimeout(() => searchIconify(q), ICONIFY_DEBOUNCE_MS);
}

async function searchIconify(query) {
  const res = document.getElementById('iconifyResults');
  if (!res) return;
  res.innerHTML = '<div class="graphic-search-loading"><span class="graphic-search-spinner"></span> Searching…</div>';

  try {
    graphicSearchAbort = new AbortController();
    const url = ICONIFY_API + '/search?query=' + encodeURIComponent(query) + '&limit=' + ICONIFY_SEARCH_LIMIT + '&prefixes=' + ICONIFY_COLORED_PREFIXES;
    const resp = await fetch(url, { signal: graphicSearchAbort.signal, timeout: ICONIFY_TIMEOUT_MS });
    if (!resp.ok) throw new Error('API error ' + resp.status);
    const data = await resp.json();
    graphicSearchAbort = null;
    if (!data.icons || data.icons.length === 0) {
      res.innerHTML = '<div class="graphic-search-empty">No results for "' + query.replace(/</g,'&lt;') + '"</div>';
      return;
    }
    let html = '<div class="graphic-search-grid">';
    data.icons.forEach(iconName => {
      // iconName is like "fluent-emoji-flat:apple"
      const parts = iconName.split(':');
      const prefix = parts[0];
      const name = parts[1];
      const svgUrl = ICONIFY_API + '/' + prefix + '/' + name + '.svg?height=48';
      const label = name.replace(/-/g, ' ');
      html += '<div class="graphic-search-icon" title="' + label + '" onclick="selectIconifyIcon(\'' + prefix + '\',\'' + name + '\')">';
      html += '<img src="' + svgUrl + '" alt="' + label + '" loading="lazy">';
      html += '</div>';
    });
    html += '</div>';
    html += '<div class="graphic-search-attr">Icons from <a href="https://iconify.design" target="_blank" rel="noopener">Iconify</a> · Open source</div>';
    res.innerHTML = html;
  } catch(err) {
    graphicSearchAbort = null;
    if (err.name === 'AbortError') return; // Cancelled, ignore
    res.innerHTML = '<div class="graphic-search-empty">⚠ Search unavailable. Use Library or Upload.</div>';
  }
}

async function selectIconifyIcon(prefix, name) {
  const side = graphicPickerSide;
  if (!side) return;
  try {
    const url = ICONIFY_API + '/' + prefix + '/' + name + '.svg?height=128';
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Fetch error');
    const svgText = await resp.text();
    const dataUrl = svgToDataUrl(svgText);
    selectGraphicForSide(side, dataUrl);
  } catch(err) {
    setStatus('Could not load icon', 'error');
  }
}

function handleGraphicFile(event) {
  const file = event.target.files[0];
  if (!file || !graphicFileSide) return;
  processGraphicFile(file, graphicFileSide);
}

function processGraphicFile(file, side) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      // Resize to fit within max dimensions
      let w = img.width, h = img.height;
      if (w > GRAPHIC_MAX_DIM || h > GRAPHIC_MAX_DIM) {
        const scale = Math.min(GRAPHIC_MAX_DIM / w, GRAPHIC_MAX_DIM / h);
        w = Math.round(w * scale);
        h = Math.round(h * scale);
      }
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);

      // Check for transparency (PNG/GIF)
      let hasAlpha = false;
      if (file.type === 'image/png' || file.type === 'image/gif') {
        try {
          const pixels = ctx.getImageData(0, 0, w, h).data;
          for (let i = 3; i < pixels.length; i += 4) {
            if (pixels[i] < 250) { hasAlpha = true; break; }
          }
        } catch(ex) { /* CORS — assume no alpha */ }
      }

      const dataUrl = hasAlpha
        ? canvas.toDataURL('image/png')
        : canvas.toDataURL('image/jpeg', GRAPHIC_JPEG_QUALITY);

      // Check size
      const byteSize = Math.round((dataUrl.length - dataUrl.indexOf(',') - 1) * 0.75);
      if (byteSize > GRAPHIC_WARN_BYTES) {
        console.warn('Graphic is ' + Math.round(byteSize / 1024) + 'KB after processing');
      }

      composeGraphics[side] = { data: dataUrl, widthPct: 25 }; // Default Medium
      closeGraphicPicker();
      renderGraphicsPanel();
      updateGraphicToggleState();
      updatePreview();
      updateDirtyIndicator();
    };
    img.onerror = function() {
      setStatus('Could not load image', 'error');
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

function removeGraphic(side) {
  composeGraphics[side] = null;
  renderGraphicsPanel();
  updateGraphicToggleState();
  // Auto-close panel if both sides empty
  if (!hasAnyGraphic()) {
    document.getElementById('graphicsPanel').classList.remove('open');
  }
  updatePreview();
  updateDirtyIndicator();
}

function setGraphicSize(side, pct) {
  if (composeGraphics[side]) {
    composeGraphics[side].widthPct = pct;
    renderGraphicsPanel();
    updatePreview();
    updateDirtyIndicator();
  }
}

function renderGraphicsPanel() {
  ['left', 'right'].forEach(side => {
    const container = document.getElementById('graphic' + side.charAt(0).toUpperCase() + side.slice(1) + 'Content');
    const g = composeGraphics[side];
    if (!g) {
      container.innerHTML = '<button class="graphic-add-btn" onclick="openGraphicPicker(\'' + side + '\')">🖼 Add</button>';
    } else {
      let html = '<span class="graphic-thumb" onclick="openGraphicPicker(\'' + side + '\')" title="Click to change" style="cursor:pointer"><img src="' + g.data + '" alt=""></span>';
      html += '<span class="graphic-size-pills">';
      ['S', 'M', 'L'].forEach(sz => {
        const pct = GRAPHIC_SIZES[sz];
        html += '<button class="graphic-size-pill' + (pct === g.widthPct ? ' active' : '') + '" onclick="setGraphicSize(\'' + side + '\',' + pct + ')">' + sz + '</button>';
      });
      html += '</span>';
      html += '<button class="graphic-swap-btn" onclick="openGraphicPicker(\'' + side + '\')" title="Change graphic">⟲</button>';
      html += '<button class="graphic-remove-btn" onclick="removeGraphic(\'' + side + '\')" title="Remove graphic">✕</button>';
      container.innerHTML = html;
    }
  });
}

function updateGraphicToggleState() {
  const btn = document.getElementById('graphicToggle');
  const panel = document.getElementById('graphicsPanel');
  const hasGraphic = hasAnyGraphic();
  // Button shows accent when graphics exist (even if panel is closed)
  btn.classList.toggle('active', hasGraphic || panel.classList.contains('open'));
}

function loadGraphicsIntoCompose(graphics) {
  composeGraphics = { left: null, right: null };
  if (graphics) {
    if (graphics.left) composeGraphics.left = { data: graphics.left.data, widthPct: graphics.left.widthPct || 25 };
    if (graphics.right) composeGraphics.right = { data: graphics.right.data, widthPct: graphics.right.widthPct || 25 };
  }
  renderGraphicsPanel();
  // Auto-open panel if graphics exist
  const panel = document.getElementById('graphicsPanel');
  if (hasAnyGraphic()) {
    panel.classList.add('open');
  } else {
    panel.classList.remove('open');
  }
  updateGraphicToggleState();
}

function clearGraphics() {
  composeGraphics = { left: null, right: null };
  renderGraphicsPanel();
  document.getElementById('graphicsPanel').classList.remove('open');
  updateGraphicToggleState();
}

function getComposeGraphics() {
  // Return a clean copy for saving (only non-null sides)
  const g = {};
  if (composeGraphics.left) g.left = { data: composeGraphics.left.data, widthPct: composeGraphics.left.widthPct };
  if (composeGraphics.right) g.right = { data: composeGraphics.right.data, widthPct: composeGraphics.right.widthPct };
  return Object.keys(g).length > 0 ? g : undefined;
}

function graphicsMatch(a, b) {
  // Compare two graphics objects for dirty state detection
  const aLeft = a && a.left, aRight = a && a.right;
  const bLeft = b && b.left, bRight = b && b.right;
  if (!!aLeft !== !!bLeft || !!aRight !== !!bRight) return false;
  if (aLeft && bLeft && (aLeft.data !== bLeft.data || aLeft.widthPct !== bLeft.widthPct)) return false;
  if (aRight && bRight && (aRight.data !== bRight.data || aRight.widthPct !== bRight.widthPct)) return false;
  return true;
}

// Helper to build graphic HTML for preview/print rendering
function buildGraphicHtml(graphicObj, cssClass) {
  if (!graphicObj) return '';
  return '<div class="' + (cssClass || 'preview-graphic') + '" style="width:' + graphicObj.widthPct + '%;flex-shrink:0;"><img src="' + graphicObj.data + '" alt=""></div>';
}

// ========== FIT ESTIMATION ==========
// Estimates whether text content will fit within a label's physical dimensions.
// Uses Arial average character widths at print time (72pt = 1in).
// Returns { fits: bool, widthOverflows: [{lineIdx, text, charCount, maxChars}], heightOverflow: bool }
function estimateFit(lines, labelType, graphics) {
  const spec = getSpec(labelType);
  // Usable dimensions in inches (accounting for print padding 0.08in top/bottom, 0.12in left/right)
  const usableW = spec.labelW - 0.24;  // 2 × 0.12in horizontal padding
  const usableH = spec.labelH - 0.16;  // 2 × 0.08in vertical padding
  // Reduce usable width for graphics
  const leftPct = (graphics && graphics.left) ? (graphics.left.widthPct || 0) : 0;
  const rightPct = (graphics && graphics.right) ? (graphics.right.widthPct || 0) : 0;
  const graphicsFraction = (leftPct + rightPct) / 100;
  const textUsableW = usableW * (1 - graphicsFraction);
  // Convert to points (72pt per inch)
  const usableWPt = textUsableW * 72;
  const usableHPt = usableH * 72;

  const widthOverflows = [];
  let totalHeightPt = 0;

  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    const fs = l.fontSize || 11;
    const lineHeightPt = fs * 1.3;
    totalHeightPt += lineHeightPt;

    // Average character width in Arial is roughly 0.5–0.6× the font size in points.
    // Use 0.52 as a conservative average for mixed case text.
    const avgCharWidth = fs * 0.52;
    const maxChars = Math.floor(usableWPt / avgCharWidth);

    const parsed = parseLine(l.text);
    let textLen = 0;
    if (parsed.type === 'split') textLen = (parsed.left + '   ' + parsed.right).length;
    else if (parsed.type === 'fill') textLen = parsed.label.length + 8; // fill line takes extra space
    else textLen = parsed.text.length;

    if (textLen > maxChars) {
      widthOverflows.push({ lineIdx: i, text: l.text, charCount: textLen, maxChars });
    }
  }

  const heightOverflow = totalHeightPt > usableHPt;
  return {
    fits: widthOverflows.length === 0 && !heightOverflow,
    widthOverflows,
    heightOverflow
  };
}

// Generates a short fit warning string for a text against a label type
function getFitWarning(textStr, alignV, labelType, graphics) {
  const lines = deserializeLines(textStr);
  if (!lines.length) return '';
  const result = estimateFit(lines, labelType, graphics);
  if (result.fits) return '';
  const warnings = [];
  if (result.widthOverflows.length > 0) {
    warnings.push(result.widthOverflows.length + ' line' + (result.widthOverflows.length !== 1 ? 's' : '') + ' may be clipped');
  }
  if (result.heightOverflow) warnings.push('text may overflow height');
  const suffix = (graphics && (graphics.left || graphics.right)) ? ' (with graphic)' : '';
  return '⚠️ ' + warnings.join(', ') + suffix;
}

// ========== CLONE TEXT ==========
async function cloneSavedText(id) {
  const original = savedTexts.find(s => s.id === id);
  if (!original) return;
  const name = await showPrompt('Name this copy:', original.name + ' (copy)', { title: '📋 Clone Text', placeholder: 'e.g. Aria, Return Address', maxLength: 40 });
  if (!name || !name.trim()) return; // cancelled or empty
  const trimmed = name.trim();
  const newId = generateId('st');
  const clone = {
    id: newId,
    name: trimmed,
    text: original.text,
    alignV: original.alignV || 'center'
  };
  if (original.graphics) clone.graphics = JSON.parse(JSON.stringify(original.graphics));
  savedTexts.push(clone);
  saveSavedTexts();
  renderSavedTexts();
  updateTabMeta();
  // Load the clone into the compose area for immediate editing
  loadSavedText(newId);
  setStatus('Cloned "' + original.name + '" as "' + trimmed + '"', 'success');
}

// ========== PREVIEW ==========
function isComposeDirty() {
  if (!hasAnyInput()) return false;
  if (!editingTextId) return true; // New unsaved text with content
  const saved = savedTexts.find(s => s.id === editingTextId);
  if (!saved) return true;
  const currentSerialized = serializeLines(getLines());
  if (saved.text !== currentSerialized || (saved.alignV || 'center') !== alignV) return true;
  if (!graphicsMatch(saved.graphics, getComposeGraphics())) return true;
  return false;
}

function updateDirtyIndicator() {
  const btn = document.getElementById('saveTextBtn');
  btn.style.display = isComposeDirty() ? '' : 'none';
}

function updatePreview() {
  const lines = getLines();
  const preview = document.getElementById('previewLabel');

  // Determine the spec to preview against
  let spec, labelTypeId;
  if (textsSubTab === 'templates') {
    // Template mode: use the Avery type dropdown
    labelTypeId = templateLabelType;
    spec = getSpec(labelTypeId);
    document.getElementById('previewDimensions').textContent = spec.sizeDisplay + ' — Avery ' + labelTypeId;
    document.getElementById('composeTypeChip').textContent = 'Avery ' + labelTypeId + ' · ' + spec.sizeDisplay;
  } else {
    // Texts mode: use the sheet dropdown
    const shId = previewSheetId || activeSheetId;
    const sh = sheets[shId];
    if (!sh) return;
    spec = getSpec(sh.labelType);
    labelTypeId = sh.labelType;
    document.getElementById('previewDimensions').textContent = spec.sizeDisplay + ' — Avery ' + sh.labelType;
    document.getElementById('composeTypeChip').textContent = 'Avery ' + sh.labelType + ' · ' + spec.sizeDisplay;
  }

  const maxW = 240, maxH = 130;
  const scale = Math.min(maxW / spec.labelW, maxH / spec.labelH);
  const pw = Math.round(spec.labelW * scale), ph = Math.round(spec.labelH * scale);
  preview.style.width = pw + 'px'; preview.style.height = ph + 'px';

  if (!lines.length) {
    preview.className = 'preview-label empty-preview';
    preview.style.justifyContent = 'center'; preview.style.alignItems = 'center';
    preview.innerHTML = '<span>Type above to preview</span>';
    document.getElementById('previewFitWarning').style.display = 'none';
    updateDirtyIndicator();
    return;
  }
  preview.className = 'preview-label';
  const gfx = getComposeGraphics();
  const hasGfx = gfx && (gfx.left || gfx.right);
  if (hasGfx) {
    // Flex row layout: [left graphic?] [text zone] [right graphic?]
    preview.style.flexDirection = 'row';
    preview.style.justifyContent = 'stretch'; preview.style.alignItems = 'stretch';
    let html = '';
    if (gfx.left) html += buildGraphicHtml(gfx.left, 'preview-graphic');
    html += '<div class="preview-text-zone" style="justify-content:' + getFlexAlign(alignV) + ';">' +
      lines.map(l => renderLineHtml(l, true)).join('') + '</div>';
    if (gfx.right) html += buildGraphicHtml(gfx.right, 'preview-graphic');
    preview.innerHTML = html;
  } else {
    preview.style.flexDirection = 'column';
    preview.style.justifyContent = getFlexAlign(alignV); preview.style.alignItems = 'stretch';
    preview.innerHTML = lines.map(l => renderLineHtml(l, true)).join('');
  }

  // Fit estimation (with graphics)
  const fitResult = estimateFit(lines, labelTypeId, gfx);
  const fitEl = document.getElementById('previewFitWarning');
  if (!fitResult.fits) {
    const warnings = [];
    if (fitResult.widthOverflows.length > 0) warnings.push(fitResult.widthOverflows.length + ' line' + (fitResult.widthOverflows.length !== 1 ? 's' : '') + ' may be clipped on print');
    if (fitResult.heightOverflow) warnings.push('text may overflow label height');
    const suffix = hasGfx ? ' (with graphic)' : '';
    fitEl.textContent = '⚠️ ' + warnings.join('; ') + suffix;
    fitEl.style.display = '';
  } else {
    fitEl.style.display = 'none';
  }
  updateDirtyIndicator();
}

function buildPreviewSheetSelect() {
  const sel = document.getElementById('previewSheetSelect');
  const label = sel.previousElementSibling; // the <label> element

  if (textsSubTab === 'templates') {
    // Template mode: show Avery label type dropdown instead of sheets
    label.textContent = 'Designed for:';
    sel.innerHTML = TYPE_ORDER.map(typeId => {
      const t = LABEL_TYPES[typeId];
      return '<option value="' + typeId + '"' + (typeId === templateLabelType ? ' selected' : '') + '>Avery ' + typeId + ' — ' + t.desc + ' (' + t.sizeDisplay + ')</option>';
    }).join('');
    sel.value = templateLabelType;
  } else {
    // Texts mode: show sheets dropdown (existing behavior)
    label.textContent = 'Preview on:';
    const ids = Object.keys(sheets).sort((a,b) => (sheets[a].createdAt||0) - (sheets[b].createdAt||0));
    sel.innerHTML = ids.map(id => {
      const s = sheets[id];
      return '<option value="' + id + '"' + (id === (previewSheetId || activeSheetId) ? ' selected' : '') + '>' + escapeHtml(s.name) + ' (' + getSpec(s.labelType).name.split(' /')[0] + ')</option>';
    }).join('');
    previewSheetId = sel.value || activeSheetId;
  }
}
function onPreviewSheetChange() {
  if (textsSubTab === 'templates') {
    templateLabelType = document.getElementById('previewSheetSelect').value;
  } else {
    previewSheetId = document.getElementById('previewSheetSelect').value;
  }
  updatePreview();
}

// ========== SAVED TEXTS ==========
function loadSavedTexts() { try { const s = localStorage.getItem(TEXTS_KEY); if (s) savedTexts = JSON.parse(s); } catch(e){} }
function saveSavedTexts() { try { localStorage.setItem(TEXTS_KEY, JSON.stringify(savedTexts)); } catch(e){} }

function renderSavedTexts() {
  const list = document.getElementById('savedTextsList');
  const countEl = document.getElementById('savedTextsCount');
  const textCount = getTexts().length;
  const tplCount = getTemplates().length;

  if (textsSubTab === 'templates') {
    // Templates sub-tab
    const allTpls = getAllTemplates();
    countEl.textContent = allTpls.length ? allTpls.length + ' total' : '';

    if (!allTpls.length) {
      list.innerHTML = '<div class="saved-texts-empty"><span class="icon">📋</span>No templates yet.<br>Create a template with field tokens like {name}.</div>' +
        '<button class="new-text-card" onclick="startNewTemplate()">+ New Template</button>';
      return;
    }

    list.innerHTML = allTpls.map(st => {
      const lines = deserializeLines(st.text);
      const previewHtml = renderMiniPreview(lines, true, st.graphics);
      const isBuiltin = st.builtin;
      const stId = st.id;
      const nameHtml = escapeHtml(st.name) + (isBuiltin ? '<span class="builtin-badge">Built-in</span>' : '');
      const labelTypeHtml = st.labelType ? '<div class="template-label-notice"><span class="notice-icon">🏷️</span>Avery ' + escapeHtml(st.labelType) + ' · ' + getSpec(st.labelType).desc + '</div>' : '';

      if (isBuiltin) {
        return '<div class="saved-text-card" onclick="loadTemplate(\'' + stId + '\')">' +
          '<div class="saved-text-card-header">' +
            '<span class="saved-text-card-name">' + nameHtml + '</span>' +
            '<span class="saved-text-card-actions">' +
              '<button class="st-action-btn" onclick="event.stopPropagation();cloneTemplate(\'' + stId + '\')" title="Clone">📋</button>' +
            '</span>' +
          '</div>' +
          '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
          labelTypeHtml +
        '</div>';
      }

      return '<div class="saved-text-card" onclick="loadTemplate(\'' + stId + '\')">' +
        '<div class="saved-text-card-header">' +
          '<span class="saved-text-card-name">' + nameHtml + '</span>' +
          '<span class="saved-text-card-actions">' +
            '<button class="st-action-btn rename" onclick="event.stopPropagation();renameSavedItem(\'' + stId + '\')" title="Rename">Aa</button>' +
            '<button class="st-action-btn" onclick="event.stopPropagation();cloneTemplate(\'' + stId + '\')" title="Clone">📋</button>' +
            '<button class="st-action-btn edit" onclick="event.stopPropagation();editTemplate(\'' + stId + '\')" title="Edit">✏️</button>' +
            '<button class="st-action-btn" onclick="event.stopPropagation();deleteTemplate(\'' + stId + '\')" title="Delete">✕</button>' +
          '</span>' +
        '</div>' +
        '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
        labelTypeHtml +
      '</div>';
    }).join('');
    list.innerHTML += '<button class="new-text-card" onclick="startNewTemplate()">+ New Template</button>';

  } else {
    // Texts sub-tab (default)
    const texts = getTexts();
    countEl.textContent = texts.length ? texts.length + ' saved' : '';

    if (!texts.length) {
      list.innerHTML = '<div class="saved-texts-empty"><span class="icon">📒</span>No saved texts yet.<br>Compose a label and click Save Text.</div>' +
        '<button class="new-text-card" onclick="startNewText()">+ New Text</button>';
      return;
    }
    const sorted = [...texts].sort((a, b) => a.name.localeCompare(b.name));
    list.innerHTML = sorted.map(st => {
      const lines = deserializeLines(st.text);
      const previewHtml = renderMiniPreview(lines, false, st.graphics);
      return '<div class="saved-text-card" onclick="loadSavedText(\'' + st.id + '\')">' +
        '<div class="saved-text-card-header">' +
          '<span class="saved-text-card-name">' + escapeHtml(st.name) + '</span>' +
          '<span class="saved-text-card-actions">' +
            '<button class="st-action-btn rename" onclick="event.stopPropagation();renameSavedItem(\'' + st.id + '\')" title="Rename">Aa</button>' +
            '<button class="st-action-btn" onclick="event.stopPropagation();cloneSavedText(\'' + st.id + '\')" title="Clone">📋</button>' +
            '<button class="st-action-btn edit" onclick="event.stopPropagation();editSavedText(\'' + st.id + '\')" title="Edit">✏️</button>' +
            '<button class="st-action-btn" onclick="event.stopPropagation();deleteSavedText(\'' + st.id + '\')" title="Delete">✕</button>' +
          '</span>' +
        '</div>' +
        '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
      '</div>';
    }).join('');
    list.innerHTML += '<button class="new-text-card" onclick="startNewText()">+ New Text</button>';
  }
}

function loadSavedText(id) {
  const s = savedTexts.find(x => x.id === id); if (!s) return;
  // Set editing mode BEFORE loading inputs so updateDirtyIndicator
  // correctly compares against the saved version instead of treating
  // populated inputs as new unsaved content
  editingTextId = id;
  const lines = deserializeLines(s.text);
  loadLinesIntoInputs(lines);
  // Restore vertical alignment
  setAlignV(s.alignV || 'center');
  // Restore graphics
  loadGraphicsIntoCompose(s.graphics);
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(id, s.name, { prefix: 'Editing' });
  showAddToSheetButton(id);
}

function editSavedText(id) {
  loadSavedText(id); // Same as clicking now
  if (currentTab !== 'texts') doSwitchTab('texts');
}

function editTextFromSheet(id, evt) {
  // Don't navigate if double-click originated from a control (buttons, selects, inputs)
  if (evt && evt.target && evt.target.closest('button, select, input, .qty-btn, .assigned-text-remove, .assigned-text-controls')) return;
  // If already editing this text, just switch tabs
  if (editingTextId === id) {
    previewSheetId = activeSheetId;
    switchTab('texts');
    return;
  }
  // Check for unsaved changes before loading a different text
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '⚠️ Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doEditTextFromSheet(id);
    });
    return;
  }
  doEditTextFromSheet(id);
}

function doEditTextFromSheet(id) {
  // Set the preview sheet to the current active sheet so dimensions match
  previewSheetId = activeSheetId;
  loadSavedText(id);
  doSwitchTab('texts');
  // Ensure the preview dropdown reflects the active sheet
  const sel = document.getElementById('previewSheetSelect');
  if (sel) sel.value = activeSheetId;
  updatePreview();
  // Scroll the saved text card into view in the right panel
  setTimeout(() => {
    const cards = document.querySelectorAll('.saved-text-card');
    cards.forEach(card => {
      if (card.onclick && card.onclick.toString().includes(id)) {
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        card.style.outline = '2px solid var(--accent)';
        setTimeout(() => { card.style.outline = ''; }, 1500);
      }
    });
  }, 100);
}

function cancelEdit() {
  // If the item being edited has no content (empty text from name-first flow), remove it
  if (editingTextId) {
    const item = savedTexts.find(x => x.id === editingTextId);
    if (item && !item.text) {
      savedTexts = savedTexts.filter(x => x.id !== editingTextId);
      saveSavedTexts();
      renderSavedTexts();
      updateTabMeta();
    }
  }
  editingTextId = null;
  clearInputs();
  hideAddToSheetButton();
  setStatus('', '');
}

function startNewText() {
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '⚠️ Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doStartNewText();
    });
    return;
  }
  doStartNewText();
}

async function doStartNewText() {
  const name = await showPrompt('Name this text:', '', { title: '📝 New Text', placeholder: 'e.g. Aria, Return Address', maxLength: 40 });
  if (!name || !name.trim()) return; // cancelled or empty
  const trimmed = name.trim();
  const id = generateId('st');
  savedTexts.push({ id, name: trimmed, text: '', alignV: 'center' });
  saveSavedTexts();
  renderSavedTexts();
  // Enter editing mode
  editingTextId = id;
  clearInputsOnly();
  hideAddToSheetButton();
  setAlignV('center');
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(id, trimmed, { prefix: 'Editing' });
  document.getElementById('line1').focus();
  showAddToSheetButton(id);
  setStatus('Ready — type your label content', 'info');
  updateTabMeta();
}

// ========== TEMPLATE MANAGEMENT ==========
function loadTemplate(id) {
  // Load a template (built-in or user) into compose
  const tpl = getBuiltinTemplate(id) || savedTexts.find(x => x.id === id);
  if (!tpl) return;
  // Set the preview to this template's label type
  if (tpl.labelType) templateLabelType = tpl.labelType;
  buildPreviewSheetSelect();
  if (tpl.builtin) {
    // Built-ins are read-only — load for viewing but don't set editing mode
    editingTextId = null;
    const lines = deserializeLines(tpl.text);
    loadLinesIntoInputs(lines);
    setAlignV(tpl.alignV || 'center');
    loadGraphicsIntoCompose(tpl.graphics);
    const indicator = document.getElementById('editingIndicator');
    indicator.style.display = 'flex';
    indicator.className = 'editing-indicator';
    indicator.innerHTML = buildEditingIndicatorHtml(null, tpl.name, { prefix: 'Viewing', builtin: true, closeLabel: 'Close' });
    setStatus('Built-in template — clone to create your own version', 'info');
    return;
  }
  // User template — same as loading a saved text
  editingTextId = id;
  const lines = deserializeLines(tpl.text);
  loadLinesIntoInputs(lines);
  setAlignV(tpl.alignV || 'center');
  loadGraphicsIntoCompose(tpl.graphics);
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(id, tpl.name, { prefix: 'Editing template' });
}

function editTemplate(id) {
  loadTemplate(id);
  if (currentTab !== 'texts') doSwitchTab('texts');
}

function startNewTemplate() {
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes. Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '⚠️ Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doStartNewTemplate();
    });
    return;
  }
  doStartNewTemplate();
}

async function doStartNewTemplate() {
  const name = await showPrompt('Name this template:', '', { title: '📋 New Template', placeholder: 'e.g. Classroom Label', maxLength: 40 });
  if (!name || !name.trim()) return; // cancelled or empty
  const trimmed = name.trim();
  const id = generateId('st');
  savedTexts.push({ id, name: trimmed, text: '', alignV: 'center', type: 'template', tokens: [], labelType: templateLabelType });
  saveSavedTexts();
  renderSavedTexts();
  // Enter editing mode
  editingTextId = id;
  clearInputsOnly();
  hideAddToSheetButton();
  setAlignV('center');
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(id, trimmed, { prefix: 'Editing template' });
  document.getElementById('line1').focus();
  setStatus('Use {T} Token to insert field placeholders', 'info');
  updateTabMeta();
}

async function cloneTemplate(id) {
  const tpl = getBuiltinTemplate(id) || savedTexts.find(x => x.id === id);
  if (!tpl) return;
  const name = await showPrompt('Name this copy:', tpl.name + ' (copy)', { title: '📋 Clone Template', placeholder: 'e.g. Classroom Label', maxLength: 40 });
  if (!name || !name.trim()) return; // cancelled or empty
  const trimmed = name.trim();
  const newId = generateId('st');
  const clone = {
    id: newId,
    name: trimmed,
    text: tpl.text,
    alignV: tpl.alignV || 'center',
    type: 'template',
    tokens: extractTokens(tpl.text),
    labelType: tpl.labelType || '5160'
  };
  if (tpl.graphics) clone.graphics = JSON.parse(JSON.stringify(tpl.graphics));
  savedTexts.push(clone);
  saveSavedTexts();
  renderSavedTexts();
  // Load clone into compose for editing
  editingTextId = newId;
  templateLabelType = clone.labelType;
  buildPreviewSheetSelect();
  const lines = deserializeLines(clone.text);
  loadLinesIntoInputs(lines);
  setAlignV(clone.alignV);
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(newId, clone.name, { prefix: 'Editing template' });
  setStatus('Cloned "' + tpl.name + '" as "' + trimmed + '"', 'success');
  updateTabMeta();
}

async function deleteTemplate(id) {
  const tpl = savedTexts.find(x => x.id === id);
  if (!tpl) return;
  const ok = await showConfirm('Delete template "' + tpl.name + '"?', { title: '🗑️ Delete Template', okText: 'Delete', danger: true });
  if (!ok) return;
  savedTexts = savedTexts.filter(x => x.id !== id);
  if (editingTextId === id) cancelEdit();
  saveSavedTexts();
  renderSavedTexts();
  setStatus('Deleted template "' + tpl.name + '"', 'info');
  updateTabMeta();
}

// ========== PASTE DATA (Clipboard Import) ==========
function pasteData() {
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '⚠️ Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doPasteData();
    });
    return;
  }
  doPasteData();
}

async function doPasteData() {
  // Check for clipboard image first — route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported — fall through to text paste
  }

  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    setStatus('Unable to read clipboard — check browser permissions', 'warning');
    return;
  }

  if (!clipText || !clipText.trim()) {
    setStatus('Nothing in clipboard', 'warning');
    return;
  }

  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;

  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }

  if (!rows.length) {
    setStatus('Unable to process clipboard data', 'warning');
    return;
  }

  // If >4 rows or tabular data with multiple rows, open import modal
  if (rows.length > 4 || (isTabular && rows.length > 1)) {
    showImportModal(rows, isTabular);
    return;
  }

  // Phase 1 flow: ≤4 plain rows go directly into compose inputs
  const snapshot = snapshotCompose();

  editingTextId = null;
  document.getElementById('editingIndicator').style.display = 'none';
  hideAddToSheetButton();
  cancelSaveName();

  for (let i = 1; i <= 4; i++) {
    document.getElementById('line' + i).value = '';
    setLineAlign(i, 'left');
    setLineSize(i, 11);
  }
  setAlignV('center');

  const maxLines = Math.min(rows.length, 4);
  for (let i = 0; i < maxLines; i++) {
    document.getElementById('line' + (i + 1)).value = rows[i];
  }

  updatePreview();
  updateDirtyIndicator();
  showSaveNameRow(false);

  pasteUndo = { type: 'paste', snapshot };
  setStatus('Pasted ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard <button class="undo-paste-btn" onclick="undoPaste()">↩️ Undo</button>', 'success');
}

// ========== MULTI-RECORD IMPORT (Phase 2) ==========
let importRows = [];       // Raw clipboard rows
let importIsTabular = false; // Tabular mode (tabs + newlines)
let importLinesPerLabel = 1; // Plain list: lines per label
let importColMap = [];       // Tabular: column → line mapping

// Paste/Import undo state
let pasteUndo = null; // { type: 'paste'|'import', ... }

function snapshotCompose() {
  const snapshot = {
    lines: [],
    aligns: [...lineAligns],
    sizes: [...lineFontSizes],
    styles: lineStyles.map(s => ({ ...s })),
    alignV: alignV,
    editingTextId: editingTextId,
    graphics: {
      left: composeGraphics.left ? { ...composeGraphics.left } : null,
      right: composeGraphics.right ? { ...composeGraphics.right } : null
    }
  };
  for (let i = 1; i <= 4; i++) {
    snapshot.lines.push(document.getElementById('line' + i).value);
  }
  return snapshot;
}

function restoreCompose(snapshot) {
  editingTextId = snapshot.editingTextId;
  for (let i = 1; i <= 4; i++) {
    document.getElementById('line' + i).value = snapshot.lines[i - 1];
    setLineAlign(i, snapshot.aligns[i - 1]);
    setLineSize(i, snapshot.sizes[i - 1]);
    setLineStyle(i, snapshot.styles ? snapshot.styles[i - 1] : {});
  }
  setAlignV(snapshot.alignV);
  loadGraphicsIntoCompose(snapshot.graphics);
  if (editingTextId) {
    const s = savedTexts.find(x => x.id === editingTextId);
    if (s) {
      const indicator = document.getElementById('editingIndicator');
      indicator.style.display = 'flex';
      indicator.className = 'editing-indicator';
      indicator.innerHTML = buildEditingIndicatorHtml(editingTextId, s.name, { prefix: s.type === 'template' ? 'Editing template' : 'Editing' });
    }
  } else {
    document.getElementById('editingIndicator').style.display = 'none';
  }
  hideAddToSheetButton();
  cancelSaveName();
  updatePreview();
  updateDirtyIndicator();
}

function undoPaste() {
  if (!pasteUndo) return;

  if (pasteUndo.type === 'paste') {
    // Restore compose state
    restoreCompose(pasteUndo.snapshot);
    cancelSaveName();
    setStatus('Paste undone', 'info');
  } else if (pasteUndo.type === 'import') {
    // Remove imported texts from savedTexts
    const idsToRemove = new Set(pasteUndo.importedIds);
    savedTexts = savedTexts.filter(s => !idsToRemove.has(s.id));
    saveSavedTexts();
    renderSavedTexts();
    // Remove sheet assignments
    if (pasteUndo.sheetId && sheets[pasteUndo.sheetId]) {
      const sh = sheets[pasteUndo.sheetId];
      if (sh.texts) {
        for (const id of pasteUndo.importedIds) {
          delete sh.texts[id];
        }
        saveSheets();
        if (activeSheetId === pasteUndo.sheetId) {
          buildAssignedTexts();
          buildSheetDetail();
          buildSheetCards();
        }
      }
    }
    // Restore compose state
    restoreCompose(pasteUndo.snapshot);
    updateTabMeta();
    setStatus('Import undone — ' + pasteUndo.importedIds.length + ' text' + (pasteUndo.importedIds.length !== 1 ? 's' : '') + ' removed', 'info');
  }
  pasteUndo = null;
}

function showImportModal(rows, isTabular) {
  importRows = rows;
  importIsTabular = isTabular;

  // Populate template dropdown
  const tplSelect = document.getElementById('importTemplateSelect');
  const allTpls = getAllTemplates();
  let tplOpts = '<option value="">No Template (manual)</option>';
  allTpls.forEach(t => {
    tplOpts += '<option value="' + escapeAttr(t.id) + '">' + escapeHtml(t.name) + '</option>';
  });
  tplSelect.innerHTML = tplOpts;
  // Default to last-used template if available
  if (lastImportTemplate && allTpls.some(t => t.id === lastImportTemplate)) {
    tplSelect.value = lastImportTemplate;
  } else {
    tplSelect.value = '';
  }

  // Show template row only when we have templates
  document.getElementById('importTemplateRow').style.display = allTpls.length ? '' : 'none';

  if (isTabular) {
    // Parse into columns: split each row by tab
    const parsed = rows.map(r => r.split('\t').map(c => c.trim()));
    const colCount = Math.max(...parsed.map(r => r.length));

    // Default mapping: first 4 columns → lines 1–4, rest → skip
    importColMap = [];
    for (let c = 0; c < colCount; c++) {
      importColMap.push(c < 4 ? (c + 1) : 0); // 0 = skip, 1–4 = line number
    }

    // Build column mapping UI (may be overridden by template selection)
    buildImportColMappingUI();
    document.getElementById('importTabularControls').style.display = '';
    document.getElementById('importPlainControls').style.display = 'none';

    document.getElementById('importSummary').textContent = parsed.length + ' rows × ' + colCount + ' columns detected';
  } else {
    // Plain list mode
    importLinesPerLabel = 1;
    document.getElementById('linesPerLabelVal').textContent = '1';
    document.getElementById('importPlainControls').style.display = '';
    document.getElementById('importTabularControls').style.display = 'none';

    document.getElementById('importSummary').textContent = rows.length + ' lines detected from clipboard';
  }

  // Populate sheet dropdown
  const sheetSelect = document.getElementById('importSheetAssign');
  let sheetOpts = '<option value="">— Don\'t assign —</option>';
  for (const [id, sh] of Object.entries(sheets)) {
    const spec = getSpec(sh.labelType);
    const pool = spec.cols * spec.rows * (sh.sheetCount || 1);
    const used = (sh.printed || []).length;
    const assigned = Object.values(sh.texts || {}).reduce((s, t) => s + (t.qty || 0), 0);
    const avail = pool - used - assigned;
    sheetOpts += '<option value="' + escapeAttr(id) + '">' + escapeHtml(sh.name) + ' (' + avail + ' spots)</option>';
  }
  sheetSelect.innerHTML = sheetOpts;
  if (activeSheetId && sheets[activeSheetId]) sheetSelect.value = activeSheetId;

  document.getElementById('importBaseName').value = '';

  // If a template was pre-selected, apply its mapping
  if (tplSelect.value) onImportTemplateChange();
  else updateImportPreview();

  document.getElementById('importTextModal').classList.add('visible');
  document.getElementById('importBaseName').focus();
}

let importTemplateTokenMap = []; // Per-column: token name (string) or null (skip)

function buildImportColMappingUI() {
  if (!importIsTabular) return;
  const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
  const colCount = Math.max(...parsed.map(r => r.length));
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;

  let mapHtml = '';
  if (tpl && tpl.tokens && tpl.tokens.length) {
    // Template mode: map columns to tokens
    document.getElementById('importColMappingTitle').textContent = 'Map columns to template tokens:';
    // Auto-map columns to tokens using headers from first row
    const headers = parsed.length > 0 ? parsed[0] : [];
    const autoMap = autoMapColumns(headers.map(h => h || ''), tpl.tokens);
    importTemplateTokenMap = [];

    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      const autoToken = autoMap[c] || null;
      importTemplateTokenMap.push(autoToken);

      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportTokenMap(' + c + ', this.value)">';
      mapHtml += '<option value="">Skip</option>';
      tpl.tokens.forEach(t => {
        mapHtml += '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>';
      });
      mapHtml += '</select></div>';
    }
  } else {
    // Manual mode: map columns to line numbers
    document.getElementById('importColMappingTitle').textContent = 'Map columns to label lines:';
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportColMap(' + c + ', this.value)">';
      mapHtml += '<option value="0"' + (importColMap[c] === 0 ? ' selected' : '') + '>Skip</option>';
      for (let ln = 1; ln <= 4; ln++) {
        mapHtml += '<option value="' + ln + '"' + (importColMap[c] === ln ? ' selected' : '') + '>→ Line ' + ln + '</option>';
      }
      mapHtml += '</select></div>';
    }
  }
  document.getElementById('importColMapping').innerHTML = mapHtml;
}

function onImportTemplateChange() {
  const tplId = document.getElementById('importTemplateSelect').value;
  lastImportTemplate = tplId || null;
  if (importIsTabular) {
    buildImportColMappingUI();
  }
  updateImportPreview();
}

function updateImportTokenMap(colIdx, tokenName) {
  importTemplateTokenMap[colIdx] = tokenName || null;
  updateImportPreview();
}

function stepLinesPerLabel(delta) {
  importLinesPerLabel = Math.max(1, Math.min(4, importLinesPerLabel + delta));
  document.getElementById('linesPerLabelVal').textContent = importLinesPerLabel;
  updateImportPreview();
}

function updateImportColMap(colIdx, val) {
  importColMap[colIdx] = parseInt(val);
  updateImportPreview();
}

function getImportTemplate() {
  const tplId = document.getElementById('importTemplateSelect')?.value;
  if (!tplId) return null;
  return getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId) || null;
}

function buildImportRecords() {
  const tpl = getImportTemplate();
  const records = [];

  if (importIsTabular) {
    const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));

    if (tpl && tpl.tokens && tpl.tokens.length) {
      // Template mode: build record objects mapping token → value
      for (const row of parsed) {
        const record = {};
        let hasData = false;
        for (let c = 0; c < importTemplateTokenMap.length; c++) {
          const token = importTemplateTokenMap[c];
          if (token && row[c]) {
            record[token] = row[c].trim();
            hasData = true;
          }
        }
        if (hasData) records.push(record);
      }
    } else {
      // Manual line mapping mode
      for (const row of parsed) {
        const lines = [];
        for (let c = 0; c < importColMap.length; c++) {
          const target = importColMap[c];
          if (target >= 1 && target <= 4) {
            while (lines.length < target) lines.push('');
            lines[target - 1] = (row[c] || '').trim();
          }
        }
        while (lines.length > 0 && !lines[lines.length - 1]) lines.pop();
        if (lines.some(l => l)) records.push(lines);
      }
    }
  } else {
    // Plain list: chunk rows by linesPerLabel
    for (let i = 0; i < importRows.length; i += importLinesPerLabel) {
      const chunk = importRows.slice(i, i + importLinesPerLabel);
      if (chunk.some(l => l.trim())) records.push(chunk);
    }
  }
  return records;
}

function updateImportPreview() {
  const records = buildImportRecords();
  const baseName = document.getElementById('importBaseName').value.trim() || 'Text';
  const count = records.length;
  const tpl = getImportTemplate();

  // Update record count
  if (!importIsTabular) {
    document.getElementById('importRecordCount').textContent = 'Creates ' + count + ' text' + (count !== 1 ? 's' : '');
  }

  // Update button text
  document.getElementById('importExecuteBtn').textContent = 'Import ' + count + ' Text' + (count !== 1 ? 's' : '');

  // Name preview
  const tplName = tpl ? tpl.name : baseName;
  const displayBaseName = document.getElementById('importBaseName').value.trim() || tplName;
  if (count <= 1) {
    document.getElementById('importNamePreview').textContent = 'Name: "' + displayBaseName + '"';
  } else {
    document.getElementById('importNamePreview').textContent = 'Names: "' + displayBaseName + ' #1" through "' + displayBaseName + ' #' + count + '"';
  }

  // Preview cards (show up to 4 + "more" indicator)
  const showCount = Math.min(records.length, 4);
  let html = '';
  for (let r = 0; r < showCount; r++) {
    const label = count === 1 ? displayBaseName : displayBaseName + ' #' + (r + 1);
    html += '<div class="import-preview-card">';
    html += '<div class="card-title">' + escapeHtml(label) + '</div>';

    if (tpl && importIsTabular && records[r] && typeof records[r] === 'object' && !Array.isArray(records[r])) {
      // Template mode: show styled preview with real data
      const appliedText = applyTemplate(tpl, records[r]);
      const lines = deserializeLines(appliedText);
      for (const line of lines) {
        if (line.text) {
          html += '<div class="card-line" style="text-align:' + line.align + ';font-size:' + Math.min(line.fontSize || 11, 12) + 'px">' + escapeHtml(line.text) + '</div>';
        }
      }
    } else {
      // Manual mode: show raw lines
      const recLines = Array.isArray(records[r]) ? records[r] : [];
      for (const line of recLines) {
        html += '<div class="card-line">' + escapeHtml(line || '') + '</div>';
      }
    }
    html += '</div>';
  }
  if (records.length > 4) {
    html += '<div class="import-preview-more">+' + (records.length - 4) + ' more</div>';
  }
  document.getElementById('importPreviewArea').innerHTML = html;
}

function executeImport() {
  const records = buildImportRecords();
  if (!records.length) { closeModal('importTextModal'); return; }

  const snapshot = snapshotCompose();
  const tpl = getImportTemplate();
  const tplName = tpl ? tpl.name : null;
  const baseName = document.getElementById('importBaseName').value.trim() || tplName || 'Text';
  const sheetId = document.getElementById('importSheetAssign').value;
  const count = records.length;

  // Create saved texts
  const newIds = [];
  for (let r = 0; r < count; r++) {
    const id = generateId('st');
    const name = count === 1 ? baseName : baseName + ' #' + (r + 1);

    let serialized, useAlignV;

    if (tpl && importIsTabular && records[r] && typeof records[r] === 'object' && !Array.isArray(records[r])) {
      // Template mode: apply template to record
      serialized = applyTemplate(tpl, records[r]);
      useAlignV = tpl.alignV || 'center';
    } else {
      // Manual mode
      const recLines = Array.isArray(records[r]) ? records[r] : [];
      const lines = recLines.map(text => ({ text: text || '', align: 'left', fontSize: 11 })).filter(l => l.text);
      if (!lines.length) continue;
      serialized = serializeLines(lines);
      useAlignV = 'center';
    }

    savedTexts.push({
      id: id,
      name: name,
      text: serialized,
      alignV: useAlignV,
      graphics: tpl && tpl.graphics ? JSON.parse(JSON.stringify(tpl.graphics)) : undefined,
      fromTemplateLabel: tpl && tpl.labelType ? tpl.labelType : undefined
    });
    newIds.push(id);
  }
  saveSavedTexts();
  renderSavedTexts();

  // Optional sheet assignment
  if (sheetId && sheets[sheetId]) {
    const sh = sheets[sheetId];
    if (!sh.texts) sh.texts = {};
    for (const id of newIds) {
      if (!sh.texts[id]) {
        sh.texts[id] = { qty: 0, placement: 'next' };
      }
    }
    saveSheets();
    if (activeSheetId === sheetId) {
      buildAssignedTexts();
    }
  }

  closeModal('importTextModal');

  // Clear compose area to new-text state
  editingTextId = null;
  document.getElementById('editingIndicator').style.display = 'none';
  hideAddToSheetButton();
  cancelSaveName();
  for (let i = 1; i <= 4; i++) {
    document.getElementById('line' + i).value = '';
    setLineAlign(i, 'left');
    setLineSize(i, 11);
  }
  setAlignV('center');
  updatePreview();
  updateDirtyIndicator();

  pasteUndo = { type: 'import', snapshot, importedIds: newIds, sheetId: sheetId || null };
  const msg = 'Imported ' + newIds.length + ' text' + (newIds.length !== 1 ? 's' : '');
  const tplMsg = tpl ? ' via "' + tpl.name + '" template' : '';
  const sheetMsg = sheetId && sheets[sheetId] ? ' — assigned to "' + sheets[sheetId].name + '"' : '';
  setStatus(msg + tplMsg + sheetMsg + ' <button class="undo-paste-btn" onclick="undoPaste()">↩️ Undo</button>', 'success');
}

// ========== OCR IMAGE IMPORT (Phase 3) ==========
let ocrImageBlob = null;    // Current image blob for OCR
let ocrResults = [];        // Array of { text, confidence } per line
let ocrRotation = 0;        // Manual rotation applied (0, 90, 180, 270)
let tesseractWorker = null; // Reusable Tesseract worker

async function loadTesseract() {
  if (window.Tesseract) return;
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(script);
  });
}

function scanImage() {
  // Check dirty state first
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '⚠️ Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      document.getElementById('ocrFileInput').click();
    });
    return;
  }
  document.getElementById('ocrFileInput').click();
}

function openOcrModal() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  // Reset UI
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loading…';
  document.getElementById('ocrResultLines').innerHTML = '';
  document.getElementById('ocrHint').textContent = '';
  document.getElementById('ocrModal').classList.add('visible');
}

function closeOcrModal() {
  document.getElementById('ocrModal').classList.remove('visible');
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
}

function ocrImageAreaClick() {
  // Only allow re-pick if we don't have results showing
  if (!ocrImageBlob) {
    document.getElementById('ocrFileInput').click();
  }
}

function handleOcrFile(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  event.target.value = ''; // Reset so same file can be re-selected
  openOcrModal();
  processOcrImage(file);
}

// Handle paste events on the OCR modal for screenshot paste
function handleOcrPaste(event) {
  const modal = document.getElementById('ocrModal');
  if (!modal.classList.contains('visible')) return;
  const items = event.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      event.preventDefault();
      const blob = item.getAsFile();
      if (blob) processOcrImage(blob);
      return;
    }
  }
}

function processOcrImage(fileOrBlob) {
  ocrImageBlob = fileOrBlob;
  ocrRotation = 0;

  // Show image preview
  const img = document.getElementById('ocrPreviewImg');
  const url = URL.createObjectURL(fileOrBlob);
  img.onload = () => URL.revokeObjectURL(url);
  img.src = url;
  img.style.display = '';
  img.style.transform = '';
  document.getElementById('ocrPlaceholder').style.display = 'none';
  document.getElementById('ocrImageArea').classList.add('has-image');

  // Show rotation controls
  document.getElementById('ocrRotationBar').style.display = '';
  document.getElementById('ocrRotationLabel').textContent = '';

  // Hide previous results
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';

  // Start OCR — preprocess then recognize
  runOcr(fileOrBlob);
}

// Canvas-based image preprocessing for better OCR accuracy
function preprocessImage(imageBlob, rotation, shadowMode) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(imageBlob);
    img.onload = () => {
      URL.revokeObjectURL(url);
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Step 0: Apply rotation
        let w = img.naturalWidth;
        let h = img.naturalHeight;
        const rot = ((rotation || 0) % 360 + 360) % 360;
        const swapDims = (rot === 90 || rot === 270);

        // Scale up small images for better OCR
        const minDim = 1500;
        if (w < minDim && h < minDim) {
          const scale = minDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        // Cap very large images
        const maxDim = 4000;
        if (w > maxDim || h > maxDim) {
          const scale = maxDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }

        // Set canvas size (swap w/h for 90°/270°)
        canvas.width = swapDims ? h : w;
        canvas.height = swapDims ? w : h;

        // Apply rotation transform and draw
        if (rot === 0) {
          ctx.drawImage(img, 0, 0, w, h);
        } else {
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(rot * Math.PI / 180);
          ctx.drawImage(img, -w / 2, -h / 2, w, h);
          ctx.restore();
        }

        // Update w/h to match canvas after rotation
        w = canvas.width;
        h = canvas.height;

        const imageData = ctx.getImageData(0, 0, w, h);
        const data = imageData.data;

        // Step 1: Convert to grayscale
        const gray = new Uint8Array(w * h);
        for (let i = 0; i < gray.length; i++) {
          const p = i * 4;
          gray[i] = Math.round(data[p] * 0.299 + data[p + 1] * 0.587 + data[p + 2] * 0.114);
        }

        // Step 2: Preprocessing (two modes)
        const totalPx = gray.length;
        if (shadowMode) {
          // Shadow mode: illumination normalization via downsampled local mean
          const ds = 2;
          const dw = Math.ceil(w / ds);
          const dh = Math.ceil(h / ds);
          const dsGray = new Float64Array(dw * dh);
          for (let dy = 0; dy < dh; dy++)
            for (let dx = 0; dx < dw; dx++)
              dsGray[dy * dw + dx] = gray[Math.min(dy * ds, h - 1) * w + Math.min(dx * ds, w - 1)];
          const block = Math.max(Math.floor(Math.max(dw, dh) / 8), 5);
          const piw = dw + 2 * block, pih = dh + 2 * block;
          const pad = new Float64Array(piw * pih);
          for (let y = 0; y < pih; y++) {
            const sy = Math.max(0, Math.min(dh - 1, y - block));
            for (let x = 0; x < piw; x++)
              pad[y * piw + x] = dsGray[sy * dw + Math.max(0, Math.min(dw - 1, x - block))];
          }
          for (let y = 0; y < pih; y++)
            for (let x = 1; x < piw; x++)
              pad[y * piw + x] += pad[y * piw + x - 1];
          for (let x = 0; x < piw; x++)
            for (let y = 1; y < pih; y++)
              pad[y * piw + x] += pad[(y - 1) * piw + x];
          const ba = (2 * block) * (2 * block);
          const dsM = new Float64Array(dw * dh);
          for (let dy = 0; dy < dh; dy++) {
            const py = dy + block, y1 = py - block, y2 = py + block;
            for (let dx = 0; dx < dw; dx++) {
              const px = dx + block, x1 = px - block, x2 = px + block;
              dsM[dy * dw + dx] = (pad[y2 * piw + x2] - pad[y1 * piw + x2] - pad[y2 * piw + x1] + pad[y1 * piw + x1]) / ba;
            }
          }
          for (let y = 0; y < h; y++) {
            const fy = y / ds, dy0 = Math.min(Math.floor(fy), dh - 1), dy1 = Math.min(dy0 + 1, dh - 1), ty = fy - dy0;
            for (let x = 0; x < w; x++) {
              const fx = x / ds, dx0 = Math.min(Math.floor(fx), dw - 1), dx1 = Math.min(dx0 + 1, dw - 1), tx = fx - dx0;
              const m = dsM[dy0*dw+dx0]*(1-ty)*(1-tx) + dsM[dy0*dw+dx1]*(1-ty)*tx + dsM[dy1*dw+dx0]*ty*(1-tx) + dsM[dy1*dw+dx1]*ty*tx;
              gray[y * w + x] = Math.max(0, Math.min(255, Math.round(gray[y * w + x] / Math.max(m, 1) * 128)));
            }
          }
        } else {
          // Normal mode: contrast stretch using 1st/99th percentile
          const hist = new Uint32Array(256);
          for (let i = 0; i < gray.length; i++) hist[gray[i]]++;
          let cumLow = 0, pMin = 0;
          for (let i = 0; i < 256; i++) { cumLow += hist[i]; if (cumLow >= totalPx * 0.01) { pMin = i; break; } }
          let cumHigh = 0, pMax = 255;
          for (let i = 255; i >= 0; i--) { cumHigh += hist[i]; if (cumHigh >= totalPx * 0.01) { pMax = i; break; } }
          const range = pMax - pMin || 1;
          for (let i = 0; i < gray.length; i++) {
            gray[i] = Math.max(0, Math.min(255, Math.round((gray[i] - pMin) * 255 / range)));
          }
        }

        // Step 3: Otsu's method for global threshold on normalized image
        const hist2 = new Uint32Array(256);
        for (let i = 0; i < gray.length; i++) hist2[gray[i]]++;
        let sumAll = 0;
        for (let i = 0; i < 256; i++) sumAll += i * hist2[i];
        let sumB = 0, wB = 0, wF = 0, maxVar = 0, bestThresh = 128;
        for (let t = 0; t < 256; t++) {
          wB += hist2[t];
          if (wB === 0) continue;
          wF = totalPx - wB;
          if (wF === 0) break;
          sumB += t * hist2[t];
          const mB = sumB / wB;
          const mF = (sumAll - sumB) / wF;
          const between = wB * wF * (mB - mF) * (mB - mF);
          if (between > maxVar) { maxVar = between; bestThresh = t; }
        }

        // Apply threshold
        for (let i = 0; i < gray.length; i++) {
          gray[i] = gray[i] > bestThresh ? 255 : 0;
        }

        // Step 4: Auto-detect if text is light-on-dark and invert if needed
        let darkPx = 0, lightPx = 0;
        const cx1 = Math.round(w * 0.25), cx2 = Math.round(w * 0.75);
        const cy1 = Math.round(h * 0.25), cy2 = Math.round(h * 0.75);
        for (let y = cy1; y < cy2; y += 3) {
          for (let x = cx1; x < cx2; x += 3) {
            if (gray[y * w + x] === 0) darkPx++; else lightPx++;
          }
        }
        if (darkPx > lightPx) {
          for (let i = 0; i < gray.length; i++) gray[i] = 255 - gray[i];
        }

        // Write back to canvas
        for (let i = 0; i < gray.length; i++) {
          const p = i * 4;
          data[p] = data[p + 1] = data[p + 2] = gray[i];
          data[p + 3] = 255;
        }
        ctx.putImageData(imageData, 0, 0);

        canvas.toBlob(blob => {
          if (blob) resolve(blob);
          else reject(new Error('Canvas toBlob failed'));
        }, 'image/png');
      } catch (err) {
        reject(err);
      }
    };
    img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Image load failed')); };
    img.src = url;
  });
}

// Parse Tesseract results with word-level confidence filtering
function parseOcrResult(result) {
  if (!result.data || !result.data.lines) return [];

  const lines = [];
  for (const line of result.data.lines) {
    const words = (line.words || []).filter(w => w.text.trim());
    if (!words.length) continue;

    // Filter words: drop low-confidence junk from edges, keep strong core
    const filtered = [];
    let foundGood = false;
    for (let i = 0; i < words.length; i++) {
      const w = words[i];
      const conf = w.confidence;
      const text = w.text.trim();

      // Skip short punctuation/symbols with low confidence anywhere
      if (text.length <= 2 && conf < 50 && /^[^a-zA-Z0-9]+$/.test(text)) continue;

      if (!foundGood) {
        // Leading edge: only start collecting once we hit a decent word
        if (conf < 50) continue;
        foundGood = true;
      }

      filtered.push(w);
    }

    // Trim low-confidence words from the right edge
    while (filtered.length > 0) {
      const last = filtered[filtered.length - 1];
      if (last.confidence < 50) { filtered.pop(); continue; }
      // Also trim trailing short punctuation even at moderate confidence
      const lt = last.text.trim();
      if (lt.length <= 2 && /^[^a-zA-Z0-9]+$/.test(lt)) { filtered.pop(); continue; }
      break;
    }

    if (!filtered.length) continue;

    // Build cleaned line text
    let text = filtered.map(w => w.text.trim()).join(' ');
    // Weighted average confidence by word length
    let totalChars = 0, weightedConf = 0;
    for (const w of filtered) {
      const len = w.text.trim().length;
      totalChars += len;
      weightedConf += w.confidence * len;
    }
    const avgConf = totalChars ? Math.round(weightedConf / totalChars) : 0;

    // Clean common OCR artifacts at start/end
    text = text.replace(/^[=|[\]{}()+*#<>~"'_\-,.;:!?]+\s*/, '');
    text = text.replace(/\s*[=|[\]{}()+*#<>~"'_\-,.;:!?]+$/, '');
    text = text.replace(/\s{2,}/g, ' ').trim();

    // Skip empty or very short results
    if (!text || text.length < 2) continue;
    // Skip lines that are mostly non-alphanumeric (noise)
    const alphaCount = (text.match(/[a-zA-Z0-9]/g) || []).length;
    if (alphaCount / text.length < 0.4) continue;
    // Skip lines where average confidence is very low (pure noise)
    if (avgConf < 40) continue;

    lines.push({ text, confidence: avgConf });
  }

  // Post-process: split lines that contain | separators (merged lines from borders)
  const expanded = [];
  for (const line of lines) {
    if (line.text.includes(' | ') || line.text.includes(' |') || line.text.includes('| ')) {
      const parts = line.text.split(/\s*\|\s*/).filter(p => p.trim());
      for (const part of parts) {
        if (part.trim().length >= 2) {
          expanded.push({ text: part.trim(), confidence: line.confidence });
        }
      }
    } else {
      expanded.push(line);
    }
  }

  return expanded;
}

async function runOcr(imageBlob) {
  const progressArea = document.getElementById('ocrProgressArea');
  const progressFill = document.getElementById('ocrProgressFill');
  const progressText = document.getElementById('ocrProgressText');

  progressArea.style.display = '';
  progressFill.style.width = '0%';
  progressText.textContent = 'Loading OCR…';

  try {
    await loadTesseract();
  } catch (err) {
    progressText.textContent = 'Failed to load OCR library';
    progressFill.style.width = '0%';
    return;
  }

  progressText.textContent = 'Preprocessing…';
  progressFill.style.width = '10%';

  let rotation = ocrRotation;

  let processedBlob;
  try {
    processedBlob = await preprocessImage(imageBlob, rotation);
  } catch (err) {
    // If preprocessing fails, fall back to raw image
    processedBlob = imageBlob;
  }

  progressText.textContent = 'Scanning…';
  progressFill.style.width = '20%';

  try {
    // Create worker if we don't have one
    if (!tesseractWorker) {
      tesseractWorker = await Tesseract.createWorker('eng', 1, {
        logger: m => {
          if (m.status === 'recognizing text') {
            const pct = Math.round(20 + m.progress * 70);
            progressFill.style.width = pct + '%';
            progressText.textContent = pct + '%';
          }
        }
      });
    }

    let result = await tesseractWorker.recognize(processedBlob);

    // Get raw line confidences for rotation decision (before word-level cleanup)
    let rawConf = 0;
    let rawLineCount = 0;
    if (result.data && result.data.lines) {
      for (const line of result.data.lines) {
        if (line.text.trim()) { rawConf += line.confidence; rawLineCount++; }
      }
    }
    const avgRawConf = rawLineCount ? rawConf / rawLineCount : 0;

    // If raw confidence is low and no manual rotation, try other orientations
    if (avgRawConf < 60 && ocrRotation === 0 && rotation === 0) {
      progressText.textContent = 'Trying rotations…';
      progressFill.style.width = '92%';

      let bestResult = result;
      let bestConf = avgRawConf;
      let bestRot = 0;

      for (const tryRot of [90, 180, 270]) {
        let rotBlob;
        try {
          rotBlob = await preprocessImage(imageBlob, tryRot);
        } catch (e) { continue; }
        const rotResult = await tesseractWorker.recognize(rotBlob);
        // Use raw line confidence for comparison
        let rotRawConf = 0, rotRawCount = 0;
        if (rotResult.data && rotResult.data.lines) {
          for (const line of rotResult.data.lines) {
            if (line.text.trim()) { rotRawConf += line.confidence; rotRawCount++; }
          }
        }
        const rotAvg = rotRawCount ? rotRawConf / rotRawCount : 0;
        if (rotAvg > bestConf) {
          bestConf = rotAvg;
          bestResult = rotResult;
          bestRot = tryRot;
        }
        // If we find a high-confidence match, stop early
        if (bestConf >= 80) break;
      }

      if (bestRot !== 0) {
        result = bestResult;
        ocrRotation = bestRot;
        document.getElementById('ocrPreviewImg').style.transform = 'rotate(' + bestRot + 'deg)';
        document.getElementById('ocrRotationLabel').textContent = bestRot + '°';
      }
    }

    // Apply word-level cleanup on the final winning result
    let lines = parseOcrResult(result);
    let finalConf = lines.length ? lines.reduce((s, l) => s + l.confidence, 0) / lines.length : 0;

    // If confidence is still low after rotation, try shadow-removal preprocessing
    if (finalConf < 70) {
      progressText.textContent = 'Trying shadow removal…';
      progressFill.style.width = '95%';
      try {
        // Try shadow mode at all 4 rotations to find the best
        let bestShadowLines = null;
        let bestShadowConf = finalConf;
        let bestShadowRot = ocrRotation;
        for (const sRot of [0, 90, 180, 270]) {
          const shadowBlob = await preprocessImage(imageBlob, sRot, true);
          const shadowResult = await tesseractWorker.recognize(shadowBlob);
          const shadowLines = parseOcrResult(shadowResult);
          const shadowConf = shadowLines.length ? shadowLines.reduce((s, l) => s + l.confidence, 0) / shadowLines.length : 0;
          if (shadowConf > bestShadowConf) {
            bestShadowConf = shadowConf;
            bestShadowLines = shadowLines;
            bestShadowRot = sRot;
          }
          if (bestShadowConf >= 80) break;
        }
        if (bestShadowLines) {
          lines = bestShadowLines;
          finalConf = bestShadowConf;
          if (bestShadowRot !== ocrRotation) {
            ocrRotation = bestShadowRot;
            document.getElementById('ocrPreviewImg').style.transform = 'rotate(' + bestShadowRot + 'deg)';
            document.getElementById('ocrRotationLabel').textContent = bestShadowRot + '°';
          }
        }
      } catch (e) { /* shadow preprocess failed, keep original */ }
    }

    ocrResults = lines;
    progressFill.style.width = '100%';
    progressText.textContent = 'Done';

    // Show results
    setTimeout(() => {
      progressArea.style.display = 'none';
      renderOcrResults();
    }, 400);

  } catch (err) {
    progressFill.style.width = '0%';
    progressText.textContent = 'OCR failed — try a clearer image';
    document.getElementById('ocrRescanBtn').style.display = '';
    document.getElementById('ocrNewImageBtn').style.display = '';
  }
}

function renderOcrResults() {
  const container = document.getElementById('ocrResultLines');
  const hint = document.getElementById('ocrHint');

  if (!ocrResults.length) {
    container.innerHTML = '<div style="color:var(--text-muted);font-size:13px;padding:8px 0">No text detected. Try a clearer image with good contrast.</div>';
    document.getElementById('ocrResultsArea').style.display = '';
    document.getElementById('ocrRescanBtn').style.display = '';
    document.getElementById('ocrNewImageBtn').style.display = '';
    document.getElementById('ocrConfirmBtn').style.display = 'none';
    return;
  }

  let html = '';
  for (let i = 0; i < ocrResults.length; i++) {
    const r = ocrResults[i];
    const isLow = r.confidence < 70;
    html += '<div class="ocr-result-line">';
    html += '<input type="text" value="' + escapeAttr(r.text) + '" class="' + (isLow ? 'low-confidence' : '') + '" oninput="updateOcrLine(' + i + ', this.value)">';
    html += '<span class="ocr-conf ' + (isLow ? 'low' : '') + '">' + r.confidence + '%</span>';
    html += '<button class="ocr-line-remove" onclick="removeOcrLine(' + i + ')" title="Remove line">✕</button>';
    html += '</div>';
  }
  container.innerHTML = html;

  const lowCount = ocrResults.filter(r => r.confidence < 70).length;
  if (lowCount > 0) {
    hint.textContent = lowCount + ' line' + (lowCount !== 1 ? 's have' : ' has') + ' low confidence — highlighted for review';
  } else {
    hint.textContent = ocrResults.length + ' line' + (ocrResults.length !== 1 ? 's' : '') + ' detected';
  }

  document.getElementById('ocrResultsArea').style.display = '';
  document.getElementById('ocrConfirmBtn').style.display = '';
  document.getElementById('ocrRescanBtn').style.display = '';
  document.getElementById('ocrNewImageBtn').style.display = '';

  // Update button text based on line count
  updateOcrConfirmBtn();
}

function updateOcrLine(idx, value) {
  if (idx >= 0 && idx < ocrResults.length) {
    ocrResults[idx].text = value;
  }
}

function removeOcrLine(idx) {
  ocrResults.splice(idx, 1);
  renderOcrResults();
}

function updateOcrConfirmBtn() {
  const lines = ocrResults.filter(r => r.text.trim());
  const btn = document.getElementById('ocrConfirmBtn');
  if (lines.length <= 4) {
    btn.textContent = 'Use ' + lines.length + ' Line' + (lines.length !== 1 ? 's' : '');
  } else {
    btn.textContent = 'Import ' + lines.length + ' Lines →';
  }
}

function ocrRescan() {
  // Reset results and re-scan same image, or pick new one
  ocrResults = [];
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  if (ocrImageBlob) {
    runOcr(ocrImageBlob);
  } else {
    document.getElementById('ocrFileInput').click();
  }
}

function ocrNewImage() {
  // Pick a different image while modal is open
  document.getElementById('ocrFileInput').click();
}

function rotateOcrImage(delta) {
  ocrRotation = ((ocrRotation + delta) % 360 + 360) % 360;
  // Update preview rotation visually
  document.getElementById('ocrPreviewImg').style.transform = ocrRotation ? 'rotate(' + ocrRotation + 'deg)' : '';
  document.getElementById('ocrRotationLabel').textContent = ocrRotation ? ocrRotation + '°' : '';
  // Re-run OCR with new rotation
  if (ocrImageBlob) {
    ocrResults = [];
    document.getElementById('ocrResultsArea').style.display = 'none';
    document.getElementById('ocrConfirmBtn').style.display = 'none';
    document.getElementById('ocrRescanBtn').style.display = 'none';
    document.getElementById('ocrNewImageBtn').style.display = 'none';
    runOcr(ocrImageBlob);
  }
}

function confirmOcr() {
  const lines = ocrResults.filter(r => r.text.trim()).map(r => r.text.trim());
  if (!lines.length) return;

  closeOcrModal();

  if (lines.length <= 4) {
    // Route to Phase 1 flow — place directly into compose inputs
    const snapshot = snapshotCompose();

    editingTextId = null;
    document.getElementById('editingIndicator').style.display = 'none';
    hideAddToSheetButton();
    cancelSaveName();

    for (let i = 1; i <= 4; i++) {
      document.getElementById('line' + i).value = '';
      setLineAlign(i, 'left');
      setLineSize(i, 11);
    }
    setAlignV('center');

    for (let i = 0; i < lines.length; i++) {
      document.getElementById('line' + (i + 1)).value = lines[i];
    }

    updatePreview();
    updateDirtyIndicator();
    showSaveNameRow(false);

    pasteUndo = { type: 'paste', snapshot };
    setStatus('Scanned ' + lines.length + ' line' + (lines.length !== 1 ? 's' : '') + ' from image <button class="undo-paste-btn" onclick="undoPaste()">↩️ Undo</button>', 'success');
  } else {
    // Route to Phase 2 flow — open import modal with the extracted lines
    showImportModal(lines, false);
  }
}

function saveCurrentText() {
  const lines = getLines();
  if (!lines.length) { setStatus('Enter text first', 'warning'); return; }

  if (editingTextId) {
    // Update existing
    const existing = savedTexts.find(s => s.id === editingTextId);
    if (existing) {
      existing.text = serializeLines(lines);
      existing.alignV = alignV;
      // Update graphics
      const gfx = getComposeGraphics();
      if (gfx) { existing.graphics = gfx; } else { delete existing.graphics; }
      // Update tokens if it's a template
      if (existing.type === 'template') {
        existing.tokens = extractTokens(existing.text);
        existing.labelType = templateLabelType;
      }
      saveSavedTexts(); renderSavedTexts();
      updateDirtyIndicator();
      setStatus('Updated "' + existing.name + '"', 'success');
      // Stay in editing mode so they can keep tweaking
    }
    return;
  }

  // New save - show name input
  const isTemplate = textsSubTab === 'templates';
  showSaveNameRow(true, isTemplate);
}

function showSaveNameRow(focusInput, isTemplate) {
  const row = document.getElementById('saveNameRow');
  const placeholder = isTemplate ? 'Name this template (e.g., Classroom Label)' : 'Name this text (e.g., Aria, Return Address)';
  if (row.style.display === 'none' || !row.innerHTML) {
    row.style.display = 'block';
    row.innerHTML = '<div class="save-name-row">' +
      '<input type="text" id="saveNameInput" placeholder="' + placeholder + '" maxlength="40">' +
      '<button class="btn btn-primary btn-sm" onclick="confirmSaveText()">Save</button>' +
      '<button class="btn btn-secondary btn-sm" onclick="cancelSaveName()">✕</button>' +
    '</div>';
    document.getElementById('saveNameInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') confirmSaveText();
      if (e.key === 'Escape') cancelSaveName();
    });
  }
  if (focusInput) document.getElementById('saveNameInput').focus();
}

function confirmSaveText() {
  const nameInput = document.getElementById('saveNameInput');
  if (!nameInput) return;
  const name = nameInput.value.trim();
  if (!name) { nameInput.style.borderColor = 'var(--danger)'; nameInput.focus(); return; }
  const lines = getLines();
  if (!lines.length) { setStatus('Enter text first', 'warning'); return; }
  const id = generateId('st');
  const serialized = serializeLines(lines);
  const isTemplate = textsSubTab === 'templates';

  const entry = { id, name, text: serialized, alignV: alignV };
  const gfx = getComposeGraphics();
  if (gfx) entry.graphics = gfx;
  if (isTemplate) {
    entry.type = 'template';
    entry.tokens = extractTokens(serialized);
    entry.labelType = templateLabelType;
  }
  savedTexts.push(entry);
  saveSavedTexts(); renderSavedTexts();
  cancelSaveName();
  // Switch into editing mode for the newly saved item
  editingTextId = id;
  updateDirtyIndicator();
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = buildEditingIndicatorHtml(id, name, { prefix: isTemplate ? 'Editing template' : 'Editing' });
  setStatus('Saved "' + name + '"', 'success');
  if (!isTemplate) showAddToSheetButton(id);
  updateTabMeta();
}

function cancelSaveName() {
  const row = document.getElementById('saveNameRow');
  row.style.display = 'none';
  row.innerHTML = '';
}

async function deleteSavedText(id) {
  const s = savedTexts.find(x => x.id === id); if (!s) return;
  const ok = await showConfirm('Delete saved text "' + s.name + '"?', { title: '🗑️ Delete Saved Text', okText: 'Delete', danger: true });
  if (!ok) return;
  savedTexts = savedTexts.filter(x => x.id !== id);
  if (editingTextId === id) cancelEdit();
  // Remove from all sheets
  for (const sh of Object.values(sheets)) {
    if (sh.texts && sh.texts[id]) delete sh.texts[id];
  }
  saveSavedTexts(); saveSheets(); renderSavedTexts();
  setStatus('Deleted "' + s.name + '"', 'info');
  updateTabMeta();
}

async function renameSavedItem(id) {
  const item = savedTexts.find(x => x.id === id);
  if (!item) return;
  const isTemplate = item.type === 'template';
  const label = isTemplate ? 'Template' : 'Text';
  const n = await showPrompt('Enter new name:', item.name, { title: '✏️ Rename ' + label, placeholder: label + ' name', maxLength: 40 });
  if (n === null) return; // cancelled
  const trimmed = n.trim();
  if (!trimmed) return; // empty — do nothing
  if (trimmed === item.name) return; // unchanged
  item.name = trimmed;
  saveSavedTexts();
  renderSavedTexts();
  // If currently editing this item, update the editing indicator
  if (editingTextId === id) {
    const indicator = document.getElementById('editingIndicator');
    indicator.innerHTML = buildEditingIndicatorHtml(id, trimmed, { prefix: isTemplate ? 'Editing template' : 'Editing' });
  }
  // Refresh assigned texts on Sheets tab in case this text is assigned
  buildAssignedTexts();
  setStatus('Renamed to "' + trimmed + '"', 'success');
}

// ========== ADD TO SHEET (from texts tab) ==========
function showAddToSheetButton(textId) {
  const row = document.getElementById('addToSheetRow');
  const sh = getActiveSheet();
  const rem = getRemaining();
  if (rem > 0 && activeSheetId) {
    // Check if already on the active sheet
    const already = sh.texts && sh.texts[textId];
    if (already) {
      row.style.display = 'block';
      row.innerHTML = '<div class="queue-nudge" style="margin-top:8px"><span class="queue-nudge-text">On "' + escapeHtml(sh.name) + '"</span>' +
        '<button class="queue-nudge-btn" onclick="switchTab(\'sheets\')">View Sheet →</button></div>';
    } else {
      row.style.display = 'block';
      row.innerHTML = '<div class="queue-nudge" style="margin-top:8px"><span class="queue-nudge-text">' + rem + ' spots on "' + escapeHtml(sh.name) + '"</span>' +
        '<button class="queue-nudge-btn" onclick="addTextToActiveSheet(\'' + textId + '\')">Add to Sheet →</button></div>';
    }
  } else {
    row.style.display = 'none';
  }
}
function hideAddToSheetButton() {
  document.getElementById('addToSheetRow').style.display = 'none';
}

function addTextToActiveSheet(textId) {
  const sh = getActiveSheet();
  if (!sh.texts) sh.texts = {};
  if (sh.texts[textId]) {
    // Already exists, just go to sheet
    switchTab('sheets');
    return;
  }
  sh.texts[textId] = { qty: 0, placement: 'next' };
  saveSheets();
  setStatus('Added to "' + sh.name + '" — go to Sheets to set quantity', 'success');
  showAddToSheetButton(textId);
  updateTabMeta();
}

// ========== SHEET PERSISTENCE ==========
function loadSheets() {
  try { const s = localStorage.getItem(SHEETS_KEY); if (s) sheets = JSON.parse(s); activeSheetId = localStorage.getItem(ACTIVE_KEY); } catch(e){}
  if (!Object.keys(sheets).length) {
    try {
      const old = localStorage.getItem('avery5160_sheets');
      if (old) { const oldSheets = JSON.parse(old); for (const [id, sh] of Object.entries(oldSheets)) { sheets[id] = { ...sh, labelType: '5160' }; } activeSheetId = localStorage.getItem('avery5160_active'); }
    } catch(e){}
  }
  // Migration: ensure all sheets have texts property, labelType, sheetCount, and placement on text entries
  for (const sh of Object.values(sheets)) {
    if (!sh.labelType) sh.labelType = '5160';
    if (!sh.texts) sh.texts = {};
    if (!sh.sheetCount) sh.sheetCount = 1;
    // v10: ensure all text entries have placement
    for (const entry of Object.values(sh.texts)) {
      if (!entry.placement) entry.placement = 'next';
    }
  }
  if (activeSheetId && sheets[activeSheetId]) return;
  if (Object.keys(sheets).length) { activeSheetId = Object.keys(sheets)[0]; saveSheets(); }
}
function saveSheets() { try { localStorage.setItem(SHEETS_KEY, JSON.stringify(sheets)); localStorage.setItem(ACTIVE_KEY, activeSheetId); } catch(e){} }

// ========== SHEETS TAB ==========
function buildSheetCards() {
  const container = document.getElementById('sheetCardsList');
  const ids = Object.keys(sheets).sort((a,b) => (sheets[a].createdAt||0) - (sheets[b].createdAt||0));

  if (!ids.length) {
    container.innerHTML = '<div class="no-sheet-selected"><span class="icon">📄</span>No sheets yet. Create one to get started.</div>';
    return;
  }

  container.innerHTML = ids.map(id => {
    const s = sheets[id], spec = getSpec(s.labelType);
    const lps = spec.cols * spec.rows;
    const count = s.sheetCount || 1;
    const total = lps * count;
    const printed = (s.printed || []).length, rem = total - printed;
    const pct = rem / total;
    const isActive = id === activeSheetId;
    const assigned = getAssignedCount(s);
    const r = 18, c = 2 * Math.PI * r;
    const strokePct = rem / total;
    const color = pct === 0 ? 'var(--danger)' : pct <= 0.2 ? 'var(--warning-text)' : 'var(--success-text)';
    const textCount = s.texts ? Object.keys(s.texts).length : 0;

    // Build detail line: "5160" vs "5160 · 3 sheets · 90 labels"
    const detailParts = ['<strong>' + spec.name.split(' /')[0] + '</strong>'];
    if (count > 1) {
      detailParts.push(count + ' sheets');
      detailParts.push(total + ' labels');
    } else {
      detailParts.push(spec.desc);
      detailParts.push(spec.sizeDisplay);
    }

    return '<div class="sheet-card' + (isActive ? ' active' : '') + '" onclick="selectSheet(\'' + id + '\')">' +
      '<div class="sheet-card-info">' +
        '<div class="sheet-card-name">' + escapeHtml(s.name) + '</div>' +
        '<div class="sheet-card-detail">' + detailParts.join(' · ') + '</div>' +
        (textCount ? '<div class="sheet-card-detail">' + textCount + ' text' + (textCount!==1?'s':'') + (assigned ? ' · ' + assigned + ' queued' : '') + '</div>' : '') +
        (function() { const inv = getInventoryForType(s.labelType); if (!inv) return ''; const sum = getInventorySummary(s.labelType); const isLow = sum.isLow && sum.stock > 0; const isEmpty = sum.stock === 0; return '<div class="sheet-stock-indicator' + (isLow || isEmpty ? ' low' : '') + '">' + (isEmpty ? '⚠ ' + LABEL_TYPES[s.labelType].name.split(' /')[0] + ': out of stock' : (isLow ? '⚠ ' : '') + LABEL_TYPES[s.labelType].name.split(' /')[0] + ': ' + sum.stock + ' in stock') + '</div>'; })() +
      '</div>' +
      '<div class="sheet-card-progress">' +
        '<svg width="48" height="48" viewBox="0 0 48 48">' +
          '<circle cx="24" cy="24" r="' + r + '" fill="none" stroke="var(--border)" stroke-width="4"/>' +
          '<circle cx="24" cy="24" r="' + r + '" fill="none" stroke="' + color + '" stroke-width="4" stroke-dasharray="' + c + '" stroke-dashoffset="' + (c * (1 - strokePct)) + '" stroke-linecap="round"/>' +
        '</svg>' +
        '<span class="progress-text">' + rem + '/' + total + '</span>' +
      '</div>' +
      '<div class="sheet-card-actions">' +
        '<button class="sheet-card-action" onclick="event.stopPropagation();renameSheet(\'' + id + '\')" title="Rename">✏️</button>' +
        (printed > 0 ? '<button class="sheet-card-action" onclick="event.stopPropagation();resetSheet(\'' + id + '\')" title="Reset all labels">🔄</button>' : '') +
        '<button class="sheet-card-action danger" onclick="event.stopPropagation();deleteSheet(\'' + id + '\')" title="Delete">🗑️</button>' +
      '</div>' +
    '</div>';
  }).join('');

  container.innerHTML += '<button class="new-sheet-card" onclick="showNewSheetModal()">+ New Sheet</button>';
}

function selectSheet(id) {
  if (!sheets[id]) return;
  activeSheetId = id;
  currentMapPage = 0;
  saveSheets();
  buildSheetCards();
  buildSheetDetail();
  buildAssignedTexts();
  updateTabMeta();
}

function buildSheetDetail() {
  const area = document.getElementById('sheetDetailArea');
  if (!activeSheetId) {
    area.innerHTML = '<div class="no-sheet-selected"><span class="icon">👈</span>Select a sheet to see its detail</div>';
    return;
  }
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const count = sh.sheetCount || 1;
  const lps = spec.cols * spec.rows;
  const { assignments, errors } = buildAssignments(sh);
  const totalLabels = Object.values(assignments).reduce((s, arr) => s + arr.length, 0);
  const hasErrors = errors.length > 0;

  // Clamp currentMapPage
  if (currentMapPage >= count) currentMapPage = count - 1;
  if (currentMapPage < 0) currentMapPage = 0;

  // Build paginated map for the current page
  const mapHtml = buildSheetMapHtml(sh, assignments, currentMapPage);

  // Build feed instructions for multi-sheet print
  let feedHtml = '';
  if (totalLabels > 0 && count > 1) {
    const pages = buildPrintPages(assignments, sh);
    if (pages.length > 0) {
      feedHtml = '<div class="feed-instructions">';
      pages.forEach((pg, pi) => {
        feedHtml += '<div class="feed-page"><span class="feed-page-num">Page ' + (pi + 1) + ' →</span> Feed your <span class="feed-sheet-name">' + escapeHtml(sh.name) + ' #' + (pg.physicalSheet + 1) + '</span> <span class="feed-count">(' + pg.count + ' label' + (pg.count !== 1 ? 's' : '') + ')</span></div>';
      });
      feedHtml += '</div>';
    }
  }

  // Print button
  let printHtml = '';
  if (totalLabels > 0) {
    const pageCount = count > 1 ? buildPrintPages(assignments, sh).length : 1;
    const pageLabel = pageCount > 1 ? ' (' + pageCount + ' pages)' : '';
    printHtml = '<div class="sheet-print-actions">' +
      '<button class="btn btn-primary btn-full" onclick="printLabels()"' + (hasErrors ? ' disabled' : '') + '>🖨️ Print ' + totalLabels + ' Label' + (totalLabels !== 1 ? 's' : '') + pageLabel + '</button>' +
      '<div style="margin-top:8px;font-size:12px;color:var(--text-faint);line-height:1.5">Set margins to <strong style="color:var(--text-muted)">None</strong> and uncheck <strong style="color:var(--text-muted)">Print headers and footers</strong></div>';
    // Inventory stock note
    const invPrint = getInventoryForType(sh.labelType);
    if (invPrint) {
      const sumPrint = getInventorySummary(sh.labelType);
      if (sumPrint.isLow || sumPrint.stock === 0) {
        const stockMsg = sumPrint.stock === 0 ? '⚠️ No ' + LABEL_TYPES[sh.labelType].name.split(' /')[0] + ' sheets in stock' : '⚠️ ' + LABEL_TYPES[sh.labelType].name.split(' /')[0] + ': ' + sumPrint.stock + ' sheet' + (sumPrint.stock !== 1 ? 's' : '') + ' remaining in stock';
        printHtml += '<div style="margin-top:6px;font-size:12px;color:var(--warning-text);font-weight:500">' + stockMsg + '</div>';
      }
    }
    if (hasErrors) {
      printHtml += '<div class="sheet-print-error">⚠️ Cannot print — ';
      printHtml += errors.map(e => {
        const st = getSavedText(e.textId);
        return '"' + escapeHtml(st ? st.name : '?') + '": ' + e.message;
      }).join('; ');
      printHtml += '</div>';
    }
    printHtml += feedHtml;
    printHtml += '</div>';
  }

  // Sheet count stepper (in detail view)
  let sheetCountHtml = '';
  if (count > 1 || true) { // always show for adjustability
    sheetCountHtml = '<div style="display:flex;align-items:center;gap:6px;margin-top:6px">' +
      '<span style="font-size:12px;font-weight:600;color:var(--text-muted)">Sheets:</span>' +
      '<div class="detail-sheet-count">' +
        '<button class="qty-btn" onclick="adjustDetailSheetCount(-1)">−</button>' +
        '<span class="qty-val">' + count + '</span>' +
        '<button class="qty-btn" onclick="adjustDetailSheetCount(1)">+</button>' +
      '</div>' +
      '<span style="font-size:12px;color:var(--text-faint);font-family:var(--mono)">' + getPoolSize(sh) + ' labels</span>' +
    '</div>';
  }

  // Pagination controls
  let paginationHtml = '';
  if (count > 1) {
    paginationHtml = '<div class="grid-pagination">' +
      '<button class="grid-page-btn" onclick="changeMapPage(-1)"' + (currentMapPage <= 0 ? ' disabled' : '') + '>◀</button>' +
      '<span class="grid-page-label">Sheet ' + (currentMapPage + 1) + ' of ' + count + '</span>' +
      '<button class="grid-page-btn" onclick="changeMapPage(1)"' + (currentMapPage >= count - 1 ? ' disabled' : '') + '>▶</button>' +
    '</div>';
  }

  // Split remaining button
  const printed = (sh.printed || []).length;
  const poolSize = getPoolSize(sh);
  const remaining = poolSize - printed;
  let splitHtml = '';
  if (printed > 0 && remaining > 0) {
    // Count physical sheets with open spots
    const sheetsWithOpen = [];
    for (let p = 0; p < count; p++) {
      let hasOpen = false;
      for (let i = p * lps; i < (p + 1) * lps; i++) {
        if (!(sh.printed || []).includes(i)) { hasOpen = true; break; }
      }
      if (hasOpen) sheetsWithOpen.push(p);
    }
    if (sheetsWithOpen.length > 0) {
      splitHtml = '<div class="split-section">' +
        '<button class="btn btn-secondary btn-sm" onclick="showSplitDialog()" style="font-size:13px">✂️ Split Remaining (' + remaining + ' label' + (remaining !== 1 ? 's' : '') + ')</button>' +
      '</div>';
    }
  }

  area.innerHTML = printHtml +
  '<div class="sheet-map-container">' +
    '<div class="sheet-map-header">' +
      '<span>' + escapeHtml(sh.name) + '</span>' +
      '<span style="font-family:var(--mono);font-size:13px;color:var(--text-muted)">Avery ' + sh.labelType + ' · ' + spec.layoutDisplay + '</span>' +
    '</div>' +
    '<div class="sheet-map-sub" style="font-size:13px">' + spec.desc + ' · ' + spec.sizeDisplay + '</div>' +
    sheetCountHtml +
    paginationHtml +
    mapHtml +
    buildRemainingBar(sh) +
    buildLegendHtml(true) +
    (lastPrintJob && lastPrintJob.sheetId === activeSheetId ? '<button class="btn btn-secondary btn-sm" onclick="undoLastPrint()" style="margin-top:12px;font-size:13px">↩️ Undo Last Print (' + lastPrintJob.indices.length + ' label' + (lastPrintJob.indices.length !== 1 ? 's' : '') + ')</button>' : '') +
    splitHtml +
  '</div>';
}

function changeMapPage(delta) {
  const sh = getActiveSheet();
  const count = sh.sheetCount || 1;
  currentMapPage = Math.max(0, Math.min(count - 1, currentMapPage + delta));
  buildSheetDetail();
}

function adjustDetailSheetCount(delta) {
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const lps = spec.cols * spec.rows;
  const currentCount = sh.sheetCount || 1;
  const newCount = currentCount + delta;

  if (newCount < 1) return;

  // Decreasing: check if last physical sheet has data
  if (delta < 0) {
    const lastSheetStart = (currentCount - 1) * lps;
    const lastSheetEnd = currentCount * lps;
    const printed = new Set(sh.printed || []);
    const { assignments } = buildAssignments(sh);
    const allAssigned = new Set();
    Object.values(assignments).forEach(arr => arr.forEach(i => allAssigned.add(i)));

    let hasData = false;
    for (let i = lastSheetStart; i < lastSheetEnd; i++) {
      if (printed.has(i) || allAssigned.has(i)) { hasData = true; break; }
    }
    if (hasData) {
      showAlert('Sheet ' + currentCount + ' has labels in use — remove assignments or reset first.', { title: '⚠️ Cannot Reduce' });
      return;
    }
  }

  sh.sheetCount = newCount;
  if (currentMapPage >= newCount) currentMapPage = newCount - 1;

  // Inventory: adjust stock for count changes
  if (inventory[sh.labelType]) {
    if (delta > 0) {
      // Increasing: deduct from stock
      inventory[sh.labelType].stock = Math.max(0, inventory[sh.labelType].stock - delta);
      addInventoryHistory(sh.labelType, { type: 'create', delta: -delta, note: 'Added ' + delta + ' sheet' + (delta !== 1 ? 's' : '') + ' to ' + sh.name, sheetId: activeSheetId });
    } else {
      // Decreasing: return to stock
      const returned = Math.abs(delta);
      inventory[sh.labelType].stock += returned;
      addInventoryHistory(sh.labelType, { type: 'adjust', delta: returned, note: 'Returned ' + returned + ' sheet' + (returned !== 1 ? 's' : '') + ' from ' + sh.name });
    }
  }

  saveSheets();
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
}

function buildPrintPages(assignmentsObj, sh) {
  sh = sh || getActiveSheet();
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const allIndices = new Set();
  Object.values(assignmentsObj).forEach(arr => arr.forEach(i => allIndices.add(i)));

  const pages = [];
  const count = sh.sheetCount || 1;
  for (let p = 0; p < count; p++) {
    let pageCount = 0;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (allIndices.has(i)) pageCount++;
    }
    if (pageCount > 0) {
      pages.push({ physicalSheet: p, count: pageCount });
    }
  }
  return pages;
}

function buildAssignedTexts() {
  const area = document.getElementById('sheetAssignedArea');
  if (!activeSheetId) { area.innerHTML = ''; return; }
  const sh = getActiveSheet();
  area.innerHTML = buildAssignedTextsHtml(sh);
}

function buildAssignedTextsHtml(sh) {
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  const { assignments, errors } = buildAssignments(sh);
  const avail = getAvailableSpots(sh);
  const spec = getSpec(sh.labelType);
  const errorMap = {};
  errors.forEach(e => { errorMap[e.textId] = e.message; });

  let html = '<div class="assigned-texts-section">' +
    '<div class="assigned-texts-header">' +
      '<span class="assigned-texts-title">Assigned Texts</span>' +
      '<button class="btn btn-primary btn-sm" onclick="showAddTextPicker()">+ Add Text</button>' +
    '</div>' +
    '<div class="assigned-texts-list">';

  if (!textIds.length) {
    html += '<div class="assigned-texts-empty">🏷️ No texts assigned yet. Click "Add Text" or go to the Texts tab to create one.</div>';
  } else {
    textIds.forEach((textId, idx) => {
      const st = getSavedText(textId);
      if (!st) return;
      const entry = sh.texts[textId];
      const qty = entry.qty || 0;
      const placement = entry.placement || 'next';
      const colorIdx = idx % TEXT_COLORS.length;
      const lines = deserializeLines(st.text);
      const previewHtml = renderMiniPreview(lines, false, st.graphics);
      const posCount = assignments[textId] ? assignments[textId].length : 0;
      const hasError = errorMap[textId];
      const fitWarning = getFitWarning(st.text, st.alignV, sh.labelType, st.graphics);

      // Build placement options
      let placementHtml = '<select class="assigned-text-placement" onchange="setTextPlacement(\'' + textId + '\', this.value)">';
      placementHtml += '<option value="next"' + (placement === 'next' ? ' selected' : '') + '>Next Avail</option>';
      for (let c = 1; c <= spec.cols; c++) {
        const val = 'col:' + c;
        placementHtml += '<option value="' + val + '"' + (placement === val ? ' selected' : '') + '>Col ' + c + '</option>';
      }
      placementHtml += '</select>';

      let spotsHtml;
      if (hasError) spotsHtml = '⚠️ ' + escapeHtml(hasError);
      else if (fitWarning) spotsHtml = '<span style="color:var(--warning-text)">' + escapeHtml(fitWarning) + '</span>';
      else spotsHtml = posCount + ' position' + (posCount!==1?'s':'') + ' assigned';

      // Template label type advisory
      let templateNoticeHtml = '';
      if (st.fromTemplateLabel && st.fromTemplateLabel !== sh.labelType) {
        const tplSpec = getSpec(st.fromTemplateLabel);
        templateNoticeHtml = '<div class="template-label-mismatch"><span class="notice-icon">ℹ️</span>Designed for Avery ' + st.fromTemplateLabel + ' (' + tplSpec.desc + ')</div>';
      }

      html += '<div class="assigned-text-row' + (hasError ? ' has-error' : '') + '" ondblclick="editTextFromSheet(\'' + textId + '\', event)" title="Double-click to edit">' +
        '<div class="assigned-text-color" style="background:' + TEXT_COLORS[colorIdx] + '"></div>' +
        '<div class="assigned-text-preview">' + previewHtml + '</div>' +
        '<div class="assigned-text-info">' +
          '<div class="assigned-text-name">' + escapeHtml(st.name) + '</div>' +
          '<div class="assigned-text-spots">' + spotsHtml + '</div>' +
          templateNoticeHtml +
        '</div>' +
        '<div class="assigned-text-controls">' +
          placementHtml +
          '<div class="assigned-text-qty">' +
            '<button class="qty-btn" onclick="adjustAssignedQty(\'' + textId + '\', -1)">−</button>' +
            '<span class="qty-val">' + qty + '</span>' +
            '<button class="qty-btn" onclick="adjustAssignedQty(\'' + textId + '\', 1)">+</button>' +
          '</div>' +
        '</div>' +
        '<button class="assigned-text-remove" onclick="removeTextFromSheet(\'' + textId + '\')" title="Remove">✕</button>' +
      '</div>';
    });
  }

  html += '</div>';
  if (avail > 0) {
    html += '<div style="margin-top:8px;font-size:13px;color:var(--text-muted);font-weight:600">' + avail + ' spot' + (avail!==1?'s':'') + ' still available</div>';
  }
  html += '</div>';
  return html;
}

function setTextPlacement(textId, value) {
  const sh = getActiveSheet();
  if (!sh.texts || !sh.texts[textId]) return;
  sh.texts[textId].placement = value;
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
}

function adjustAssignedQty(textId, delta) {
  const sh = getActiveSheet();
  if (!sh.texts || !sh.texts[textId]) return;
  const current = sh.texts[textId].qty || 0;
  const maxAdd = getAvailableSpots(sh);
  let newQty = current + delta;
  if (newQty < 0) newQty = 0;
  if (delta > 0 && maxAdd <= 0) return; // no room
  if (newQty > current + maxAdd) newQty = current + maxAdd;
  sh.texts[textId].qty = newQty;
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

async function removeTextFromSheet(textId) {
  const sh = getActiveSheet();
  const st = getSavedText(textId);
  const name = st ? st.name : 'this text';
  const ok = await showConfirm('Remove "' + name + '" from this sheet?', { title: 'Remove Text', okText: 'Remove', danger: true });
  if (!ok) return;
  if (sh.texts) delete sh.texts[textId];
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

function showAddTextPicker() {
  const sh = getActiveSheet();
  const existingIds = new Set(sh.texts ? Object.keys(sh.texts) : []);
  const texts = getTexts(); // Only regular texts, not templates
  const available = texts.filter(st => !existingIds.has(st.id));

  if (!texts.length) {
    showAlert('No saved texts yet. Go to the Texts tab to create one first.', { title: 'No Texts Available' });
    return;
  }
  if (!available.length) {
    showAlert('All saved texts are already assigned to this sheet.', { title: 'All Assigned' });
    return;
  }

  const modal = document.getElementById('addTextModal');
  document.getElementById('addTextModalTitle').textContent = '🏷️ Add Text to "' + sh.name + '"';
  document.getElementById('addTextModalMsg').textContent = 'Choose a text to assign:';

  const list = document.getElementById('addTextPickerList');
  list.innerHTML = available.sort((a,b) => a.name.localeCompare(b.name)).map(st => {
    const lines = deserializeLines(st.text);
    const previewHtml = renderMiniPreview(lines, false, st.graphics);
    return '<div class="saved-text-card" onclick="pickTextForSheet(\'' + st.id + '\')" style="cursor:pointer">' +
      '<div class="saved-text-card-header"><span class="saved-text-card-name">' + escapeHtml(st.name) + '</span></div>' +
      '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
    '</div>';
  }).join('');

  modal.classList.add('visible');
}

function pickTextForSheet(textId) {
  const sh = getActiveSheet();
  if (!sh.texts) sh.texts = {};
  sh.texts[textId] = { qty: 0, placement: 'next' };
  saveSheets();
  closeModal('addTextModal');
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

// ========== SHEET MAP RENDERING ==========
function buildSheetMapHtml(sh, assignmentsObj, page) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const poolSize = lps * count;
  const printed = new Set(sh.printed || []);
  const assignments = assignmentsObj || buildAssignments(sh).assignments;

  // If page is undefined, default to 0 (first physical sheet)
  if (page === undefined) page = 0;

  // Build reverse map: index -> { textId, colorIdx }
  const indexMap = {};
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  textIds.forEach((textId, colorIdx) => {
    const indices = assignments[textId] || [];
    indices.forEach(idx => { indexMap[idx] = { textId, colorIdx: colorIdx % TEXT_COLORS.length }; });
  });

  // Calculate the range of pool indices for this page
  const pageStart = page * lps;
  const pageEnd = pageStart + lps;

  const gridStyle = 'grid-template-columns: repeat(' + spec.cols + ', 1fr)';
  const cellFont = poolSize > 40 ? 7 : poolSize > 20 ? 8 : 9;
  const numFont = poolSize > 40 ? 6 : 7;
  const showNum = lps <= 80;

  let gridHtml = '<div class="label-grid" style="' + gridStyle + '">';
  for (let i = pageStart; i < pageEnd; i++) {
    const isPrinted = printed.has(i);
    const assignment = indexMap[i];
    let cls = 'label-cell';
    if (isPrinted) cls += ' printed';
    else if (assignment) cls += ' cell-color-' + assignment.colorIdx;

    const ar = 'aspect-ratio: ' + spec.labelW + ' / ' + spec.labelH;
    const clickAttr = isPrinted ? ' onclick="toggleCellPrinted(' + i + ')" title="Click to mark as available"' : '';
    let inner = showNum ? '<span class="label-number" style="font-size:' + numFont + 'px">' + (i+1) + '</span>' : '';
    if (isPrinted) {
      inner += '<span class="printed-badge" style="font-size:' + numFont + 'px">✓</span>';
    } else if (assignment) {
      const st = getSavedText(assignment.textId);
      if (st) {
        const lines = deserializeLines(st.text);
        inner += '<span class="label-text" style="font-size:' + cellFont + 'px">' + escapeHtml(getFlatText(lines).substring(0, 20)) + '</span>';
      }
    } else if (lps <= 30) {
      inner += '<span class="empty-state">avail</span>';
    }
    gridHtml += '<div class="' + cls + '" style="font-size:' + cellFont + 'px;' + ar + '"' + clickAttr + '>' + inner + '</div>';
  }
  gridHtml += '</div>';
  return gridHtml;
}

function buildRemainingBar(sh) {
  const total = getTotal(sh), printed = getPrinted(sh).length;
  const rem = total - printed;
  const pct = rem / total;
  const bannerClass = rem === 0 ? 'empty' : pct <= 0.2 ? 'low' : 'plenty';
  const assigned = getAssignedCount(sh);
  const unassigned = rem - assigned;

  return '<div class="remaining-bar ' + bannerClass + '">' +
    '<span class="count">' + rem + '</span> label' + (rem!==1?'s':'') + ' remaining' +
    (assigned > 0 ? ' <span style="font-size:12px;font-weight:500;opacity:0.8">(' + assigned + ' assigned, ' + Math.max(0,unassigned) + ' open)</span>' : '') +
  '</div>';
}

function buildLegendHtml(showAssigned) {
  let html = '<div class="legend">' +
    '<div class="legend-item"><div class="legend-swatch available"></div> Available</div>';
  if (showAssigned) {
    html += '<div class="legend-item"><div class="legend-swatch" style="background:' + TEXT_COLORS[0] + ';border-color:' + TEXT_COLORS[0] + '"></div> Assigned</div>';
  }
  html += '<div class="legend-item"><div class="legend-swatch printed"></div> Used</div></div>';
  return html;
}

// ========== CELL & SHEET RESET ==========
function toggleCellPrinted(idx) {
  const sh = getActiveSheet();
  if (!sh.printed) return;
  const pos = sh.printed.indexOf(idx);
  if (pos === -1) return; // not printed, nothing to do
  sh.printed.splice(pos, 1);
  saveSheets();
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
}

async function resetSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const printedCount = (sh.printed || []).length;
  if (printedCount === 0) {
    showAlert('No used labels to reset on "' + sh.name + '".', { title: 'Nothing to Reset' });
    return;
  }
  const count = sh.sheetCount || 1;
  const poolSize = getPoolSize(sh);
  const countLabel = count > 1 ? 'Reset all ' + count + ' sheets (' + poolSize + ' positions)' : 'Reset "' + sh.name + '" to all labels available';
  const ok = await showConfirm(
    countLabel + '? This will unmark ' + printedCount + ' used position' + (printedCount !== 1 ? 's' : '') + ' and set all quantities to 0.\n\nThis is useful when you replace the physical sheet' + (count > 1 ? 's' : '') + ' with fresh one' + (count > 1 ? 's' : '') + '.',
    { title: '🔄 Reset Sheet', okText: 'Reset All', danger: true }
  );
  if (!ok) return;
  sh.printed = [];
  if (sh.texts) {
    for (const entry of Object.values(sh.texts)) { entry.qty = 0; }
  }
  saveSheets();
  lastPrintJob = null;
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  setStatus('"' + sh.name + '" reset — all ' + poolSize + ' labels available', 'success');
}

// ========== SHEET MANAGEMENT ==========
function showNewSheetModal() {
  newSheetLabelType = '5160';
  newSheetCount = 1;
  document.getElementById('newSheetName').value = '';
  buildLabelTypeGrid();
  updateNewSheetCapacity();
  const modal = document.getElementById('newSheetModal');
  const title = document.getElementById('newSheetModalTitle');
  const cancelBtn = document.getElementById('newSheetCancelBtn');
  if (firstRunRequired) { title.textContent = '👋 Welcome — Create Your First Sheet'; cancelBtn.style.display = 'none'; }
  else { title.textContent = '📄 New Label Sheet'; cancelBtn.style.display = ''; }
  modal.classList.add('visible');
  document.getElementById('newSheetName').focus();
}

function stepNewSheetCount(delta) {
  newSheetCount = Math.max(1, newSheetCount + delta);
  document.getElementById('newSheetCountVal').textContent = newSheetCount;
  updateNewSheetCapacity();
}

function updateNewSheetCapacity() {
  const spec = getSpec(newSheetLabelType);
  const lps = spec.cols * spec.rows;
  const total = lps * newSheetCount;
  document.getElementById('newSheetCountVal').textContent = newSheetCount;
  const el = document.getElementById('newSheetCapacity');
  let capText = '';
  if (newSheetCount > 1) {
    capText = total + ' labels total';
  } else {
    capText = lps + ' labels/sheet';
  }
  // Show inventory stock info
  const inv = getInventoryForType(newSheetLabelType);
  if (inv) {
    const sum = getInventorySummary(newSheetLabelType);
    capText += ' · ' + sum.stock + ' in stock';
    if (newSheetCount > sum.stock) {
      capText += ' ⚠️';
    }
  }
  el.textContent = capText;
}

function buildLabelTypeGrid() {
  const grid = document.getElementById('labelTypeGrid');
  grid.innerHTML = TYPE_ORDER.map(typeId => {
    const t = LABEL_TYPES[typeId], total = t.cols * t.rows;
    const sel = typeId === newSheetLabelType ? ' selected' : '';
    const miniCols = Math.min(t.cols, 4), miniRows = Math.min(t.rows, 5);
    const cellW = Math.max(4, Math.round(20 * t.labelW / Math.max(t.labelW, t.labelH)));
    const cellH = Math.max(3, Math.round(20 * t.labelH / Math.max(t.labelW, t.labelH)));
    let miniHtml = '<div class="ltc-mini-grid" style="grid-template-columns:repeat(' + miniCols + ',' + cellW + 'px)">';
    for (let i = 0; i < miniCols * miniRows; i++) miniHtml += '<div class="ltc-mini-cell" style="width:' + cellW + 'px;height:' + cellH + 'px"></div>';
    miniHtml += '</div>';
    if (t.rows > 5) miniHtml += '<div style="font-size:9px;color:var(--text-faint);margin-top:1px">+' + (t.rows-5) + ' more rows</div>';
    return '<div class="label-type-card' + sel + '" onclick="selectLabelType(\'' + typeId + '\')" data-type="' + typeId + '">' +
      '<div class="ltc-header"><span class="ltc-name">' + typeId + '</span><span class="ltc-count">' + total + '/sheet</span></div>' +
      '<div class="ltc-desc">' + t.desc + '</div>' +
      '<div class="ltc-dims">' + t.sizeDisplay + ' — ' + t.layoutDisplay + '</div>' + miniHtml + '</div>';
  }).join('');
}

function selectLabelType(typeId) {
  newSheetLabelType = typeId;
  document.querySelectorAll('.label-type-card').forEach(c => c.classList.toggle('selected', c.dataset.type === typeId));
  updateNewSheetCapacity();
}

async function createNewSheet() {
  const name = document.getElementById('newSheetName').value.trim();
  if (!name) { document.getElementById('newSheetName').style.borderColor = 'var(--danger)'; return; }
  const id = generateId();
  sheets[id] = { name, printed: [], labelType: newSheetLabelType, sheetCount: newSheetCount, texts: {}, createdAt: Date.now() };
  activeSheetId = id; currentMapPage = 0; saveSheets();

  // Deduct from inventory
  if (inventory[newSheetLabelType]) {
    recordInventoryCreate(newSheetLabelType, newSheetCount, id, name);
  }

  firstRunRequired = false;
  closeModal('newSheetModal');
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  if (newSheetCount > 1) {
    const labels = Array.from({ length: newSheetCount }, (_, i) => '"' + name + ' #' + (i+1) + '"').join(', ');
    await showAlert('Mark your physical sheets: write ' + labels + ' on the back of each sheet.', { title: '📝 Label Your Sheets' });
  }
}

async function renameSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const n = await showPrompt('Enter new name:', sh.name, { title: '✏️ Rename Sheet', placeholder: 'Sheet name', maxLength: 40 });
  if (n && n.trim()) { sh.name = n.trim(); saveSheets(); buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta(); }
}

async function deleteSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const isLast = Object.keys(sheets).length <= 1;
  const count = sh.sheetCount || 1;
  const poolInfo = count > 1 ? ' (' + count + ' sheets, ' + getPoolSize(sh) + ' positions)' : '';
  const msg = isLast ? 'Delete "' + sh.name + '"' + poolInfo + '? This is your only sheet.' : 'Delete "' + sh.name + '"' + poolInfo + '?';
  const ok = await showConfirm(msg, { title: '🗑️ Delete Sheet', okText: 'Delete', danger: true });
  if (!ok) return;
  // Return unused sheets to inventory
  if (inventory[sh.labelType]) {
    const returnable = countReturnableSheets(sh);
    if (returnable > 0) {
      returnInventoryStock(sh.labelType, returnable, 'Returned ' + returnable + ' sheet' + (returnable !== 1 ? 's' : '') + ' — Deleted sheet: ' + sh.name);
    }
  }
  delete sheets[id];
  if (Object.keys(sheets).length) {
    if (activeSheetId === id) { activeSheetId = Object.keys(sheets)[0]; currentMapPage = 0; }
    saveSheets(); buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  } else {
    activeSheetId = null; currentMapPage = 0; saveSheets();
    firstRunRequired = true; buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
    showNewSheetModal();
  }
}

function closeModal(id) {
  if (id === 'newSheetModal' && firstRunRequired) return;
  document.getElementById(id).classList.remove('visible');
}

// ========== UI UPDATES ==========
function setStatus(msg, type) {
  const el = document.getElementById('statusMsg');
  // Support HTML in status messages (for undo buttons)
  if (msg.includes('<')) el.innerHTML = msg;
  else el.textContent = msg;
  el.className = 'status-msg' + (type ? ' ' + type : '');
}

// ========== LABEL INVENTORY (v1.9.0) ==========
function loadInventory() {
  try { const s = localStorage.getItem(INVENTORY_KEY); if (s) inventory = JSON.parse(s); } catch(e) {}
}
function saveInventory() {
  try { localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory)); } catch(e) {}
}
function getInventoryForType(labelType) { return inventory[labelType] || null; }

function getInventorySummary(labelType) {
  const inv = inventory[labelType];
  const spec = LABEL_TYPES[labelType];
  if (!spec) return null;
  const lps = spec.cols * spec.rows;
  const stock = inv ? inv.stock : 0;

  // Compute active sheet stats from existing sheet data
  let activeSheets = 0, partialSheets = 0, partialLabels = 0, fullyConsumed = 0;
  for (const sh of Object.values(sheets)) {
    if (sh.labelType !== labelType) continue;
    const count = sh.sheetCount || 1;
    const printed = new Set(sh.printed || []);
    for (let p = 0; p < count; p++) {
      activeSheets++;
      let open = 0;
      for (let i = p * lps; i < (p + 1) * lps; i++) {
        if (!printed.has(i)) open++;
      }
      if (open > 0) { partialSheets++; partialLabels += open; }
      else { fullyConsumed++; }
    }
  }

  return {
    stock, lps,
    stockLabels: stock * lps,
    activeSheets, partialSheets, partialLabels, fullyConsumed,
    totalSheets: stock + partialSheets,
    totalLabels: (stock * lps) + partialLabels,
    isLow: inv ? stock <= inv.lowThreshold : false,
    lowThreshold: inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
}

function addInventoryHistory(labelType, entry) {
  if (!inventory[labelType]) return;
  entry.date = Date.now();
  entry.balance = inventory[labelType].stock;
  inventory[labelType].history.push(entry);
  saveInventory();
}

function addInventoryStock(labelType, qty, note) {
  if (!inventory[labelType]) return;
  inventory[labelType].stock += qty;
  addInventoryHistory(labelType, { type: 'add', delta: qty, note: note || 'Added stock' });
}

function adjustInventoryStock(labelType, delta, note) {
  if (!inventory[labelType]) return;
  inventory[labelType].stock = Math.max(0, inventory[labelType].stock + delta);
  addInventoryHistory(labelType, { type: 'adjust', delta, note: note || 'Manual adjustment' });
}

function recordInventoryCreate(labelType, sheetCount, sheetId, sheetName) {
  if (!inventory[labelType]) return;
  inventory[labelType].stock = Math.max(0, inventory[labelType].stock - sheetCount);
  addInventoryHistory(labelType, {
    type: 'create', delta: -sheetCount,
    note: 'Created sheet: ' + sheetName + ' (' + sheetCount + ' sheet' + (sheetCount !== 1 ? 's' : '') + ')',
    sheetId
  });
}

function recordInventoryPrint(labelType, labels, sheetsUsed, sheetsConsumed, sheetId, sheetName) {
  if (!inventory[labelType]) return;
  // Stock does not change on print — sheets already moved from stock on creation
  addInventoryHistory(labelType, {
    type: 'print', delta: 0, labels, sheetsUsed, sheetsConsumed,
    sheetName, sheetId,
    note: 'Printed ' + labels + ' label' + (labels !== 1 ? 's' : '') + ' on ' + sheetName
  });
}

function removeLastInventoryPrint(labelType, sheetId) {
  if (!inventory[labelType]) return;
  const hist = inventory[labelType].history;
  // Find the last print entry for this sheet
  for (let i = hist.length - 1; i >= 0; i--) {
    if (hist[i].type === 'print' && hist[i].sheetId === sheetId) {
      hist.splice(i, 1);
      saveInventory();
      return;
    }
  }
}

function returnInventoryStock(labelType, count, reason) {
  if (!inventory[labelType] || count <= 0) return;
  inventory[labelType].stock += count;
  addInventoryHistory(labelType, { type: 'adjust', delta: count, note: reason });
}

// ── Inventory UI ──
function showInventoryPanel() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  inventoryView = 'list';
  inventoryDetailType = null;
  renderInventoryContent();
  document.getElementById('inventoryModal').classList.add('visible');
}

function renderInventoryContent() {
  const el = document.getElementById('inventoryContent');
  if (inventoryView === 'history' && inventoryDetailType) {
    renderInventoryHistory(el);
  } else {
    renderInventoryList(el);
  }
}

function renderInventoryList(el) {
  const trackedTypes = Object.keys(inventory).sort((a, b) => {
    const ia = TYPE_ORDER.indexOf(a), ib = TYPE_ORDER.indexOf(b);
    return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
  });

  let html = '<div class="inventory-header"><h3>📦 Label Inventory</h3>' +
    '<button class="btn btn-secondary btn-sm" onclick="closeModal(\'inventoryModal\')">Close</button></div>';

  if (!trackedTypes.length) {
    html += '<div class="inventory-empty"><span class="icon">📦</span>No label types tracked yet.<br>Track your label supply to see stock levels, consumption history, and low-stock alerts.</div>';
  } else {
    trackedTypes.forEach(typeId => {
      const spec = LABEL_TYPES[typeId];
      if (!spec) return;
      const sum = getInventorySummary(typeId);
      const isLow = sum.isLow && sum.stock > 0;
      const isEmpty = sum.stock === 0;

      html += '<div class="inventory-card' + (isLow ? ' low-stock' : '') + '">' +
        '<div class="inventory-card-header">' +
          '<span class="inventory-card-type">' + spec.name + '</span>' +
          '<div style="display:flex;align-items:center;gap:6px">' +
            (isLow ? '<span class="inventory-badge">⚠ Low Stock</span>' : '') +
            (isEmpty ? '<span class="inventory-badge" style="color:var(--error-text);background:var(--error-bg);border-color:var(--error-border)">Out of Stock</span>' : '') +
            '<button class="inv-delete-btn" onclick="deleteInventoryType(\'' + typeId + '\')" title="Stop tracking">✕</button>' +
          '</div>' +
        '</div>' +
        '<div class="inventory-card-desc">' + spec.desc + ' · ' + spec.sizeDisplay + ' · ' + (spec.cols * spec.rows) + '/sheet</div>' +
        '<div class="inventory-card-stats">' +
          'Stock: <strong>' + sum.stock + '</strong> sheet' + (sum.stock !== 1 ? 's' : '') + ' <span style="color:var(--text-faint)">(' + sum.stockLabels + ' labels)</span><br>' +
          (sum.activeSheets > 0 ? 'Active: <strong>' + sum.activeSheets + '</strong> sheet' + (sum.activeSheets !== 1 ? 's' : '') + ' in use' + (sum.partialSheets > 0 && sum.fullyConsumed > 0 ? ' <span style="color:var(--text-faint)">(' + sum.partialSheets + ' partial, ' + sum.fullyConsumed + ' fully printed)</span>' : (sum.fullyConsumed > 0 ? ' <span style="color:var(--text-faint)">(' + sum.fullyConsumed + ' fully printed)</span>' : '')) + '<br>' : '') +
          '<span class="inv-total">Total: ' + sum.totalSheets + ' sheet' + (sum.totalSheets !== 1 ? 's' : '') + ' · ' + sum.totalLabels + ' labels available</span>' +
        '</div>' +
        '<div class="inventory-card-btns">' +
          '<button class="btn btn-primary btn-sm" onclick="promptAddStock(\'' + typeId + '\')">+ Add Stock</button>' +
          '<button class="btn btn-secondary btn-sm" onclick="promptAdjustStock(\'' + typeId + '\')">Adjust</button>' +
          '<button class="btn btn-secondary btn-sm" onclick="showInventoryHistoryView(\'' + typeId + '\')">History</button>' +
        '</div>' +
      '</div>';
    });
  }

  // "Track new" button — show only types not yet tracked
  const untrackedTypes = TYPE_ORDER.filter(t => !inventory[t]);
  if (untrackedTypes.length) {
    html += '<button class="inventory-new-card" onclick="trackNewLabelType()">+ Track New Label Type</button>';
  }

  el.innerHTML = html;
}

function renderInventoryHistory(el) {
  const typeId = inventoryDetailType;
  const inv = inventory[typeId];
  const spec = LABEL_TYPES[typeId];
  if (!inv || !spec) { inventoryView = 'list'; renderInventoryList(el); return; }
  const sum = getInventorySummary(typeId);

  let html = '<div class="inventory-header">' +
    '<div><button class="inventory-back-btn" onclick="inventoryView=\'list\';renderInventoryContent()">← Back</button></div>' +
    '<button class="btn btn-secondary btn-sm" onclick="closeModal(\'inventoryModal\')">Close</button>' +
  '</div>' +
  '<h3 style="margin-bottom:12px">📦 ' + spec.name + ' — ' + spec.desc + '</h3>';

  // Summary
  html += '<div class="inv-history-summary">' +
    'Stock: <strong>' + sum.stock + '</strong> sheet' + (sum.stock !== 1 ? 's' : '') + ' (' + sum.stockLabels + ' labels)<br>' +
    (sum.activeSheets > 0 ? 'Active: <strong>' + sum.activeSheets + '</strong> sheet' + (sum.activeSheets !== 1 ? 's' : '') + ' in use' + (sum.partialSheets > 0 && sum.fullyConsumed > 0 ? ' (' + sum.partialSheets + ' partial, ' + sum.fullyConsumed + ' fully printed)' : (sum.fullyConsumed > 0 ? ' (' + sum.fullyConsumed + ' fully printed)' : '')) + '<br>' : '') +
    '<span class="inv-total">Total: ' + sum.totalSheets + ' sheet' + (sum.totalSheets !== 1 ? 's' : '') + ' · ' + sum.totalLabels + ' labels available</span>' +
    '<div class="inv-threshold-row">' +
      '<label>Low-stock alert at:</label>' +
      '<input type="number" class="inv-threshold-input" value="' + inv.lowThreshold + '" min="0" max="999" onchange="setLowThreshold(\'' + typeId + '\',parseInt(this.value)||0)">' +
      '<span style="font-size:11px;color:var(--text-faint)">sheets</span>' +
    '</div>' +
  '</div>';

  // History log
  const hist = [...inv.history].reverse();
  html += '<div style="font-size:13px;font-weight:600;color:var(--heading);margin-bottom:8px">History (' + hist.length + ')</div>';
  if (!hist.length) {
    html += '<div class="inv-history-empty">No history yet. Stock changes and print jobs will appear here.</div>';
  } else {
    html += '<div class="inv-history-list">';
    hist.forEach(h => {
      const d = new Date(h.date);
      const dateStr = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ', ' + d.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
      const icon = h.type === 'add' ? '📦' : h.type === 'create' ? '📋' : h.type === 'print' ? '🖨️' : '✏️';
      let deltaStr = '', deltaCls = 'inv-delta-zero';
      if (h.delta > 0) { deltaStr = '+' + h.delta; deltaCls = 'inv-delta-pos'; }
      else if (h.delta < 0) { deltaStr = '' + h.delta; deltaCls = 'inv-delta-neg'; }
      else { deltaStr = '—'; }

      let extraMeta = '';
      if (h.type === 'print' && h.labels) {
        extraMeta = ' · ' + h.labels + ' label' + (h.labels !== 1 ? 's' : '');
      }

      html += '<div class="inv-history-entry">' +
        '<span class="inv-history-icon">' + icon + '</span>' +
        '<div class="inv-history-body">' +
          '<div class="inv-history-note">' + escapeHtml(h.note || '') + '</div>' +
          '<div class="inv-history-meta">' + dateStr + extraMeta + ' · Stock: ' + h.balance + '</div>' +
        '</div>' +
        '<span class="inv-history-delta ' + deltaCls + '">' + deltaStr + '</span>' +
      '</div>';
    });
    html += '</div>';
  }

  el.innerHTML = html;
}

function showInventoryHistoryView(typeId) {
  inventoryView = 'history';
  inventoryDetailType = typeId;
  renderInventoryContent();
}

async function trackNewLabelType() {
  const untrackedTypes = TYPE_ORDER.filter(t => !inventory[t]);
  if (!untrackedTypes.length) { showAlert('All label types are already being tracked.'); return; }

  // Build a picker using the custom dialog as a confirm with HTML
  let pickerHtml = '<div style="margin-bottom:12px">Select an Avery label type to track:</div>' +
    '<div class="label-type-grid" style="max-height:220px">';
  untrackedTypes.forEach(typeId => {
    const t = LABEL_TYPES[typeId], total = t.cols * t.rows;
    pickerHtml += '<div class="label-type-card" onclick="this.parentNode.querySelectorAll(\'.label-type-card\').forEach(c=>c.classList.remove(\'selected\'));this.classList.add(\'selected\');this.dataset.picked=\'1\'" data-type="' + typeId + '">' +
      '<div class="ltc-header"><span class="ltc-name">' + typeId + '</span><span class="ltc-count">' + total + '/sheet</span></div>' +
      '<div class="ltc-desc">' + t.desc + '</div>' +
      '<div class="ltc-dims">' + t.sizeDisplay + '</div>' +
    '</div>';
  });
  pickerHtml += '</div>';

  // Use simple approach: show prompt with type selection via inline script
  // For simplicity, let's use a sequential flow
  const typeId = await new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay visible';
    overlay.style.zIndex = '1100';
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.maxWidth = '480px';
    modal.innerHTML = '<h3>📦 Track New Label Type</h3>' + pickerHtml +
      '<div class="modal-btns" style="margin-top:12px">' +
        '<button class="btn btn-secondary" id="invPickCancel">Cancel</button>' +
        '<button class="btn btn-primary" id="invPickOk">Track</button>' +
      '</div>';
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.addEventListener('click', e => { if (e.target === overlay) { document.body.removeChild(overlay); resolve(null); } });
    modal.querySelector('#invPickCancel').onclick = () => { document.body.removeChild(overlay); resolve(null); };
    modal.querySelector('#invPickOk').onclick = () => {
      const sel = modal.querySelector('.label-type-card.selected');
      document.body.removeChild(overlay);
      resolve(sel ? sel.dataset.type : null);
    };
  });

  if (!typeId) return;

  const spec = LABEL_TYPES[typeId];
  const qtyStr = await showPrompt('How many sheets of ' + spec.name + ' do you have in stock?', '0', { title: '📦 Initial Stock Count', placeholder: 'Number of sheets' });
  if (qtyStr === null) return;
  const qty = Math.max(0, parseInt(qtyStr) || 0);

  inventory[typeId] = { stock: qty, lowThreshold: DEFAULT_LOW_THRESHOLD, history: [] };
  if (qty > 0) {
    addInventoryHistory(typeId, { type: 'add', delta: qty, note: 'Initial stock' });
  }
  saveInventory();
  renderInventoryContent();
  // Refresh sheet cards to show stock indicators
  if (currentTab === 'sheets') buildSheetCards();
}

async function promptAddStock(typeId) {
  const spec = LABEL_TYPES[typeId];
  if (!spec) return;
  const qtyStr = await showPrompt('How many sheets of ' + spec.name + ' to add?', '', { title: '📦 Add Stock', placeholder: 'Number of sheets' });
  if (qtyStr === null) return;
  const qty = parseInt(qtyStr);
  if (!qty || qty <= 0) return;

  const note = await showPrompt('Note (optional):', 'New purchase', { title: '📦 Add Stock — ' + qty + ' sheets' });
  if (note === null) return;

  addInventoryStock(typeId, qty, note || 'Added stock');
  renderInventoryContent();
  if (currentTab === 'sheets') buildSheetCards();
}

async function promptAdjustStock(typeId) {
  const inv = inventory[typeId];
  const spec = LABEL_TYPES[typeId];
  if (!inv || !spec) return;

  // Build adjustment dialog
  const result = await new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay visible';
    overlay.style.zIndex = '1100';
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.maxWidth = '400px';
    modal.innerHTML = '<h3>✏️ Adjust Stock — ' + spec.name + '</h3>' +
      '<div style="font-size:13px;color:var(--text-muted);margin-bottom:12px">Current stock: ' + inv.stock + ' sheets</div>' +
      '<div style="display:flex;gap:8px;margin-bottom:10px">' +
        '<button class="btn btn-sm" id="adjAdd" style="flex:1;justify-content:center" onclick="this.classList.add(\'btn-primary\');this.nextElementSibling.classList.remove(\'btn-primary\');this.nextElementSibling.classList.add(\'btn-secondary\');this.classList.remove(\'btn-secondary\')">+ Add</button>' +
        '<button class="btn btn-sm btn-primary" id="adjRemove" style="flex:1;justify-content:center" onclick="this.classList.add(\'btn-primary\');this.previousElementSibling.classList.remove(\'btn-primary\');this.previousElementSibling.classList.add(\'btn-secondary\');this.classList.remove(\'btn-secondary\')">− Remove</button>' +
      '</div>' +
      '<input type="number" id="adjQty" class="modal" style="width:100%;padding:10px 14px;border:2px solid var(--input-border);border-radius:8px;background:var(--input-bg);color:var(--text);font-size:15px;font-family:inherit;margin-bottom:10px" min="1" value="1" placeholder="Quantity">' +
      '<input type="text" id="adjNote" placeholder="Reason (required)" style="width:100%;padding:10px 14px;border:2px solid var(--input-border);border-radius:8px;background:var(--input-bg);color:var(--text);font-size:15px;font-family:inherit;margin-bottom:10px" maxlength="100">' +
      '<div class="modal-btns">' +
        '<button class="btn btn-secondary" id="adjCancel">Cancel</button>' +
        '<button class="btn btn-primary" id="adjOk">Apply</button>' +
      '</div>';
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.addEventListener('click', e => { if (e.target === overlay) { document.body.removeChild(overlay); resolve(null); } });
    modal.querySelector('#adjCancel').onclick = () => { document.body.removeChild(overlay); resolve(null); };
    modal.querySelector('#adjOk').onclick = () => {
      const qty = parseInt(modal.querySelector('#adjQty').value) || 0;
      const note = modal.querySelector('#adjNote').value.trim();
      const isAdd = modal.querySelector('#adjAdd').classList.contains('btn-primary');
      if (!note) { modal.querySelector('#adjNote').style.borderColor = 'var(--danger)'; return; }
      if (qty <= 0) { modal.querySelector('#adjQty').style.borderColor = 'var(--danger)'; return; }
      document.body.removeChild(overlay);
      resolve({ delta: isAdd ? qty : -qty, note });
    };
  });

  if (!result) return;
  adjustInventoryStock(typeId, result.delta, result.note);
  renderInventoryContent();
  if (currentTab === 'sheets') buildSheetCards();
}

async function deleteInventoryType(typeId) {
  const spec = LABEL_TYPES[typeId];
  if (!spec) return;
  const ok = await showConfirm('Stop tracking ' + spec.name + ' inventory? History will be lost.', { title: '📦 Remove Tracking', okText: 'Remove', danger: true });
  if (!ok) return;
  delete inventory[typeId];
  saveInventory();
  renderInventoryContent();
  if (currentTab === 'sheets') buildSheetCards();
}

function setLowThreshold(typeId, value) {
  if (!inventory[typeId]) return;
  inventory[typeId].lowThreshold = Math.max(0, value);
  saveInventory();
}

// Helper: count physical sheets returned on sheet deletion
function countReturnableSheets(sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  let returnable = 0;
  for (let p = 0; p < count; p++) {
    let hasOpen = false;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!printed.has(i)) { hasOpen = true; break; }
    }
    if (hasOpen) returnable++;
  }
  return returnable;
}

// Helper: count sheets consumed in a print job
function countSheetsConsumedByPrint(sh, newlyPrintedIndices) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const allPrinted = new Set([...(sh.printed || []), ...newlyPrintedIndices]);
  let consumed = 0;
  for (let p = 0; p < count; p++) {
    let allDone = true;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!allPrinted.has(i)) { allDone = false; break; }
    }
    if (allDone) consumed++;
  }
  // Subtract already-consumed before this print
  const prevPrinted = new Set(sh.printed || []);
  let prevConsumed = 0;
  for (let p = 0; p < count; p++) {
    let allDone = true;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!prevPrinted.has(i)) { allDone = false; break; }
    }
    if (allDone) prevConsumed++;
  }
  return consumed - prevConsumed;
}

// ========== PRINTING ==========
async function printLabels() {
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const { assignments, errors } = buildAssignments(sh);

  // Abort if any placement errors
  if (errors.length > 0) {
    const msgs = errors.map(e => {
      const st = getSavedText(e.textId);
      return '"' + (st ? st.name : '?') + '": ' + e.message;
    }).join('\n');
    showAlert('Cannot print — placement errors:\n\n' + msgs, { title: '⚠️ Print Aborted' });
    return;
  }

  const textIds = sh.texts ? Object.keys(sh.texts).filter(id => (sh.texts[id].qty || 0) > 0) : [];
  if (!textIds.length) return;

  // Build print map: pool index → { lines, alignV, graphics }
  const printMap = {};
  textIds.forEach(textId => {
    const st = getSavedText(textId);
    if (!st) return;
    const lines = deserializeLines(st.text);
    const indices = assignments[textId] || [];
    indices.forEach(idx => { printMap[idx] = { lines, alignV: st.alignV || 'center', graphics: st.graphics }; });
  });

  if (!Object.keys(printMap).length) return;

  const totalLabels = Object.keys(printMap).length;

  // Group by physical sheet
  const pageSheets = [];
  for (let p = 0; p < count; p++) {
    const pageLabels = [];
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (printMap[i]) {
        const localIdx = i % lps;
        const row = Math.floor(localIdx / spec.cols);
        const col = localIdx % spec.cols;
        pageLabels.push({ row, col, data: printMap[i] });
      }
    }
    if (pageLabels.length > 0) {
      pageSheets.push({ physicalSheet: p, labels: pageLabels });
    }
  }

  // Build iframe content with one page per physical sheet
  let pagesHtml = '';
  pageSheets.forEach((pg, pi) => {
    let pageHtml = '';
    pg.labels.forEach(lbl => {
      const top = spec.topMargin + lbl.row * (spec.labelH + spec.vGutter);
      const left = spec.leftMargin + lbl.col * (spec.labelW + spec.hGutter);
      const linesHtml = lbl.data.lines.map(l => renderPrintLineHtml(l)).join('');
      const gfx = lbl.data.graphics;
      const hasGfx = gfx && (gfx.left || gfx.right);

      if (hasGfx) {
        // Flex row layout with graphic(s) + text zone
        let innerHtml = '';
        if (gfx.left) innerHtml += '<div class="print-graphic" style="width:' + gfx.left.widthPct + '%;"><img src="' + gfx.left.data + '"></div>';
        innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(lbl.data.alignV) + ';">' + linesHtml + '</div>';
        if (gfx.right) innerHtml += '<div class="print-graphic" style="width:' + gfx.right.widthPct + '%;"><img src="' + gfx.right.data + '"></div>';
        pageHtml += '<div class="print-label print-label-gfx" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;">' + innerHtml + '</div>';
      } else {
        pageHtml += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;justify-content:' + getFlexAlign(lbl.data.alignV) + ';">' + linesHtml + '</div>';
      }
    });
    const breakStyle = pi < pageSheets.length - 1 ? 'page-break-after:always;' : '';
    pagesHtml += '<div class="print-sheet" style="' + breakStyle + '">' + pageHtml + '</div>';
  });

  // Use an iframe for printing
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);

  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write('<!DOCTYPE html><html><head><style>' +
    '@page { size: letter; margin: 0; }' +
    'html, body { margin:0; padding:0; }' +
    '.print-sheet { width:8.5in; height:11in; margin:0; padding:0; position:relative; overflow:hidden; box-sizing:border-box; }' +
    '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }' +
    '.print-label-gfx { flex-direction:row; align-items:stretch; }' +
    '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }' +
    '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }' +
    '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }' +
    '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; }' +
    '.print-line.align-left { justify-content:flex-start; text-align:left; }' +
    '.print-line.align-center { justify-content:center; text-align:center; }' +
    '.print-line.align-right { justify-content:flex-end; text-align:right; }' +
    '.print-line.align-split { justify-content:space-between; text-align:left; }' +
    '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }' +
    '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }' +
    '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }' +
  '</style></head><body>' +
    pagesHtml +
  '</body></html>');
  iframeDoc.close();

  // Wait for iframe to render, then print it
  iframe.contentWindow.focus();
  iframe.contentWindow.print();

  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);

  // After print dialog closes, ask user to confirm
  const confirmed = await showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer. Did the print complete successfully?',
    { title: '🖨️ Confirm Print', okText: 'Yes, printed OK', cancelText: 'No, discard' }
  );

  if (confirmed) {
    // Inventory: compute print stats before marking positions
    const printedIndices = Object.keys(printMap).map(Number);
    const newlyConsumed = countSheetsConsumedByPrint(sh, printedIndices);
    const pagesUsed = pageSheets.length;

    // Mark positions as printed, reset qtys, keep associations
    sh.printed = [...new Set([...(sh.printed||[]), ...printedIndices])];
    for (const textId of textIds) {
      if (sh.texts[textId]) sh.texts[textId].qty = 0;
    }
    saveSheets();

    // Record in inventory
    if (inventory[sh.labelType]) {
      recordInventoryPrint(sh.labelType, totalLabels, pagesUsed, newlyConsumed, activeSheetId, sh.name);
    }

    // Stash for undo
    lastPrintJob = { sheetId: activeSheetId, indices: Object.keys(printMap).map(Number), textQtys: {} };
    textIds.forEach(id => { lastPrintJob.textQtys[id] = (assignments[id] || []).length; });

    const rem = getRemaining();
    buildSheetCards();
    buildSheetDetail();
    buildAssignedTexts();
    updateTabMeta();
    if (rem > 0) {
      setStatus('Printed! ' + rem + ' spots left on "' + sh.name + '"', 'success');
    } else {
      showAlert('"' + sh.name + '" is now full. Select or create another sheet.', { title: '✅ Sheet Complete' });
    }
  } else {
    setStatus('Print cancelled — no labels were marked as used', 'warning');
  }
}

async function undoLastPrint() {
  if (!lastPrintJob) return;
  const sh = sheets[lastPrintJob.sheetId];
  if (!sh) { lastPrintJob = null; return; }
  const ok = await showConfirm(
    'Undo the last print on "' + sh.name + '"? This will unmark ' + lastPrintJob.indices.length + ' position' + (lastPrintJob.indices.length !== 1 ? 's' : '') + ' as used and restore the quantities.',
    { title: '↩️ Undo Last Print', okText: 'Undo', cancelText: 'Keep' }
  );
  if (!ok) return;
  // Remove printed indices
  const undoSet = new Set(lastPrintJob.indices);
  sh.printed = (sh.printed || []).filter(i => !undoSet.has(i));
  // Restore text qtys
  if (lastPrintJob.textQtys && sh.texts) {
    for (const [textId, qty] of Object.entries(lastPrintJob.textQtys)) {
      if (sh.texts[textId]) sh.texts[textId].qty = qty;
    }
  }
  saveSheets();
  // Remove inventory print entry
  if (inventory[sh.labelType]) {
    removeLastInventoryPrint(sh.labelType, lastPrintJob.sheetId);
  }
  const undoneSheetId = lastPrintJob.sheetId;
  const undoneName = sh.name;
  lastPrintJob = null;
  // Refresh if we're looking at that sheet
  if (activeSheetId === undoneSheetId) {
    buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  }
  setStatus('Print undone — positions restored on "' + undoneName + '"', 'success');
}

// ========== SPLIT REMAINING ==========
function showSplitDialog() {
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);

  // Count open positions and physical sheets with open spots
  let openCount = 0;
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    let sheetOpen = 0;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!printed.has(i)) sheetOpen++;
    }
    if (sheetOpen > 0) {
      sheetsWithOpen.push({ physicalSheet: p, open: sheetOpen });
      openCount += sheetOpen;
    }
  }

  if (openCount === 0) return;

  document.getElementById('splitSummary').textContent = openCount + ' open label' + (openCount !== 1 ? 's' : '') + ' across ' + sheetsWithOpen.length + ' physical sheet' + (sheetsWithOpen.length !== 1 ? 's' : '');

  // Default name suggestion
  const specName = spec.name.split(' /')[0];
  document.getElementById('splitName').value = 'Leftover ' + specName + ' - ' + new Date().toLocaleDateString('en-US', { month: 'short' });

  // If only one physical sheet with open spots, hide split/together choice
  const splitModeRadios = document.querySelectorAll('input[name="splitMode"]');
  const splitModeContainer = splitModeRadios[0].closest('div');
  if (sheetsWithOpen.length <= 1) {
    splitModeContainer.style.display = 'none';
  } else {
    splitModeContainer.style.display = '';
  }

  document.getElementById('splitModal').classList.add('visible');
  document.getElementById('splitName').focus();
}

function executeSplit() {
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);

  const name = document.getElementById('splitName').value.trim();
  if (!name) { document.getElementById('splitName').style.borderColor = 'var(--danger)'; return; }

  const splitMode = document.querySelector('input[name="splitMode"]:checked').value;
  const textMode = document.querySelector('input[name="splitTexts"]:checked').value;

  // Identify physical sheets with open positions
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    const localPrinted = [];
    let hasOpen = false;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (printed.has(i)) {
        localPrinted.push(i % lps); // remap to local index
      } else {
        hasOpen = true;
      }
    }
    if (hasOpen) {
      sheetsWithOpen.push({ physicalSheet: p, localPrinted });
    }
  }

  if (sheetsWithOpen.length === 0) { closeModal('splitModal'); return; }

  // Build text associations if keeping
  const textsToCarry = {};
  if (textMode === 'keep' && sh.texts) {
    for (const [textId, entry] of Object.entries(sh.texts)) {
      textsToCarry[textId] = { qty: 0, placement: entry.placement || 'next' };
    }
  }

  if (splitMode === 'separate' && sheetsWithOpen.length > 1) {
    // Create one new sheet per physical sheet with open spots
    sheetsWithOpen.forEach((info, idx) => {
      const newId = generateId();
      const suffix = sheetsWithOpen.length > 1 ? ' #' + (idx + 1) : '';
      sheets[newId] = {
        name: name + suffix,
        printed: [...info.localPrinted],
        labelType: sh.labelType,
        sheetCount: 1,
        texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
        createdAt: Date.now() + idx
      };
    });
  } else {
    // Keep together as one pool
    const newId = generateId();
    const newCount = sheetsWithOpen.length;
    // Remap printed positions to new contiguous pool
    const newPrinted = [];
    sheetsWithOpen.forEach((info, newPage) => {
      info.localPrinted.forEach(localIdx => {
        newPrinted.push(newPage * lps + localIdx);
      });
    });
    sheets[newId] = {
      name: name,
      printed: newPrinted,
      labelType: sh.labelType,
      sheetCount: newCount,
      texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
      createdAt: Date.now()
    };
  }

  // Reduce original sheet or delete it entirely
  const fullyConsumed = count - sheetsWithOpen.length;
  if (fullyConsumed === 0) {
    // All physical sheets had open positions — original is now empty, delete it
    delete sheets[activeSheetId];
    // Switch active sheet to the first newly created one
    const newIds = Object.keys(sheets).filter(id => sheets[id].createdAt >= Date.now() - 1000);
    activeSheetId = newIds.length > 0 ? newIds[0] : Object.keys(sheets)[0] || null;
    saveActiveSheet();
  } else if (fullyConsumed > 0 && fullyConsumed < count) {
    // Keep only the consumed physical sheets in the original
    sh.sheetCount = fullyConsumed;
    // Remove printed indices that belong to split-off sheets
    const keepRange = fullyConsumed * lps;
    sh.printed = sh.printed.filter(i => i < keepRange);
  }

  saveSheets();
  closeModal('splitModal');
  currentMapPage = 0;
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  setStatus('Split remaining labels into new sheet' + (splitMode === 'separate' && sheetsWithOpen.length > 1 ? 's' : ''), 'success');
}

// ========== EVENTS ==========
document.getElementById('newSheetName').addEventListener('keydown', e => { if (e.key==='Enter') createNewSheet(); if (e.key==='Escape' && !firstRunRequired) closeModal('newSheetModal'); });
document.getElementById('splitName').addEventListener('keydown', e => { if (e.key==='Enter') executeSplit(); if (e.key==='Escape') closeModal('splitModal'); });
document.getElementById('importBaseName').addEventListener('keydown', e => { if (e.key==='Enter') executeImport(); if (e.key==='Escape') closeModal('importTextModal'); });
document.getElementById('importBaseName').addEventListener('input', () => updateImportPreview());
document.addEventListener('paste', handleOcrPaste);
document.querySelectorAll('.modal-overlay').forEach(el => el.addEventListener('click', function(e) {
  if (e.target !== this) return;
  if (this.id === 'dialogModal') { dialogResolve(_dialogMode === 'alert'); }
  else if (this.id === 'ocrModal') { closeOcrModal(); }
  else { closeModal(this.id); }
}));

// ========== INIT ==========
initTheme();
loadSheets();
loadSavedTexts();
loadCustomTokens();
loadInventory();

if (!Object.keys(sheets).length) {
  firstRunRequired = true;
  switchTab('sheets');
  showNewSheetModal();
} else {
  switchTab('sheets');
  buildSheetCards();
  buildSheetDetail();
  buildAssignedTexts();
  renderSavedTexts();
  updateTabMeta();
}

</script>
</body>
</html>
