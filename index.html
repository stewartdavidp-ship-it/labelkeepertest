<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="gs-app-id" content="labelkeeper">
<meta name="version" content="3.17.0">

<!-- App Meta Tags -->
<meta name="description" content="Print labels without wasting a single position. Track which spots on your label sheets have been used.">
<meta name="theme-color" content="#1a1a1a">

<title>LabelKeeper</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f5f5f0;
  --surface: #ffffff;
  --surface-alt: #fafaf8;
  --text: #1a1a1a;
  --text-secondary: #4a4a4a;
  --text-muted: #777;
  --text-faint: #aaa;
  --border: #e0e0dc;
  --border-light: #eaeae6;
  --input-bg: #ffffff;
  --input-border: #d0d0cc;
  --heading: #0a0a0a;
  --accent: #2563eb;
  --accent-hover: #1d4ed8;
  --accent-bg: #eff4ff;
  --accent-text: #1e52c0;
  --success-bg: #ecfdf5;
  --success-text: #047a56;
  --success-border: #a7f3d0;
  --warning-bg: #fffbeb;
  --warning-text: #b45309;
  --warning-border: #fcd34d;
  --error-bg: #fef2f2;
  --error-text: #dc2626;
  --error-border: #fca5a5;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
  --radius: 12px;
  --radius-sm: 8px;
  --mono: 'JetBrains Mono', monospace;
}

[data-theme="dark"] {
  --bg: #0c0c10;
  --surface: #1a1a22;
  --surface-alt: #141418;
  --text: #eaeaee;
  --text-secondary: #b8b8c0;
  --text-muted: #8888a0;
  --text-faint: #606078;
  --border: #2e2e3a;
  --border-light: #242430;
  --input-bg: #1e1e28;
  --input-border: #3a3a48;
  --heading: #f8f8fc;
  --accent: #6c9eff;
  --accent-hover: #90b8ff;
  --accent-bg: #1c2440;
  --accent-text: #90b8ff;
  --success-bg: #0d2818;
  --success-text: #5cf0c0;
  --success-border: #208868;
  --warning-bg: #2d2006;
  --warning-text: #ffd85c;
  --warning-border: #c07820;
  --error-bg: #2d0a0a;
  --error-text: #ffa0a0;
  --error-border: #dc3838;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow: 0 2px 8px rgba(0,0,0,0.4);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.5);
}

body {
  font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

/* ===== APP SHELL ===== */
.app-shell {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* ===== HEADER ===== */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0 24px;
}

.app-title {
  font-size: 22px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 10px;
  letter-spacing: -0.02em;
}

.app-title .version {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-faint);
  font-family: var(--mono);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-btn {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--text-secondary);
  transition: all 0.15s;
  box-shadow: var(--shadow-sm);
}

.icon-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== WORKFLOW HUB ===== */
.workflow-hub {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.workflow-heading {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.workflow-cards-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

@media (max-width: 480px) {
  .workflow-cards-row {
    grid-template-columns: 1fr;
  }
}

.workflow-card-primary {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 24px 20px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  gap: 8px;
  box-shadow: var(--shadow-sm);
}

.workflow-card-primary:hover {
  border-color: var(--accent);
  box-shadow: var(--shadow);
  transform: translateY(-2px);
}

.workflow-card-primary:active {
  transform: translateY(0);
}

.workflow-card-primary:first-child {
  border-left: 3px solid var(--accent);
}

.workflow-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: var(--shadow-sm);
}

.workflow-card:hover {
  border-color: var(--accent);
  box-shadow: var(--shadow);
  transform: translateY(-1px);
}

.workflow-card:active {
  transform: translateY(0);
}

.workflow-icon {
  font-size: 32px;
  flex-shrink: 0;
}

.workflow-content {
  flex: 1;
  min-width: 0;
}

.workflow-title {
  font-size: 17px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.workflow-desc {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.4;
}

.workflow-arrow {
  font-size: 20px;
  color: var(--text-faint);
  transition: transform 0.2s, color 0.2s;
}

.workflow-card:hover .workflow-arrow,
.workflow-card-primary:hover .workflow-arrow {
  color: var(--accent);
  transform: translateX(4px);
}

/* ===== AI CONVERSATIONAL PROMPT ===== */
.workflow-ai-prompt {
  margin-top: 4px;
}

.ai-conv-input-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  transition: border-color 0.2s;
}

.ai-conv-input-row:focus-within {
  border-color: var(--accent);
}

.ai-conv-sparkle {
  font-size: 18px;
  flex-shrink: 0;
}

.ai-conv-input {
  flex: 1;
  border: none;
  background: transparent;
  font-family: inherit;
  font-size: 15px;
  color: var(--text-primary);
  outline: none;
  padding: 6px 0;
}

.ai-conv-input::placeholder {
  color: var(--text-faint);
  font-style: italic;
}

.ai-conv-send {
  flex-shrink: 0;
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: none;
  background: var(--accent);
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  font-size: 16px;
}

.ai-conv-send:hover {
  background: var(--accent-hover, var(--accent));
  transform: scale(1.05);
}

.ai-conv-send:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.ai-conv-send-icon {
  font-weight: 700;
}

.ai-conv-suggestions {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.ai-conv-chip {
  padding: 5px 12px;
  font-size: 12px;
  font-family: inherit;
  border: 1px solid var(--border);
  border-radius: 100px;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.ai-conv-chip:hover {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-bg);
}

.ai-conv-status {
  margin-top: 10px;
}

.ai-conv-thinking {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: var(--accent-bg);
  border-radius: var(--radius);
  font-size: 13px;
  color: var(--text-secondary);
}

.ai-conv-response {
  margin-top: 10px;
  padding: 14px 16px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-primary);
}

.ai-conv-response .ai-conv-msg {
  margin-bottom: 10px;
}

.ai-conv-response .ai-conv-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.ai-conv-action-btn {
  padding: 8px 16px;
  font-size: 13px;
  font-family: inherit;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-conv-action-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.ai-conv-action-btn.primary {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.ai-conv-action-btn.primary:hover {
  opacity: 0.9;
}

.ai-conv-error {
  color: var(--error-text, #ef4444);
  font-size: 13px;
  margin-top: 4px;
}

/* ===== QUICK LINKS ===== */
.workflow-quick-links {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  padding-top: 8px;
  border-top: 1px solid var(--border);
}

.workflow-quick-label {
  font-size: 12px;
  color: var(--text-faint);
  margin-right: 2px;
}

.workflow-quick-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 100px;
  padding: 5px 14px;
  font-size: 12px;
  font-family: inherit;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
}

.workflow-quick-btn:hover {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-bg);
}

/* Quick Actions section (T10-T11) */
.quick-actions-section {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}

.quick-actions-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 10px;
}

.quick-actions-label {
  font-size: 12px;
  color: var(--text-faint);
  font-weight: 500;
}

.quick-actions-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.quick-action-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.15s;
}

.quick-action-item:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.quick-action-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.quick-action-content {
  flex: 1;
  min-width: 0;
}

.quick-action-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.quick-action-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 1px;
}

.quick-action-badge {
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-bg);
  color: var(--accent);
  flex-shrink: 0;
}

.quick-actions-empty {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
  padding: 8px 0;
}

/* ===== AI CATEGORY MODAL ===== */
.ai-category-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  margin-bottom: 16px;
}

.ai-category-card {
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.ai-category-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: translateY(-2px);
}

.ai-category-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.ai-category-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.ai-category-desc {
  font-size: 11px;
  color: var(--text-muted);
  line-height: 1.3;
}

/* AI Category Form */
.ai-form-section {
  margin-bottom: 16px;
}

.ai-form-label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: block;
}

.ai-form-input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
}

.ai-form-input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-bg);
}

.ai-form-input::placeholder {
  color: var(--text-faint);
}

.ai-form-textarea {
  min-height: 80px;
  resize: vertical;
}

.ai-form-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-form-row {
  display: flex;
  gap: 12px;
}

.ai-form-row .ai-form-section {
  flex: 1;
}

/* AI Quick suggestions */
.ai-suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}

/* Generic button styles for AI modals */
.btn {
  padding: 12px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border-color: var(--border);
}

.btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ai-suggestion-chip {
  padding: 6px 10px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-size: 12px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-suggestion-chip:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent-text);
}

/* ===== TAB BAR (Power Mode) ===== */
/* Desktop: Top tab bar */
.tab-bar {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--border);
  margin-bottom: 24px;
  overflow-x: auto;
}

/* Mobile: Bottom tab bar */
@media (max-width: 767px) {
  .tab-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-bottom: none;
    border-top: 1px solid var(--border);
    margin-bottom: 0;
    padding: 0;
    padding-bottom: env(safe-area-inset-bottom, 0);
    z-index: 100;
    justify-content: space-around;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
  }
  
  .app-shell {
    padding-bottom: 70px; /* Space for bottom nav */
  }
}

/* Hide workflow hub when not on workflows tab */
.workflow-hub {
  display: none;
}

.workflow-hub.active {
  display: flex;
}

.tab-btn {
  padding: 12px 18px;
  border: none;
  background: none;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  position: relative;
  transition: color 0.2s;
  white-space: nowrap;
}

.tab-btn:hover {
  color: var(--text);
}

.tab-btn.active {
  color: var(--accent);
}

/* Desktop: underline indicator */
.tab-btn.active::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  height: 2px;
  background: var(--accent);
}

/* Mobile: icon-style tabs */
@media (max-width: 767px) {
  .tab-btn {
    flex: 1;
    padding: 10px 8px;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  
  .tab-btn::before {
    font-size: 20px;
  }
  
  .tab-btn[data-tab="workflows"]::before { content: 'ðŸ '; }
  .tab-btn[data-tab="sheets"]::before { content: 'ðŸ“„'; }
  .tab-btn[data-tab="saved"]::before { content: 'ðŸ’¾'; }
  .tab-btn[data-tab="templates"]::before { content: 'ðŸ“'; }
  .tab-btn[data-tab="inventory"]::before { content: 'ðŸ“¦'; }
  .tab-btn[data-tab="history"]::before { content: 'ðŸ“œ'; }
  
  .tab-btn.active::after {
    display: none;
  }
}

/* ===== TAB PANELS ===== */
.tab-panel {
  display: none;
  animation: fadeIn 0.2s ease;
}

.tab-panel.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}

.panel-placeholder {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-muted);
}

.panel-placeholder-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.panel-placeholder-text {
  font-size: 15px;
}

/* ===== TAB CONTENT LIST ===== */
.tab-content-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.list-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 18px;
  cursor: pointer;
  transition: all 0.15s;
}

.list-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.builtin {
  opacity: 0.8;
}

.list-card.low {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

.list-card.empty {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.list-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.list-card-meta {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.badge {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--text-faint);
  color: var(--surface);
}

/* ===== TAB HEADERS ===== */
.tab-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 12px;
}

.tab-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.tab-actions {
  display: flex;
  gap: 8px;
}

.tab-action-btn {
  padding: 8px 14px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: background 0.15s;
}

.tab-action-btn:hover {
  background: var(--accent-hover);
}

.tab-action-btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 2px solid var(--border);
}

.tab-action-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

/* ===== SHEET CARDS (Enhanced) ===== */
.sheet-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  transition: all 0.15s;
}

.sheet-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.sheet-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}

.sheet-card-info {
  flex: 1;
  min-width: 0;
}

.sheet-card-name {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 4px;
}

.sheet-card-type {
  font-size: 13px;
  color: var(--text-muted);
}

.sheet-note-display {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
  padding: 6px 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin: 8px 12px 0;
}

.sheet-card-actions {
  display: flex;
  gap: 4px;
}

.sheet-card-btn {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.sheet-card-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.sheet-card-btn.danger:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

/* Sheet Grid Preview */
.sheet-grid {
  display: grid;
  gap: 2px;
  background: var(--border);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 2px;
}

.sheet-grid-cell {
  background: var(--surface);
  aspect-ratio: 1;
  min-width: 8px;
  border-radius: 2px;
}

.sheet-grid-cell.clickable {
  cursor: pointer;
  transition: all 0.15s;
}

.sheet-grid-cell.clickable:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  background: var(--border);
}

.sheet-grid-cell.printed {
  background: var(--text-faint);
}

.sheet-grid-cell.printed.clickable:hover {
  background: var(--text-muted);
}

.sheet-grid-cell.queued {
  background: var(--accent);
}

.sheet-stats {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sheet-stat-value {
  font-weight: 600;
  color: var(--heading);
}

/* ===== ASSIGNED TEXTS (Sheet-Content Relationship) ===== */
.assigned-texts-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.assigned-texts-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.assigned-texts-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
}

.assigned-texts-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.assigned-text-row {
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface-alt);
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.15s;
}

.assigned-text-row:hover {
  border-color: var(--accent);
}

.assigned-text-row.has-error {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.assigned-text-color {
  width: 6px;
  height: 32px;
  border-radius: 3px;
  flex-shrink: 0;
}

.assigned-text-info {
  flex: 1;
  min-width: 0;
}

.assigned-text-name {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.assigned-text-spots {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.assigned-text-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.assigned-text-placement {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 12px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M3 5l3 3 3-3'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 6px center;
  padding-right: 24px;
}

.assigned-text-placement:focus {
  outline: none;
  border-color: var(--accent);
}

.assigned-text-qty {
  display: flex;
  align-items: center;
}

.assigned-text-qty .qty-btn {
  width: 28px;
  height: 28px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

.assigned-text-qty .qty-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.assigned-text-qty .qty-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.assigned-text-qty .qty-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.assigned-text-qty .qty-val {
  min-width: 36px;
  height: 28px;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--heading);
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.assigned-text-remove {
  background: var(--input-bg);
  border: 1px solid var(--border);
  font-size: 14px;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin-left: 8px;
}

.assigned-text-remove:hover {
  color: var(--error-text);
  background: var(--error-bg);
  border-color: var(--error-border);
}

.assigned-texts-empty {
  padding: 12px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  border: 1px dashed var(--border);
  border-radius: var(--radius-sm);
}

.assigned-add-btn {
  font-size: 12px;
  padding: 4px 10px;
}

/* Sheet Print Actions */
.sheet-print-actions {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sheet-print-actions > div:first-child:not(.sheet-secondary-actions) {
  display: flex;
  align-items: center;
  gap: 12px;
}

.sheet-secondary-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 4px;
}

.sheet-print-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.15s;
}

.sheet-print-btn:hover:not(:disabled) {
  background: var(--accent-hover);
}

.sheet-print-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.sheet-print-summary {
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-print-error {
  font-size: 12px;
  color: var(--error-text);
  margin-top: 8px;
}

/* Multi-sheet grid container */
.sheet-grids-container {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: flex-start;
}

.sheet-grid-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.sheet-grid-label {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 500;
}

/* Sheet grid pagination (for many sheets) */
.sheet-grid-pagination {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.sheet-grid-page-btn {
  background: var(--input-bg);
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.15s;
}

.sheet-grid-page-btn:hover:not(:disabled) {
  border-color: var(--accent);
  color: var(--accent);
}

.sheet-grid-page-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.sheet-grid-page-info {
  font-size: 12px;
  color: var(--text-muted);
}

/* Text colors for grid visualization */
.text-color-0 { background: #6366f1; }
.text-color-1 { background: #ec4899; }
.text-color-2 { background: #14b8a6; }
.text-color-3 { background: #f59e0b; }
.text-color-4 { background: #8b5cf6; }
.text-color-5 { background: #ef4444; }
.text-color-6 { background: #22c55e; }
.text-color-7 { background: #3b82f6; }

/* Cell colors for grid visualization (match text colors) */
.sheet-grid-cell.cell-color-0 { background: #6366f1; }
.sheet-grid-cell.cell-color-1 { background: #ec4899; }
.sheet-grid-cell.cell-color-2 { background: #14b8a6; }
.sheet-grid-cell.cell-color-3 { background: #f59e0b; }
.sheet-grid-cell.cell-color-4 { background: #8b5cf6; }
.sheet-grid-cell.cell-color-5 { background: #ef4444; }
.sheet-grid-cell.cell-color-6 { background: #22c55e; }
.sheet-grid-cell.cell-color-7 { background: #3b82f6; }

/* ===== SAVED CONTENT CARDS (Enhanced) ===== */
.saved-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  transition: all 0.15s;
  cursor: pointer;
}

.saved-card:hover {
  border-color: var(--accent);
}

.saved-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.saved-card-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.saved-card-preview {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.saved-card-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
}

.saved-card:hover .saved-card-actions {
  opacity: 1;
}

/* ===== HISTORY CARDS (Enhanced) ===== */
.history-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 14px;
  transition: all 0.15s;
}

.history-card:hover {
  border-color: var(--accent);
}

/* T2: Prominent multi-select indicator */
.history-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 2px var(--accent);
}

.history-card.selected .history-card-icon {
  opacity: 1;
}

.history-card-icon {
  font-size: 24px;
  opacity: 0.6;
}

.history-card-info {
  flex: 1;
  min-width: 0;
}

.history-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 2px;
}

.history-card-meta {
  font-size: 13px;
  color: var(--text-muted);
}

.history-card-action {
  padding: 8px 12px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.history-card-action:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== REPRINT LIST ===== */
.reprint-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 400px;
  overflow-y: auto;
  padding: 4px;
}

/* ===== INVENTORY CARDS ===== */
.inventory-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 12px;
}

.inventory-card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
}

.inventory-card-type {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.inventory-card-name {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.inventory-card-desc {
  font-size: 13px;
  color: var(--text-muted);
}

.inventory-card-status {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 20px;
}

.inventory-card-status.inv-ok {
  background: var(--success-bg);
  color: var(--success-text);
}

.inventory-card-status.inv-low {
  background: var(--warning-bg);
  color: var(--warning-text);
}

.inventory-card-status.inv-empty {
  background: var(--error-bg);
  color: var(--error-text);
}

.inventory-card-body {
  display: flex;
  gap: 24px;
  margin-bottom: 16px;
}

.inventory-stat {
  text-align: center;
}

.inventory-stat-value {
  font-size: 28px;
  font-weight: 700;
  font-family: var(--mono);
  color: var(--heading);
  line-height: 1;
}

.inventory-stat-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

.inventory-card-actions {
  display: flex;
  gap: 8px;
}

.inventory-adjust-btn {
  padding: 8px 14px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.inventory-adjust-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.inventory-adjust-btn.wide {
  flex: 1;
}

.inventory-adjust-btn.danger:hover {
  border-color: var(--error-text);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== PRINT INVENTORY WARNING ===== */
.print-inv-warning {
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  margin-top: 12px;
}

.print-inv-warning.warning {
  background: var(--warning-bg);
  color: var(--warning-text);
  border: 1px solid var(--warning-border);
}

.print-inv-warning.error {
  background: var(--error-bg);
  color: var(--error-text);
  border: 1px solid var(--error-border);
}

/* ===== SIMPLE MODAL (for edit/create) ===== */
.simple-modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.simple-modal-overlay.visible {
  display: flex;
}

.simple-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.simple-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.simple-modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.simple-modal-body {
  padding: 20px 24px;
}

.simple-modal-footer {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  padding: 16px 24px;
  border-top: 1px solid var(--border-light);
}

.form-group {
  margin-bottom: 16px;
}

.form-label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.form-input {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

.form-select {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.form-hint {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* ===== WELCOME / FIRST RUN ===== */
.welcome-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.welcome-overlay.visible {
  display: flex;
}

.welcome-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 480px;
  max-height: 90vh;
  overflow-y: auto;
  text-align: center;
}

.welcome-header {
  padding: 40px 30px 20px;
  background: linear-gradient(135deg, var(--accent-bg), transparent);
  border-bottom: 1px solid var(--border-light);
}

.welcome-icon {
  font-size: 56px;
  margin-bottom: 16px;
}

.welcome-title {
  font-size: 26px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.welcome-version {
  font-size: 13px;
  font-family: var(--mono);
  color: var(--text-muted);
}

.welcome-body {
  padding: 24px 30px;
}

.welcome-tagline {
  font-size: 16px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 24px;
}

.welcome-features {
  display: flex;
  flex-direction: column;
  gap: 12px;
  text-align: left;
  margin-bottom: 24px;
}

.welcome-feature {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.welcome-feature-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.welcome-feature-text {
  font-size: 14px;
  color: var(--text);
  line-height: 1.4;
}

.welcome-feature-text strong {
  color: var(--heading);
}

.welcome-data-status {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 20px;
  text-align: left;
}

.welcome-data-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.welcome-data-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.welcome-data-item {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 13px;
  color: var(--text-muted);
  background: var(--surface);
  padding: 4px 10px;
  border-radius: 12px;
  border: 1px solid var(--border-light);
}

.welcome-data-item.has-data {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.welcome-footer {
  padding: 20px 30px 30px;
}

.welcome-btn-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.welcome-btn {
  width: 100%;
  padding: 14px 20px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.welcome-btn-primary {
  background: var(--accent);
  color: #fff;
}

.welcome-btn-primary:hover {
  background: var(--accent-hover);
}

.welcome-btn-secondary {
  background: var(--surface);
  border: 2px solid var(--border);
  color: var(--text-secondary);
}

.welcome-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.welcome-skip {
  margin-top: 8px;
  font-size: 13px;
  color: var(--text-muted);
  cursor: pointer;
  background: none;
  border: none;
  font-family: inherit;
}

.welcome-skip:hover {
  color: var(--accent);
  text-decoration: underline;
}

/* ===== TOAST NOTIFICATIONS ===== */
.toast-container {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 3000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
}

.toast {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 20px;
  box-shadow: var(--shadow-lg);
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  color: var(--text);
  animation: toastSlideIn 0.3s ease;
  pointer-events: auto;
  max-width: 90vw;
}

.toast.success {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.toast.error {
  background: var(--error-bg);
  border-color: var(--error-border);
  color: var(--error-text);
}

.toast.warning {
  background: var(--warning-bg);
  border-color: var(--warning-border);
  color: var(--warning-text);
}

.toast-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.toast.exiting {
  animation: toastSlideOut 0.3s ease forwards;
}

@keyframes toastSlideIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes toastSlideOut {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(20px); }
}

/* ===== MOBILE TOUCH IMPROVEMENTS ===== */
@media (max-width: 600px) {
  .workflow-card {
    padding: 18px;
    min-height: 80px;
  }
  
  .wizard-btn {
    min-height: 48px;
    padding: 14px 20px;
  }
  
  .icon-btn {
    width: 44px;
    height: 44px;
  }
  
  .tab-btn {
    padding: 14px 16px;
  }
  
  .form-input, .form-select {
    padding: 14px 12px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  .secondary-link {
    padding: 12px 16px;
  }
  
  .setup-stock-btn {
    width: 52px;
    height: 52px;
    font-size: 22px;
  }
  
  .welcome-modal {
    max-width: 100%;
    border-radius: var(--radius-sm);
  }
  
  .welcome-header {
    padding: 30px 20px 16px;
  }
  
  .welcome-body {
    padding: 20px;
  }
  
  .welcome-footer {
    padding: 16px 20px 24px;
  }
}

/* ===== SAFE AREA (for notched devices) ===== */
@supports (padding: max(0px)) {
  .app-shell {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
  
  .toast-container {
    bottom: max(24px, calc(env(safe-area-inset-bottom) + 16px));
  }
}

/* ===== MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.visible {
  display: flex;
}

.modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 400px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.modal-close {
  width: 32px;
  height: 32px;
  border: none;
  background: none;
  font-size: 20px;
  color: var(--text-muted);
  cursor: pointer;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-close:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.modal-body {
  padding: 20px 24px;
}

/* ===== SETTINGS ===== */
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 0;
  border-bottom: 1px solid var(--border-light);
}

.setting-row:last-child {
  border-bottom: none;
}

.setting-label {
  font-size: 15px;
  font-weight: 500;
  color: var(--text);
}

.setting-desc {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* Toggle Switch */
.toggle {
  width: 48px;
  height: 28px;
  background: var(--border);
  border-radius: 14px;
  position: relative;
  cursor: pointer;
  transition: background 0.2s;
  flex-shrink: 0;
}

.toggle.active {
  background: var(--accent);
}

.toggle-thumb {
  width: 22px;
  height: 22px;
  background: white;
  border-radius: 50%;
  position: absolute;
  top: 3px;
  left: 3px;
  transition: transform 0.2s;
  box-shadow: var(--shadow-sm);
}

.toggle.active .toggle-thumb {
  transform: translateX(20px);
}

.settings-divider {
  height: 1px;
  background: var(--border);
  margin: 20px 0;
}

.settings-section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 16px;
}

.settings-data-stats {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-bottom: 16px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 13px;
  color: var(--text-muted);
}

.settings-data-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.settings-data-stat strong {
  color: var(--text);
  font-weight: 600;
}

.settings-btn-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.settings-action-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.settings-action-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.settings-action-btn.secondary {
  background: var(--surface-alt);
}

.settings-action-btn.danger:hover {
  border-color: var(--error-border);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== DEVICE ROLE SELECTOR ===== */
.device-role-selector {
  display: flex;
  gap: 12px;
  margin-top: 8px;
}

.device-role-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.2s;
}

.device-role-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.device-role-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.device-role-btn .role-icon {
  font-size: 24px;
  margin-bottom: 8px;
}

.device-role-btn .role-name {
  font-weight: 600;
  color: var(--text);
  font-size: 14px;
}

.device-role-btn .role-desc {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.device-role-btn.active .role-name {
  color: var(--accent-text);
}

/* Satellite pending list */
.satellite-pending-list {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 8px;
  max-height: 150px;
  overflow-y: auto;
}

.satellite-pending-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  background: var(--surface);
  border-radius: var(--radius-sm);
  margin-bottom: 4px;
}

.satellite-pending-item:last-child {
  margin-bottom: 0;
}

.satellite-pending-name {
  font-size: 13px;
  color: var(--text);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.satellite-pending-delete {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px 8px;
  font-size: 14px;
  border-radius: 4px;
}

.satellite-pending-delete:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.satellite-pending-empty {
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  padding: 12px;
}

/* Satellite mode indicator */
.satellite-mode-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: var(--warning-bg);
  color: var(--warning-text);
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
}

/* Workflow card disabled state */
.workflow-card.disabled {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
}

.workflow-card .primary-only-badge {
  display: none;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.workflow-card.disabled .primary-only-badge {
  display: block;
}

/* ===== AI PROMPT MODAL ===== */
.ai-prompt-section {
  margin-bottom: 4px;
}

.ai-prompt-box {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-family: var(--mono);
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  color: var(--text-secondary);
  max-height: 200px;
  overflow-y: auto;
  margin-bottom: 12px;
}

.ai-prompt-copy-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  border: 2px solid var(--accent);
  border-radius: var(--radius-sm);
  background: var(--accent-bg);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--accent-text);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-prompt-copy-btn:hover {
  background: var(--accent);
  color: white;
}

.ai-prompt-divider {
  height: 1px;
  background: var(--border-light);
  margin: 20px 0;
}

.ai-prompt-steps {
  margin: 0;
  padding-left: 20px;
  color: var(--text-secondary);
  font-size: 13px;
  line-height: 1.8;
}

.ai-prompt-steps li {
  margin-bottom: 4px;
}

.ai-prompt-example {
  user-select: all;
}

/* Keyboard Shortcuts Modal */
.shortcuts-section {
  margin-bottom: 20px;
}

.shortcuts-section:last-child {
  margin-bottom: 0;
}

.shortcuts-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.shortcut-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--border-light);
}

.shortcut-row:last-child {
  border-bottom: none;
}

.shortcut-key {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
}

.shortcut-desc {
  font-size: 13px;
  color: var(--text-secondary);
}

/* ===== FULL EDITOR MODAL (ported from v1.2.0) ===== */
.full-editor-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 1000;
  overflow-y: auto;
}

.full-editor-overlay.visible {
  display: block;
}

.full-editor-container {
  max-width: 700px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

.full-editor-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 24px;
}

.full-editor-back {
  width: 40px;
  height: 40px;
  border: 2px solid var(--border);
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.full-editor-back:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.full-editor-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.full-editor-subtitle {
  font-size: 13px;
  color: var(--text-muted);
}

.full-editor-panel {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 16px;
}

.full-editor-section-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

/* Line input rows */
.fe-line-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}

.fe-line-num {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  width: 16px;
  text-align: center;
  flex-shrink: 0;
  font-family: var(--mono);
}

.fe-line-input {
  flex: 1;
  padding: 10px 12px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 15px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.2s;
  min-width: 0;
}

.fe-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-line-input::placeholder {
  color: var(--text-faint);
  font-size: 13px;
}

.fe-align-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
}

.fe-align-btn:hover {
  border-color: var(--accent);
}

.fe-align-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-size-stepper {
  display: flex;
  align-items: center;
  flex-shrink: 0;
}

.fe-size-btn {
  width: 26px;
  height: 36px;
  border: 2px solid var(--border);
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-size-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.fe-size-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.fe-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-size-val {
  width: 32px;
  height: 36px;
  border-top: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.fe-style-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
  position: relative;
}

.fe-style-btn:hover {
  border-color: var(--accent);
}

.fe-style-btn.has-styles {
  color: var(--accent);
  border-color: var(--accent);
}

.fe-style-btn.popover-open {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Style popover */
.fe-style-popover {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  z-index: 100;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  margin-top: 6px;
  box-shadow: var(--shadow-lg);
  min-width: 220px;
}

.fe-style-popover.open {
  display: block;
}

.fe-popover-section {
  margin-bottom: 10px;
}

.fe-popover-section:last-child {
  margin-bottom: 0;
}

.fe-popover-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 6px;
}

.fe-style-toggles {
  display: flex;
  gap: 6px;
}

.fe-style-toggle {
  width: 36px;
  height: 34px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-style-toggle:hover {
  border-color: var(--accent);
}

.fe-style-toggle.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-style-toggle .lbl-b { font-weight: 800; }
.fe-style-toggle .lbl-i { font-style: italic; font-family: Georgia, serif; }
.fe-style-toggle .lbl-u { text-decoration: underline; }
.fe-style-toggle .lbl-s { text-decoration: line-through; }

.fe-color-palette {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.fe-color-swatch {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid var(--border);
  transition: all 0.15s;
}

.fe-color-swatch:hover {
  border-color: var(--accent);
  transform: scale(1.1);
}

.fe-color-swatch.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent);
}

.fe-color-swatch.swatch-none {
  background: var(--surface);
  position: relative;
}

.fe-color-swatch.swatch-none::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 50%;
  width: 2px;
  height: calc(100% - 6px);
  background: var(--error-text);
  transform: rotate(45deg);
}

/* Line hint */
.fe-line-hint {
  font-size: 12px;
  color: var(--text-faint);
  margin-top: 4px;
  padding-left: 22px;
}

.fe-line-hint code {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 1px 4px;
  font-size: 11px;
  font-family: var(--mono);
}

/* Token Panel */
.fe-token-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  padding-left: 22px;
}

.fe-token-toggle {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

.fe-token-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-toggle.active {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-panel {
  display: none;
  margin-top: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}

.fe-token-panel.visible {
  display: block;
}

.fe-token-category {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 10px;
  margin-bottom: 6px;
}

.fe-token-category:first-child {
  margin-top: 0;
}

.fe-token-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 4px;
}

.fe-token-chip {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  font-size: 12px;
  font-family: var(--mono);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-chip:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-token-custom-row {
  display: flex;
  gap: 6px;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}

.fe-token-custom-row input {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-family: var(--mono);
}

.fe-token-custom-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-token-custom-row button {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-custom-row button:hover {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

/* Vertical alignment */
.fe-valign-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-valign-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
}

.fe-valign-btn {
  min-width: 38px;
  height: 34px;
  padding: 0 8px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-valign-btn:hover {
  border-color: var(--accent);
}

.fe-valign-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Graphics panel */
.fe-graphics-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-graphics-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.fe-graphics-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  min-width: 45px;
}

.fe-graphic-add {
  padding: 6px 14px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-muted);
  cursor: pointer;
  font-family: inherit;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-graphic-add:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-graphic-thumb {
  width: 44px;
  height: 44px;
  border-radius: 6px;
  border: 2px solid var(--border);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  cursor: pointer;
}

.fe-graphic-thumb:hover {
  border-color: var(--accent);
}

.fe-graphic-thumb img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.fe-graphic-size-pills {
  display: flex;
  gap: 4px;
}

.fe-graphic-size-pill {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
}

.fe-graphic-size-pill:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-graphic-size-pill.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-graphic-remove {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-faint);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  transition: all 0.15s;
}

.fe-graphic-remove:hover {
  border-color: var(--error-border);
  color: var(--error-text);
  background: var(--error-bg);
}

/* Preview */
.fe-preview-container {
  background: repeating-conic-gradient(#d8d8d2 0% 25%, #e4e4de 0% 50%) 50% / 12px 12px;
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100px;
}

[data-theme="dark"] .fe-preview-container {
  background: repeating-conic-gradient(#2a2a32 0% 25%, #1e1e26 0% 50%) 50% / 12px 12px;
}

.fe-preview-label {
  background: white;
  border: 2px solid #888;
  border-radius: 4px;
  padding: 8px 10px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  transition: all 0.15s;
}

.fe-preview-label .preview-line {
  width: 100%;
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  line-height: 1.3;
}

.fe-preview-label .preview-line.align-left { justify-content: flex-start; }
.fe-preview-label .preview-line.align-center { justify-content: center; }
.fe-preview-label .preview-line.align-right { justify-content: flex-end; }

.fe-preview-label.empty-preview {
  align-items: center;
  justify-content: center;
  color: #bbb;
  font-size: 12px;
  font-style: italic;
}

.fe-preview-dimensions {
  text-align: center;
  font-size: 11px;
  color: var(--text-faint);
  margin-top: 8px;
  font-family: var(--mono);
}

/* Preview type selector */
.fe-preview-type-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-top: 8px;
}

.fe-preview-type-label {
  font-size: 11px;
  color: var(--text-muted);
}

.fe-preview-type-select {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 11px;
  font-family: var(--mono);
  cursor: pointer;
}

.fe-preview-type-select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Border controls */
.fe-border-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-border-row {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.fe-border-toggles {
  display: flex;
  gap: 4px;
}

.fe-border-toggle {
  width: 32px;
  height: 32px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-muted);
  cursor: pointer;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.fe-border-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-border-toggle.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-border-color {
  display: flex;
  align-items: center;
  gap: 4px;
}

.fe-border-color-swatch {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
}

.fe-border-color-swatch:hover {
  border-color: var(--accent);
}

/* Global style controls */
.fe-global-style-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px 12px;
  background: var(--surface-alt);
  border-radius: 8px;
}

.fe-global-style-label {
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  white-space: nowrap;
}

.fe-global-style-btn {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 11px;
  font-family: inherit;
  transition: all 0.15s;
}

.fe-global-style-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-global-style-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

/* Unsaved changes indicator */
.fe-dirty-indicator {
  display: none;
  color: var(--warning-text);
  font-size: 11px;
  margin-left: 8px;
}

.fe-dirty-indicator.visible {
  display: inline;
}

/* Actions */
.fe-actions {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.fe-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid transparent;
  border-radius: 10px;
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-btn-primary {
  background: var(--accent);
  color: white;
}

.fe-btn-primary:hover {
  background: var(--accent-hover);
}

.fe-btn-secondary {
  background: var(--surface);
  border-color: var(--border);
  color: var(--text);
}

.fe-btn-secondary:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Name input for save */
.fe-name-row {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.fe-name-input {
  flex: 1;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.fe-name-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Graphic picker modal */
.fe-graphic-picker {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1100;
  align-items: center;
  justify-content: center;
}

.fe-graphic-picker.visible {
  display: flex;
}

.fe-graphic-picker-modal {
  background: var(--surface);
  border-radius: var(--radius);
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.fe-gp-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-light);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.fe-gp-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
}

.fe-gp-close {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-size: 20px;
  cursor: pointer;
  border-radius: 6px;
}

.fe-gp-close:hover {
  background: var(--surface-alt);
  color: var(--text);
}

.fe-gp-tabs {
  display: flex;
  border-bottom: 1px solid var(--border-light);
}

.fe-gp-tab {
  flex: 1;
  padding: 10px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  border-bottom: 2px solid transparent;
}

.fe-gp-tab:hover {
  color: var(--text);
  background: var(--surface-alt);
}

.fe-gp-tab.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

.fe-gp-body {
  padding: 16px;
  overflow-y: auto;
  flex: 1;
}

.fe-gp-upload-area {
  text-align: center;
  padding: 30px;
}

.fe-gp-upload-btn {
  padding: 12px 24px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-gp-upload-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-gp-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.fe-gp-icon {
  width: 48px;
  height: 48px;
  border: 2px solid var(--border-light);
  border-radius: 8px;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px;
  transition: all 0.15s;
}

.fe-gp-icon:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: scale(1.05);
}

.fe-gp-icon svg {
  width: 100%;
  height: 100%;
}

/* ===== WIZARD (for workflows) ===== */
.wizard-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 900;
  overflow-y: auto;
}

.wizard-overlay.visible {
  display: block;
}

.wizard-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.wizard-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 32px;
}

.wizard-back {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  box-shadow: var(--shadow-sm);
}

.wizard-back:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.wizard-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.wizard-step {
  flex: 1;
  display: none;
  flex-direction: column;
}

.wizard-step.active {
  display: flex;
}

.wizard-question {
  font-size: 22px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 24px;
  line-height: 1.3;
}

.wizard-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.wizard-option {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 18px 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 14px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 500;
  color: var(--text);
  text-align: left;
}

.wizard-option:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option-icon {
  font-size: 24px;
}

/* ===== WIZARD TEXT EDITOR ===== */
.wizard-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.editor-lines {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.editor-line {
  display: flex;
  gap: 8px;
  align-items: stretch;
}

.editor-line-input {
  flex: 1;
  padding: 12px 14px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.15s;
}

.editor-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.editor-line-input::placeholder {
  color: var(--text-faint);
}

.editor-controls {
  display: flex;
  gap: 4px;
}

.editor-align-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-align-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-align-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.editor-size-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-size-btn.size-s { font-size: 11px; }
.editor-size-btn.size-m { font-size: 14px; }
.editor-size-btn.size-l { font-size: 17px; }

.editor-size-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Preview */
.editor-preview-section {
  margin-top: 8px;
}

.editor-preview-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.editor-preview-frame {
  background: white;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  min-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.editor-preview-label-box {
  background: #fff;
  border: 1px solid #ccc;
  width: 100%;
  max-width: 263px;
  height: 96px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 8px 12px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
}

.preview-line {
  line-height: 1.3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-line.align-left { text-align: left; }
.preview-line.align-center { text-align: center; }
.preview-line.align-right { text-align: right; }

/* Actions */
.wizard-actions {
  display: flex;
  gap: 12px;
  margin-top: auto;
  padding-top: 24px;
}

.wizard-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.wizard-btn-secondary {
  background: var(--surface);
  color: var(--text);
}

.wizard-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.wizard-btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.wizard-btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.wizard-btn-primary.danger {
  background: var(--error-text);
  border-color: var(--error-text);
}

.wizard-btn-primary.danger:hover {
  background: #b91c1c;
  border-color: #b91c1c;
}

/* ===== WF1: PRINT SOMETHING NEW ===== */

.wf1-progress {
  display: flex;
  gap: 4px;
  margin-bottom: 24px;
}

.wf1-progress-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--border);
  transition: all 0.2s;
}

.wf1-progress-dot.active {
  background: var(--accent);
  width: 24px;
  border-radius: 4px;
}

.wf1-progress-dot.done {
  background: var(--success-text);
}

/* Type grid (reused from existing, refined for WF1) */
.wf1-type-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
  margin-bottom: 16px;
}

.wf1-type-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 12px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
  position: relative;
  user-select: none; /* Prevent text selection on double-click */
}

.wf1-type-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-type-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 1px var(--accent);
}

/* Double-click hint on hover (T1) */
.wf1-type-card::before {
  content: 'Double-click to select & continue';
  position: absolute;
  bottom: -24px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: var(--text-muted);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
}

.wf1-type-card:hover::before {
  opacity: 1;
}

.wf1-type-card.last-used::after {
  content: 'Last used';
  position: absolute;
  top: -8px;
  right: 8px;
  background: var(--accent);
  color: white;
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.wf1-type-card-id {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 2px;
}

.wf1-type-card-desc {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.wf1-type-card-meta {
  font-size: 11px;
  color: var(--text-muted);
}

.wf1-type-card-badge {
  display: inline-block;
  font-size: 10px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--warning-bg);
  color: var(--warning-text);
  margin-top: 4px;
}

/* Inventory check step */
.wf1-inventory-status {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 20px;
}

.wf1-inventory-status.has-stock {
  border-color: var(--success-border);
  background: var(--success-bg);
}

.wf1-inventory-status.low-stock {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

.wf1-inventory-status.no-stock {
  border-color: var(--border);
}

.wf1-inventory-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.wf1-inventory-msg {
  font-size: 15px;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 4px;
  line-height: 1.4;
}

.wf1-inventory-detail {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.4;
}

.wf1-inventory-actions {
  display: flex;
  gap: 10px;
  margin-top: 16px;
  flex-wrap: wrap;
}

.wf1-inv-btn {
  padding: 10px 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  color: var(--text);
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.wf1-inv-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.wf1-inv-btn.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.wf1-inv-btn.primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

/* Inline inventory add */
.wf1-inv-add-inline {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-top: 16px;
}

.wf1-inv-add-inline label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.wf1-inv-add-inline input[type="number"] {
  width: 100%;
  max-width: 120px;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  font-family: inherit;
  font-size: 16px;
  text-align: center;
}

.wf1-inv-add-inline input[type="number"]:focus {
  outline: none;
  border-color: var(--accent);
}

.wf1-inv-add-actions {
  display: flex;
  gap: 10px;
  margin-top: 14px;
}

/* Content type choice step */
.wf1-content-choices {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.wf1-content-choice {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: flex-start;
  gap: 16px;
}

.wf1-content-choice:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-content-choice-icon {
  font-size: 28px;
  flex-shrink: 0;
  line-height: 1;
}

.wf1-content-choice-text {
  flex: 1;
}

.wf1-content-choice-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.wf1-content-choice-desc {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.3;
}

/* Quantity in content type step */
.wf1-qty-row {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-top: 20px;
  padding: 16px 20px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
}

.wf1-qty-label {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}

.wf1-qty-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.wf1-qty-btn {
  width: 36px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.wf1-qty-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.wf1-qty-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.wf1-qty-value {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
  min-width: 40px;
  text-align: center;
}

.wf1-qty-hint {
  font-size: 12px;
  color: var(--text-muted);
  text-align: right;
  margin-top: 6px;
}

/* ===== WF1 Step 4: Feasibility Check ===== */
.wf1-feasibility {
  padding: 16px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
}
.wf1-feasibility.ok { background: var(--success-bg, rgba(34,197,94,0.08)); border-left: 4px solid var(--success, #22c55e); }
.wf1-feasibility.warn { background: var(--warning-bg, rgba(234,179,8,0.08)); border-left: 4px solid var(--warning, #eab308); }
.wf1-feasibility.error { background: var(--danger-bg, rgba(239,68,68,0.08)); border-left: 4px solid var(--danger, #ef4444); }
.wf1-feas-icon { font-size: 24px; margin-bottom: 8px; }
.wf1-feas-msg { font-size: 15px; font-weight: 600; color: var(--heading); margin-bottom: 6px; }
.wf1-feas-detail { font-size: 13px; color: var(--text-muted); line-height: 1.5; }
.wf1-feas-actions { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
.wf1-feas-actions .wf1-inv-btn { font-size: 13px; }

/* ===== WF1 Step 5: Sheet Picker ===== */
.wf1-sheet-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.wf1-sheet-card {
  display: flex; align-items: center; gap: 14px;
  padding: 14px 16px; border-radius: var(--radius-sm);
  border: 2px solid var(--border); background: var(--surface);
  cursor: pointer; transition: border-color 0.15s, background 0.15s;
}
.wf1-sheet-card:hover { border-color: var(--accent); }
.wf1-sheet-card.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-sheet-card.create-new { border-style: dashed; }
.wf1-sheet-card.create-new:hover { border-style: solid; }
.wf1-sheet-icon { font-size: 22px; flex-shrink: 0; }
.wf1-sheet-info { flex: 1; min-width: 0; }
.wf1-sheet-name { font-size: 14px; font-weight: 600; color: var(--heading); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.wf1-sheet-meta { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
.wf1-sheet-spots { font-size: 13px; font-weight: 600; color: var(--accent); white-space: nowrap; }
.wf1-sheet-badge {
  display: inline-block; font-size: 10px; font-weight: 600; padding: 2px 7px;
  border-radius: 10px; text-transform: uppercase; margin-left: 6px;
}
.wf1-sheet-badge.dedicated { background: rgba(139,92,246,0.12); color: #8b5cf6; }
.wf1-sheet-badge.open { background: rgba(34,197,94,0.12); color: #22c55e; }
.wf1-sheet-badge.stale { background: rgba(234,179,8,0.12); color: #ca8a04; }
.wf1-sheet-warning { font-size: 12px; color: var(--warning, #ca8a04); margin-top: 6px; padding: 8px 12px; background: var(--warning-bg, rgba(234,179,8,0.06)); border-radius: var(--radius-sm); }

/* ===== WF1 Step 6: Content Editor ===== */
.wf1-editor-wrapper { margin-bottom: 16px; }
.wf1-editor-tools { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
.wf1-editor-tool-btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 6px 12px; font-size: 12px; font-weight: 600;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  background: var(--surface); color: var(--text); cursor: pointer;
  transition: border-color 0.15s;
}
.wf1-editor-tool-btn:hover { border-color: var(--accent); color: var(--accent); }
.wf1-content-actions { display: flex; gap: 8px; margin-top: 12px; }

/* Batch sub-steps */
.wf1-batch-section { margin-bottom: 16px; }
.wf1-batch-section-title { font-size: 14px; font-weight: 600; color: var(--heading); margin-bottom: 8px; }
.wf1-batch-upload {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 28px 16px; text-align: center; cursor: pointer;
  transition: border-color 0.2s; background: var(--surface);
}
.wf1-batch-upload:hover { border-color: var(--accent); }
.wf1-batch-upload-icon { font-size: 28px; margin-bottom: 8px; }
.wf1-batch-upload-text { font-size: 13px; color: var(--text-muted); }
.wf1-batch-upload-zone {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 32px 20px; text-align: center; transition: all 0.2s; background: var(--surface);
}
.wf1-batch-upload-zone:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf1-batch-upload-or { font-size: 12px; color: var(--text-muted); margin: 12px 0; }
.wf1-batch-loaded-success { text-align: center; padding: 20px; }
.wf1-batch-planning { }
.wf1-plan-summary { text-align: center; margin-bottom: 16px; padding: 16px; background: var(--accent-bg); border-radius: var(--radius-sm); }
.wf1-plan-count { font-size: 28px; font-weight: 700; color: var(--accent); }
.wf1-plan-detail { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
.wf1-plan-warning { text-align: center; padding: 20px; }
.wf1-plan-options { display: flex; flex-direction: column; gap: 8px; }
.wf1-plan-option {
  display: flex; align-items: flex-start; gap: 12px; padding: 14px;
  border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; transition: all 0.15s; background: var(--surface);
}
.wf1-plan-option:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf1-plan-option-icon { font-size: 24px; flex-shrink: 0; }
.wf1-plan-option-content { flex: 1; }
.wf1-plan-option-title { font-weight: 600; color: var(--heading); font-size: 14px; }
.wf1-plan-option-desc { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
.wf1-mixed-mode-header {
  display: flex; align-items: flex-start; gap: 12px; padding: 14px;
  background: var(--accent-bg); border: 2px solid var(--accent); border-radius: var(--radius-sm);
  margin-bottom: 12px;
}
.wf1-mixed-mode-icon { font-size: 24px; }
.wf1-mixed-mode-text { font-size: 13px; color: var(--text); line-height: 1.5; }
.wf1-batch-status { font-size: 13px; color: var(--text-muted); margin-top: 8px; padding: 10px 14px; background: var(--surface-alt, var(--surface)); border-radius: var(--radius-sm); border: 1px solid var(--border); }
.wf1-batch-status.success { border-color: var(--success, #22c55e); }
.wf1-batch-template-list { display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto; }
.wf1-batch-template-item {
  padding: 10px 12px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; font-size: 13px; transition: border-color 0.15s;
}
.wf1-batch-template-item:hover { border-color: var(--accent); }
.wf1-batch-template-item.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-batch-template-name { font-weight: 600; color: var(--heading); }
.wf1-batch-template-preview { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
.wf1-batch-mapping { display: flex; flex-direction: column; gap: 6px; }
.wf1-batch-map-row { display: flex; align-items: center; gap: 10px; font-size: 13px; }
.wf1-batch-map-row label { flex: 0 0 100px; font-weight: 600; color: var(--heading); }
.wf1-batch-map-row select { flex: 1; padding: 6px 8px; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 13px; background: var(--surface); color: var(--text); }
.wf1-batch-preview-scroll { max-height: 300px; overflow-y: auto; }
.wf1-batch-preview-label { padding: 8px 12px; border: 1px solid var(--border); border-radius: var(--radius-sm); margin-bottom: 6px; font-size: 12px; line-height: 1.5; background: var(--surface); }
.wf1-batch-preview-count { font-size: 13px; color: var(--text-muted); margin-bottom: 8px; }

/* ===== WF1 Step 5: Mini-Grid in Sheet Picker ===== */
.wf1-sheet-mini-grid {
  display: grid; gap: 1px; background: var(--border); border: 1px solid var(--border);
  border-radius: 3px; padding: 1px; margin-top: 8px;
}
.wf1-sheet-mini-cell {
  aspect-ratio: 1; min-width: 6px; border-radius: 1px; background: var(--surface);
}
.wf1-sheet-mini-cell.used { background: var(--text-faint); }
.wf1-sheet-mini-cell.next { background: var(--accent); opacity: 0.7; }
.wf1-sheet-grid-legend {
  display: flex; gap: 10px; margin-top: 6px; font-size: 10px; color: var(--text-muted);
}
.wf1-sheet-grid-legend span::before {
  content: ''; display: inline-block; width: 8px; height: 8px; border-radius: 2px;
  margin-right: 3px; vertical-align: middle;
}
.wf1-sheet-grid-legend .leg-avail::before { background: var(--surface); border: 1px solid var(--border); }
.wf1-sheet-grid-legend .leg-used::before { background: var(--text-faint); }
.wf1-sheet-grid-legend .leg-next::before { background: var(--accent); opacity: 0.7; }
/* WF1 Orientation Picker (T3) - in-card version */
.wf1-orientation-section {
  margin-top: 8px; padding: 8px 0 0 0; 
  border-top: 1px solid var(--border-light, var(--border));
}
.wf1-orientation-label {
  font-size: 11px; font-weight: 500; color: var(--text-muted); margin-bottom: 6px;
}
.wf1-orientation-options {
  display: flex; gap: 6px; flex-wrap: wrap;
}
.wf1-orientation-opt {
  flex: 1; min-width: 70px; padding: 6px 8px; border: 1px solid var(--border);
  border-radius: var(--radius-sm); cursor: pointer; text-align: center;
  font-size: 11px; color: var(--text); background: var(--surface);
  transition: border-color 0.15s, background 0.15s;
}
.wf1-orientation-opt:hover { border-color: var(--accent); }
.wf1-orientation-opt.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-orientation-opt-icon { font-size: 14px; margin-bottom: 1px; }
.wf1-orientation-opt-text { font-size: 10px; color: var(--text-muted); }
/* Rich formatting badge in WF1 editor */
.wf1-rich-badge {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 11px; color: var(--accent); padding: 4px 10px;
  background: var(--accent-bg); border-radius: var(--radius-sm);
  margin-top: 8px;
}
/* Safari print notice */
.safari-print-notice {
  font-size: 12px; color: var(--warning, #ca8a04); padding: 8px 12px;
  background: var(--warning-bg, rgba(234,179,8,0.06)); border-radius: var(--radius-sm);
  margin-top: 12px; line-height: 1.5;
}

/* ===== WF1 Multi-Sheet Plan ===== */
.wf1-multisheet-plan {
  margin-top: 16px; padding: 14px; border: 2px solid var(--accent);
  border-radius: var(--radius-sm); background: var(--accent-bg);
}
.wf1-multisheet-title {
  font-size: 13px; font-weight: 700; color: var(--accent); margin-bottom: 10px;
  display: flex; align-items: center; gap: 6px;
}
.wf1-multisheet-steps { display: flex; flex-direction: column; gap: 6px; }
.wf1-multisheet-step {
  display: flex; align-items: center; gap: 10px;
  font-size: 13px; color: var(--text); padding: 8px 10px;
  background: var(--surface); border-radius: var(--radius-sm); border: 1px solid var(--border);
}
.wf1-multisheet-step .step-num {
  flex-shrink: 0; width: 22px; height: 22px; border-radius: 50%;
  background: var(--accent); color: #fff; font-size: 11px; font-weight: 700;
  display: flex; align-items: center; justify-content: center;
}
.wf1-multisheet-step .step-detail { flex: 1; }
.wf1-multisheet-step .step-count {
  flex-shrink: 0; font-weight: 600; color: var(--accent); font-size: 12px;
}
.wf1-multisheet-note {
  font-size: 11px; color: var(--text-muted); margin-top: 8px; line-height: 1.5;
}
/* Multi-sheet post-print */
.wf1-postprint-sheets { display: flex; flex-direction: column; gap: 4px; margin: 8px 0 12px; }
.wf1-postprint-sheet-row {
  font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 6px;
}
.wf1-postprint-sheet-row .sheet-icon { opacity: 0.6; }

/* ===== OCR Line-Mapping UI ===== */
.ocr-line-mapper { margin-top: 12px; }
.ocr-lm-title { font-size: 13px; font-weight: 700; color: var(--heading); margin-bottom: 10px; }
.ocr-lm-layout { display: flex; gap: 12px; }
.ocr-lm-source, .ocr-lm-target { flex: 1; min-width: 0; }
.ocr-lm-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; }
.ocr-lm-source-list { display: flex; flex-direction: column; gap: 4px; min-height: 120px; }
.ocr-lm-source-item {
  display: flex; align-items: center; gap: 6px;
  padding: 6px 8px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; font-size: 12px; color: var(--text); background: var(--surface);
  transition: all 0.15s; user-select: none;
}
.ocr-lm-source-item:hover { border-color: var(--accent); }
.ocr-lm-source-item.selected { border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-source-item.assigned { opacity: 0.45; border-style: dashed; }
.ocr-lm-source-item .lm-grip { color: var(--text-faint); font-size: 10px; flex-shrink: 0; }
.ocr-lm-source-item .lm-text { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ocr-lm-source-item .lm-conf { font-size: 10px; color: var(--text-muted); flex-shrink: 0; }
.ocr-lm-source-item .lm-conf.low { color: var(--warning-text); font-weight: 700; }
.ocr-lm-target-slots { display: flex; flex-direction: column; gap: 6px; }
.ocr-lm-slot {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 8px 10px; min-height: 32px; cursor: pointer;
  transition: all 0.15s; display: flex; align-items: center; gap: 6px;
}
.ocr-lm-slot:hover { border-color: var(--accent); }
.ocr-lm-slot.highlight { border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-slot.filled { border-style: solid; border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-slot .slot-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--text-muted);
  flex-shrink: 0; min-width: 42px;
}
.ocr-lm-slot .slot-content { flex: 1; min-width: 0; font-size: 12px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ocr-lm-slot .slot-placeholder { flex: 1; font-size: 11px; color: var(--text-faint); font-style: italic; }
.ocr-lm-slot .slot-clear {
  flex-shrink: 0; background: none; border: none; cursor: pointer;
  font-size: 14px; color: var(--text-muted); padding: 0 2px; line-height: 1;
}
.ocr-lm-slot .slot-clear:hover { color: var(--error-text); }
.ocr-lm-actions { display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end; }
.ocr-lm-actions button { font-size: 12px; padding: 5px 12px; }
.ocr-lm-hint { font-size: 11px; color: var(--text-muted); margin-top: 8px; text-align: center; line-height: 1.5; }
/* Responsive: stack vertically on narrow screens */
@media (max-width: 480px) {
  .ocr-lm-layout { flex-direction: column; }
}

/* ===== WF1 Step 7: Preview ===== */
.wf1-preview-summary { font-size: 14px; color: var(--text-muted); margin-bottom: 16px; }
.wf1-preview-frame {
  border: 2px solid var(--border); border-radius: var(--radius-sm);
  padding: 16px; background: #fff; min-height: 120px;
  display: flex; flex-direction: column; justify-content: center; align-items: center;
}
.wf1-preview-label-box {
  border: 1px dashed #ccc; padding: 10px 14px; max-width: 300px; width: 100%; box-sizing: border-box;
}
.wf1-preview-label-box .preview-line { line-height: 1.4; color: #000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* ===== WF1 Step 8: Post-Print ===== */
.wf1-postprint { text-align: center; padding: 20px 0; }
.wf1-postprint-icon { font-size: 48px; margin-bottom: 12px; }
.wf1-postprint-msg { font-size: 16px; font-weight: 600; color: var(--heading); margin-bottom: 8px; }
.wf1-postprint-detail { font-size: 13px; color: var(--text-muted); margin-bottom: 20px; }
.wf1-postprint-actions { display: flex; flex-direction: column; gap: 10px; max-width: 320px; margin: 0 auto; }
.wf1-postprint-btn {
  display: flex; align-items: center; gap: 10px;
  padding: 12px 16px; border-radius: var(--radius-sm);
  border: 2px solid var(--border); background: var(--surface);
  cursor: pointer; font-size: 13px; color: var(--text);
  transition: border-color 0.15s; text-align: left;
}
.wf1-postprint-btn:hover { border-color: var(--accent); }
.wf1-postprint-btn.primary { border-color: var(--accent); background: var(--accent-bg); }

/* ===== WF2: PRINT SOMETHING AGAIN ===== */
.wf2-progress { display: flex; gap: 8px; justify-content: center; padding: 12px 0; }
.wf2-progress-dot {
  width: 10px; height: 10px; border-radius: 50%;
  background: var(--border); transition: all 0.2s;
}
.wf2-progress-dot.active { background: var(--accent); transform: scale(1.3); }
.wf2-progress-dot.done { background: var(--accent); opacity: 0.5; }

/* Content selector â€” three sections */
.wf2-section-label {
  font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
  color: var(--text-muted); margin: 16px 0 8px; padding: 0 4px;
}
.wf2-section-label:first-child { margin-top: 4px; }

.wf2-content-list {
  display: flex; flex-direction: column; gap: 6px;
  max-height: 420px; overflow-y: auto; padding: 2px;
}
.wf2-content-card {
  background: var(--surface); border: 2px solid var(--border); border-radius: var(--radius-sm);
  padding: 12px 14px; display: flex; align-items: center; gap: 12px;
  cursor: pointer; transition: all 0.15s;
}
.wf2-content-card:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf2-content-card.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf2-content-card-icon { font-size: 22px; opacity: 0.7; flex-shrink: 0; }
.wf2-content-card-info { flex: 1; min-width: 0; }
.wf2-content-card-title {
  font-size: 14px; font-weight: 600; color: var(--heading);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.wf2-content-card-meta { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
.wf2-content-card-badge {
  font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em;
  padding: 2px 6px; border-radius: 4px; flex-shrink: 0;
}
.wf2-content-card-badge.dedicated { background: var(--accent-bg); color: var(--accent); }
.wf2-content-card-badge.history { background: #f0f4ff; color: #5b7db1; }
[data-theme="dark"] .wf2-content-card-badge.history { background: #1a2a4a; color: #7ba3d4; }
.wf2-content-card-actions { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
.wf2-quick-btn {
  background: var(--success, #22c55e); color: white; border: none; border-radius: 4px;
  padding: 4px 10px; font-size: 11px; font-weight: 600; cursor: pointer;
  white-space: nowrap; transition: background 0.15s;
}
.wf2-quick-btn:hover { background: #16a34a; }
[data-theme="dark"] .wf2-quick-btn { background: #15803d; }
[data-theme="dark"] .wf2-quick-btn:hover { background: #22c55e; }

.wf2-search-row {
  display: flex; gap: 8px; margin-bottom: 8px;
}
.wf2-search-input {
  flex: 1; padding: 8px 12px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  font-family: inherit; font-size: 14px; background: var(--surface); color: var(--text);
}
.wf2-search-input:focus { outline: none; border-color: var(--accent); }
.wf2-search-input::placeholder { color: var(--text-muted); }

.wf2-empty { text-align: center; padding: 40px 20px; color: var(--text-muted); }
.wf2-empty-icon { font-size: 40px; margin-bottom: 10px; opacity: 0.5; }
.wf2-empty-text { font-size: 14px; line-height: 1.5; }

/* Quantity step */
.wf2-qty-section { text-align: center; padding: 20px 0; }
.wf2-qty-prompt { font-size: 15px; color: var(--text); margin-bottom: 16px; }
.wf2-qty-prompt strong { color: var(--heading); }
.wf2-qty-controls {
  display: flex; align-items: center; justify-content: center; gap: 12px;
}
.wf2-qty-btn {
  width: 40px; height: 40px; border-radius: 50%; border: 2px solid var(--border);
  background: var(--surface); color: var(--text); font-size: 20px; font-weight: 700;
  cursor: pointer; transition: all 0.15s; display: flex; align-items: center; justify-content: center;
}
.wf2-qty-btn:hover { border-color: var(--accent); color: var(--accent); }
.wf2-qty-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.wf2-qty-value {
  font-size: 32px; font-weight: 700; color: var(--heading); min-width: 60px; text-align: center;
}
.wf2-qty-hint { font-size: 13px; color: var(--text-muted); margin-top: 12px; }

/* Sheet validation step */
.wf2-sheet-status {
  padding: 16px; border-radius: var(--radius-sm); margin-bottom: 12px;
  display: flex; align-items: flex-start; gap: 12px;
}
.wf2-sheet-status.ok { background: #e8f5e9; border: 1px solid #a5d6a7; }
.wf2-sheet-status.warn { background: #fff8e1; border: 1px solid #ffe082; }
.wf2-sheet-status.error { background: #ffebee; border: 1px solid #ef9a9a; }
[data-theme="dark"] .wf2-sheet-status.ok { background: #1b3a1b; border-color: #2e5e2e; }
[data-theme="dark"] .wf2-sheet-status.warn { background: #3a3418; border-color: #5e5428; }
[data-theme="dark"] .wf2-sheet-status.error { background: #3a1b1b; border-color: #5e2e2e; }
.wf2-sheet-status-icon { font-size: 24px; flex-shrink: 0; }
.wf2-sheet-status-text { font-size: 14px; color: var(--text); line-height: 1.5; }

/* ===== RESPONSIVE ===== */
@media (max-width: 600px) {
  .app-shell {
    padding: 16px;
  }
  
  .workflow-card {
    padding: 16px 18px;
  }
  
  .workflow-icon {
    font-size: 28px;
  }
  
  .workflow-title {
    font-size: 16px;
  }
  
  .secondary-links {
    gap: 6px;
  }
  
  .secondary-link {
    padding: 6px 12px;
    font-size: 12px;
  }
}

/* ===== BATCH IMPORT ===== */
.batch-import-modal { max-width: 560px; }

.batch-file-zone {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 100px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: all 0.15s;
}

.batch-file-zone:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.batch-file-zone.has-file {
  border-style: solid;
  border-color: var(--success-border);
  background: var(--success-bg);
  cursor: default;
}

.batch-file-zone .file-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.batch-file-zone .file-prompt {
  font-size: 13px;
  color: var(--text-muted);
}

.batch-file-zone .file-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 6px;
}

.batch-file-zone .file-info {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.batch-col-mapping {
  margin-bottom: 16px;
  max-height: 180px;
  overflow-y: auto;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px;
}

.batch-col-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  border-bottom: 1px solid var(--border-light);
}

.batch-col-row:last-child {
  border-bottom: none;
}

.batch-col-header {
  flex: 1;
  font-size: 12px;
  font-weight: 600;
  color: var(--heading);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.batch-col-arrow {
  color: var(--text-muted);
  font-size: 12px;
}

.batch-col-token {
  min-width: 120px;
  padding: 4px 8px;
  border: 1px solid var(--input-border);
  border-radius: 4px;
  font-size: 11px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.batch-col-token:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-summary {
  padding: 12px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  background: var(--accent-bg);
  border: 1px solid var(--border);
  font-size: 13px;
  color: var(--accent-text);
}

.batch-summary-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
}

.batch-summary-row .label {
  color: var(--text-secondary);
}

.batch-summary-row .value {
  font-weight: 700;
  font-family: var(--mono);
}

.batch-job-name-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 16px;
}

.batch-job-name-row label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  white-space: nowrap;
}

.batch-job-name-row input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.batch-job-name-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-preview-section {
  margin-bottom: 16px;
}

.batch-preview-title {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

.batch-preview-cards {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 4px 0;
}

.batch-preview-card {
  flex-shrink: 0;
  width: 150px;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-size: 10px;
  line-height: 1.4;
  color: var(--text);
  font-family: Arial, sans-serif;
}

.batch-preview-card .preview-line {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
}

.batch-preview-card .preview-line.align-left { justify-content: flex-start; }
.batch-preview-card .preview-line.align-center { justify-content: center; }
.batch-preview-card .preview-line.align-right { justify-content: flex-end; }

.batch-preview-more {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--text-muted);
  font-weight: 600;
  padding: 0 12px;
}

/* Job Banner */
.job-banner {
  background: var(--accent-bg);
  border: 2px solid var(--accent);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 20px;
}

.job-banner-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.job-banner-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 8px;
}

.job-banner-title .job-icon {
  font-size: 18px;
}

.job-banner-actions {
  display: flex;
  gap: 8px;
}

.job-banner-progress {
  margin-bottom: 12px;
}

.job-progress-bar {
  height: 8px;
  background: var(--border);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 6px;
}

.job-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s;
}

.job-progress-text {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-align: center;
}

.job-banner-info {
  display: flex;
  gap: 16px;
  font-size: 13px;
  color: var(--text-secondary);
}

/* Job Complete Modal */
.job-complete-modal { max-width: 400px; }

.job-complete-summary {
  text-align: center;
  padding: 20px 0;
}

.job-complete-icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.job-complete-count {
  font-size: 36px;
  font-weight: 700;
  color: var(--heading);
}

.job-complete-label {
  font-size: 14px;
  color: var(--text-secondary);
}

.job-remainder-options {
  padding: 16px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin-top: 16px;
}

.job-remainder-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 12px;
}

.job-remainder-option {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 8px 0;
  cursor: pointer;
}

.job-remainder-option input {
  margin-top: 2px;
}

.job-remainder-option-label {
  font-size: 13px;
  color: var(--text);
}

.job-remainder-option-desc {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* ===== SPLIT SHEET MODAL ===== */
.split-modal { max-width: 460px; }
.split-summary {
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 14px;
  color: var(--text);
  margin-bottom: 16px;
  text-align: center;
}
.split-form { display: flex; flex-direction: column; gap: 14px; }
.split-form-group { display: flex; flex-direction: column; gap: 6px; }
.split-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
.split-form label {
  font-size: 14px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.split-form label input[type="radio"] {
  margin: 0;
  accent-color: var(--accent);
}
.split-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.split-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}

/* ===== CLIPBOARD IMPORT MODAL ===== */
.import-modal { max-width: 560px; }
.import-summary {
  padding: 10px 14px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 13px;
  color: var(--text);
  margin-bottom: 14px;
  text-align: center;
}
.import-form { display: flex; flex-direction: column; gap: 14px; }
.import-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; }
.import-form select, .import-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  width: 100%;
}
.import-form select:focus, .import-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}
.import-stepper {
  display: inline-flex;
  align-items: center;
  gap: 0;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  overflow: hidden;
}
.import-stepper button {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.import-stepper button:hover { background: var(--accent-bg); color: var(--accent); }
.import-stepper span {
  min-width: 36px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  background: var(--input-bg);
  padding: 6px 8px;
}
.import-col-mapping { display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; }
.import-col-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 10px;
  background: var(--surface-alt);
  border-radius: 6px;
}
.import-col-row .col-sample {
  flex: 1;
  font-size: 12px;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.import-col-row select {
  width: auto;
  min-width: 100px;
  padding: 4px 8px;
  font-size: 12px;
}
.import-preview-area {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  padding: 10px;
  background: var(--surface-alt);
  border-radius: 6px;
  min-height: 60px;
}
.import-preview-label {
  padding: 6px 10px;
  background: var(--preview-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: Arial, sans-serif;
  font-size: 10px;
  color: var(--preview-text);
  line-height: 1.3;
}
.import-name-preview { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

/* ===== PRINT CSS ===== */
@media print {
  @page { size: letter; margin: 0; }
  html, body { 
    height: 11in !important; 
    width: 8.5in !important; 
    margin: 0 !important; 
    padding: 0 !important; 
    overflow: hidden !important; 
    background: #fff !important; 
    color: #000 !important; 
  }
  body > *:not(.print-sheet) { 
    display: none !important; 
    height: 0 !important; 
    width: 0 !important; 
    overflow: hidden !important; 
    position: absolute !important; 
    visibility: hidden !important; 
  }
  .print-sheet { 
    display: block !important; 
    visibility: visible !important; 
    position: relative !important; 
    width: 8.5in; 
    height: 11in; 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    box-sizing: border-box; 
  }
  .print-label {
    position: absolute; 
    overflow: hidden; 
    font-family: Arial, sans-serif;
    line-height: 1.3; 
    color: #000; 
    display: flex; 
    flex-direction: column;
    box-sizing: border-box;
  }
  .print-label .print-line { 
    width: 100%; 
    display: flex; 
    white-space: nowrap; 
    overflow: hidden; 
  }
  .print-label .print-line.align-left { justify-content: flex-start; text-align: left; }
  .print-label .print-line.align-center { justify-content: center; text-align: center; }
  .print-label .print-line.align-right { justify-content: flex-end; text-align: right; }
  .print-label .print-line.align-split { justify-content: space-between; text-align: left; }
  .print-label .print-line.align-split-fill { display: flex; justify-content: space-between; align-items: flex-end; gap: 12px; }
  .print-label .print-line.align-split-fill .split-fill-left,
  .print-label .print-line.align-split-fill .split-fill-right { display: flex; align-items: flex-end; gap: 3px; flex: 1; }
  .print-label .print-line.align-split-fill .split-fill-right { justify-content: flex-end; }
  .print-label .print-line.fill-line { display: flex; align-items: flex-end; gap: 3px; }
  .print-label .print-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .print-label .print-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid #000; min-width: 0.25in; margin-bottom: 1px; }
  .print-label.empty { color: transparent; }
  /* Tent card printing styles */
  .print-label.tent-card { position: relative; }
  .print-label .fold-line { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px dashed #bbb; z-index: 1; }
  .print-label .tent-top, .print-label .tent-bottom { position: absolute; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; padding: 0.1in; box-sizing: border-box; }
  .print-label .tent-top { top: 0; height: 50%; }
  .print-label .tent-bottom { bottom: 0; height: 50%; transform: rotate(180deg); }
}

.print-sheet { display: none; }

/* ===== BYOAI - AI Assistant Styles ===== */
.ai-key-modal {
  max-width: 420px;
}

.ai-key-modal h3 {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}

.ai-key-input-wrapper {
  margin: 16px 0;
}

.ai-key-input {
  width: 100%;
  padding: 12px;
  font-family: var(--mono);
  font-size: 13px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
}

.ai-key-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-key-hint {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 8px;
}

.ai-key-providers {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 12px;
  font-size: 12px;
  color: var(--text-secondary);
}

.ai-key-providers a {
  color: var(--accent);
  text-decoration: none;
}

.ai-key-providers a:hover {
  text-decoration: underline;
}

.ai-key-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px;
  border-radius: var(--radius-sm);
  background: var(--success-bg);
  color: var(--success-text);
  margin-bottom: 16px;
}

.ai-key-status.no-key {
  background: var(--surface-alt);
  color: var(--text-secondary);
}

.ai-ask-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
}

.ai-ask-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

.ai-ask-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.ai-prompt-input-wrapper {
  margin: 16px 0;
}

.ai-prompt-input {
  width: 100%;
  padding: 12px;
  font-size: 14px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 80px;
}

.ai-prompt-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-prompt-input::placeholder {
  color: var(--text-muted);
}

.ai-generating {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  font-size: 13px;
}

.ai-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: ai-spin 0.8s linear infinite;
}

@keyframes ai-spin {
  to { transform: rotate(360deg); }
}

.ai-error {
  padding: 12px;
  background: var(--error-bg);
  color: var(--error-text);
  border-radius: var(--radius-sm);
  font-size: 13px;
  margin-top: 12px;
}

.ai-settings-section {
  border-top: 1px solid var(--border);
  padding-top: 16px;
  margin-top: 16px;
}

.ai-settings-section h4 {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* ===== AI Preview Modal ===== */
.ai-preview-modal {
  max-width: 540px;
}

.ai-preview-section {
  margin-bottom: 16px;
}

.ai-preview-section-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-understanding {
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-size: 14px;
  color: var(--text);
  border-left: 3px solid var(--accent);
}

.ai-preview-labels {
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  overflow: hidden;
  max-height: 280px;
  overflow-y: auto;
}

.ai-preview-label-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
}

.ai-preview-label-item:last-child {
  border-bottom: none;
}

.ai-preview-label-item:hover {
  background: var(--surface-alt);
}

.ai-preview-label-num {
  min-width: 24px;
  height: 24px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 600;
  flex-shrink: 0;
}

.ai-preview-label-content {
  flex: 1;
  min-width: 0;
}

.ai-preview-label-text {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  word-break: break-word;
}

.ai-preview-label-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-preview-label-edit {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 14px;
  transition: all 0.15s;
  flex-shrink: 0;
}

.ai-preview-label-edit:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.ai-preview-settings {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  font-size: 13px;
  color: var(--text-secondary);
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.ai-preview-setting {
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-setting strong {
  color: var(--text);
}

.ai-preview-skip-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 8px 0;
}

.ai-preview-skip-label input {
  cursor: pointer;
}

.ai-preview-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview inline edit mode */
.ai-preview-label-item.editing {
  background: var(--accent-bg);
}

.ai-preview-label-item.editing .ai-preview-label-text {
  display: none;
}

.ai-preview-edit-input {
  width: 100%;
  padding: 8px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--accent);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
}

.ai-preview-edit-input:focus {
  outline: none;
}

.ai-preview-edit-actions {
  display: flex;
  gap: 6px;
  margin-top: 6px;
}

.ai-preview-edit-actions button {
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  border: none;
}

.ai-preview-edit-save {
  background: var(--accent);
  color: white;
}

.ai-preview-edit-cancel {
  background: var(--surface-alt);
  color: var(--text-secondary);
  border: 1px solid var(--border) !important;
}

/* Refine panel */
.ai-refine-panel {
  display: none;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview error state */
.ai-preview-error {
  padding: 24px;
  text-align: center;
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  border-radius: var(--radius-sm);
}

.ai-preview-error-icon {
  font-size: 32px;
  margin-bottom: 12px;
}

.ai-preview-error-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--warning-text);
  margin-bottom: 8px;
}

.ai-preview-error-message {
  font-size: 14px;
  color: var(--text);
  line-height: 1.5;
  margin-bottom: 12px;
}

.ai-preview-error-hint {
  font-size: 13px;
  color: var(--text-muted);
  font-style: italic;
}

.ai-refine-panel.visible {
  display: block;
}

.ai-refine-original {
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.ai-refine-original strong {
  color: var(--text-secondary);
}

.ai-refine-input {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 60px;
}

.ai-refine-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-refine-input::placeholder {
  color: var(--text-muted);
}

.ai-refine-actions {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

/* ===== EMOJI PICKER (Full Editor) ===== */
.fe-emoji-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.fe-emoji-toggle {
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.fe-emoji-toggle:hover { border-color: var(--accent); }
.fe-emoji-toggle.active { border-color: var(--accent); background: var(--accent-bg); }
.fe-emoji-panel {
  display: none;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-lg);
  padding: 10px;
  margin-bottom: 12px;
}
.fe-emoji-panel.visible { display: block; }
.fe-emoji-search {
  width: 100%;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 13px;
  font-family: inherit;
  margin-bottom: 8px;
}
.fe-emoji-search:focus { outline: none; border-color: var(--accent); }
.fe-emoji-search::placeholder { color: var(--text-faint); }
.fe-emoji-scroll { max-height: 220px; overflow-y: auto; }
.fe-emoji-category { margin-bottom: 8px; }
.fe-emoji-category-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 4px;
}
.fe-emoji-grid { display: flex; flex-wrap: wrap; gap: 2px; }
.fe-emoji-btn {
  width: 34px;
  height: 34px;
  border: none;
  border-radius: 6px;
  background: transparent;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.1s;
}
.fe-emoji-btn:hover { background: var(--accent-bg); }

/* ===== OCR SCAN MODAL ===== */
.ocr-image-area {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 8px;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 140px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: border-color 0.15s;
}
.ocr-image-area:hover { border-color: var(--accent); }
.ocr-image-area.has-image { cursor: default; border-style: solid; padding: 12px; }
.ocr-image-area img {
  max-width: 100%;
  max-height: 220px;
  border-radius: 4px;
  object-fit: contain;
}
.ocr-placeholder {
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  line-height: 1.5;
}
.ocr-rotation-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 12px;
}
.ocr-rotate-btn {
  padding: 6px 14px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  transition: all 0.15s;
}
.ocr-rotate-btn:hover { border-color: var(--accent); background: var(--accent-bg); }
.ocr-rotation-label {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
  text-align: center;
}
.ocr-progress {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 0;
}
.ocr-progress-bar {
  flex: 1;
  height: 8px;
  background: var(--surface-alt);
  border-radius: 4px;
  overflow: hidden;
}
.ocr-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s ease;
}
.ocr-progress-text {
  font-size: 12px;
  color: var(--text-secondary);
  min-width: 90px;
  text-align: right;
  font-family: var(--mono);
}
.ocr-results-area {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}
.ocr-results-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.ocr-result-line {
  display: flex;
  align-items: center;
  gap: 8px;
}
.ocr-result-line input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 13px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.ocr-result-line input:focus { outline: none; border-color: var(--accent); }
.ocr-result-line input.low-confidence { border-color: var(--warning-text); background: var(--warning-bg); }
.ocr-result-line .ocr-conf {
  font-size: 10px;
  font-family: var(--mono);
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
}
.ocr-result-line .ocr-conf.low { color: var(--warning-text); font-weight: 700; }
.ocr-result-line .ocr-line-remove {
  width: 28px;
  height: 28px;
  border: none;
  background: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  flex-shrink: 0;
}
.ocr-result-line .ocr-line-remove:hover { background: var(--error-bg); color: var(--error-text); }
.ocr-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
  font-style: italic;
}

/* ===== INVENTORY BREAKDOWN BAR ===== */
.inventory-breakdown {
  margin-bottom: 16px;
}
.inventory-breakdown-bar {
  display: flex;
  height: 12px;
  border-radius: 6px;
  overflow: hidden;
  background: var(--surface-alt);
  margin-bottom: 8px;
}
.inventory-breakdown-segment {
  height: 100%;
  min-width: 2px;
  transition: width 0.3s ease;
}
.inventory-breakdown-segment.shelf { background: var(--success-text); }
.inventory-breakdown-segment.assigned { background: var(--accent); }
.inventory-breakdown-segment.partial { background: var(--warning-text); }
.inventory-breakdown-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 12px;
}
.inventory-breakdown-item {
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--text-secondary);
}
.inventory-breakdown-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}
.inventory-breakdown-dot.shelf { background: var(--success-text); }
.inventory-breakdown-dot.assigned { background: var(--accent); }
.inventory-breakdown-dot.partial { background: var(--warning-text); }
.inventory-burn-rate {
  margin-top: 8px;
  padding: 8px 12px;
  background: var(--surface-hover, #f8f9fa);
  border-radius: 6px;
  font-size: 12px;
  color: var(--text-muted);
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}
.inventory-burn-stat { display: flex; align-items: center; gap: 4px; }
.inventory-burn-stat strong { color: var(--text); font-weight: 600; }
.inventory-burn-stat.warn strong { color: var(--warning-text); }
.inventory-burn-stat.danger strong { color: var(--danger, #dc2626); }
.inventory-breakdown-value {
  font-weight: 600;
  font-family: var(--mono);
}

/* ===== HISTORY TAB IMPROVEMENTS ===== */
.history-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}
.history-search {
  flex: 1;
  min-width: 200px;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.history-search:focus { outline: none; border-color: var(--accent); }
.history-search::placeholder { color: var(--text-faint); }
.history-filter-select {
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  min-width: 140px;
}
.history-filter-select:focus { outline: none; border-color: var(--accent); }
.history-date-group {
  margin-bottom: 20px;
}
.history-date-header {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border-light);
}
.history-group-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.history-card-checkbox {
  width: 20px;
  height: 20px;
  margin-right: 4px;
  cursor: pointer;
}
.history-bulk-actions {
  display: flex;
  gap: 10px;
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  align-items: center;
}
.history-bulk-count {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent-text);
  margin-right: auto;
}
.history-bulk-btn {
  padding: 8px 14px;
  background: var(--accent);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: #fff;
  cursor: pointer;
  transition: all 0.15s;
}
.history-bulk-btn:hover { background: var(--accent-hover); }
.history-bulk-btn.secondary {
  background: transparent;
  border: 2px solid var(--accent);
  color: var(--accent);
}
.history-bulk-btn.secondary:hover {
  background: var(--accent-bg);
}
.history-no-results {
  text-align: center;
  padding: 32px;
  color: var(--text-muted);
  font-size: 14px;
}
</style>
</head>
<body>

<div class="app-shell" id="appShell">
  <!-- Header -->
  <header class="app-header">
    <div class="app-title">
      ðŸ·ï¸ LabelKeeper
      <span class="version">v3.17.0</span>
    </div>
    <div class="header-actions">
      <button class="icon-btn" onclick="openSettings()" title="Settings">âš™ï¸</button>
    </div>
  </header>

  <!-- Tab Bar -->
  <nav class="tab-bar" id="tabBar">
    <button class="tab-btn active" data-tab="workflows" onclick="switchTab('workflows')">Workflows</button>
    <button class="tab-btn" data-tab="sheets" onclick="switchTab('sheets')">Sheets</button>
    <button class="tab-btn" data-tab="saved" onclick="switchTab('saved')">Content</button>
    <button class="tab-btn" data-tab="templates" onclick="switchTab('templates')">Templates</button>
    <button class="tab-btn" data-tab="inventory" onclick="switchTab('inventory')">Inventory</button>
    <button class="tab-btn" data-tab="history" onclick="switchTab('history')">History</button>
  </nav>

  <!-- Workflow Hub (Workflows Tab) -->
  <main class="workflow-hub active" id="workflowHub">
    <div>
      <h2 class="workflow-heading">What would you like to do?</h2>
    </div>
    
    <div class="workflow-cards-row">
      <div class="workflow-card-primary" onclick="wf1Start()">
        <div class="workflow-icon">ðŸ–¨ï¸</div>
        <div class="workflow-title">Print Something New</div>
        <div class="workflow-desc">Create new labels â€” single design or a mailing list</div>
      </div>
      
      <div class="workflow-card-primary" onclick="wf2Start()">
        <div class="workflow-icon">ðŸ”„</div>
        <div class="workflow-title">Print Something Again</div>
        <div class="workflow-desc">Reprint from your saved content or history</div>
      </div>
    </div>
    
    <!-- AI conversational prompt â€” only visible when AI key is set -->
    <div class="workflow-ai-prompt" id="workflowAiPrompt" style="display:none;">
      <div class="ai-conv-input-row">
        <span class="ai-conv-sparkle">âœ¨</span>
        <input type="text" class="ai-conv-input" id="aiConvInput" 
          placeholder="...or tell me what you need" 
          onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();aiConvSend()}"
          autocomplete="off">
        <button class="ai-conv-send" id="aiConvSendBtn" onclick="aiConvSend()" title="Send">
          <span class="ai-conv-send-icon">â†’</span>
        </button>
      </div>
      <div class="ai-conv-suggestions" id="aiConvSuggestions">
        <span class="ai-conv-chip" onclick="aiConvFill('I need address labels')">ðŸ“¬ Address labels</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Print name badges for a meeting')">ðŸ‘‹ Name badges</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Make pantry labels')">ðŸ·ï¸ Organize</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Reprint my last labels')">ðŸ”„ Reprint</span>
      </div>
      <div class="ai-conv-status" id="aiConvStatus" style="display:none;">
        <div class="ai-conv-thinking">
          <div class="ai-spinner"></div>
          <span id="aiConvStatusText">Thinking...</span>
        </div>
      </div>
      <div class="ai-conv-response" id="aiConvResponse" style="display:none;"></div>
    </div>
    
    <!-- Quick Actions section (T10-T11) - populated dynamically -->
    <div class="quick-actions-section" id="quickActionsSection">
      <!-- Populated by renderQuickActions() -->
    </div>
  </main>

  <!-- Tab Panels (Power Mode) -->
  <div id="tabPanels">
    <div class="tab-panel" id="panel-sheets">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“„</div>
        <div class="panel-placeholder-text">Your label sheets will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-saved">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ’¾</div>
        <div class="panel-placeholder-text">Saved content will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-templates">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“</div>
        <div class="panel-placeholder-text">Templates will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-inventory">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“¦</div>
        <div class="panel-placeholder-text">Inventory tracking will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-history">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“œ</div>
        <div class="panel-placeholder-text">Print history will appear here</div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" style="max-width: 440px;">
    <div class="modal-header">
      <div class="modal-title">Settings</div>
      <button class="modal-close" onclick="closeSettings()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="setting-row">
        <div>
          <div class="setting-label">Dark Mode</div>
          <div class="setting-desc">Use dark color theme</div>
        </div>
        <div class="toggle" id="darkModeToggle" onclick="toggleDarkMode()">
          <div class="toggle-thumb"></div>
        </div>
      </div>
      
      <div class="setting-row" style="margin-top: 16px;">
        <div style="flex: 1;">
          <div class="setting-label">Quick Actions</div>
          <div class="setting-desc">Number of recent prints to show on home screen (0 = hide)</div>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="quickActionsCount" min="0" max="10" step="1" style="width: 60px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updateQuickActionsCount()">
        </div>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Advanced</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Print calibration settings. Safari's print preview may not accurately show label positions, but the actual print is usually correct at 1.0. Only reduce below 1.0 if labels are actually misaligned on paper.
      </div>
      
      <div class="setting-row" style="margin-bottom: 12px;">
        <div style="flex: 1;">
          <div class="setting-label">Safari Vertical Scale</div>
          <div class="setting-desc" style="font-size: 11px;">Compresses labels vertically to fit Safari's print area (0.90-1.0)</div>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="safariVScale" min="0.90" max="1.0" step="0.01" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
        </div>
      </div>
      
      <div class="setting-row" style="gap: 16px;">
        <div style="flex: 1;">
          <div class="setting-label">Manual Vertical Offset</div>
          <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
            <input type="number" id="printOffsetTop" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
            <span style="color: var(--text-muted); font-size: 13px;">in</span>
          </div>
        </div>
        <div style="flex: 1;">
          <div class="setting-label">Manual Horizontal Offset</div>
          <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
            <input type="number" id="printOffsetLeft" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
            <span style="color: var(--text-muted); font-size: 13px;">in</span>
          </div>
        </div>
      </div>
      
      <div class="setting-row" style="margin-top: 16px;">
        <div>
          <div class="setting-label">Show Label Boundaries</div>
          <div class="setting-desc">Print light gray rectangles showing label positions for alignment testing</div>
        </div>
        <div class="toggle" id="labelBoundariesToggle" onclick="toggleLabelBoundaries()">
          <div class="toggle-thumb"></div>
        </div>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Data Management</div>
      
      <div class="settings-data-stats" id="settingsDataStats">
        <!-- Populated by JS -->
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Device Sync</div>
      
      <!-- Device Role Selector -->
      <div class="setting-row" style="margin-bottom: 16px;">
        <div class="setting-label">This device is:</div>
        <div class="device-role-selector" id="deviceRoleSelector">
          <button class="device-role-btn" data-role="primary" onclick="setDeviceRole('primary')">
            <span class="role-icon">ðŸ’»</span>
            <span class="role-name">Primary</span>
            <span class="role-desc">Full access, can print</span>
          </button>
          <button class="device-role-btn" data-role="satellite" onclick="setDeviceRole('satellite')">
            <span class="role-icon">ðŸ“±</span>
            <span class="role-name">Satellite</span>
            <span class="role-desc">Capture content only</span>
          </button>
        </div>
      </div>
      
      <!-- Primary mode buttons -->
      <div id="syncPrimaryUI">
        <div class="setting-desc" style="margin-bottom: 12px;">
          Sync content between your primary and satellite devices.
        </div>
        <div class="settings-btn-row">
          <button class="settings-action-btn" onclick="primaryReceiveFromSatellite()">
            <span>ðŸ“¥</span> Receive from Satellite
          </button>
          <button class="settings-action-btn" onclick="primaryShareToSatellite()">
            <span>ðŸ“¤</span> Share to Satellite
          </button>
        </div>
        <div class="settings-btn-row" style="margin-top: 8px;">
          <button class="settings-action-btn secondary" onclick="primaryTransferRole()">
            <span>ðŸ”„</span> Transfer Primary to Another Device
          </button>
        </div>
      </div>
      
      <!-- Satellite mode buttons -->
      <div id="syncSatelliteUI" style="display: none;">
        <div class="setting-desc" style="margin-bottom: 12px;">
          Content you create here will sync to your primary device.
        </div>
        
        <!-- Pending queue display -->
        <div id="satellitePendingSection" style="margin-bottom: 16px;">
          <div class="setting-label" style="margin-bottom: 8px;">Pending sync (<span id="satellitePendingCount">0</span> items):</div>
          <div id="satellitePendingList" class="satellite-pending-list">
            <!-- Populated by JS -->
          </div>
        </div>
        
        <div class="settings-btn-row">
          <button class="settings-action-btn" onclick="satelliteShareToPrimary()">
            <span>ðŸ“¤</span> Share to Primary
          </button>
          <button class="settings-action-btn" onclick="satelliteReceiveFromPrimary()">
            <span>ðŸ“¥</span> Receive from Primary
          </button>
        </div>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Backup &amp; Restore</div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="exportAllData()">
          <span>ðŸ“¤</span> Export Backup
        </button>
        <label class="settings-action-btn">
          <span>ðŸ“¥</span> Import Backup
          <input type="file" accept=".json" style="display:none;" onchange="importData(this.files[0])">
        </label>
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn secondary" onclick="showWelcome()">
          <span>ðŸ‘‹</span> Show Welcome Screen
        </button>
        <button class="settings-action-btn danger" onclick="clearAllData()">
          <span>ðŸ—‘ï¸</span> Clear All Data
        </button>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">AI Integration</div>
      
      <!-- BYOAI Status -->
      <div id="aiKeyStatus" class="ai-key-status no-key">
        <span>ðŸ”‘</span>
        <span id="aiKeyStatusText">No API key configured</span>
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" id="aiKeyConfigBtn" onclick="showAIKeyModal()">
          <span>ðŸ”‘</span> <span id="aiKeyConfigBtnText">Add API Key</span>
        </button>
        <button class="settings-action-btn secondary" id="aiKeyClearBtn" onclick="clearAIKey()" style="display: none;">
          <span>ðŸ—‘ï¸</span> Remove Key
        </button>
      </div>
      
      <div class="setting-desc" style="margin: 12px 0;">
        Add your own API key to enable "âœ¨ Ask AI" in the editor. Your key stays on this device only.
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">External AI (Copy/Paste)</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Use any AI (Claude, ChatGPT, etc.) to generate labels. Copy the prompt below and paste AI-generated labels directly into the editor.
      </div>
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showAIPromptModal()">
          <span>ðŸ¤–</span> View AI Prompt
        </button>
        <button class="settings-action-btn secondary" onclick="copyDeepLinkExample()">
          <span>ðŸ”—</span> Copy Link Format
        </button>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Help</div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showShortcutsModal()">
          <span>âŒ¨ï¸</span> Keyboard Shortcuts
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Modal -->
<div class="modal-overlay" id="shortcutsModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <div class="modal-title">Keyboard Shortcuts</div>
      <button class="modal-close" onclick="closeShortcutsModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="shortcuts-section">
        <div class="shortcuts-title">Global</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Esc</span>
          <span class="shortcut-desc">Close modal or wizard</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">?</span>
          <span class="shortcut-desc">Show this help (when not typing)</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Text Editor / OCR</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Ctrl+V</span>
          <span class="shortcut-desc">Paste text or image</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Enter</span>
          <span class="shortcut-desc">Confirm dialog / Submit form</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Navigation</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Tab</span>
          <span class="shortcut-desc">Move between fields</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Prompt Modal -->
<div class="modal-overlay" id="aiPromptModal">
  <div class="modal" style="max-width: 560px;">
    <div class="modal-header">
      <div class="modal-title">AI Integration</div>
      <button class="modal-close" onclick="closeAIPromptModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ“‹ Copy this prompt to your AI assistant:</h3>
        <div class="ai-prompt-box" id="aiPromptBox">
          <!-- Populated by JS -->
        </div>
        <button class="ai-prompt-copy-btn" onclick="copyAIPrompt()">
          <span>ðŸ“‹</span> Copy Prompt
        </button>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ¤– How it works:</h3>
        <ol class="ai-prompt-steps">
          <li>Copy the prompt above and paste it into Claude, ChatGPT, or any AI</li>
          <li>Ask the AI to generate labels (e.g., "Create address labels for John Smith at 123 Main St")</li>
          <li>Copy the AI's output</li>
          <li>Paste into LabelKeeper's text editor â€” it auto-detects the format!</li>
        </ol>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ”— Deep Link Format:</h3>
        <div class="ai-prompt-example" style="font-family: var(--mono); font-size: 12px; background: var(--surface-alt); padding: 12px; border-radius: 8px; word-break: break-all;">
          labelkeeper.html?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1
        </div>
        <div class="setting-desc" style="margin-top: 8px;">
          Use pipe (|) to separate lines. URL-encode special characters.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Key Setup Modal (BYOAI) -->
<div class="modal-overlay" id="aiKeyModal">
  <div class="modal ai-key-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Enable AI Assistant</div>
      <button class="modal-close" onclick="closeAIKeyModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <p style="color: var(--text-secondary); margin-bottom: 16px;">
        Paste your API key to use AI features. Your key stays on this device only â€” it's never sent anywhere except directly to your chosen AI provider.
      </p>
      
      <div class="ai-key-input-wrapper">
        <input type="password" class="ai-key-input" id="aiKeyInput" placeholder="sk-ant-... or sk-..." autocomplete="off">
        <div class="ai-key-hint">
          Works with: <strong>Claude</strong> â€¢ <strong>OpenAI</strong> â€¢ <strong>Gemini</strong>
        </div>
      </div>
      
      <div class="ai-key-providers">
        <span>Get a key:</span>
        <a href="https://console.anthropic.com/settings/keys" target="_blank">Claude â†’</a>
        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI â†’</a>
        <a href="https://aistudio.google.com/app/apikey" target="_blank">Gemini â†’</a>
      </div>
      
      <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIKeyModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveAIKey()">Save & Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Modal -->
<div class="modal-overlay" id="aiCategoryModal">
  <div class="modal" style="max-width: 500px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ What kind of labels?</div>
      <button class="modal-close" onclick="closeAICategoryModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-category-grid">
        <div class="ai-category-card" onclick="selectAICategory('address')">
          <div class="ai-category-icon">ðŸ“¬</div>
          <div class="ai-category-title">Address</div>
          <div class="ai-category-desc">Return address or shipping labels</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('gift')">
          <div class="ai-category-icon">ðŸŽ</div>
          <div class="ai-category-title">Gift</div>
          <div class="ai-category-desc">Gift tags for any occasion</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('organize')">
          <div class="ai-category-icon">ðŸ·ï¸</div>
          <div class="ai-category-title">Organize</div>
          <div class="ai-category-desc">Pantry, files, bins, storage</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('moving')">
          <div class="ai-category-icon">ðŸ“¦</div>
          <div class="ai-category-title">Moving</div>
          <div class="ai-category-desc">Box labels with room & contents</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('nametag')">
          <div class="ai-category-icon">ðŸ‘‹</div>
          <div class="ai-category-title">Name Tag</div>
          <div class="ai-category-desc">Name badges for events</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('custom')">
          <div class="ai-category-icon">âœï¸</div>
          <div class="ai-category-title">Custom</div>
          <div class="ai-category-desc">Describe anything you need</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Form Modal -->
<div class="modal-overlay" id="aiFormModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <button class="modal-back" onclick="backToAICategories()" style="background:none;border:none;font-size:20px;cursor:pointer;color:var(--text-secondary);margin-right:8px;">â†</button>
      <div class="modal-title" id="aiFormTitle">âœ¨ Address Labels</div>
      <button class="modal-close" onclick="closeAIFormModal()">Ã—</button>
    </div>
    <div class="modal-body" id="aiFormBody">
      <!-- Form content injected by JS -->
    </div>
  </div>
</div>

<!-- AI Generate Modal (BYOAI) -->
<div class="modal-overlay" id="aiGenerateModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Ask AI</div>
      <button class="modal-close" onclick="closeAIGenerateModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-input-wrapper">
        <textarea class="ai-prompt-input" id="aiPromptTextarea" placeholder="Describe the label you want to create...

Examples:
â€¢ Return address label for John Smith at 123 Main St, Boston MA 02101
â€¢ Shipping label for Acme Corp, 456 Business Ave, Suite 100, Chicago IL 60601
â€¢ Make a label that says &quot;Happy Birthday&quot; with confetti vibes"></textarea>
      </div>
      
      <div id="aiGenerateStatus" style="display: none;">
        <div class="ai-generating">
          <div class="ai-spinner"></div>
          <span>Generating...</span>
        </div>
      </div>
      
      <div id="aiGenerateError" class="ai-error" style="display: none;"></div>
      
      <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIGenerateModal()">Cancel</button>
        <button class="btn btn-primary" id="aiGenerateBtn" onclick="generateWithAI()">
          âœ¨ Generate
        </button>
      </div>
    </div>
  </div>
</div>

<!-- AI Preview Modal -->
<div class="modal-overlay" id="aiPreviewModal">
  <div class="modal ai-preview-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ AI Preview</div>
      <button class="modal-close" onclick="closeAIPreviewModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Understanding section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“ What I understood</div>
        <div class="ai-preview-understanding" id="aiPreviewUnderstanding">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Labels section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ·ï¸ Labels I'll create (<span id="aiPreviewLabelCount">0</span>)</div>
        <div class="ai-preview-labels" id="aiPreviewLabels">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Settings section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“‹ Settings</div>
        <div class="ai-preview-settings">
          <div class="ai-preview-setting">
            <span>Type:</span>
            <strong id="aiPreviewType">5160 Address Labels</strong>
          </div>
          <div class="ai-preview-setting">
            <span>Quantity:</span>
            <strong id="aiPreviewQty">1</strong>
          </div>
        </div>
      </div>
      
      <!-- Skip preview checkbox -->
      <label class="ai-preview-skip-label">
        <input type="checkbox" id="aiPreviewSkip" onchange="toggleAIPreviewSkip()">
        <span>Don't show preview (trust AI output)</span>
      </label>
      
      <!-- Refine panel (hidden by default) -->
      <div class="ai-refine-panel" id="aiRefinePanel">
        <div class="ai-refine-original">
          <strong>Original request:</strong> <span id="aiRefineOriginal"></span>
        </div>
        <textarea class="ai-refine-input" id="aiRefineInput" placeholder="Add more detail or corrections..."></textarea>
        <div class="ai-refine-actions">
          <button class="btn btn-secondary" onclick="hideRefinePanel()">Cancel</button>
          <button class="btn btn-primary" onclick="regenerateWithRefinement()">âœ¨ Regenerate</button>
        </div>
      </div>
      
      <!-- Action buttons -->
      <div class="ai-preview-actions" id="aiPreviewActions">
        <button class="btn btn-secondary" onclick="closeAIPreviewModal()">Cancel</button>
        <button class="btn btn-secondary" onclick="showRefinePanel()">ðŸ”„ Refine</button>
        <button class="btn btn-primary" onclick="acceptAIPreview()">âœ“ Accept</button>
      </div>
    </div>
  </div>
</div>

<!-- OCR Scan Modal -->
<div class="modal-overlay" id="ocrModal" style="z-index: 1100;">
  <div class="modal" style="max-width: 520px;">
    <div class="modal-header">
      <div class="modal-title">ðŸ“· Scan Image</div>
      <button class="modal-close" onclick="closeOcrModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Image area: shows preview, click to pick file -->
      <div class="ocr-image-area" id="ocrImageArea" onclick="ocrImageAreaClick()">
        <div class="ocr-placeholder" id="ocrPlaceholder">
          <div style="font-size: 32px; margin-bottom: 6px;">ðŸ“·</div>
          <div>Click to select an image, or drag & drop</div>
          <div style="font-size: 11px; margin-top: 6px; color: var(--text-faint);">or paste a screenshot (Ctrl+V / âŒ˜V)</div>
        </div>
        <img id="ocrPreviewImg" style="display: none;" alt="Scanned image">
      </div>
      <input type="file" id="ocrFileInput" accept="image/*" style="display: none;" onchange="handleOcrFile(event)">
      
      <!-- Rotation controls -->
      <div class="ocr-rotation-bar" id="ocrRotationBar" style="display: none;">
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(-90)" title="Rotate left">â†¶</button>
        <span class="ocr-rotation-label" id="ocrRotationLabel"></span>
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(90)" title="Rotate right">â†·</button>
      </div>
      
      <!-- Progress bar -->
      <div id="ocrProgressArea" style="display: none;">
        <div class="ocr-progress">
          <div class="ocr-progress-bar"><div class="ocr-progress-fill" id="ocrProgressFill"></div></div>
          <div class="ocr-progress-text" id="ocrProgressText">Loadingâ€¦</div>
        </div>
      </div>
      
      <!-- Editable results -->
      <div id="ocrResultsArea" style="display: none;">
        <div class="ocr-results-label">Extracted text â€” edit as needed:</div>
        <div class="ocr-results-area" id="ocrResultLines"></div>
        <div class="ocr-hint" id="ocrHint"></div>
      </div>
      
      <div class="modal-btns" style="margin-top: 16px;">
        <button class="btn btn-secondary" onclick="closeOcrModal()">Cancel</button>
        <button class="btn btn-secondary" id="ocrNewImageBtn" style="display: none;" onclick="ocrNewImage()">ðŸ“· New</button>
        <button class="btn btn-secondary" id="ocrRescanBtn" style="display: none;" onclick="ocrRescan()">ðŸ”„ Rescan</button>
        <button class="btn btn-primary" id="ocrConfirmBtn" style="display: none;" onclick="confirmOcr()">Use Text</button>
      </div>
    </div>
  </div>
</div>

<!-- Full Editor (ported from v1.2.0) -->
<div class="full-editor-overlay" id="fullEditorOverlay">
  <div class="full-editor-container">
    <div class="full-editor-header">
      <button class="full-editor-back" onclick="closeFullEditor()">â†</button>
      <div>
        <div class="full-editor-title" id="fullEditorTitle">Edit Label</div>
        <div class="full-editor-subtitle" id="fullEditorSubtitle">Full formatting options</div>
      </div>
    </div>
    
    <!-- Name input (for new/rename) -->
    <div class="fe-name-row" id="feNameRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feName" placeholder="Name this label (e.g., Return Address, Aria's Labels)">
    </div>
    
    <!-- Name display for existing (editable) -->
    <div class="fe-name-row" id="feNameEditRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feNameEdit" placeholder="Label name">
      <span class="fe-dirty-indicator" id="feDirtyIndicator">â— unsaved</span>
    </div>
    
    <!-- Text Input Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Label Text</div>
      
      <!-- Global Style Controls -->
      <div class="fe-global-style-row">
        <span class="fe-global-style-label">All lines:</span>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('bold')" id="feGlobalBold" title="Bold all"><b>B</b></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('italic')" id="feGlobalItalic" title="Italic all"><i>I</i></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('underline')" id="feGlobalUnderline" title="Underline all"><u>U</u></button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('left')" title="Align all left">â†</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('center')" title="Align all center">â€¢</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('right')" title="Align all right">â†’</button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(11)" title="Size 11 all">11</button>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(14)" title="Size 14 all">14</button>
      </div>
      
      <div id="feLineInputs">
        <!-- Line 1 -->
        <div class="fe-line-row">
          <span class="fe-line-num">1</span>
          <input type="text" class="fe-line-input" id="feLine1" placeholder="Line 1 â€” use || to split, __ for fill line" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=1">
          <button class="fe-align-btn active" data-line="1" data-align="left" onclick="setFeAlign(1,'left')">â†</button>
          <button class="fe-align-btn" data-line="1" data-align="center" onclick="setFeAlign(1,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="1" data-align="right" onclick="setFeAlign(1,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(1,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize1">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(1,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn1" onclick="toggleFeStylePopover(1)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover1"></div>
          </div>
        </div>
        
        <!-- Line 2 -->
        <div class="fe-line-row">
          <span class="fe-line-num">2</span>
          <input type="text" class="fe-line-input" id="feLine2" placeholder="Line 2" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=2">
          <button class="fe-align-btn active" data-line="2" data-align="left" onclick="setFeAlign(2,'left')">â†</button>
          <button class="fe-align-btn" data-line="2" data-align="center" onclick="setFeAlign(2,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="2" data-align="right" onclick="setFeAlign(2,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(2,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize2">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(2,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn2" onclick="toggleFeStylePopover(2)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover2"></div>
          </div>
        </div>
        
        <!-- Line 3 -->
        <div class="fe-line-row">
          <span class="fe-line-num">3</span>
          <input type="text" class="fe-line-input" id="feLine3" placeholder="Line 3" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=3">
          <button class="fe-align-btn active" data-line="3" data-align="left" onclick="setFeAlign(3,'left')">â†</button>
          <button class="fe-align-btn" data-line="3" data-align="center" onclick="setFeAlign(3,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="3" data-align="right" onclick="setFeAlign(3,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(3,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize3">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(3,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn3" onclick="toggleFeStylePopover(3)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover3"></div>
          </div>
        </div>
        
        <!-- Line 4 -->
        <div class="fe-line-row">
          <span class="fe-line-num">4</span>
          <input type="text" class="fe-line-input" id="feLine4" placeholder="Line 4" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=4">
          <button class="fe-align-btn active" data-line="4" data-align="left" onclick="setFeAlign(4,'left')">â†</button>
          <button class="fe-align-btn" data-line="4" data-align="center" onclick="setFeAlign(4,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="4" data-align="right" onclick="setFeAlign(4,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(4,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize4">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(4,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn4" onclick="toggleFeStylePopover(4)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover4"></div>
          </div>
        </div>
      </div>
      
      <div class="fe-line-hint">Use <code>||</code> to split a line Â· Use <code>__</code> for a fill line, e.g. <code>Name__</code></div>
      
      <!-- Token Panel (for templates) -->
      <div class="fe-token-toggle-row" id="feTokenToggleRow" style="display:none;">
        <button class="fe-token-toggle" id="feTokenToggle" onclick="toggleFeTokenPanel()">{T} Insert Token</button>
      </div>
      <div class="fe-token-panel" id="feTokenPanel"></div>
      
      <!-- Emoji Panel -->
      <div class="fe-emoji-toggle-row">
        <button class="fe-emoji-toggle" id="feClearToggle" onclick="clearEditorLines()" title="Clear text lines">ðŸ§¹ Clear</button>
        <button class="fe-emoji-toggle" id="fePasteToggle" onclick="pasteToEditor()" title="Paste from clipboard">ðŸ“‹ Paste</button>
        <button class="fe-emoji-toggle" id="feEmojiToggle" onclick="toggleFeEmojiPanel()">ðŸ˜€ Emoji</button>
        <button class="fe-emoji-toggle" id="feOcrToggle" onclick="openOcrModal()">ðŸ“· Scan</button>
      </div>
      <div class="fe-emoji-panel" id="feEmojiPanel">
        <input type="text" class="fe-emoji-search" id="feEmojiSearch" placeholder="Search emojiâ€¦" oninput="filterFeEmojis()">
        <div class="fe-emoji-scroll" id="feEmojiScroll"></div>
      </div>
      
      <!-- Vertical Alignment -->
      <div class="fe-valign-row">
        <span class="fe-valign-label">Vertical:</span>
        <button class="fe-valign-btn" data-valign="top" onclick="setFeValign('top')">â†‘</button>
        <button class="fe-valign-btn active" data-valign="center" onclick="setFeValign('center')">â€”</button>
        <button class="fe-valign-btn" data-valign="bottom" onclick="setFeValign('bottom')">â†“</button>
        <button class="fe-valign-btn" data-valign="spread" onclick="setFeValign('spread')">â†•</button>
      </div>
      
      <!-- Graphics -->
      <div class="fe-graphics-section">
        <div class="full-editor-section-title">Graphics</div>
        <div class="fe-graphics-row" id="feGraphicsLeft">
          <span class="fe-graphics-label">Left:</span>
          <span id="feGraphicLeftContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('left')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
        <div class="fe-graphics-row" id="feGraphicsRight">
          <span class="fe-graphics-label">Right:</span>
          <span id="feGraphicRightContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('right')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
      </div>
      
      <!-- Border Controls -->
      <div class="fe-border-section">
        <div class="full-editor-section-title">Label Border</div>
        <div class="fe-border-row">
          <div class="fe-border-toggles">
            <button class="fe-border-toggle" id="feBorderTop" onclick="toggleFeBorder('top')" title="Top border">T</button>
            <button class="fe-border-toggle" id="feBorderBottom" onclick="toggleFeBorder('bottom')" title="Bottom border">B</button>
            <button class="fe-border-toggle" id="feBorderLeft" onclick="toggleFeBorder('left')" title="Left border">L</button>
            <button class="fe-border-toggle" id="feBorderRight" onclick="toggleFeBorder('right')" title="Right border">R</button>
          </div>
          <button class="fe-global-style-btn" onclick="toggleAllBorders()" id="feBorderAll" title="Toggle all borders">All</button>
          <div class="fe-border-color">
            <input type="color" class="fe-border-color-swatch" id="feBorderColor" value="#000000" onchange="updateFeBorderColor(this.value)" title="Border color">
          </div>
        </div>
      </div>
    </div>
    
    <!-- Preview Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Preview</div>
      <div class="fe-preview-container">
        <div class="fe-preview-label empty-preview" id="fePreviewLabel">
          <span>Type above to preview</span>
        </div>
      </div>
      <div class="fe-preview-dimensions" id="fePreviewDimensions"></div>
      <div class="fe-preview-type-row">
        <span class="fe-preview-type-label">Preview as:</span>
        <select class="fe-preview-type-select" id="fePreviewType" onchange="changeFePreviewType(this.value)">
          <option value="5160">5160 (1Ã—2â…)</option>
          <option value="5163">5163 (2Ã—4)</option>
          <option value="5164">5164 (3â…“Ã—4)</option>
          <option value="8163">8163 (2Ã—4)</option>
        </select>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="fe-actions">
      <button class="fe-btn fe-btn-secondary" onclick="closeFullEditor()">Cancel</button>
      <button class="fe-btn fe-btn-secondary" id="feBackToWizardBtn" onclick="closeFullEditorToWizard()" style="display:none;">â† Back to Wizard</button>
      <button class="fe-btn fe-btn-primary" id="feSaveBtn" onclick="saveFromFullEditor()">Save</button>
    </div>
  </div>
</div>

<!-- Graphic Picker Modal -->
<div class="fe-graphic-picker" id="feGraphicPicker">
  <div class="fe-graphic-picker-modal">
    <div class="fe-gp-header">
      <span class="fe-gp-title">Add Graphic</span>
      <button class="fe-gp-close" onclick="closeFeGraphicPicker()">Ã—</button>
    </div>
    <div class="fe-gp-tabs">
      <button class="fe-gp-tab active" data-tab="library" onclick="switchFeGpTab('library')">Library</button>
      <button class="fe-gp-tab" data-tab="upload" onclick="switchFeGpTab('upload')">Upload</button>
    </div>
    <div class="fe-gp-body" id="feGpBody">
      <!-- Populated by JS -->
    </div>
  </div>
  <input type="file" id="feGraphicFileInput" accept="image/*" style="display:none" onchange="handleFeGraphicUpload(event)">
</div>

<!-- Print Wizard -->
<!-- ============================================ -->
<!-- WF1: Print Something New Wizard              -->
<!-- ============================================ -->
<div class="wizard-overlay" id="wf1Wizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="wf1Back()">â†</button>
      <div class="wizard-title">Print Something New</div>
    </div>
    
    <!-- Progress indicator -->
    <div class="wf1-progress" id="wf1Progress"></div>
    
    <!-- WF1 Step 1: What label type? -->
    <div class="wizard-step active" id="wf1Step1">
      <div class="wizard-question">What label type are you printing?</div>
      <div class="wf1-type-grid" id="wf1TypeGrid">
        <!-- Populated by wf1RenderTypeGrid() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1TypeNextBtn" onclick="wf1ToStep2()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 2: Inventory check -->
    <div class="wizard-step" id="wf1Step2">
      <div class="wizard-question">Inventory Check</div>
      <div id="wf1InventoryContent">
        <!-- Populated by wf1RenderInventoryCheck() -->
      </div>
      <div class="wizard-actions" id="wf1Step2Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1InvNextBtn" onclick="wf1ToStep3()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 3: Content type + quantity -->
    <div class="wizard-step" id="wf1Step3">
      <div class="wizard-question" id="wf1Step3Question">What kind of print job?</div>
      <div id="wf1Step3Content">
        <div class="wf1-content-choices">
          <div class="wf1-content-choice" onclick="wf1SetJobType('individual')" ondblclick="wf1SetJobTypeAndAdvance('individual')">
            <div class="wf1-content-choice-icon">ðŸ·ï¸</div>
            <div class="wf1-content-choice-text">
              <div class="wf1-content-choice-title">Same content on every label</div>
              <div class="wf1-content-choice-desc">One design, printed multiple times</div>
            </div>
          </div>
          <div class="wf1-content-choice" onclick="wf1SetJobType('batch')" ondblclick="wf1SetJobTypeAndAdvance('batch')">
            <div class="wf1-content-choice-icon">ðŸ“‹</div>
            <div class="wf1-content-choice-text">
              <div class="wf1-content-choice-title">Different content on each label</div>
              <div class="wf1-content-choice-desc">A mailing list, name tags, or unique labels</div>
            </div>
          </div>
        </div>
        
        <div class="wf1-qty-row" id="wf1QtyRow" style="display:none;">
          <div class="wf1-qty-label">How many labels?</div>
          <div class="wf1-qty-controls">
            <button class="wf1-qty-btn" id="wf1QtyMinus" onclick="wf1AdjustQty(-1)">âˆ’</button>
            <div class="wf1-qty-value" id="wf1QtyValue">1</div>
            <button class="wf1-qty-btn" onclick="wf1AdjustQty(1)">+</button>
          </div>
        </div>
        <div class="wf1-qty-hint" id="wf1QtyHint" style="display:none;"></div>
      </div>
      
      <div class="wizard-actions" id="wf1Step3Actions" style="display:none;">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf1ToStep4()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 4: Feasibility check -->
    <div class="wizard-step" id="wf1Step4">
      <div class="wizard-question">Can we handle this job?</div>
      <div id="wf1FeasibilityContent">
        <!-- Populated by wf1RenderFeasibility() -->
      </div>
      <div class="wizard-actions" id="wf1Step4Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1FeasNextBtn" onclick="wf1ToStep5()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 5: Sheet selection -->
    <div class="wizard-step" id="wf1Step5">
      <div class="wizard-question">Which sheet do you want to print on?</div>
      <div id="wf1SheetPickerContent">
        <!-- Populated by wf1RenderSheetPicker() -->
      </div>
      <div class="wizard-actions" id="wf1Step5Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1SheetNextBtn" onclick="wf1ToStep6()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 6: Create content -->
    <div class="wizard-step" id="wf1Step6">
      <div class="wizard-question" id="wf1ContentQuestion">What should the labels say?</div>
      <div id="wf1ContentArea">
        <!-- Populated by wf1RenderContentStep() -->
      </div>
      <div class="wizard-actions" id="wf1Step6Actions" style="display:none;">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1ContentNextBtn" onclick="wf1ToStep7()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 7: Preview & print -->
    <div class="wizard-step" id="wf1Step7">
      <div class="wizard-question">Ready to print?</div>
      <div id="wf1PreviewContent">
        <!-- Populated by wf1RenderPreview() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf1ExecutePrint()">ðŸ–¨ï¸ Print</button>
      </div>
    </div>
    
    <!-- WF1 Step 8: Post-print -->
    <div class="wizard-step" id="wf1Step8">
      <div id="wf1PostPrintContent">
        <!-- Populated by wf1RenderPostPrint() -->
      </div>
      <div class="wizard-actions" id="wf1Step8Actions">
        <button class="wizard-btn wizard-btn-primary" onclick="wf1Close()">Done</button>
      </div>
    </div>
  </div>
  <input type="file" id="wf1BatchFileInput" accept=".csv,.tsv,.txt" style="display:none;" onchange="wf1HandleBatchFile(this)">
</div>

<!-- WF2: Print Something Again Wizard -->
<div class="wizard-overlay" id="wf2Wizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="wf2Back()">â†</button>
      <div class="wizard-title">Print Something Again</div>
    </div>
    
    <!-- Progress indicator -->
    <div class="wf2-progress" id="wf2Progress"></div>
    
    <!-- WF2 Step 1: Select content to reprint -->
    <div class="wizard-step active" id="wf2Step1">
      <div class="wizard-question">What are you reprinting?</div>
      <div id="wf2ContentSelector">
        <!-- Populated by wf2RenderContentSelector() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" id="wf2Step1NextBtn" onclick="wf2ToStep2()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 2: Quantity check -->
    <div class="wizard-step" id="wf2Step2">
      <div class="wizard-question">How many copies?</div>
      <div id="wf2QuantityContent">
        <!-- Populated by wf2RenderQuantityCheck() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf2ToStep3()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 3: Sheet validation -->
    <div class="wizard-step" id="wf2Step3">
      <div class="wizard-question">Which sheet to print on?</div>
      <div id="wf2SheetContent">
        <!-- Populated by wf2RenderSheetCheck() -->
      </div>
      <div class="wizard-actions" id="wf2Step3Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf2SheetNextBtn" onclick="wf2ToStep4()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 4: Preview & Print -->
    <div class="wizard-step" id="wf2Step4">
      <div class="wizard-question">Ready to print?</div>
      <div id="wf2PreviewContent">
        <!-- Populated by wf2RenderPreview() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf2ExecutePrint()">ðŸ–¨ï¸ Print</button>
      </div>
    </div>
    
    <!-- WF2 Step 5: Post-print -->
    <div class="wizard-step" id="wf2Step5">
      <div id="wf2PostPrintContent">
        <!-- Populated by wf2RenderPostPrint() -->
      </div>
      <div class="wizard-actions" id="wf2Step5Actions">
        <button class="wizard-btn wizard-btn-primary" onclick="wf2Close()">Done</button>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Sheet Modal -->
<div class="simple-modal-overlay" id="sheetModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="sheetModalTitle">New Sheet</div>
      <button class="modal-close" onclick="closeSheetModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheet Name</label>
        <input type="text" class="form-input" id="sheetNameInput" placeholder="e.g., Holiday Cards" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="sheetTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group" id="sheetCountGroup">
        <label class="form-label">Number of Physical Sheets</label>
        <input type="number" class="form-input" id="sheetCountInput" value="1" min="1" max="20">
        <div class="form-hint">Pool multiple sheets together for large jobs</div>
      </div>
      <div class="form-group">
        <label class="form-label">Note <span style="color:var(--text-faint);font-weight:normal">(optional)</span></label>
        <input type="text" class="form-input" id="sheetNoteInput" placeholder="e.g., For client mailings" maxlength="80">
        <div class="form-hint">Brief description of what this sheet is for</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSheetModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSheetModal()">Save</button>
    </div>
  </div>
</div>

<!-- Create/Edit Saved Text Modal -->
<div class="simple-modal-overlay" id="savedTextModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="savedTextModalTitle">New Saved Text</div>
      <button class="modal-close" onclick="closeSavedTextModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Name</label>
        <input type="text" class="form-input" id="savedTextNameInput" placeholder="e.g., Return Address" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Line 1</label>
        <input type="text" class="form-input" id="savedTextLine1" placeholder="First line" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 2</label>
        <input type="text" class="form-input" id="savedTextLine2" placeholder="Second line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 3</label>
        <input type="text" class="form-input" id="savedTextLine3" placeholder="Third line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 4</label>
        <input type="text" class="form-input" id="savedTextLine4" placeholder="Fourth line (optional)" maxlength="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSavedTextModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSavedTextModal()">Save</button>
    </div>
  </div>
</div>

<!-- Confirm Dialog -->
<div class="simple-modal-overlay" id="confirmModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="confirmModalTitle">Confirm</div>
      <button class="modal-close" onclick="closeConfirmModal(false)">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p id="confirmModalMessage">Are you sure?</p>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" id="confirmModalCancelBtn" onclick="closeConfirmModal(false)">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" id="confirmModalOkBtn" onclick="closeConfirmModal(true)">OK</button>
    </div>
  </div>
</div>

<!-- Add Text to Sheet Picker Modal -->
<div class="simple-modal-overlay" id="addTextPickerModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="addTextPickerTitle">Add Content</div>
      <button class="modal-close" onclick="closeAddTextPickerModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p style="margin-bottom: 12px; color: var(--text-secondary); font-size: 13px;">Select content to add:</p>
      <div class="tab-content-list" style="max-height: 280px; overflow-y: auto;" id="addTextPickerContent">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<!-- Add Inventory Modal -->
<div class="simple-modal-overlay" id="addInventoryModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title">Add Label Type to Inventory</div>
      <button class="modal-close" onclick="closeAddInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="addInventoryTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="addInventoryStock" value="10" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="addInventoryThreshold" value="5" min="0" max="100">
        <div class="form-hint">You'll see a warning when stock drops to this level</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAddInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAddInventory()">Add</button>
    </div>
  </div>
</div>

<!-- Adjust Inventory Modal -->
<div class="simple-modal-overlay" id="adjustInventoryModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="adjustInventoryTitle">Adjust Stock</div>
      <button class="modal-close" onclick="closeAdjustInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="adjustInventoryStock" value="0" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="adjustInventoryThreshold" value="5" min="0" max="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAdjustInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAdjustInventory()">Save</button>
    </div>
  </div>
</div>

<!-- Batch Import Modal -->
<div class="modal-overlay" id="batchImportModal">
  <div class="modal batch-import-modal">
    <h3>ðŸ“¦ Create Batch Print Job</h3>
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
      Import a CSV file and print labels using template: <strong id="batchTemplateName"></strong>
    </div>

    <!-- File drop zone -->
    <div class="batch-file-zone" id="batchFileZone" onclick="document.getElementById('batchFileInput').click()">
      <span class="file-icon">ðŸ“„</span>
      <span class="file-prompt">Click to select a CSV file or drag & drop here</span>
    </div>
    <input type="file" id="batchFileInput" accept=".csv,.txt" style="display:none" onchange="handleBatchFile(event)">

    <!-- Column mapping (shown after file loaded) -->
    <div id="batchMappingSection" style="display:none">
      <div style="font-size:12px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px">
        Map CSV columns to template tokens:
      </div>
      <div class="batch-col-mapping" id="batchColMapping"></div>

      <!-- Summary -->
      <div class="batch-summary" id="batchSummary"></div>

      <!-- Job name -->
      <div class="batch-job-name-row">
        <label for="batchJobName">Job name:</label>
        <input type="text" id="batchJobName" placeholder="e.g., Holiday Mailing 2024">
      </div>

      <!-- Preview cards -->
      <div class="batch-preview-section">
        <div class="batch-preview-title">Preview (first 3 labels)</div>
        <div class="batch-preview-cards" id="batchPreviewCards"></div>
      </div>
    </div>

    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeBatchImportModal()">Cancel</button>
      <button class="btn btn-primary" id="batchCreateBtn" style="display:none" onclick="createBatchJob()">ðŸ“¦ Create Print Job</button>
    </div>
  </div>
</div>

<!-- Job Complete Modal -->
<div class="modal-overlay" id="jobCompleteModal">
  <div class="modal job-complete-modal">
    <div class="job-complete-summary">
      <div class="job-complete-icon">âœ…</div>
      <div class="job-complete-count" id="jobCompleteCount">0</div>
      <div class="job-complete-label">labels printed successfully</div>
    </div>
    
    <div class="job-remainder-options" id="jobRemainderOptions" style="display:none">
      <div class="job-remainder-title">What would you like to do with the remaining positions on the last sheet?</div>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="keep" checked>
        <div>
          <div class="job-remainder-option-label">Keep as partial sheet</div>
          <div class="job-remainder-option-desc">Save the sheet for future printing</div>
        </div>
      </label>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="discard">
        <div>
          <div class="job-remainder-option-label">Discard remaining positions</div>
          <div class="job-remainder-option-desc">Delete all job sheets (saves space)</div>
        </div>
      </label>
    </div>
    
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-primary" onclick="completeJob()">Done</button>
    </div>
  </div>
</div>

<!-- Split Remaining Modal (ported from v1.2) -->
<div class="simple-modal-overlay" id="splitModal">
  <div class="simple-modal split-modal">
    <h3>âœ‚ï¸ Split Remaining Labels</h3>
    <div class="split-summary" id="splitSummary"></div>
    <div class="split-form">
      <div class="split-form-group">
        <label for="splitName" class="split-form-title">New sheet name:</label>
        <input type="text" id="splitName" placeholder="Leftover 5160 - Feb" maxlength="40">
      </div>
      <div class="split-form-group" id="splitModeGroup">
        <div class="split-form-title">Physical sheets:</div>
        <label><input type="radio" name="splitMode" value="separate" checked> Split into separate sheets</label>
        <label><input type="radio" name="splitMode" value="together"> Keep together as one pool</label>
      </div>
      <div class="split-form-group">
        <div class="split-form-title">Text associations:</div>
        <label><input type="radio" name="splitTexts" value="remove" checked> Remove texts (clean slate)</label>
        <label><input type="radio" name="splitTexts" value="keep"> Keep texts (qty set to 0)</label>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeSimpleModal('splitModal')">Cancel</button>
      <button class="btn btn-primary" onclick="executeSplit()">âœ‚ï¸ Split</button>
    </div>
  </div>
</div>

<!-- Clipboard Import Modal (ported from v1.2) -->
<div class="modal-overlay" id="importTextModal">
  <div class="modal import-modal">
    <h3>ðŸ“‹ Import from Clipboard</h3>
    <div class="import-summary" id="importSummary"></div>
    <div class="import-form">
      <!-- Template selection -->
      <div id="importTemplateRow">
        <label for="importTemplateSelect" class="import-form-title">Apply template:</label>
        <select id="importTemplateSelect" onchange="onImportTemplateChange()">
          <option value="">No Template (manual)</option>
        </select>
      </div>
      <!-- Plain list mode: lines per label -->
      <div id="importPlainControls" style="display:none">
        <div class="import-form-title">Lines per label:</div>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="import-stepper">
            <button onclick="stepLinesPerLabel(-1)">âˆ’</button>
            <span id="linesPerLabelVal">1</span>
            <button onclick="stepLinesPerLabel(1)">+</button>
          </div>
          <span style="font-size:13px;color:var(--text-secondary)" id="importRecordCount"></span>
        </div>
      </div>
      <!-- Tabular mode: column mapping -->
      <div id="importTabularControls" style="display:none">
        <div class="import-form-title" id="importColMappingTitle">Map columns to label lines:</div>
        <div class="import-col-mapping" id="importColMapping"></div>
      </div>
      <!-- Preview -->
      <div>
        <div class="import-form-title">Preview:</div>
        <div class="import-preview-area" id="importPreviewArea"></div>
      </div>
      <!-- Base name -->
      <div>
        <label for="importBaseName" class="import-form-title">Base name:</label>
        <input type="text" id="importBaseName" placeholder="e.g. Student" maxlength="40">
        <div class="import-name-preview" id="importNamePreview"></div>
      </div>
      <!-- Sheet assignment -->
      <div>
        <label for="importSheetAssign" class="import-form-title">Assign to sheet (optional):</label>
        <select id="importSheetAssign">
          <option value="">â€” Don't assign â€”</option>
        </select>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeModal('importTextModal')">Cancel</button>
      <button class="btn btn-primary" id="importExecuteBtn" onclick="executeImport()">Import</button>
    </div>
  </div>
</div>

<!-- Welcome / First Run Modal -->
<div class="welcome-overlay" id="welcomeModal">
  <div class="welcome-modal">
    <div class="welcome-header">
      <div class="welcome-icon">ðŸ·ï¸</div>
      <div class="welcome-title">Welcome to LabelKeeper</div>
      <div class="welcome-version">v3.17.0</div>
    </div>
    <div class="welcome-body">
      <div class="welcome-tagline">
        Print labels without wasting a single position. LabelKeeper tracks which spots on your label sheets have been used, so you can print one label at a time or hundredsâ€”and never lose track.
      </div>
      
      <div class="welcome-features">
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“‹</div>
          <div class="welcome-feature-text">
            <strong>Track Sheet Usage</strong><br>
            Never wonder which positions are already printedâ€”the app remembers for you.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¦</div>
          <div class="welcome-feature-text">
            <strong>Manage Inventory</strong><br>
            Know when you're running low on label sheets before you need them.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¬</div>
          <div class="welcome-feature-text">
            <strong>Batch Printing</strong><br>
            Import a mailing list and print dozens of labels in one go.
          </div>
        </div>
      </div>
      
      <div class="welcome-data-status" id="welcomeDataStatus" style="display:none;">
        <div class="welcome-data-title">ðŸ“ Found Existing Data</div>
        <div class="welcome-data-items" id="welcomeDataItems">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>
    <div class="welcome-footer">
      <div class="welcome-btn-group">
        <button class="welcome-btn welcome-btn-primary" onclick="closeWelcome(true)">Get Started</button>
        <button class="welcome-btn welcome-btn-secondary" onclick="showSetupWizardFromWelcome()" id="welcomeSetupBtn" style="display:none;">Set Up Label Sheets First</button>
      </div>
      <button class="welcome-skip" onclick="closeWelcome(false)">Don't show again</button>
    </div>
  </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Device Sync Modal -->
<div class="simple-modal-overlay" id="syncModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="syncModalTitle">Device Sync</div>
      <button class="modal-close" onclick="closeSyncModal()">Ã—</button>
    </div>
    <div class="simple-modal-body" id="syncModalBody">
      <!-- Content populated by JS -->
    </div>
  </div>
</div>

<div class="print-sheet" id="printSheet"></div>

<script>
// ============================================================================
// LABELKEEPER v2.5.0 â€” DATA LAYER
// ============================================================================

// ========== LABEL TYPES (from v1.x) ==========
const LABEL_TYPES = {
  '5160': { name: '5160 / 8160', desc: 'Standard Address', labelW: 2.625, labelH: 1, cols: 3, rows: 10, topMargin: 0.5, leftMargin: 0.1875, hGutter: 0.125, vGutter: 0, sizeDisplay: '1â€³ Ã— 2â…â€³', layoutDisplay: '3 Ã— 10' },
  '5161': { name: '5161 / 8161', desc: 'Address + Logo', labelW: 4, labelH: 1, cols: 2, rows: 10, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 10' },
  '5162': { name: '5162 / 8162', desc: 'Large Address', labelW: 4, labelH: 1.333, cols: 2, rows: 7, topMargin: 0.8335, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 7' },
  '5163': { name: '5163 / 8163', desc: 'Shipping', labelW: 4, labelH: 2, cols: 2, rows: 5, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '2â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 5' },
  '5164': { name: '5164 / 8164', desc: 'Large Shipping', labelW: 4, labelH: 3.333, cols: 2, rows: 3, topMargin: 0.5005, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '3â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 3' },
  '5167': { name: '5167 / 8167', desc: 'Return Address (tiny)', labelW: 1.75, labelH: 0.5, cols: 4, rows: 20, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'Â½â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 20' },
  '5168': { name: '5168 / 8168', desc: 'Extra Large Shipping', labelW: 3.5, labelH: 5, cols: 2, rows: 2, topMargin: 0.5, leftMargin: 0.5, hGutter: 0.5, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 5â€³', layoutDisplay: '2 Ã— 2' },
  '5195': { name: '5195 / 8195', desc: 'Small Return Address', labelW: 1.75, labelH: 0.667, cols: 4, rows: 15, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'â…”â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 15' },
  '5165': { name: '5165', desc: 'Full Sheet', labelW: 8.5, labelH: 11, cols: 1, rows: 1, topMargin: 0, leftMargin: 0, hGutter: 0, vGutter: 0, sizeDisplay: '8Â½â€³ Ã— 11â€³', layoutDisplay: '1 Ã— 1' },
  // Name Badges & Tent Cards (Session 21)
  '5395': { name: '5395', desc: 'Name Badge', labelW: 3.375, labelH: 2.333, cols: 2, rows: 4, topMargin: 0.55, leftMargin: 0.6875, hGutter: 0.375, vGutter: 0.19, sizeDisplay: '2â…“â€³ Ã— 3â…œâ€³', layoutDisplay: '2 Ã— 4', category: 'badge' },
  '5302': { name: '5302', desc: 'Tent Card (Small)', labelW: 3.5, labelH: 4, cols: 2, rows: 2, topMargin: 0.75, leftMargin: 0.75, hGutter: 0, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 2â€³ (folded)', layoutDisplay: '2 Ã— 2', category: 'tent', foldLine: 2 }
};
const TYPE_ORDER = ['5160', '5163', '5164', '5161', '5162', '5167', '5195', '5168', '5165', '5395', '5302'];

// ========== LOCALSTORAGE KEYS ==========
// v1.x compatible keys (preserved for data migration)
const SHEETS_KEY = 'avery_sheets_v6';
const ACTIVE_KEY = 'avery_active_v6';
const TEXTS_KEY = 'avery5160_saved_texts';
const THEME_KEY = 'avery5160_theme';
const INVENTORY_KEY = 'avery_inventory';
const ACTIVE_JOB_KEY = 'avery_active_job';
const JOB_HISTORY_KEY = 'avery_job_history';
const CUSTOM_TOKENS_KEY = 'avery5160_custom_tokens';

// v2.0 keys
const SETTINGS_KEY = 'lk_settings';
const PRINT_HISTORY_KEY = 'lk_print_history';
const FIRST_RUN_KEY = 'lk_first_run';
const SATELLITE_PENDING_KEY = 'lk_satellite_pending';
const INVENTORY_HISTORY_KEY = 'lk_inventory_history';

// ========== APP STATE ==========
let settings = {
  darkMode: false,
  lastLabelType: '5160',
  printOffsetTop: 0,       // Manual offset - inches to shift print vertically
  printOffsetLeft: 0,      // Manual offset - inches to shift print horizontally  
  safariPrintOffset: 0.5,  // Safari auto-compensation (adjustable) - DEPRECATED
  safariVScale: 1.0,      // Safari vertical compression ratio (0.90-1.0) â€” default 1.0; only reduce if actual prints are misaligned
  showLabelBoundaries: false, // Debug: show label boundary rectangles on print
  deviceRole: 'primary',   // 'primary' or 'satellite' - controls sync behavior
  storeId: null,           // Unique ID for this device/browser combo
  quickActionsCount: 5     // Number of quick actions to show on home (0-10) â€” T11
};

let sheets = {};
let activeSheetId = null;
let savedTexts = [];
let inventory = {};
let activeJob = null;
let jobHistory = [];
let customTokens = [];
let inventoryHistory = [];  // G8: tracks inventory changes over time
let printHistory = [];
let lastPrintJob = null; // For undo last print (from v1.2)

// Safari detection for print offset compensation
// Safari doesn't properly respect @page { margin: 0 } in iframes
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// Helper to get Safari offset (uses settings value, defaults to 0.5)
function getSafariPrintOffset() {
  return isSafari ? (settings.safariPrintOffset ?? 0.5) : 0;
}

// Batch job state (for CSV import)
let batchTemplateId = null;
let batchCsvData = null;
let batchCsvFileName = null;
let batchColTokenMap = [];

// UI state
let currentTab = 'workflows';
// Wizard state managed by WF1/WF2
let sheetGridPages = {}; // Tracks current page for multi-sheet grids

// ========== BUILT-IN TEMPLATES ==========
const BUILTIN_TEMPLATES = [
  { id: '__builtin_mailing', name: 'Mailing Address', text: 'left,11:{first_name} {last_name}\nleft,11:{street}\nleft,11:{city}, {state} {zip}\nleft,10:{country}', alignV: 'center', type: 'template', tokens: ['first_name','last_name','street','city','state','zip','country'], builtin: true, labelType: '5160' },
  { id: '__builtin_return', name: 'Return Address', text: 'left,9:{name}\nleft,9:{street}\nleft,9:{city}, {state} {zip}', alignV: 'center', type: 'template', tokens: ['name','street','city','state','zip'], builtin: true, labelType: '5167' },
  { id: '__builtin_classroom', name: 'Classroom Label', text: 'left,14:{student_name}\ncenter,11:Room {room} || {teacher}\ncenter,10:Level: {level}', alignV: 'center', type: 'template', tokens: ['student_name','room','teacher','level'], builtin: true, labelType: '5160' },
  { id: '__builtin_namebadge', name: 'Name Badge', text: 'center,16:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5163' },
  // Name Badge templates for 5395
  { id: '__builtin_badge_simple', name: 'Name Badge (Simple)', text: 'center,24:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_company', name: 'Name Badge (Company)', text: 'center,10:HELLO my name is\ncenter,20:{name}\ncenter,12:{company}', alignV: 'center', type: 'template', tokens: ['name','company'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_event', name: 'Name Badge (Event)', text: 'center,18:{name}\ncenter,12:{title}\ncenter,10:{company}', alignV: 'center', type: 'template', tokens: ['name','title','company'], builtin: true, labelType: '5395' },
  // Tent Card templates for 5302
  { id: '__builtin_tent_name', name: 'Tent Card (Name)', text: 'center,28:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_table', name: 'Tent Card (Table)', text: 'center,14:Table\ncenter,36:{table_number}', alignV: 'center', type: 'template', tokens: ['table_number'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_food', name: 'Tent Card (Food Label)', text: 'center,18:{dish_name}\ncenter,11:{description}', alignV: 'center', type: 'template', tokens: ['dish_name','description'], builtin: true, labelType: '5302' }
];

// Built-in tokens for template editing (categorized)
const BUILTIN_TOKENS = {
  'Name': ['name', 'first_name', 'last_name', 'prefix', 'suffix'],
  'Address': ['street', 'street2', 'city', 'state', 'zip', 'country'],
  'School': ['student_name', 'room', 'teacher', 'grade', 'level', 'student_id'],
  'General': ['title', 'company', 'department', 'phone', 'email'],
  'Events': ['table_number', 'dish_name', 'description', 'event_name', 'date']
};

// Token alias map for auto-mapping columns during CSV import
const TOKEN_ALIASES = {
  'first_name': ['first name', 'first', 'fname', 'given name', 'given_name'],
  'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name'],
  'name': ['full name', 'fullname', 'full_name', 'student name', 'student_name', 'guest', 'guest name'],
  'student_name': ['student name', 'student', 'pupil', 'child name'],
  'street': ['street address', 'address', 'address1', 'address_1', 'street_address', 'addr'],
  'street2': ['address 2', 'address2', 'address_2', 'apt', 'suite', 'unit'],
  'city': ['town', 'municipality'],
  'state': ['province', 'region', 'st'],
  'zip': ['zip code', 'zipcode', 'postal', 'postal code', 'postal_code', 'postcode'],
  'country': ['nation'],
  'room': ['room number', 'classroom'],
  'teacher': ['teacher name', 'instructor'],
  'grade': ['year', 'class year'],
  'title': ['job title', 'position'],
  'company': ['organization', 'org', 'employer'],
  'phone': ['telephone', 'tel', 'mobile', 'cell'],
  'email': ['email address', 'e-mail'],
  'table_number': ['table', 'table no', 'table #', 'seating'],
  'dish_name': ['dish', 'food', 'item', 'menu item'],
  'description': ['desc', 'details', 'notes', 'info', 'ingredients', 'allergens']
};

// ========== EMOJI DATA ==========
const EMOJI_DATA = [
  { cat: 'Common', emojis: [
    { e: 'â­', n: 'star' }, { e: 'â¤ï¸', n: 'heart love' }, { e: 'âœ…', n: 'check done' }, { e: 'âŒ', n: 'x cross no' },
    { e: 'âš ï¸', n: 'warning caution' }, { e: 'ðŸ“Œ', n: 'pin pushpin' }, { e: 'ðŸ”´', n: 'red circle' }, { e: 'ðŸŸ¢', n: 'green circle' },
    { e: 'ðŸ”µ', n: 'blue circle' }, { e: 'ðŸŸ¡', n: 'yellow circle' }, { e: 'â¬›', n: 'black square' }, { e: 'â¬œ', n: 'white square' },
    { e: 'â–¶ï¸', n: 'play arrow right' }, { e: 'â—€ï¸', n: 'left arrow' }, { e: 'ðŸ”¹', n: 'diamond blue' }, { e: 'ðŸ”¸', n: 'diamond orange' },
  ]},
  { cat: 'School', emojis: [
    { e: 'ðŸ“š', n: 'books reading' }, { e: 'ðŸ“–', n: 'open book reading' }, { e: 'ðŸŽ’', n: 'backpack school bag' }, { e: 'âœ‚ï¸', n: 'scissors craft' },
    { e: 'ðŸ“', n: 'triangle ruler math' }, { e: 'ðŸ“', n: 'ruler measure' }, { e: 'ðŸ–ï¸', n: 'crayon color draw' }, { e: 'ðŸ–Œï¸', n: 'paintbrush art' },
    { e: 'ðŸŽ¨', n: 'art palette paint color' }, { e: 'ðŸ”¬', n: 'microscope science' }, { e: 'ðŸ§ª', n: 'test tube science lab' }, { e: 'ðŸ§®', n: 'abacus math count' },
    { e: 'ðŸŽµ', n: 'music note' }, { e: 'ðŸŽ¶', n: 'music notes' }, { e: 'ðŸ…', n: 'medal award' }, { e: 'ðŸ†', n: 'trophy winner award' },
    { e: 'ðŸ““', n: 'notebook journal' }, { e: 'ðŸ–Šï¸', n: 'pen write' }, { e: 'âœï¸', n: 'pencil write' }, { e: 'ðŸ“', n: 'memo note write' },
    { e: 'ðŸ§©', n: 'puzzle piece' }, { e: 'ðŸŽ²', n: 'dice game' }, { e: 'ðŸ§¸', n: 'teddy bear toy' }, { e: 'ðŸª', n: 'kite play' },
    { e: 'ðŸŽ', n: 'apple teacher' }, { e: 'ðŸ›', n: 'caterpillar bug insect' }, { e: 'ðŸ¸', n: 'frog animal' }, { e: 'ðŸ¢', n: 'turtle animal slow' },
    { e: 'ðŸ¦•', n: 'dinosaur dino' }, { e: 'ðŸ', n: 'bee honeybee insect' }, { e: 'ðŸž', n: 'ladybug insect' }, { e: 'ðŸ¦', n: 'lion animal' },
  ]},
  { cat: 'People', emojis: [
    { e: 'ðŸ˜€', n: 'smile happy' }, { e: 'ðŸ˜Š', n: 'blush smile' }, { e: 'ðŸ‘‹', n: 'wave hello' }, { e: 'ðŸ‘', n: 'thumbs up' },
    { e: 'ðŸ‘Ž', n: 'thumbs down' }, { e: 'ðŸ‘', n: 'clap hands' }, { e: 'ðŸ™', n: 'pray thanks' }, { e: 'ðŸ’ª', n: 'strong muscle' },
    { e: 'ðŸŽ‰', n: 'party celebrate' }, { e: 'ðŸŽ‚', n: 'birthday cake' }, { e: 'ðŸ‘¤', n: 'person silhouette' }, { e: 'ðŸ‘¥', n: 'people group' },
  ]},
  { cat: 'Office', emojis: [
    { e: 'ðŸ“', n: 'folder file' }, { e: 'ðŸ“‚', n: 'open folder' }, { e: 'ðŸ“‹', n: 'clipboard' }, { e: 'ðŸ“Ž', n: 'paperclip' },
    { e: 'âœï¸', n: 'pencil edit' }, { e: 'ðŸ–Šï¸', n: 'pen' }, { e: 'ðŸ“', n: 'memo note' }, { e: 'ðŸ“Š', n: 'chart graph' },
    { e: 'ðŸ“…', n: 'calendar date' }, { e: 'ðŸ—“ï¸', n: 'calendar spiral' }, { e: 'ðŸ“‡', n: 'card index' }, { e: 'ðŸ·ï¸', n: 'label tag' },
    { e: 'ðŸ“¦', n: 'box package' }, { e: 'ðŸ—‚ï¸', n: 'dividers tabs' }, { e: 'ðŸ”‘', n: 'key' }, { e: 'ðŸ”’', n: 'lock' },
  ]},
  { cat: 'Places', emojis: [
    { e: 'ðŸ ', n: 'home house' }, { e: 'ðŸ¢', n: 'office building' }, { e: 'ðŸ«', n: 'school' }, { e: 'ðŸ¥', n: 'hospital' },
    { e: 'â›ª', n: 'church' }, { e: 'ðŸ›ï¸', n: 'classical building' }, { e: 'ðŸ“', n: 'location pin' }, { e: 'ðŸš—', n: 'car' },
    { e: 'âœˆï¸', n: 'airplane travel' }, { e: 'ðŸŒŽ', n: 'earth globe' }, { e: 'ðŸª', n: 'store shop' }, { e: 'ðŸ…¿ï¸', n: 'parking' },
  ]},
  { cat: 'Nature', emojis: [
    { e: 'ðŸŒŸ', n: 'glowing star' }, { e: 'â˜€ï¸', n: 'sun' }, { e: 'ðŸŒ™', n: 'moon' }, { e: 'ðŸŒˆ', n: 'rainbow' },
    { e: 'ðŸ”¥', n: 'fire hot' }, { e: 'ðŸ’§', n: 'water drop' }, { e: 'â„ï¸', n: 'snowflake cold' }, { e: 'ðŸŒº', n: 'flower' },
    { e: 'ðŸŒ²', n: 'tree pine' }, { e: 'ðŸ€', n: 'clover luck' }, { e: 'ðŸ¾', n: 'paw prints animal' }, { e: 'ðŸ¦‹', n: 'butterfly' },
  ]},
  { cat: 'Arrows & Numbers', emojis: [
    { e: 'âž¡ï¸', n: 'right arrow' }, { e: 'â¬…ï¸', n: 'left arrow' }, { e: 'â¬†ï¸', n: 'up arrow' }, { e: 'â¬‡ï¸', n: 'down arrow' },
    { e: 'â†©ï¸', n: 'return back' }, { e: 'ðŸ”„', n: 'refresh cycle' }, { e: 'â‘ ', n: 'one 1' }, { e: 'â‘¡', n: 'two 2' },
    { e: 'â‘¢', n: 'three 3' }, { e: 'â‘£', n: 'four 4' }, { e: 'â‘¤', n: 'five 5' }, { e: 'â’¶', n: 'letter a' },
    { e: 'â’·', n: 'letter b' }, { e: 'â’¸', n: 'letter c' }, { e: 'â„¢', n: 'trademark' }, { e: 'Â©', n: 'copyright' },
  ]},
];

// ========== OCR STATE ==========
let ocrImageBlob = null;
let ocrResults = [];
let ocrRotation = 0;

// ========== HISTORY FILTER STATE ==========
let historySearchQuery = '';
let historyTypeFilter = 'all';
let historySelectedIds = new Set();

const DEFAULT_LOW_THRESHOLD = 5;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function escapeHtml(t) {
  const d = document.createElement('div');
  d.textContent = t;
  return d.innerHTML;
}

function escapeAttr(t) {
  return t.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' ');
}

function generateId(prefix) {
  // If satellite mode, add sat_ prefix so we can track what was created here
  if (settings.deviceRole === 'satellite') {
    const storeId = getOrCreateStoreId();
    return 'sat_' + (prefix || 'id') + '_' + storeId + '_' + Date.now();
  }
  return (prefix || 'id') + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
}

// Get or create a unique store ID for this device/browser
function getOrCreateStoreId() {
  if (settings.storeId) return settings.storeId;
  
  // Generate: platform-browser-random
  const ua = navigator.userAgent;
  const platform = /iPhone|iPad/.test(ua) ? 'ios' : 
                   /Mac/.test(ua) ? 'mac' : 
                   /Win/.test(ua) ? 'win' : 
                   /Android/.test(ua) ? 'android' : 'other';
  const browser = /Chrome/.test(ua) && !/Edg/.test(ua) ? 'chrome' :
                  /Safari/.test(ua) && !/Chrome/.test(ua) ? 'safari' :
                  /Firefox/.test(ua) ? 'firefox' : 
                  /Edg/.test(ua) ? 'edge' : 'other';
  const random = Math.random().toString(36).substring(2, 8);
  
  settings.storeId = `${platform}-${browser}-${random}`;
  saveSettings();
  return settings.storeId;
}

// Check if an ID was created on this satellite device
function isLocalSatelliteItem(id) {
  if (settings.deviceRole !== 'satellite') return false;
  const storeId = getOrCreateStoreId();
  return id && id.startsWith('sat_') && id.includes('_' + storeId + '_');
}

// Get satellite pending queue
function getSatellitePending() {
  try {
    return JSON.parse(localStorage.getItem(SATELLITE_PENDING_KEY) || '[]');
  } catch (e) {
    return [];
  }
}

// Save satellite pending queue
function saveSatellitePending(pending) {
  try {
    localStorage.setItem(SATELLITE_PENDING_KEY, JSON.stringify(pending));
  } catch (e) {}
}

// Add item to satellite pending queue
function addToSatellitePending(id) {
  if (settings.deviceRole !== 'satellite') return;
  const pending = getSatellitePending();
  if (!pending.includes(id)) {
    pending.push(id);
    saveSatellitePending(pending);
  }
}

// Remove item from satellite pending queue
function removeFromSatellitePending(id) {
  const pending = getSatellitePending();
  const filtered = pending.filter(p => p !== id);
  saveSatellitePending(filtered);
}

// ========== LABEL TYPE HELPERS ==========
function getSpec(typeId) {
  return LABEL_TYPES[typeId || '5160'];
}

function getLabelsPerSheet(typeId) {
  const spec = getSpec(typeId);
  return spec.cols * spec.rows;
}

// ========== SHEET HELPERS ==========
function getSheet(id) {
  return sheets[id] || null;
}

function getActiveSheet() {
  return sheets[activeSheetId] || null;
}

function getPoolSize(sh) {
  const spec = getSpec(sh.labelType);
  return spec.cols * spec.rows * (sh.sheetCount || 1);
}

function getPrintedCount(sh) {
  return (sh.printed || []).length;
}

function getRemainingCount(sh) {
  return getPoolSize(sh) - getPrintedCount(sh);
}

function getAssignedCount(sh) {
  if (!sh.texts) return 0;
  return Object.values(sh.texts).reduce((sum, t) => sum + (t.qty || 0), 0);
}

function getAvailableSpots(sh) {
  return Math.max(0, getRemainingCount(sh) - getAssignedCount(sh));
}

// Get physical sheet info for a position index
function getPhysicalSheet(index, sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const physicalSheet = Math.floor(index / lps);
  const localIndex = index % lps;
  const localRow = Math.floor(localIndex / spec.cols);
  const localCol = localIndex % spec.cols;
  return { physicalSheet, localIndex, row: localRow, col: localCol };
}

// Build position assignments for a sheet
function buildAssignments(sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const total = lps * (sh.sheetCount || 1);
  const printed = new Set(sh.printed || []);
  const assignments = {};
  const errors = [];
  const used = new Set();

  if (!sh.texts) return { assignments, errors };

  const textIds = Object.keys(sh.texts);

  // First pass: place column-specific texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0 || placement === 'next') continue;

    const colNum = parseInt(placement.split(':')[1]) - 1;
    if (colNum < 0 || colNum >= spec.cols) {
      assignments[textId] = [];
      errors.push({ textId, message: 'Column ' + (colNum+1) + ' does not exist' });
      continue;
    }
    const indices = [];
    for (let p = 0; p < (sh.sheetCount || 1) && indices.length < qty; p++) {
      for (let r = 0; r < spec.rows && indices.length < qty; r++) {
        const idx = p * lps + r * spec.cols + colNum;
        if (!printed.has(idx) && !used.has(idx)) {
          indices.push(idx);
          used.add(idx);
        }
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' in Column ' + (colNum+1) + ' but only ' + indices.length + ' available' });
    }
  }

  // Second pass: place "next available" texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0) { assignments[textId] = assignments[textId] || []; continue; }
    if (placement !== 'next') continue;

    const indices = [];
    for (let i = 0; i < total && indices.length < qty; i++) {
      if (!printed.has(i) && !used.has(i)) {
        indices.push(i);
        used.add(i);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' spots but only ' + indices.length + ' available' });
    }
  }

  // Ensure all textIds have an entry
  for (const textId of textIds) {
    if (!assignments[textId]) assignments[textId] = [];
  }

  return { assignments, errors };
}

// ========== SAVED TEXT HELPERS ==========
function getSavedText(id) {
  // Check user texts first
  const found = savedTexts.find(t => t.id === id);
  if (found) return found;
  // Check built-in templates
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getBuiltinTemplate(id) {
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getTexts() {
  return savedTexts.filter(t => t.type !== 'template');
}

function getTemplates() {
  return [...BUILTIN_TEMPLATES, ...savedTexts.filter(t => t.type === 'template')];
}

// ========== LINE SERIALIZATION ==========
function serializeLines(lines) {
  return lines.map(l => {
    let meta = l.align + ',' + (l.fontSize || 11);
    const flags = (l.bold ? 'b' : '') + (l.italic ? 'i' : '') + (l.underline ? 'u' : '') + (l.strikethrough ? 's' : '');
    const color = l.color || '';
    const fill = l.fillColor || '';
    const borders = l.borders || '';
    if (flags || color || fill || borders) {
      meta += ',' + flags + ',' + color + ',' + fill + ',' + borders;
    }
    return meta + ':' + l.text;
  }).join('\n');
}

function deserializeLines(str) {
  if (!str) return [];
  return str.split('\n').filter(s => s.trim()).map(s => {
    // Extended format: align,fontSize,flags,color,fillColor,borders:text
    const m3 = s.match(/^(left|center|right),(\d+),([\s\S]*?):(.*)$/);
    if (m3) {
      const parts = m3[3].split(',');
      const flags = parts[0] || '';
      const color = parts[1] || '';
      const fill = parts[2] || '';
      const borders = parts[3] || '';
      const line = { text: m3[4], align: m3[1], fontSize: parseInt(m3[2]) || 11 };
      if (flags.includes('b')) line.bold = true;
      if (flags.includes('i')) line.italic = true;
      if (flags.includes('u')) line.underline = true;
      if (flags.includes('s')) line.strikethrough = true;
      if (color) line.color = color;
      if (fill) line.fillColor = fill;
      if (borders) line.borders = borders;
      return line;
    }
    // Legacy format: align,fontSize:text
    const m2 = s.match(/^(left|center|right),(\d+):(.*)$/);
    if (m2) return { text: m2[3], align: m2[1], fontSize: parseInt(m2[2]) || 11 };
    const m = s.match(/^(left|center|right):(.*)$/);
    if (m) return { text: m[2], align: m[1], fontSize: 11 };
    return { text: s, align: 'left', fontSize: 11 };
  });
}

function getFlatText(lines) {
  return lines.map(l => l.text).join(' / ');
}

// Generate a clean, descriptive name for content created via wizard
function generateContentName(lines, labelType) {
  // Try to extract meaningful text from the first non-empty line
  let firstLine = '';
  for (const line of lines) {
    const text = (line.text || '').trim();
    if (text) {
      // Clean up fill-in blanks and split syntax
      let clean = text
        .replace(/__+/g, '___')  // Normalize underscores
        .replace(/\|\|/g, ' / ') // Replace split marker
        .trim();
      if (clean && clean !== '___') {
        firstLine = clean;
        break;
      }
    }
  }
  
  // If we found meaningful text, use first 20 chars
  if (firstLine && firstLine.length > 3) {
    const preview = firstLine.substring(0, 20);
    return preview + (firstLine.length > 20 ? '...' : '');
  }
  
  // Fallback: generate a date-based name
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
  const typeLabel = labelType ? LABEL_TYPES[labelType]?.name || labelType : 'Label';
  
  return typeLabel + ' - ' + dateStr + ' ' + timeStr;
}

// Parse line for split (||) and fill (__) syntax
function parseLine(text) {
  if (text.includes('||')) {
    const parts = text.split('||').map(s => s.trim());
    const left = parts[0];
    const right = parts.slice(1).join(' ').trim();
    
    // Check if either side has fill-line syntax
    const leftHasFill = left.includes('__');
    const rightHasFill = right.includes('__');
    
    if (leftHasFill || rightHasFill) {
      // Parse each side for fill-line
      let leftParsed = { type: 'normal', text: left };
      let rightParsed = { type: 'normal', text: right };
      
      if (leftHasFill) {
        const idx = left.indexOf('__');
        leftParsed = { type: 'fill', label: left.substring(0, idx), trailing: left.substring(idx + 2).trim() };
      }
      if (rightHasFill) {
        const idx = right.indexOf('__');
        rightParsed = { type: 'fill', label: right.substring(0, idx), trailing: right.substring(idx + 2).trim() };
      }
      
      return { type: 'split-fill', left: leftParsed, right: rightParsed };
    }
    
    return { type: 'split', left, right };
  }
  if (text.includes('__')) {
    const idx = text.indexOf('__');
    return { type: 'fill', label: text.substring(0, idx), trailing: text.substring(idx + 2).trim() };
  }
  return { type: 'normal', text };
}

// ========== TOKEN SYSTEM ==========
function extractTokens(text) {
  const re = /\{([a-z][a-z0-9_]*)\}/gi;
  const tokens = [];
  let m;
  while ((m = re.exec(text)) !== null) {
    const token = m[1].toLowerCase();
    if (!tokens.includes(token)) tokens.push(token);
  }
  return tokens;
}

function replaceTokens(text, record) {
  return text.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, token) => {
    const key = token.toLowerCase();
    return record[key] !== undefined ? record[key] : match;
  });
}

// ========== AI INTEGRATION (v2.0 - Session 9) ==========

/**
 * Parse #LABELKEEPER format from clipboard/text
 * Format:
 *   #LABELKEEPER
 *   type: 5160
 *   qty: 3
 *   ---
 *   Line 1 content
 *   Line 2 content
 *   Line 3 content
 *   Line 4 content
 * 
 * Returns: { valid: true, type, qty, lines[] } or { valid: false }
 */
function parseLabelKeeperFormat(text) {
  if (!text || typeof text !== 'string') {
    return { valid: false };
  }
  
  const trimmed = text.trim();
  
  // Must start with #LABELKEEPER (case insensitive)
  if (!trimmed.toUpperCase().startsWith('#LABELKEEPER')) {
    return { valid: false };
  }
  
  // Split into header and content
  const separatorIndex = trimmed.indexOf('---');
  if (separatorIndex === -1) {
    return { valid: false };
  }
  
  const headerSection = trimmed.substring(0, separatorIndex);
  const contentSection = trimmed.substring(separatorIndex + 3).trim();
  
  // Parse header fields
  const headerLines = headerSection.split('\n').map(l => l.trim()).filter(l => l && l !== '#LABELKEEPER');
  
  let type = null;
  let qty = 1;
  
  for (const line of headerLines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) continue;
    
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    
    if (key === 'type') {
      // Accept formats: "5160", "avery5160", "avery 5160"
      const typeMatch = value.match(/\d{4}/);
      if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
        type = typeMatch[0];
      }
    } else if (key === 'qty' || key === 'quantity' || key === 'count') {
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
        qty = parsed;
      }
    }
  }
  
  // Parse content lines (up to 4)
  const contentLines = contentSection.split('\n').map(l => l.trim());
  const lines = contentLines.slice(0, 4);
  
  // Pad to 4 lines if needed
  while (lines.length < 4) {
    lines.push('');
  }
  
  // Must have at least one non-empty line
  if (lines.every(l => !l)) {
    return { valid: false };
  }
  
  return {
    valid: true,
    type: type,  // null means use default/last-used
    qty: qty,
    lines: lines
  };
}

/**
 * Parse URL query parameters for deep linking
 * Supported params:
 *   ?text=Line1|Line2|Line3|Line4  (pipe-separated)
 *   ?type=5160
 *   ?qty=3
 *   ?action=print  (goes directly to print wizard)
 * 
 * Returns: { hasParams: true, text, type, qty, action } or { hasParams: false }
 */
function parseUrlParams() {
  const params = new URLSearchParams(window.location.search);
  
  // Check for sheet deep link (QR code scan)
  if (params.has('sheet')) {
    return { 
      hasParams: true,
      action: 'openSheet',
      sheetId: params.get('sheet')
    };
  }
  
  if (!params.has('text') && !params.has('action')) {
    return { hasParams: false };
  }
  
  const result = {
    hasParams: true,
    text: null,
    lines: ['', '', '', ''],
    type: null,
    qty: 1,
    action: params.get('action') || 'print'
  };
  
  // Parse text (pipe-separated lines)
  if (params.has('text')) {
    const textParam = params.get('text');
    const lines = textParam.split('|').map(l => l.trim());
    result.lines = lines.slice(0, 4);
    while (result.lines.length < 4) {
      result.lines.push('');
    }
    result.text = textParam;
  }
  
  // Parse type
  if (params.has('type')) {
    const typeMatch = params.get('type').match(/\d{4}/);
    if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
      result.type = typeMatch[0];
    }
  }
  
  // Parse quantity
  if (params.has('qty')) {
    const parsed = parseInt(params.get('qty'), 10);
    if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
      result.qty = parsed;
    }
  }
  
  return result;
}

/**
 * Generate shareable prompt for AI assistants
 */
function getAIPromptTemplate() {
  return `When generating labels for LabelKeeper, format your output like this:

#LABELKEEPER
type: 5160
qty: 1
---
Line 1 (name or main text)
Line 2 (address line 1 or subtitle)
Line 3 (address line 2 or additional info)
Line 4 (city, state zip or footer)

Supported label types:
- 5160: Address labels (1" x 2.625", 30/sheet)
- 5163: Shipping labels (2" x 4", 10/sheet)
- 5167: Return address (0.5" x 1.75", 80/sheet)
- 5161: Address (1" x 4", 20/sheet)
- 5162: Address (1.33" x 4", 14/sheet)
- 5164: Shipping (3.33" x 4", 6/sheet)
- 8463: Shipping (2" x 4", 10/sheet)
- 18163: Shipping (2" x 4", 10/sheet)
- 5267: Return address (0.5" x 1.75", 80/sheet)

The user can paste this format directly into LabelKeeper for instant preview and printing.`;
}

// ============================================================================
// DATA PERSISTENCE
// ============================================================================

// ========== SETTINGS ==========
function loadSettings() {
  try {
    const saved = localStorage.getItem(SETTINGS_KEY);
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
    } else {
      // No saved settings - check system preference for dark mode
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        settings.darkMode = true;
      }
    }
    // Check legacy theme key
    const legacyTheme = localStorage.getItem(THEME_KEY);
    if (legacyTheme === 'dark') {
      settings.darkMode = true;
    }
  } catch(e) {}
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    localStorage.setItem(THEME_KEY, settings.darkMode ? 'dark' : 'light');
  } catch(e) {}
}

// ========== SHEETS ==========
function loadSheets() {
  try {
    const s = localStorage.getItem(SHEETS_KEY);
    if (s) sheets = JSON.parse(s);
    activeSheetId = localStorage.getItem(ACTIVE_KEY);
  } catch(e) {}
  
  // Try legacy migration
  if (!Object.keys(sheets).length) {
    try {
      const old = localStorage.getItem('avery5160_sheets');
      if (old) {
        const oldSheets = JSON.parse(old);
        for (const [id, sh] of Object.entries(oldSheets)) {
          sheets[id] = { ...sh, id, labelType: '5160' };
        }
        activeSheetId = localStorage.getItem('avery5160_active');
      }
    } catch(e) {}
  }
  
  // Ensure data consistency
  for (const [id, sh] of Object.entries(sheets)) {
    if (!sh.id) sh.id = id;  // Ensure id property exists
    if (!sh.labelType) sh.labelType = '5160';
    if (!sh.texts) sh.texts = {};
    if (!sh.sheetCount) sh.sheetCount = 1;
    if (!sh.printed) sh.printed = [];
    for (const entry of Object.values(sh.texts)) {
      if (!entry.placement) entry.placement = 'next';
    }
  }
  
  // Set active sheet if none
  if (!activeSheetId || !sheets[activeSheetId]) {
    if (Object.keys(sheets).length) {
      activeSheetId = Object.keys(sheets)[0];
    }
  }
}

function saveSheets() {
  try {
    localStorage.setItem(SHEETS_KEY, JSON.stringify(sheets));
    localStorage.setItem(ACTIVE_KEY, activeSheetId || '');
  } catch(e) {}
}

// ========== SAVED TEXTS ==========
function loadSavedTexts() {
  try {
    const s = localStorage.getItem(TEXTS_KEY);
    if (s) savedTexts = JSON.parse(s);
  } catch(e) {}
}

function saveSavedTexts() {
  try {
    localStorage.setItem(TEXTS_KEY, JSON.stringify(savedTexts));
  } catch(e) {}
}

// ========== INVENTORY ==========
function loadInventory() {
  try {
    const s = localStorage.getItem(INVENTORY_KEY);
    if (s) inventory = JSON.parse(s);
  } catch(e) {}
}

function saveInventory() {
  try {
    localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory));
  } catch(e) {}
}

// G8: Inventory history tracking
function loadInventoryHistory() {
  try {
    const s = localStorage.getItem(INVENTORY_HISTORY_KEY);
    if (s) inventoryHistory = JSON.parse(s);
  } catch(e) {}
}

function saveInventoryHistory() {
  try {
    localStorage.setItem(INVENTORY_HISTORY_KEY, JSON.stringify(inventoryHistory));
  } catch(e) {}
}

function addInventoryEvent(typeId, action, delta, newStock) {
  inventoryHistory.push({
    ts: Date.now(),
    type: typeId,
    action: action,  // 'add', 'set', 'print', 'adjust', 'remove'
    delta: delta,
    stock: newStock
  });
  // Keep last 500 events across all types
  if (inventoryHistory.length > 500) {
    inventoryHistory = inventoryHistory.slice(-500);
  }
  saveInventoryHistory();
}

function getInventoryBurnRate(typeId) {
  const events = inventoryHistory.filter(e => e.type === typeId);
  if (events.length < 2) return null;

  // Find the first stock event (when tracking began)
  const firstEvent = events[0];
  const lastEvent = events[events.length - 1];
  const daysSinceStart = (lastEvent.ts - firstEvent.ts) / 86400000;
  if (daysSinceStart < 1) return null;

  // Count total consumption: sum of negative deltas from 'print' and negative 'adjust'
  let totalConsumed = 0;
  for (const e of events) {
    if (e.delta < 0) totalConsumed += Math.abs(e.delta);
  }

  if (totalConsumed === 0) return null;

  const monthsElapsed = daysSinceStart / 30;
  const ratePerMonth = monthsElapsed > 0 ? totalConsumed / monthsElapsed : 0;
  const currentStock = inventory[typeId] ? inventory[typeId].stock : 0;
  const weeksLeft = ratePerMonth > 0 ? (currentStock / (ratePerMonth / 4.33)) : null;

  return {
    totalConsumed,
    daysSinceStart: Math.floor(daysSinceStart),
    ratePerMonth: Math.round(ratePerMonth * 10) / 10,
    weeksLeft: weeksLeft !== null ? Math.round(weeksLeft) : null,
    firstTracked: firstEvent.ts
  };
}

function getInventoryForType(labelType) {
  return inventory[labelType] || null;
}

function getInventorySummary(labelType) {
  const inv = inventory[labelType];
  const spec = LABEL_TYPES[labelType];
  if (!spec) return null;
  const lps = spec.cols * spec.rows;
  const stock = inv ? inv.stock : 0;

  let activeSheets = 0, partialSheets = 0, partialLabels = 0, fullyConsumed = 0;
  let assignedUnusedSheets = 0; // Sheets assigned to content but fully available
  let assignedPartialSheets = 0; // Sheets assigned with some printed
  
  for (const sh of Object.values(sheets)) {
    if (sh.labelType !== labelType) continue;
    const count = sh.sheetCount || 1;
    const printed = new Set(sh.printed || []);
    for (let p = 0; p < count; p++) {
      activeSheets++;
      let open = 0;
      for (let i = p * lps; i < (p + 1) * lps; i++) {
        if (!printed.has(i)) open++;
      }
      if (open === lps) {
        // All positions available
        assignedUnusedSheets++;
        partialSheets++; // Still count toward partial for legacy
        partialLabels += open;
      } else if (open > 0) {
        assignedPartialSheets++;
        partialSheets++;
        partialLabels += open;
      } else {
        fullyConsumed++;
      }
    }
  }

  return {
    stock, lps,
    stockLabels: stock * lps,
    activeSheets, partialSheets, partialLabels, fullyConsumed,
    assignedUnusedSheets,
    assignedPartialSheets,
    totalSheets: stock + partialSheets,
    totalLabels: (stock * lps) + partialLabels,
    isLow: inv ? stock <= inv.lowThreshold : false,
    lowThreshold: inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
}

// ========== BATCH JOBS ==========
function loadActiveJob() {
  try {
    const stored = localStorage.getItem(ACTIVE_JOB_KEY);
    activeJob = stored ? JSON.parse(stored) : null;
  } catch(e) { activeJob = null; }
}

function saveActiveJob() {
  try {
    if (activeJob) {
      localStorage.setItem(ACTIVE_JOB_KEY, JSON.stringify(activeJob));
    } else {
      localStorage.removeItem(ACTIVE_JOB_KEY);
    }
  } catch(e) {}
}

function hasActiveJob() {
  return activeJob !== null;
}

function getActiveJob() {
  return activeJob;
}

function loadJobHistory() {
  try {
    const stored = localStorage.getItem(JOB_HISTORY_KEY);
    jobHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { jobHistory = []; }
}

function saveJobHistory() {
  try {
    localStorage.setItem(JOB_HISTORY_KEY, JSON.stringify(jobHistory));
  } catch(e) {}
}

// ========== PRINT HISTORY (v2 new) ==========
function loadPrintHistory() {
  try {
    const stored = localStorage.getItem(PRINT_HISTORY_KEY);
    printHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { printHistory = []; }
}

function savePrintHistory() {
  try {
    localStorage.setItem(PRINT_HISTORY_KEY, JSON.stringify(printHistory));
  } catch(e) {}
}

function addPrintHistoryEntry(entry) {
  printHistory.unshift({
    id: generateId('ph'),
    timestamp: Date.now(),
    ...entry
  });
  // Keep last 100 entries
  if (printHistory.length > 100) {
    printHistory = printHistory.slice(0, 100);
  }
  savePrintHistory();
}

// ========== CUSTOM TOKENS ==========
function loadCustomTokens() {
  try {
    const s = localStorage.getItem(CUSTOM_TOKENS_KEY);
    if (s) customTokens = JSON.parse(s);
  } catch(e) {}
}

function saveCustomTokens() {
  try {
    localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(customTokens));
  } catch(e) {}
}

// ============================================================================
// SHEET OPERATIONS
// ============================================================================

function createSheet(name, labelType, sheetCount = 1, note = '') {
  const id = generateId('sh');
  sheets[id] = {
    id,
    name,
    labelType,
    sheetCount,
    note: note || '',
    printed: [],
    texts: {},
    createdAt: Date.now()
  };
  activeSheetId = id;
  saveSheets();
  return id;
}

function deleteSheet(id) {
  if (!sheets[id]) return false;
  delete sheets[id];
  if (activeSheetId === id) {
    activeSheetId = Object.keys(sheets)[0] || null;
  }
  saveSheets();
  return true;
}

async function confirmDeleteSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  const ok = await showConfirmDialog(
    'Delete "' + sh.name + '"? This removes the sheet and all position data. This cannot be undone.',
    'Delete Sheet',
    'Delete',
    'Cancel'
  );
  if (ok) {
    deleteSheet(id);
    showToast('Sheet deleted', 'success');
    renderCurrentTab();
  }
}

function retireSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  sh.retired = true;
  sh.retiredAt = Date.now();
  saveSheets();
  showToast('"' + sh.name + '" retired â€” it won\'t appear in print workflows', 'success');
  renderCurrentTab();
}

function unretireSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  sh.retired = false;
  sh.retiredAt = null;
  saveSheets();
  showToast('"' + sh.name + '" restored to active sheets', 'success');
  renderCurrentTab();
}

function renameSheet(id, newName) {
  if (!sheets[id]) return false;
  sheets[id].name = newName;
  saveSheets();
  return true;
}

function setActiveSheet(id) {
  if (sheets[id]) {
    activeSheetId = id;
    saveSheets();
  }
}

function markPositionsPrinted(sheetId, positions) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const printed = new Set(sh.printed || []);
  for (const pos of positions) {
    printed.add(pos);
  }
  sh.printed = Array.from(printed).sort((a, b) => a - b);
  saveSheets();
}

// ============================================================================
// SAVED TEXT OPERATIONS
// ============================================================================

function createSavedText(name, lines, opts = {}) {
  const id = generateId('st');
  const entry = {
    id,
    name,
    text: serializeLines(lines),
    alignV: opts.alignV || 'center',
    createdAt: Date.now()
  };
  if (opts.graphics) entry.graphics = opts.graphics;
  if (opts.isTemplate) {
    entry.type = 'template';
    entry.tokens = extractTokens(entry.text);
    entry.labelType = opts.labelType || '5160';
  }
  savedTexts.push(entry);
  saveSavedTexts();
  
  // Track in satellite pending queue if in satellite mode
  addToSatellitePending(id);
  
  return id;
}

function updateSavedText(id, updates) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  savedTexts[idx] = { ...savedTexts[idx], ...updates };
  if (updates.text && savedTexts[idx].type === 'template') {
    savedTexts[idx].tokens = extractTokens(updates.text);
  }
  saveSavedTexts();
  return true;
}

function deleteSavedText(id) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  
  // In satellite mode, can only delete items that are still in pending queue
  if (settings.deviceRole === 'satellite') {
    const pending = getSatellitePending();
    if (!pending.includes(id)) {
      showToast("Can't delete - synced from primary device", 'error');
      return false;
    }
    // Remove from pending queue
    removeFromSatellitePending(id);
  }
  
  savedTexts.splice(idx, 1);
  // Remove from all sheets
  for (const sh of Object.values(sheets)) {
    if (sh.texts && sh.texts[id]) {
      delete sh.texts[id];
    }
  }
  saveSavedTexts();
  saveSheets();
  return true;
}

function cloneSavedText(id, newName) {
  const original = getSavedText(id);
  if (!original) return null;
  const clone = {
    id: generateId('st'),
    name: newName,
    text: original.text,
    alignV: original.alignV || 'center',
    createdAt: Date.now()
  };
  if (original.graphics) clone.graphics = JSON.parse(JSON.stringify(original.graphics));
  if (original.type === 'template') {
    clone.type = 'template';
    clone.tokens = [...(original.tokens || [])];
    clone.labelType = original.labelType || '5160';
  }
  savedTexts.push(clone);
  saveSavedTexts();
  
  // Track in satellite pending queue if in satellite mode
  addToSatellitePending(clone.id);
  
  return clone.id;
}

// ============================================================================
// DATA EXPORT/IMPORT
// ============================================================================

function exportAllDataJSON() {
  const data = {
    version: '3.17.0',
    exportedAt: new Date().toISOString(),
    sheets,
    savedTexts,
    inventory,
    inventoryHistory,
    activeJob,
    jobHistory,
    customTokens,
    printHistory,
    settings,
    theme: settings.darkMode ? 'dark' : 'light'
  };
  return JSON.stringify(data, null, 2);
}

function importAllData(json) {
  try {
    const data = JSON.parse(json);
    
    // Validate
    if (!data.sheets && !data.savedTexts) {
      throw new Error('Invalid backup file');
    }
    
    // Import sheets
    if (data.sheets) {
      sheets = data.sheets;
      // Ensure consistency
      for (const sh of Object.values(sheets)) {
        if (!sh.labelType) sh.labelType = '5160';
        if (!sh.texts) sh.texts = {};
        if (!sh.sheetCount) sh.sheetCount = 1;
        if (!sh.printed) sh.printed = [];
      }
      activeSheetId = Object.keys(sheets)[0] || null;
      saveSheets();
    }
    
    // Import texts
    if (data.savedTexts) {
      savedTexts = data.savedTexts;
      saveSavedTexts();
    }
    
    // Import inventory
    if (data.inventory) {
      inventory = data.inventory;
      saveInventory();
    }
    
    // Import inventory history (G8)
    if (data.inventoryHistory) {
      inventoryHistory = data.inventoryHistory;
      saveInventoryHistory();
    }
    
    // Import jobs
    if (data.activeJob !== undefined) {
      activeJob = data.activeJob;
      saveActiveJob();
    }
    if (data.jobHistory) {
      jobHistory = data.jobHistory;
      saveJobHistory();
    }
    
    // Import custom tokens
    if (data.customTokens) {
      customTokens = data.customTokens;
      saveCustomTokens();
    }
    
    // Import print history
    if (data.printHistory) {
      printHistory = data.printHistory;
      savePrintHistory();
    }
    
    // Import theme
    if (data.theme) {
      settings.darkMode = data.theme === 'dark';
      saveSettings();
    }
    
    return { success: true };
  } catch(e) {
    return { success: false, error: e.message };
  }
}

// ============================================================================
// DATA STATS (for UI)
// ============================================================================

function getDataStats() {
  const sheetCount = Object.keys(sheets).length;
  const textCount = savedTexts.filter(t => t.type !== 'template').length;
  const templateCount = savedTexts.filter(t => t.type === 'template').length + BUILTIN_TEMPLATES.length;
  const inventoryTypes = Object.keys(inventory).length;
  
  let totalAvailable = 0;
  let totalPrinted = 0;
  for (const sh of Object.values(sheets)) {
    totalAvailable += getRemainingCount(sh);
    totalPrinted += getPrintedCount(sh);
  }
  
  return {
    sheetCount,
    textCount,
    templateCount,
    inventoryTypes,
    totalAvailable,
    totalPrinted,
    printHistoryCount: printHistory.length,
    hasData: sheetCount > 0 || textCount > 0
  };
}

// ============================================================================
// UI STATE & NAVIGATION
// ============================================================================

function applyTheme() {
  document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light');
  updateToggle('darkModeToggle', settings.darkMode);
}

function toggleDarkMode() {
  settings.darkMode = !settings.darkMode;
  saveSettings();
  applyTheme();
}

function updateToggle(id, active) {
  const toggle = document.getElementById(id);
  if (toggle) {
    toggle.classList.toggle('active', active);
  }
}

function openSettings() {
  // Populate data stats
  const stats = getDataStats();
  const statsEl = document.getElementById('settingsDataStats');
  statsEl.innerHTML = 
    '<div class="settings-data-stat">ðŸ“„ <strong>' + stats.sheetCount + '</strong> sheet' + (stats.sheetCount !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ’¾ <strong>' + stats.textCount + '</strong> saved text' + (stats.textCount !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“¦ <strong>' + stats.inventoryTypes + '</strong> inventory type' + (stats.inventoryTypes !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“œ <strong>' + stats.printHistoryCount + '</strong> history item' + (stats.printHistoryCount !== 1 ? 's' : '') + '</div>';
  
  // Populate print offset fields
  document.getElementById('safariVScale').value = settings.safariVScale ?? 1.0;
  document.getElementById('printOffsetTop').value = settings.printOffsetTop || 0;
  document.getElementById('printOffsetLeft').value = settings.printOffsetLeft || 0;
  
  // Populate Quick Actions count (T11)
  document.getElementById('quickActionsCount').value = settings.quickActionsCount ?? 5;
  
  // Update label boundaries toggle
  const boundariesToggle = document.getElementById('labelBoundariesToggle');
  if (boundariesToggle) {
    boundariesToggle.classList.toggle('active', settings.showLabelBoundaries);
  }
  
  // Update device role UI
  updateDeviceRoleUI();
  
  // Update AI key status
  updateAIKeyStatusUI();
  
  document.getElementById('settingsModal').classList.add('visible');
}

function toggleLabelBoundaries() {
  settings.showLabelBoundaries = !settings.showLabelBoundaries;
  const toggle = document.getElementById('labelBoundariesToggle');
  if (toggle) {
    toggle.classList.toggle('active', settings.showLabelBoundaries);
  }
  saveSettings();
  showToast(settings.showLabelBoundaries ? 'Label boundaries enabled' : 'Label boundaries disabled', 'success');
}

function updatePrintOffset() {
  settings.safariVScale = parseFloat(document.getElementById('safariVScale').value) || 1.0;
  // Clamp to valid range
  if (settings.safariVScale < 0.90) settings.safariVScale = 0.90;
  if (settings.safariVScale > 1.0) settings.safariVScale = 1.0;
  document.getElementById('safariVScale').value = settings.safariVScale;
  
  settings.printOffsetTop = parseFloat(document.getElementById('printOffsetTop').value) || 0;
  settings.printOffsetLeft = parseFloat(document.getElementById('printOffsetLeft').value) || 0;
  saveSettings();
  showToast('Print settings saved', 'success');
}

// T11: Update Quick Actions count setting
function updateQuickActionsCount() {
  let count = parseInt(document.getElementById('quickActionsCount').value) || 5;
  // Clamp to valid range
  if (count < 0) count = 0;
  if (count > 10) count = 10;
  document.getElementById('quickActionsCount').value = count;
  
  settings.quickActionsCount = count;
  saveSettings();
  
  // Immediately refresh the Quick Actions display
  renderQuickActions();
  
  showToast('Quick actions updated', 'success');
}

function closeSettings() {
  document.getElementById('settingsModal').classList.remove('visible');
}

// ========== AI PROMPT MODAL ==========
function showAIPromptModal() {
  const promptBox = document.getElementById('aiPromptBox');
  if (promptBox) {
    promptBox.textContent = getAIPromptTemplate();
  }
  document.getElementById('aiPromptModal').classList.add('visible');
}

function closeAIPromptModal() {
  document.getElementById('aiPromptModal').classList.remove('visible');
}

function copyAIPrompt() {
  const prompt = getAIPromptTemplate();
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(prompt).then(() => {
      showToast('Prompt copied to clipboard!', 'success');
    }).catch(() => {
      fallbackCopyToClipboard(prompt);
    });
  } else {
    fallbackCopyToClipboard(prompt);
  }
}

function fallbackCopyToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    document.execCommand('copy');
    showToast('Prompt copied!', 'success');
  } catch (e) {
    showToast('Failed to copy. Please select and copy manually.', 'warning');
  }
  document.body.removeChild(textarea);
}

function copyDeepLinkExample() {
  const baseUrl = window.location.href.split('?')[0];
  const example = baseUrl + '?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1';
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(example).then(() => {
      showToast('Link format copied!', 'success');
    }).catch(() => {
      showToast('Copy failed', 'error');
    });
  }
}

// ========== BYOAI - Bring Your Own AI ==========
const AI_KEY_STORAGE = 'lk_ai_key';
const AI_PROVIDER_STORAGE = 'lk_ai_provider';

// Detect provider from API key format
function detectAIProvider(key) {
  if (!key) return null;
  key = key.trim();
  if (key.startsWith('sk-ant-')) return 'claude';
  if (key.startsWith('sk-')) return 'openai';
  // Gemini keys are typically 39 chars and alphanumeric
  if (/^[A-Za-z0-9_-]{39}$/.test(key)) return 'gemini';
  return null;
}

// Get stored AI key
function getAIKey() {
  try {
    return localStorage.getItem(AI_KEY_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Get stored provider
function getAIProvider() {
  try {
    return localStorage.getItem(AI_PROVIDER_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Save AI key
function saveAIKeyToStorage(key, provider) {
  try {
    localStorage.setItem(AI_KEY_STORAGE, key);
    localStorage.setItem(AI_PROVIDER_STORAGE, provider);
    return true;
  } catch (e) {
    return false;
  }
}

// Clear AI key
function clearAIKeyFromStorage() {
  try {
    localStorage.removeItem(AI_KEY_STORAGE);
    localStorage.removeItem(AI_PROVIDER_STORAGE);
    return true;
  } catch (e) {
    return false;
  }
}

// Update Settings UI to reflect AI key status
function updateAIKeyStatusUI() {
  const hasKey = !!getAIKey();
  const provider = getAIProvider();
  
  const statusEl = document.getElementById('aiKeyStatus');
  const statusTextEl = document.getElementById('aiKeyStatusText');
  const configBtn = document.getElementById('aiKeyConfigBtn');
  const configBtnText = document.getElementById('aiKeyConfigBtnText');
  const clearBtn = document.getElementById('aiKeyClearBtn');
  
  // Show/hide AI prompt on workflow hub
  const aiPrompt = document.getElementById('workflowAiPrompt');
  if (aiPrompt) aiPrompt.style.display = hasKey ? 'block' : 'none';
  
  if (!statusEl) return;
  
  if (hasKey && provider) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    statusEl.classList.remove('no-key');
    statusTextEl.textContent = `Connected to ${providerNames[provider] || provider}`;
    configBtnText.textContent = 'Change Key';
    clearBtn.style.display = 'inline-flex';
  } else {
    statusEl.classList.add('no-key');
    statusTextEl.textContent = 'No API key configured';
    configBtnText.textContent = 'Add API Key';
    clearBtn.style.display = 'none';
  }
}

// Show AI Key modal
function showAIKeyModal() {
  const input = document.getElementById('aiKeyInput');
  if (input) {
    input.value = getAIKey();
  }
  document.getElementById('aiKeyModal').classList.add('visible');
}

// Close AI Key modal
function closeAIKeyModal() {
  document.getElementById('aiKeyModal').classList.remove('visible');
}

// Save AI key from modal
function saveAIKey() {
  const input = document.getElementById('aiKeyInput');
  const key = input ? input.value.trim() : '';
  
  if (!key) {
    showToast('Please enter an API key', 'warning');
    return;
  }
  
  const provider = detectAIProvider(key);
  if (!provider) {
    showToast('Unrecognized key format. Please use a Claude, OpenAI, or Gemini key.', 'error');
    return;
  }
  
  if (saveAIKeyToStorage(key, provider)) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    showToast(`${providerNames[provider]} API key saved!`, 'success');
    closeAIKeyModal();
    updateAIKeyStatusUI();
  } else {
    showToast('Failed to save key', 'error');
  }
}

// Clear AI key
function clearAIKey() {
  if (confirm('Remove your API key? You can add it again anytime.')) {
    clearAIKeyFromStorage();
    showToast('API key removed', 'info');
    updateAIKeyStatusUI();
  }
}

// ===== AI CATEGORY FLOW =====
let currentAICategory = null;

function openAICategoryModal() {
  // Check if AI key is configured first
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  document.getElementById('aiCategoryModal').classList.add('visible');
}

function closeAICategoryModal() {
  document.getElementById('aiCategoryModal').classList.remove('visible');
}

function selectAICategory(category) {
  currentAICategory = category;
  closeAICategoryModal();
  showAICategoryForm(category);
}

function showAICategoryForm(category) {
  const titleEl = document.getElementById('aiFormTitle');
  const bodyEl = document.getElementById('aiFormBody');
  
  const forms = {
    address: {
      title: 'ðŸ“¬ Address Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Full Address</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiAddressInput" placeholder="Paste or type the full address...

Example:
John Smith
123 Main Street
Boston, MA 02101"></textarea>
          <div class="ai-form-hint">Include name, street, city, state, and zip</div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    gift: {
      title: 'ðŸŽ Gift Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Who is it for?</label>
          <input type="text" class="ai-form-input" id="aiGiftTo" placeholder="Sarah, Mom, The Johnsons...">
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">What's the occasion?</label>
          <input type="text" class="ai-form-input" id="aiGiftOccasion" placeholder="Birthday, Christmas, Thank you...">
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Birthday')">Birthday</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Christmas')">Christmas</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Thank You')">Thank You</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Wedding')">Wedding</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Baby Shower')">Baby Shower</span>
          </div>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">From (optional)</label>
          <input type="text" class="ai-form-input" id="aiGiftFrom" placeholder="With love from...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    organize: {
      title: 'ðŸ·ï¸ Organization Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What are you labeling?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiOrganizeItems" placeholder="List items (one per line or comma separated)...

Examples:
â€¢ Flour, Sugar, Rice, Pasta
â€¢ Q1 Reports, Tax Documents, Receipts
â€¢ Kids Toys, Winter Clothes, Holiday Decor"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('pantry')">ðŸ¥« Pantry</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('files')">ðŸ“ Files</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('bins')">ðŸ“¦ Storage Bins</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('kids')">ðŸ§¸ Kids Stuff</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    moving: {
      title: 'ðŸ“¦ Moving Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What rooms/boxes do you need?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiMovingRooms" placeholder="List rooms or box contents...

Example:
Kitchen - Pots & Pans
Kitchen - Fragile Dishes
Bedroom - Clothes
Garage - Tools"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Kitchen')">Kitchen</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bedroom')">Bedroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bathroom')">Bathroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Living Room')">Living Room</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Garage')">Garage</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('FRAGILE')">âš ï¸ Fragile</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    nametag: {
      title: 'ðŸ‘‹ Name Tags',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Names</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiNametagNames" placeholder="Enter names (one per line or comma separated)...

Example:
John Smith
Sarah Johnson
Mike Williams"></textarea>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">Event or company (optional)</label>
          <input type="text" class="ai-form-input" id="aiNametagEvent" placeholder="Team Meeting, Book Club, Acme Corp...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Name Tags</button>
        </div>
      `
    },
    custom: {
      title: 'âœï¸ Custom Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Describe what you need</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiCustomPrompt" placeholder="Tell the AI what kind of labels you want...

Examples:
â€¢ Warning labels for homemade hot sauce bottles
â€¢ Return address with a fun gardening theme
â€¢ Labels for my handmade candle business"></textarea>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Generate</button>
        </div>
      `
    }
  };
  
  const form = forms[category];
  titleEl.textContent = form.title;
  bodyEl.innerHTML = form.html;
  
  document.getElementById('aiFormModal').classList.add('visible');
}

function closeAIFormModal() {
  document.getElementById('aiFormModal').classList.remove('visible');
  currentAICategory = null;
}

function backToAICategories() {
  closeAIFormModal();
  openAICategoryModal();
}

// Helper functions for suggestion chips
function fillGiftOccasion(value) {
  document.getElementById('aiGiftOccasion').value = value;
}

function fillOrganizeType(type) {
  const examples = {
    pantry: 'Flour, Sugar, Rice, Pasta, Cereal, Oats',
    files: 'Tax Documents, Medical Records, Insurance, Receipts',
    bins: 'Holiday Decor, Winter Clothes, Sports Equipment',
    kids: 'Toys, Art Supplies, Books, Games'
  };
  document.getElementById('aiOrganizeItems').value = examples[type] || '';
}

function fillMovingRoom(room) {
  const input = document.getElementById('aiMovingRooms');
  const current = input.value.trim();
  if (current) {
    input.value = current + '\n' + room;
  } else {
    input.value = room;
  }
}

// Build prompt from category form and generate
async function generateFromCategory() {
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  const statusEl = document.getElementById('aiFormStatus');
  const errorEl = document.getElementById('aiFormError');
  const btn = document.getElementById('aiFormSubmit');
  
  // Build the prompt based on category
  let prompt = '';
  
  switch (currentAICategory) {
    case 'address':
      const address = document.getElementById('aiAddressInput').value.trim();
      if (!address) {
        showToast('Please enter an address', 'warning');
        return;
      }
      prompt = `Format this as a clean address label:\n${address}`;
      break;
      
    case 'gift':
      const to = document.getElementById('aiGiftTo').value.trim();
      const occasion = document.getElementById('aiGiftOccasion').value.trim();
      const from = document.getElementById('aiGiftFrom').value.trim();
      if (!to) {
        showToast('Please enter who the gift is for', 'warning');
        return;
      }
      prompt = `Create a gift tag label for ${to}`;
      if (occasion) prompt += ` for ${occasion}`;
      if (from) prompt += `, from ${from}`;
      break;
      
    case 'organize':
      const items = document.getElementById('aiOrganizeItems').value.trim();
      if (!items) {
        showToast('Please enter items to label', 'warning');
        return;
      }
      prompt = `Create organization labels for these items (one label per item, keep text short and clear):\n${items}`;
      break;
      
    case 'moving':
      const rooms = document.getElementById('aiMovingRooms').value.trim();
      if (!rooms) {
        showToast('Please enter rooms or contents', 'warning');
        return;
      }
      prompt = `Create moving box labels for these (include room name prominently, add relevant icon if possible with text):\n${rooms}`;
      break;
      
    case 'nametag':
      const names = document.getElementById('aiNametagNames').value.trim();
      const event = document.getElementById('aiNametagEvent').value.trim();
      if (!names) {
        showToast('Please enter names', 'warning');
        return;
      }
      prompt = `Create name tag labels for these people`;
      if (event) prompt += ` (for: ${event})`;
      prompt += `:\n${names}`;
      break;
      
    case 'custom':
      const customPrompt = document.getElementById('aiCustomPrompt').value.trim();
      if (!customPrompt) {
        showToast('Please describe what you need', 'warning');
        return;
      }
      prompt = customPrompt;
      break;
      
    default:
      showToast('Unknown category', 'error');
      return;
  }
  
  // Show loading
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, prompt);
    
    closeAIFormModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: prompt,
        category: currentAICategory,
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, prompt, currentAICategory);
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Open AI Generate modal (or key modal if no key)
function openAIGenerate() {
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  
  // Clear previous state
  const textarea = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  if (textarea) textarea.value = '';
  if (statusEl) statusEl.style.display = 'none';
  if (errorEl) errorEl.style.display = 'none';
  if (btn) btn.disabled = false;
  
  document.getElementById('aiGenerateModal').classList.add('visible');
}

// Close AI Generate modal
function closeAIGenerateModal() {
  document.getElementById('aiGenerateModal').classList.remove('visible');
}

// Generate label content with AI
async function generateWithAI() {
  const key = getAIKey();
  const provider = getAIProvider();
  const promptInput = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  const userPrompt = promptInput ? promptInput.value.trim() : '';
  
  if (!userPrompt) {
    showToast('Please describe the label you want', 'warning');
    return;
  }
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Show loading state
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, userPrompt);
    
    closeAIGenerateModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: userPrompt,
        category: 'custom',
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, userPrompt, 'custom');
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Call the appropriate AI provider API
async function callAIProvider(provider, key, userPrompt) {
  const systemPrompt = `You are a label content generator for LabelKeeper. Output label content in LabelKeeper format.

OUTPUT FORMAT:
Return up to 4 lines of label text, optionally with formatting and graphics instructions.

LINE FORMAT:
alignment,size:text

ALIGNMENT: left | center | right (default: left)
SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left-aligned and right-aligned parts
  Example: "left,11:Teacher: Smith || Room: 101" 
  This renders "Teacher: Smith" on the left and "Room: 101" on the right of the same line

â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) to create a blank line for writing
  Example: "left,11:Name: __" renders as "Name: _______________" (a long line for writing)
  
â€¢ DECORATIVE LINES: For visual separators, use Unicode characters:
  - Solid line: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (use â”€ character, NOT dashes)
  - Dotted: Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· (use Â· middle dot)
  - Stars: â˜… â˜… â˜… â˜… â˜… or â˜† â˜† â˜† â˜† â˜†
  - Hearts: â™¥ â™¥ â™¥ â™¥ â™¥
  - Arrows: â†’ â† â†‘ â†“
  
DO NOT use ASCII dashes (---) for decorative lines. Use proper Unicode box-drawing characters.

EXAMPLES:
"center,14:FRAGILE" - Large centered text
"left,11:From: || To:" - Split line with labels on each side
"center,11:â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" - Decorative separator line
"left,11:Signature: __" - Fill-in line for signature

GRAPHICS:
You CAN generate custom SVG graphics! If the user wants an icon, logo, or image:
1. Output the label text lines first
2. Then add a line starting with SVG_LEFT: or SVG_RIGHT: followed by valid SVG code
3. SVG should use viewBox="0 0 64 64" and be self-contained with solid fills (not just strokes)

Example with graphic:
left,14:Warning
center,11:Hot Surface
SVG_LEFT:<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><text x="32" y="42" text-anchor="middle" fill="white" font-size="32" font-weight="bold">!</text></svg>

COMMON ICON SVGs YOU CAN USE:
- Warning triangle: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4L4 56h56L32 4z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>
- Checkmark: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32L28 40L44 24" stroke="#fff" stroke-width="4" fill="none"/></svg>
- X/Stop: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><path d="M20 20L44 44M44 20L20 44" stroke="#fff" stroke-width="4"/></svg>
- Heart: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56C16 44 4 32 4 20c0-10 8-16 18-16 6 0 10 4 10 4s4-4 10-4c10 0 18 6 18 16 0 12-12 24-28 36z" fill="#ef4444"/></svg>
- Star: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#fbbf24"/></svg>
- Arrow right: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32h32M36 20l12 12-12 12" stroke="#333" stroke-width="4" fill="none" stroke-linecap="round"/></svg>
- Box/Package: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/></svg>
- Fragile glass: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8L44 8L44 28Q44 48 32 56Q20 48 20 28Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20L32 32L28 32L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>

Feel free to create custom SVGs for specific requests (logos, symbols, simple illustrations). Keep SVGs simple with solid fills for good print quality.

QR CODES / BARCODES:
You cannot generate functional QR codes or barcodes. If requested, explain they need to use Full Editor and upload a QR code image.

OUTPUT ONLY THE FORMATTED LINES AND OPTIONAL SVG. NO EXPLANATIONS OR MARKDOWN.`;

  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 200,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 200,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 200
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
}

// ============================================================================
// AI PREVIEW SYSTEM - Shows what AI understood before applying
// ============================================================================

const AI_SKIP_PREVIEW_KEY = 'lk_ai_skip_preview';

// State for current AI preview
let aiPreviewState = {
  originalPrompt: '',
  category: null,
  understanding: '',
  labels: [],
  suggestedType: '5160',
  quantity: 1,
  svgLeft: null,
  svgRight: null
};

// Check if user wants to skip preview
function shouldSkipAIPreview() {
  try {
    return localStorage.getItem(AI_SKIP_PREVIEW_KEY) === 'true';
  } catch (e) {
    return false;
  }
}

// Toggle skip preview preference
function toggleAIPreviewSkip() {
  const checkbox = document.getElementById('aiPreviewSkip');
  try {
    if (checkbox && checkbox.checked) {
      localStorage.setItem(AI_SKIP_PREVIEW_KEY, 'true');
    } else {
      localStorage.removeItem(AI_SKIP_PREVIEW_KEY);
    }
  } catch (e) {}
}

// New system prompt that returns JSON with understanding
function getAISystemPromptWithPreview() {
  return `You are a label content generator for LabelKeeper. You MUST respond with valid JSON only.

RESPONSE FORMAT (strict JSON, no markdown):
{
  "understanding": "Brief summary of what the user wants (1-2 sentences)",
  "labels": [
    {
      "preview": "Human-readable preview text for this label",
      "lines": ["alignment,size:text", ...],
      "svg": null or "SVG_LEFT:..." or "SVG_RIGHT:..."
    }
  ],
  "suggestedType": "5160",
  "quantity": 1,
  "error": null
}

HANDLING IMPOSSIBLE REQUESTS:
If you cannot fulfill the request (e.g., user asks you to access files, browse the web, read emails, or do something outside label generation), respond with:
{
  "understanding": "What the user asked for",
  "labels": [],
  "suggestedType": "5160",
  "quantity": 0,
  "error": "Brief explanation of why this can't be done and what the user could do instead"
}
Example error: "I cannot access local files or Excel documents. To create labels from your contacts, please copy the contact information from Excel and paste it here, or use the CSV Import feature in the main menu."

IMPORTANT: Always respond with JSON. Never write conversational text or instructions as label content.

LABEL LINE FORMAT:
alignment,size:text
- ALIGNMENT: left | center | right (default: left)
- SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left and right parts
  Example: "left,11:Teacher: Smith || Room: 101"
â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) for a blank line
  Example: "left,11:Name: __"
â€¢ DECORATIVE LINES: Use Unicode: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (not dashes)

LABEL TYPES:
- "5160": Address labels (30/sheet) - most common
- "5163": Shipping labels (10/sheet) - larger
- "5167": Return address (80/sheet) - small
- "5395": Name badges (8/sheet)

GRAPHICS (optional):
For icons/images, add svg field with "SVG_LEFT:<svg...>" or "SVG_RIGHT:<svg...>"
SVG should use viewBox="0 0 64 64" with solid fills.

MULTIPLE LABELS:
If user wants multiple different labels (e.g., "labels for Flour, Sugar, Rice"), create separate label objects in the array.
If user wants multiple copies of the SAME label, use quantity field instead.

EXAMPLES:

Request: "Address label for John Smith, 123 Main St, Boston MA"
{
  "understanding": "Creating an address label for John Smith in Boston",
  "labels": [{"preview": "John Smith\\n123 Main St\\nBoston, MA", "lines": ["left,11:John Smith", "left,11:123 Main St", "left,11:Boston, MA"], "svg": null}],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Pantry labels for Flour, Sugar, and Rice"
{
  "understanding": "Creating 3 pantry organization labels",
  "labels": [
    {"preview": "FLOUR", "lines": ["center,14:FLOUR"], "svg": null},
    {"preview": "SUGAR", "lines": ["center,14:SUGAR"], "svg": null},
    {"preview": "RICE", "lines": ["center,14:RICE"], "svg": null}
  ],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Warning label with exclamation icon"
{
  "understanding": "Creating a warning label with an icon",
  "labels": [{"preview": "âš ï¸ WARNING\\nHot Surface", "lines": ["center,14:WARNING", "center,11:Hot Surface"], "svg": "SVG_LEFT:<svg viewBox=\\"0 0 64 64\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M32 4L4 56h56L32 4z\\" fill=\\"#fbbf24\\"/><rect x=\\"29\\" y=\\"20\\" width=\\"6\\" height=\\"20\\" fill=\\"#1f2937\\"/><circle cx=\\"32\\" cy=\\"48\\" r=\\"4\\" fill=\\"#1f2937\\"/></svg>"}],
  "suggestedType": "5163",
  "quantity": 1
}

RESPOND WITH VALID JSON ONLY. NO MARKDOWN, NO EXPLANATION, NO CODE BLOCKS.`;
}

// Call AI provider and get structured preview data
async function callAIProviderForPreview(provider, key, userPrompt) {
  const systemPrompt = getAISystemPromptWithPreview();
  
  let responseText = '';
  
  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 1000,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 1000
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
  
  // Parse JSON response
  try {
    // Clean up response - remove markdown code blocks if present
    let cleanJson = responseText.trim();
    if (cleanJson.startsWith('```json')) {
      cleanJson = cleanJson.slice(7);
    } else if (cleanJson.startsWith('```')) {
      cleanJson = cleanJson.slice(3);
    }
    if (cleanJson.endsWith('```')) {
      cleanJson = cleanJson.slice(0, -3);
    }
    cleanJson = cleanJson.trim();
    
    const parsed = JSON.parse(cleanJson);
    return parsed;
  } catch (e) {
    console.error('Failed to parse AI response as JSON:', responseText);
    
    // Detect if this looks like a conversational refusal/explanation rather than label content
    const lowerResponse = responseText.toLowerCase();
    const refusalPatterns = [
      'i cannot', 'i can\'t', 'i\'m unable', 'i am unable',
      'i don\'t have access', 'i do not have access',
      'unfortunately', 'i\'m sorry', 'i apologize',
      'not able to', 'unable to access', 'cannot access',
      'please provide', 'you\'ll need to', 'you will need to',
      'copy and paste', 'copy the', 'paste the',
      'however,', 'instead,', 'alternatively,'
    ];
    
    const looksLikeRefusal = refusalPatterns.some(pattern => lowerResponse.includes(pattern));
    
    if (looksLikeRefusal) {
      // This is an explanation/refusal - return as error, not label content
      return {
        understanding: 'Unable to complete this request',
        labels: [],
        suggestedType: '5160',
        quantity: 0,
        error: responseText.split('\n').slice(0, 4).join(' ').substring(0, 300) + (responseText.length > 300 ? '...' : '')
      };
    }
    
    // Fallback: try to create a basic response from raw text (only if it looks like actual content)
    return {
      understanding: 'Generated label content',
      labels: [{
        preview: responseText.split('\n')[0] || 'Label',
        lines: responseText.split('\n').filter(l => l.trim()).slice(0, 4),
        svg: null
      }],
      suggestedType: '5160',
      quantity: 1,
      error: null
    };
  }
}

// Show AI Preview modal with results
function showAIPreviewModal(previewData, originalPrompt, category) {
  // Store state
  aiPreviewState = {
    originalPrompt: originalPrompt,
    category: category,
    understanding: previewData.understanding || 'Generated labels',
    labels: previewData.labels || [],
    suggestedType: previewData.suggestedType || '5160',
    quantity: previewData.quantity || 1,
    error: previewData.error || null,
    svgLeft: null,
    svgRight: null
  };
  
  // Extract SVG from first label if present
  if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
    const svg = aiPreviewState.labels[0].svg;
    if (svg.startsWith('SVG_LEFT:')) {
      aiPreviewState.svgLeft = svg.substring(9).trim();
    } else if (svg.startsWith('SVG_RIGHT:')) {
      aiPreviewState.svgRight = svg.substring(10).trim();
    }
  }
  
  // Populate understanding
  document.getElementById('aiPreviewUnderstanding').textContent = aiPreviewState.understanding;
  
  // Handle error state
  const labelsContainer = document.getElementById('aiPreviewLabels');
  const labelCountEl = document.getElementById('aiPreviewLabelCount');
  const acceptBtn = document.getElementById('aiPreviewAcceptBtn');
  
  if (aiPreviewState.error) {
    // Show error message instead of labels
    labelCountEl.textContent = '0';
    labelsContainer.innerHTML = `
      <div class="ai-preview-error">
        <div class="ai-preview-error-icon">âš ï¸</div>
        <div class="ai-preview-error-title">Unable to generate labels</div>
        <div class="ai-preview-error-message">${escapeHtml(aiPreviewState.error)}</div>
        <div class="ai-preview-error-hint">Use the "Refine" button below to provide different information or rephrase your request.</div>
      </div>
    `;
    // Disable accept button when there's an error
    if (acceptBtn) {
      acceptBtn.disabled = true;
      acceptBtn.style.opacity = '0.5';
    }
  } else {
    // Normal flow - populate labels list
    labelCountEl.textContent = aiPreviewState.labels.length;
    labelsContainer.innerHTML = '';
    
    if (acceptBtn) {
      acceptBtn.disabled = false;
      acceptBtn.style.opacity = '1';
    }
  
    aiPreviewState.labels.forEach((label, index) => {
      const item = document.createElement('div');
      item.className = 'ai-preview-label-item';
      item.dataset.index = index;
      
      // Format preview text for display
      const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
      const displayText = previewText.replace(/\\n/g, '\n');
      
      // Build meta info
      let metaInfo = [];
      if (label.lines && label.lines.length > 0) {
        const firstLine = label.lines[0];
        if (firstLine.includes(',')) {
          const parts = firstLine.split(':')[0].split(',');
          if (parts[0]) metaInfo.push(parts[0]);
          if (parts[1]) metaInfo.push('size ' + parts[1]);
        }
      }
      if (label.svg) metaInfo.push('has graphic');
      
      item.innerHTML = `
        <div class="ai-preview-label-num">${index + 1}</div>
        <div class="ai-preview-label-content">
          <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
          ${metaInfo.length ? `<div class="ai-preview-label-meta">${metaInfo.join(' â€¢ ')}</div>` : ''}
        </div>
        <button class="ai-preview-label-edit" onclick="editPreviewLabel(${index})" title="Edit this label">âœï¸</button>
      `;
      
      labelsContainer.appendChild(item);
    });
  }
  
  // Populate settings
  const typeSpec = LABEL_TYPES[aiPreviewState.suggestedType];
  const typeDisplay = typeSpec ? `${aiPreviewState.suggestedType} ${typeSpec.desc}` : aiPreviewState.suggestedType;
  document.getElementById('aiPreviewType').textContent = typeDisplay;
  document.getElementById('aiPreviewQty').textContent = aiPreviewState.labels.length > 1 
    ? aiPreviewState.labels.length + ' labels' 
    : aiPreviewState.quantity;
  
  // Set skip checkbox state
  const skipCheckbox = document.getElementById('aiPreviewSkip');
  if (skipCheckbox) {
    skipCheckbox.checked = shouldSkipAIPreview();
  }
  
  // Hide refine panel
  hideRefinePanel();
  
  // Show modal
  document.getElementById('aiPreviewModal').classList.add('visible');
}

// Close AI Preview modal
function closeAIPreviewModal() {
  document.getElementById('aiPreviewModal').classList.remove('visible');
  hideRefinePanel();
}

// Edit a specific label in preview
function editPreviewLabel(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item || item.classList.contains('editing')) return;
  
  const label = aiPreviewState.labels[index];
  const textEl = item.querySelector('.ai-preview-label-text');
  const currentText = label.preview || label.lines?.join('\n') || '';
  
  // Switch to edit mode
  item.classList.add('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  const originalHTML = contentDiv.innerHTML;
  
  contentDiv.innerHTML = `
    <textarea class="ai-preview-edit-input" rows="3">${escapeHtml(currentText.replace(/\\n/g, '\n'))}</textarea>
    <div class="ai-preview-edit-actions">
      <button class="ai-preview-edit-save" onclick="savePreviewLabelEdit(${index})">Save</button>
      <button class="ai-preview-edit-cancel" onclick="cancelPreviewLabelEdit(${index})">Cancel</button>
    </div>
  `;
  
  // Store original HTML for cancel
  item.dataset.originalHtml = originalHTML;
  
  // Focus input
  const input = contentDiv.querySelector('.ai-preview-edit-input');
  if (input) input.focus();
}

// Save edited label
function savePreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const input = item.querySelector('.ai-preview-edit-input');
  const newText = input ? input.value.trim() : '';
  
  if (newText) {
    // Update state
    const lines = newText.split('\n').filter(l => l.trim()).slice(0, 4);
    aiPreviewState.labels[index].preview = newText.replace(/\n/g, '\\n');
    aiPreviewState.labels[index].lines = lines.map(l => 'left,11:' + l);
    
    // Rebuild item
    rebuildPreviewLabelItem(index);
  } else {
    cancelPreviewLabelEdit(index);
  }
}

// Cancel label edit
function cancelPreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  item.classList.remove('editing');
  const contentDiv = item.querySelector('.ai-preview-label-content');
  if (contentDiv && item.dataset.originalHtml) {
    contentDiv.innerHTML = item.dataset.originalHtml;
  }
}

// Rebuild label item after edit
function rebuildPreviewLabelItem(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const label = aiPreviewState.labels[index];
  const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
  const displayText = previewText.replace(/\\n/g, '\n');
  
  item.classList.remove('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  contentDiv.innerHTML = `
    <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
  `;
}

// Show refine panel
function showRefinePanel() {
  document.getElementById('aiRefineOriginal').textContent = aiPreviewState.originalPrompt;
  document.getElementById('aiRefineInput').value = '';
  document.getElementById('aiRefinePanel').classList.add('visible');
  document.getElementById('aiPreviewActions').style.display = 'none';
  document.getElementById('aiRefineInput').focus();
}

// Hide refine panel
function hideRefinePanel() {
  document.getElementById('aiRefinePanel').classList.remove('visible');
  document.getElementById('aiPreviewActions').style.display = 'flex';
}

// Regenerate with refinement
async function regenerateWithRefinement() {
  const refinement = document.getElementById('aiRefineInput').value.trim();
  if (!refinement) {
    showToast('Please add some refinement details', 'warning');
    return;
  }
  
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Build combined prompt
  const combinedPrompt = `Original request: ${aiPreviewState.originalPrompt}\n\nRefinement: ${refinement}`;
  
  // Close preview and show loading
  closeAIPreviewModal();
  
  // Re-trigger the appropriate flow
  try {
    showToast('Regenerating with your refinements...', 'info');
    
    const previewData = await callAIProviderForPreview(provider, key, combinedPrompt);
    
    if (shouldSkipAIPreview()) {
      applyAIPreviewToWizard();
    } else {
      showAIPreviewModal(previewData, combinedPrompt, aiPreviewState.category);
    }
  } catch (error) {
    console.error('AI regeneration error:', error);
    showToast(error.message || 'Failed to regenerate. Try again.', 'error');
  }
}

// Accept and apply the AI preview
function acceptAIPreview() {
  applyAIPreviewToWizard();
  closeAIPreviewModal();
  showToast('Labels created! Review and print.', 'success');
}

// Apply AI preview state to the wizard
function applyAIPreviewToWizard() {
  if (aiPreviewState.labels.length === 0) return;
  
  // If called from WF1, populate WF1 editor instead
  if (wf1_aiActive) {
    const label = aiPreviewState.labels[0];
    const lines = label.lines || [];
    
    // Build content lines from AI output
    wf1ContentLines = [];
    for (let i = 0; i < Math.min(lines.length, 4); i++) {
      const parsed = parseLabelLine(lines[i] || '');
      wf1ContentLines.push(parsed);
    }
    
    // Re-open WF1 wizard at step 6
    wf1_aiActive = false;
    showWizard('wf1Wizard');
    wf1ShowStep('wf1Step6');
    wf1PopulateEditorFromLines(wf1ContentLines);
    showToast('AI content applied!', 'success');
    return;
  }
  
  // If multiple labels, create each as separate content
  if (aiPreviewState.labels.length > 1) {
    // Save each label as content
    aiPreviewState.labels.forEach((label, i) => {
      const lines = label.lines || [];
      const parsedLines = lines.map(parseLabelLine);
      
      // Create content item
      const id = 'text_' + Date.now() + '_' + i;
      const textContent = parsedLines.map(l => l.text).join('\n');
      
      // Save to storage (simplified - just text for now)
      const savedTexts = loadSavedTexts();
      savedTexts[id] = {
        text: textContent,
        lines: parsedLines,
        isTemplate: false,
        createdAt: Date.now()
      };
      saveSavedTexts(savedTexts);
    });
    
    showToast(`${aiPreviewState.labels.length} labels saved to Content!`, 'success');
    showTab('content');
    renderContentTab();
    return;
  }
  
  // Single label - route to WF1
  const label = aiPreviewState.labels[0];
  const lines = label.lines || [];
  
  // Build content lines from AI output
  const parsedLines = [];
  for (let i = 0; i < Math.min(lines.length, 4); i++) {
    parsedLines.push(parseLabelLine(lines[i] || ''));
  }
  
  // Start WF1 and populate content at step 6
  wf1Start();
  setTimeout(function() {
    wf1PopulateEditorFromLines(parsedLines);
    
    // Handle SVG graphics
    if (aiPreviewState.svgLeft || aiPreviewState.svgRight) {
      showToast('Opening Full Editor to apply graphics...', 'info');
      window._aiGeneratedSvgLeft = aiPreviewState.svgLeft;
      window._aiGeneratedSvgRight = aiPreviewState.svgRight;
      
      wf1_fullEditorActive = true;
      setTimeout(function() {
        openFullEditorFromWizard();
        setTimeout(function() {
          if (window._aiGeneratedSvgLeft) {
            const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgLeft);
            feGraphics.left = { data: svgDataUrl, size: 'M' };
          }
          if (window._aiGeneratedSvgRight) {
            const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgRight);
            feGraphics.right = { data: svgDataUrl, size: 'M' };
          }
          updateFullEditorPreview();
          renderFeGraphics();
          window._aiGeneratedSvgLeft = null;
          window._aiGeneratedSvgRight = null;
        }, 100);
      }, 300);
    }
  }, 100);
}

// ============================================================================
// AI CONVERSATIONAL LAYER (Phase 4) â€” Natural language â†’ WF1/WF2
// ============================================================================

// Fill the AI prompt input with suggestion text
function aiConvFill(text) {
  const input = document.getElementById('aiConvInput');
  if (input) {
    input.value = text;
    input.focus();
  }
}

// Conversation history for multi-turn AI chat
let aiConvHistory = [];

// Reset conversational UI to idle state
function aiConvReset() {
  aiConvHistory = []; // Clear conversation history
  document.getElementById('aiConvInput').value = '';
  document.getElementById('aiConvStatus').style.display = 'none';
  document.getElementById('aiConvResponse').style.display = 'none';
  document.getElementById('aiConvResponse').innerHTML = '';
  document.getElementById('aiConvSuggestions').style.display = 'flex';
  document.getElementById('aiConvSendBtn').disabled = false;
}

// Gather current app state context for the AI system prompt
function aiConvGetAppContext() {
  const ctx = { inventory: {}, sheets: [], savedContent: [], recentHistory: [] };
  
  // Inventory summary per type
  for (const typeId of TYPE_ORDER) {
    const summary = getInventorySummary(typeId);
    if (summary && (summary.stock > 0 || summary.partialLabels > 0)) {
      ctx.inventory[typeId] = {
        type: LABEL_TYPES[typeId].desc,
        stock: summary.stock,
        stockLabels: summary.stockLabels,
        partialLabels: summary.partialLabels,
        totalLabels: summary.totalLabels
      };
    }
  }
  
  // Active sheets with room
  for (const sh of Object.values(sheets)) {
    const remaining = getRemainingCount(sh);
    if (remaining > 0) {
      const spec = LABEL_TYPES[sh.labelType];
      ctx.sheets.push({
        name: sh.name,
        type: sh.labelType,
        typeDesc: spec ? spec.desc : sh.labelType,
        remaining: remaining,
        hasDedicatedContent: sh.texts && Object.keys(sh.texts).length > 0
      });
    }
  }
  
  // Saved content (names only, not full text)
  const stArr = savedTexts || [];
  for (const t of stArr) {
    if (t.name || t.text) {
      ctx.savedContent.push(t.name || (typeof t.text === 'string' ? t.text.substring(0, 40) : 'Saved'));
    }
  }
  
  // Recent print history (last 5)
  const hist = printHistory || [];
  for (let i = 0; i < Math.min(5, hist.length); i++) {
    const h = hist[i];
    ctx.recentHistory.push({
      name: h.textName || h.name || 'Unknown',
      labelType: h.labelType,
      count: h.count || h.totalLabels || 0,
      date: h.date || h.printedAt || ''
    });
  }
  
  return ctx;
}

// Build the conversational AI system prompt
function aiConvBuildSystemPrompt(appContext) {
  const typeList = TYPE_ORDER.map(t => {
    const spec = LABEL_TYPES[t];
    const lps = spec.cols * spec.rows;
    return t + ': ' + spec.desc + ' (' + spec.sizeDisplay + ', ' + lps + '/sheet)';
  }).join('\n  ');
  
  let invSummary = 'None tracked';
  const invKeys = Object.keys(appContext.inventory);
  if (invKeys.length > 0) {
    invSummary = invKeys.map(k => {
      const i = appContext.inventory[k];
      return k + ' (' + i.type + '): ' + i.totalLabels + ' labels available';
    }).join('; ');
  }
  
  let sheetSummary = 'No active sheets with room';
  if (appContext.sheets.length > 0) {
    sheetSummary = appContext.sheets.map(s =>
      '"' + s.name + '" (' + s.type + ' ' + s.typeDesc + '): ' + s.remaining + ' spots'
    ).join('; ');
  }
  
  let histSummary = 'No recent prints';
  if (appContext.recentHistory.length > 0) {
    histSummary = appContext.recentHistory.map(h =>
      '"' + h.name + '" (' + h.labelType + ', ' + h.count + ' labels, ' + h.date + ')'
    ).join('; ');
  }
  
  return `You are the AI assistant for LabelKeeper, a label printing app. Your job is to gather all the information needed for a print job, then route the user to the right place with clear instructions.

RESPOND WITH VALID JSON ONLY. No markdown, no explanation, no code blocks.

RESPONSE FORMAT:
{
  "message": "Your response to the user (see MESSAGE GUIDELINES below)",
  "action": "wf1" | "wf2" | "editor" | "clarify" | "settings",
  "params": {
    "labelType": "5160" | "5163" | ... | null,
    "jobType": "individual" | "batch" | null,
    "quantity": number | null,
    "contentLines": ["alignment,size:text", ...] | null,
    "batchItems": [["line1","line2",...], ...] | null,
    "savedContentName": "name of saved content to reprint" | null,
    "skipToStep": number | null,
    "printOrientation": "row" | "col1" | "col2" | null,
    "editorMode": "paste" | "new" | "template" | null,
    "clipboardReady": true | false | null
  }
}

INFORMATION NEEDED FOR A PRINT JOB:
1. Label type (5160, 5163, 5167, 5395, 5302, etc.)
2. Content (what text to print - either provided directly, from saved content, or user will paste/import)
3. Quantity (how many labels)
4. Orientation (optional: row-by-row, column 1 first, column 2 first)
5. Sheet (which physical sheet - usually auto-selected, but user may specify)

ACTIONS:
- "clarify": Use this when you're missing critical information that can be gathered with a simple question. PREFERRED over routing with incomplete info.
- "wf1": Start Print Something New workflow. Use when you have enough info OR need interactive UI (sheet picker, content editor).
- "wf2": Start Print Something Again workflow. Use when user wants to reprint saved content.
- "editor": Open Full Editor directly. Use when user will paste/import content and you have the other info needed.
- "settings": User wants to manage inventory, sheets, or settings.

LABEL TYPES:
  ${typeList}

TYPE INFERENCE RULES:
- "address labels", "mailing labels" â†’ 5160
- "shipping labels" â†’ 5163 (or 5164 for large)
- "return address" â†’ 5167 or 5195
- "name badges", "name tags" â†’ 5395
- "tent cards", "table cards", "place cards" â†’ 5302
- "full page", "full sheet" â†’ 5165
- For general/organization labels, ASK what type

USER'S CURRENT APP STATE:
- Inventory: ${invSummary}
- Active sheets with room: ${sheetSummary}
- Recent print history: ${histSummary}
- Saved content: ${appContext.savedContent.length > 0 ? appContext.savedContent.slice(0, 8).join(', ') : 'None'}

DECISION PROCESS:
1. Parse what the user ALREADY KNOWS from their message
2. Identify what's STILL MISSING from the required info
3. If missing 1-2 simple pieces of info â†’ action "clarify" and ASK
4. If user needs interactive UI (paste content, pick from visual sheet grid) â†’ route to appropriate screen
5. When routing, set ALL known params so workflow can skip completed steps

CLARIFY STRATEGY (action: "clarify"):
- Ask specific, focused questions
- List what you understood first, then ask what's missing
- Example: "Got it - 10 labels, column 1 first. What type of labels? (address, shipping, name badges, etc.)"
- If user mentions importing from Word/Excel but you don't know if it's ready: "Is the text already copied to your clipboard, or do you need to copy it first?"

WHEN TO USE "editor" ACTION:
- User will paste/import content from external source (Word, Excel, etc.)
- You have: label type (or can infer), quantity, orientation
- Set editorMode: "paste" if they'll paste, "new" if they'll type
- Set clipboardReady: true if they said content is ready/copied, false if they need to copy it first

MESSAGE GUIDELINES:

For action "clarify":
- Brief, conversational
- Acknowledge what you understood
- Ask specific question(s) about what's missing
- Example: "Got it - you want to print from a Word doc, column 1 first. A couple quick questions: 1) What type of labels? 2) How many do you need?"

For action "editor" (routing to text editor):
- Confirm what you understood (label type, quantity, orientation)
- Explain you're taking them to the text editor
- Give step-by-step instructions:
  * If clipboardReady is false: "Go to Word, copy your text (up to 4 lines), then come back"
  * Tell them to click the Paste button
  * Mention the preview panel shows how the label will look
  * Mention optional styling tools (alignment, size)
- Example message for editor with paste:
  "Here's what I have: 10 address labels, column 1 first.\\n\\nNext: I'll take you to the text editor.\\n1. Go to Word and copy your text (up to 4 lines)\\n2. Come back and click the ðŸ“‹ Paste button\\n3. Your text appears in the text boxes\\n\\nThe preview panel shows how your label will look. Use the styling tools to adjust alignment and size if needed."

For action "wf1" or "wf2":
- Confirm what you understood
- Briefly explain what will happen next
- If skipping steps, mention it: "I'll take you straight to [step] since I have the other details"

PRINT ORIENTATION:
- "first column", "column 1", "col 1", "left column" â†’ printOrientation "col1"
- "second column", "column 2", "col 2", "right column" â†’ printOrientation "col2"
- "row by row", "across", "normal" â†’ printOrientation "row"

CONTENT LINE FORMAT (for contentLines when user provides actual text):
alignment,size:text
- Example: "center,14:FRAGILE" or "left,11:John Smith"

RESPOND WITH JSON ONLY.`;
}

// Send the user's message to the AI
async function aiConvSend() {
  const input = document.getElementById('aiConvInput');
  const userText = (input.value || '').trim();
  if (!userText) return;
  
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Clear input immediately
  input.value = '';
  
  // Show loading
  document.getElementById('aiConvSendBtn').disabled = true;
  document.getElementById('aiConvSuggestions').style.display = 'none';
  document.getElementById('aiConvStatus').style.display = 'block';
  document.getElementById('aiConvStatusText').textContent = 'Thinking...';
  document.getElementById('aiConvResponse').style.display = 'none';
  
  // Add user message to history
  aiConvHistory.push({ role: 'user', content: userText });
  
  try {
    const appContext = aiConvGetAppContext();
    const systemPrompt = aiConvBuildSystemPrompt(appContext);
    
    // Call AI provider with full conversation history
    let responseText = await aiConvCallProvider(provider, key, systemPrompt, aiConvHistory);
    
    // Parse JSON
    let result;
    try {
      let clean = responseText.trim();
      if (clean.startsWith('```json')) clean = clean.slice(7);
      else if (clean.startsWith('```')) clean = clean.slice(3);
      if (clean.endsWith('```')) clean = clean.slice(0, -3);
      clean = clean.trim();
      result = JSON.parse(clean);
    } catch (e) {
      console.error('Failed to parse AI conv response:', responseText);
      result = { message: 'I had trouble understanding that. Could you try describing what labels you need?', action: 'clarify', params: {} };
    }
    
    // Add assistant response to history (store the message for context)
    aiConvHistory.push({ role: 'assistant', content: result.message || responseText });
    
    // Hide loading
    document.getElementById('aiConvStatus').style.display = 'none';
    
    // Handle the result
    aiConvHandleResult(result, userText);
    
  } catch (error) {
    console.error('AI conv error:', error);
    // Remove the failed user message from history
    aiConvHistory.pop();
    document.getElementById('aiConvStatus').style.display = 'none';
    document.getElementById('aiConvResponse').style.display = 'block';
    document.getElementById('aiConvResponse').innerHTML =
      '<div class="ai-conv-error">âš ï¸ ' + escapeHtml(error.message || 'Failed to connect to AI. Check your API key.') + '</div>' +
      '<div style="margin-top:8px;"><button class="ai-conv-action-btn" onclick="aiConvReset()">Try Again</button></div>';
  } finally {
    document.getElementById('aiConvSendBtn').disabled = false;
  }
}

// Call the AI provider for conversational intent parsing
async function aiConvCallProvider(provider, key, systemPrompt, conversationHistory) {
  // Build messages array from conversation history
  // For multi-turn, we need proper role alternation
  
  if (provider === 'claude') {
    // Claude uses system prompt separately, messages array for conversation
    // First message includes system context, then alternating user/assistant
    const messages = [];
    
    // For the first turn, include system prompt with the user message
    // For subsequent turns, just use the conversation history
    if (conversationHistory.length === 1) {
      messages.push({ 
        role: 'user', 
        content: systemPrompt + '\n\nUser: ' + conversationHistory[0].content 
      });
    } else {
      // Multi-turn: include system prompt context with first message
      for (let i = 0; i < conversationHistory.length; i++) {
        const msg = conversationHistory[i];
        if (i === 0) {
          messages.push({ 
            role: 'user', 
            content: systemPrompt + '\n\nUser: ' + msg.content 
          });
        } else {
          messages.push({ 
            role: msg.role, 
            content: msg.role === 'user' ? 'User: ' + msg.content : msg.content 
          });
        }
      }
    }
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 800,
        messages: messages
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'Claude API error: ' + response.status);
    }
    const data = await response.json();
    return data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    // OpenAI uses system message + conversation history
    const messages = [{ role: 'system', content: systemPrompt }];
    for (const msg of conversationHistory) {
      messages.push({ role: msg.role, content: msg.content });
    }
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + key
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 800,
        messages: messages
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'OpenAI API error: ' + response.status);
    }
    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    // Gemini uses contents array with role-based parts
    const contents = [];
    for (const msg of conversationHistory) {
      contents.push({
        role: msg.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: msg.role === 'user' && contents.length === 0 
          ? systemPrompt + '\n\nUser: ' + msg.content 
          : msg.content }]
      });
    }
    
    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=' + key, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: contents,
        generationConfig: { maxOutputTokens: 800 }
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'Gemini API error: ' + response.status);
    }
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
}

// Format AI message for display - converts newlines to <br> and escapes HTML
function formatAiMessage(msg) {
  if (!msg) return '';
  return escapeHtml(msg).replace(/\\n/g, '<br>').replace(/\n/g, '<br>');
}

// Handle the structured AI response
function aiConvHandleResult(result, userText) {
  const responseEl = document.getElementById('aiConvResponse');
  const params = result.params || {};
  
  if (result.action === 'clarify') {
    // AI needs more info â€” show message and keep input active for follow-up
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Start Over</button>' +
      '</div>';
    // Focus input for follow-up response (input already cleared in aiConvSend)
    document.getElementById('aiConvInput').focus();
    return;
  }
  
  if (result.action === 'settings') {
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn" onclick="switchTab(\'inventory\');aiConvReset()">Open Inventory</button>' +
        '<button class="ai-conv-action-btn" onclick="switchTab(\'sheets\');aiConvReset()">Open Sheets</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Dismiss</button>' +
      '</div>';
    return;
  }
  
  if (result.action === 'editor') {
    // Open Full Editor directly â€” user will import/paste their own content
    const labelType = params.labelType || null;
    const spec = labelType ? LABEL_TYPES[labelType] : null;
    const typeDesc = spec ? spec.desc + ' (' + labelType + ')' : null;
    const editorMode = params.editorMode || 'new';
    
    let buttonText = 'Open Editor â†’';
    if (editorMode === 'paste') buttonText = 'Open Editor â†’';
    if (editorMode === 'template') buttonText = 'Open Template Editor â†’';
    
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn primary" onclick="aiConvLaunchEditor();aiConvReset()">' + buttonText + '</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Cancel</button>' +
      '</div>';
    // Store params for editor launch
    window._aiConvEditorParams = params;
    return;
  }
  
  if (result.action === 'wf2') {
    // Show confirmation then launch WF2
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn primary" onclick="aiConvLaunchWF2();aiConvReset()">Print Again â†’</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Cancel</button>' +
      '</div>';
    // Store params for WF2 launch
    window._aiConvWF2Params = params;
    return;
  }
  
  if (result.action === 'wf1') {
    // Determine what we can pre-fill and describe it
    const labelType = params.labelType || null;
    const spec = labelType ? LABEL_TYPES[labelType] : null;
    const typeDesc = spec ? spec.desc + ' (' + labelType + ')' : null;
    const jobType = params.jobType || null;
    const qty = params.quantity || null;
    const hasContent = (params.contentLines && params.contentLines.length > 0) || (params.batchItems && params.batchItems.length > 0);
    
    // Build summary of what will be pre-filled
    let summary = result.message;
    
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(summary) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn primary" onclick="aiConvLaunchWF1();aiConvReset()">Let\'s Go â†’</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Cancel</button>' +
      '</div>';
    // Store params for WF1 launch
    window._aiConvWF1Params = params;
    return;
  }
  
  // Fallback
  responseEl.style.display = 'block';
  responseEl.innerHTML =
    '<div class="ai-conv-msg">' + formatAiMessage(result.message || 'I\'m not sure what to do with that.') + '</div>' +
    '<div class="ai-conv-actions">' +
      '<button class="ai-conv-action-btn" onclick="aiConvReset()">Try Again</button>' +
    '</div>';
}

// Launch WF1 with AI-determined parameters
function aiConvLaunchWF1() {
  const params = window._aiConvWF1Params || {};
  window._aiConvWF1Params = null;
  
  // Store params for deferred content fill
  window._aiConvPendingContent = params;
  
  // Pre-set print orientation if specified (T12)
  if (params.printOrientation) {
    const orientMap = { 'row': 'next', 'col1': 'col1', 'col2': 'col2' };
    wf1Orientation = orientMap[params.printOrientation] || 'next';
    showToast('Print orientation: ' + (wf1Orientation === 'col1' ? 'Column 1 first' : wf1Orientation === 'col2' ? 'Column 2 first' : 'Row by row'), 'info');
  }
  
  // Start WF1 normally
  wf1Start();
  
  // Pre-fill label type if determined
  if (params.labelType && LABEL_TYPES[params.labelType]) {
    wf1LabelType = params.labelType;
    wf1RenderTypeGrid();
    
    // Auto-advance to step 2 (inventory check)
    setTimeout(function() {
      wf1SelectType(params.labelType);
      wf1ToStep2();
    }, 100);
  }
}

// Called when WF1 reaches step 6 â€” check if AI has pending content to fill
function aiConvFillContentIfPending() {
  const params = window._aiConvPendingContent;
  if (!params) return;
  window._aiConvPendingContent = null;
  
  if (params.contentLines && params.contentLines.length > 0 && wf1JobType === 'individual') {
    wf1ContentLines = [];
    for (var i = 0; i < Math.min(params.contentLines.length, 4); i++) {
      wf1ContentLines.push(parseLabelLine(params.contentLines[i] || ''));
    }
    wf1PopulateEditorFromLines(wf1ContentLines);
    wf1UpdateContentNextBtn();
    showToast('AI pre-filled your label content', 'success');
  }
  // Note: batch content requires CSV import â€” AI sets up the workflow but content must be imported by user
}

// Continue advancing WF1 through steps based on AI params
function aiConvAdvanceWF1(params) {
  // We're at step 2 (inventory). Auto-continue to step 3.
  if (wf1Step === 2) {
    wf1ToStep3();
  }
  
  setTimeout(function() {
    // At step 3 (content type choice) â€” set job type and quantity
    if (wf1Step === 3) {
      if (params.jobType === 'batch' && params.batchItems && params.batchItems.length > 0) {
        // Set batch
        if (params.quantity) wf1Quantity = params.quantity;
        wf1SetJobType('batch');
      } else {
        // Individual
        if (params.quantity) wf1Quantity = params.quantity;
        wf1SetJobType('individual');
        // Update quantity display if we have one
        if (params.quantity) {
          wf1Quantity = params.quantity;
          var qtyEl = document.getElementById('wf1QtyValue');
          if (qtyEl) qtyEl.textContent = wf1Quantity;
        }
      }
    }
    
    // Auto-continue to step 4 after a moment
    setTimeout(function() {
      wf1ToStep4();
      // Content fill happens via aiConvFillContentIfPending() when step 6 renders
    }, 200);
  }, 200);
}

// Launch WF2 with AI-determined parameters
function aiConvLaunchWF2() {
  var params = window._aiConvWF2Params || {};
  window._aiConvWF2Params = null;
  
  wf2Start();
  
  // If a specific saved content name was referenced, try to find and select it
  if (params.savedContentName) {
    setTimeout(function() {
      // Look for matching content in WF2's content browser
      var cards = document.querySelectorAll('#wf2ContentSelector .wf2-content-card');
      for (var i = 0; i < cards.length; i++) {
        var nameEl = cards[i].querySelector('.wf2-content-card-name');
        if (nameEl && nameEl.textContent.toLowerCase().includes(params.savedContentName.toLowerCase())) {
          cards[i].click();
          showToast('Found matching content', 'success');
          break;
        }
      }
    }, 300);
  }
}

// Launch Full Editor directly with AI-determined parameters
function aiConvLaunchEditor() {
  var params = window._aiConvEditorParams || {};
  window._aiConvEditorParams = null;
  
  // Store print orientation preference if specified
  if (params.printOrientation) {
    window._aiConvPrintOrientation = params.printOrientation;
    showToast('Print orientation: ' + (params.printOrientation === 'col1' ? 'Column 1 first' : params.printOrientation === 'col2' ? 'Column 2 first' : 'Row by row'), 'info');
  }
  
  // Store quantity if specified
  if (params.quantity) {
    window._aiConvQuantity = params.quantity;
  }
  
  // Set label type in settings if specified (for preview)
  if (params.labelType && LABEL_TYPES[params.labelType]) {
    settings.lastLabelType = params.labelType;
    saveSettings();
  }
  
  // Open the Full Editor
  const isTemplate = params.editorMode === 'template';
  openFullEditor(null, isTemplate);
  
  // If paste mode AND clipboard is ready, trigger paste after editor opens
  // If clipboardReady is explicitly false, user was told to go copy first - don't auto-paste
  if (params.editorMode === 'paste' && params.clipboardReady === true) {
    setTimeout(function() {
      pasteToEditor();
    }, 400);
  }
}

// Parse a label line format "alignment,size:text"
function parseLabelLine(rawLine) {
  let text = rawLine;
  let align = 'left';
  let fontSize = 11;
  
  if (!rawLine) return { text: '', align, fontSize };
  
  const colonIndex = rawLine.indexOf(':');
  if (colonIndex > 0 && colonIndex < 15) {
    const prefix = rawLine.substring(0, colonIndex);
    const parts = prefix.split(',');
    
    if (parts.length >= 1 && ['left', 'center', 'right'].includes(parts[0])) {
      align = parts[0];
      text = rawLine.substring(colonIndex + 1);
      
      if (parts.length >= 2) {
        const size = parseInt(parts[1]);
        if ([9, 11, 14].includes(size)) {
          fontSize = size;
        }
      }
    }
  }
  
  return { text, align, fontSize };
}

// ============================================================================
// FULL EDITOR (ported from v1.2.0)
// ============================================================================

// Full editor state
let feEditingId = null;  // ID of text being edited (null = new)
let feIsTemplate = false;
let feLines = [
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
];
let feAlignV = 'center';
let feGraphics = { left: null, right: null };
let feActiveStylePopover = null;
let feGraphicPickerSide = null;

// New: Dirty tracking
let feDirty = false;
let feOriginalState = null;

// New: Border state
let feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };

// New: Preview label type
let fePreviewLabelType = '5160';

// Color palette
const FE_COLORS = ['#000000', '#dc2626', '#2563eb', '#16a34a', '#ea580c', '#9333ea', '#78350f', '#6b7280'];

// Built-in graphics library (full 83-icon library from v1.8.0)
const FE_GRAPHICS_CATEGORIES = {
  school: { label: 'ðŸ“š School', order: 1 },
  mailing: { label: 'âœ‰ï¸ Mailing', order: 2 },
  winter: { label: 'â„ï¸ Winter', order: 3 },
  spring: { label: 'ðŸŒ· Spring', order: 4 },
  summer: { label: 'â˜€ï¸ Summer/Fall', order: 5 },
  occasion: { label: 'ðŸŽ‰ Occasions', order: 6 },
  symbol: { label: 'âš¡ Symbols', order: 7 }
};

const FE_GRAPHICS_LIBRARY = [
  // School & Education (~15)
  {id:'apple',cat:'school',name:'Apple',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="38" rx="20" ry="22" fill="#ef4444"/><path d="M32 16 Q36 8 42 10" stroke="#16a34a" stroke-width="3" fill="none"/><ellipse cx="34" cy="12" rx="6" ry="4" fill="#22c55e"/></svg>'},
  {id:'book',cat:'school',name:'Book',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 h20 v48 h-20 a4 4 0 0 1 -4 -4 v-40 a4 4 0 0 1 4 -4z" fill="#3b82f6"/><path d="M28 8 h20 a4 4 0 0 1 4 4 v40 a4 4 0 0 1 -4 4 h-20 v-48z" fill="#2563eb"/><line x1="28" y1="8" x2="28" y2="56" stroke="#1d4ed8" stroke-width="2"/><line x1="14" y1="20" x2="24" y2="20" stroke="#93c5fd" stroke-width="2"/><line x1="14" y1="28" x2="22" y2="28" stroke="#93c5fd" stroke-width="2"/></svg>'},
  {id:'pencil',cat:'school',name:'Pencil',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="12,52 8,60 16,56 52,20 48,16" fill="#fbbf24"/><polygon points="52,20 56,16 52,8 48,12 48,16" fill="#f472b6"/><polygon points="8,60 12,52 16,56" fill="#1f2937"/></svg>'},
  {id:'ruler',cat:'school',name:'Ruler',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="16" rx="2" fill="#fbbf24"/><g stroke="#92400e" stroke-width="1.5"><line x1="16" y1="24" x2="16" y2="32"/><line x1="24" y1="24" x2="24" y2="28"/><line x1="32" y1="24" x2="32" y2="32"/><line x1="40" y1="24" x2="40" y2="28"/><line x1="48" y1="24" x2="48" y2="32"/></g></svg>'},
  {id:'scissors',cat:'school',name:'Scissors',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="48" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><circle cx="18" cy="16" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="42" x2="56" y2="28" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="22" x2="56" y2="36" stroke="#6b7280" stroke-width="4"/></svg>'},
  {id:'crayon',cat:'school',name:'Crayon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="40" rx="4" fill="#ef4444"/><polygon points="12,16 32,4 52,16" fill="#fca5a5"/><rect x="20" y="24" width="24" height="8" fill="#fef2f2"/></svg>'},
  {id:'globe',cat:'school',name:'Globe',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="28" r="24" fill="#3b82f6"/><ellipse cx="32" cy="28" rx="10" ry="24" fill="none" stroke="#1d4ed8" stroke-width="2"/><line x1="8" y1="28" x2="56" y2="28" stroke="#1d4ed8" stroke-width="2"/><path d="M12 18 Q32 24 52 18" fill="none" stroke="#1d4ed8" stroke-width="2"/><path d="M12 38 Q32 32 52 38" fill="none" stroke="#1d4ed8" stroke-width="2"/><rect x="28" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'backpack',cat:'school',name:'Backpack',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="44" rx="6" fill="#8b5cf6"/><rect x="20" y="32" width="24" height="16" rx="2" fill="#c4b5fd"/><path d="M20 16 Q20 4 32 4 Q44 4 44 16" fill="none" stroke="#6d28d9" stroke-width="4"/></svg>'},
  {id:'bus',cat:'school',name:'School Bus',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="56" height="28" rx="4" fill="#fbbf24"/><rect x="8" y="24" width="12" height="12" fill="#fef3c7"/><rect x="24" y="24" width="12" height="12" fill="#fef3c7"/><rect x="40" y="24" width="12" height="12" fill="#fef3c7"/><circle cx="16" cy="52" r="6" fill="#1f2937"/><circle cx="48" cy="52" r="6" fill="#1f2937"/><rect x="4" y="14" width="56" height="6" fill="#f59e0b"/></svg>'},
  {id:'gradcap',cat:'school',name:'Graduation Cap',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,8 4,24 32,40 60,24" fill="#1f2937"/><rect x="28" y="24" width="8" height="24" fill="#1f2937"/><path d="M16 28 v16 Q32 56 48 44 v-16" fill="#374151"/><circle cx="56" cy="44" r="4" fill="#fbbf24"/><line x1="56" y1="24" x2="56" y2="44" stroke="#fbbf24" stroke-width="2"/></svg>'},
  {id:'abc',cat:'school',name:'ABC Blocks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="32" width="24" height="24" fill="#ef4444"/><rect x="20" y="20" width="24" height="24" fill="#22c55e"/><rect x="36" y="8" width="24" height="24" fill="#3b82f6"/><text x="16" y="50" text-anchor="middle" fill="white" font-size="14" font-weight="bold">A</text><text x="32" y="38" text-anchor="middle" fill="white" font-size="14" font-weight="bold">B</text><text x="48" y="26" text-anchor="middle" fill="white" font-size="14" font-weight="bold">C</text></svg>'},
  {id:'star',cat:'school',name:'Star',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#f59e0b"/></svg>'},
  {id:'microscope',cat:'school',name:'Microscope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="48" width="24" height="8" rx="2" fill="#6b7280"/><rect x="36" y="12" width="8" height="36" fill="#9ca3af"/><circle cx="40" cy="12" r="8" fill="#3b82f6"/><rect x="16" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'music',cat:'school',name:'Music Note',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="48" rx="10" ry="8" fill="#1f2937"/><rect x="28" y="12" width="4" height="36" fill="#1f2937"/><path d="M32 12 Q48 8 48 20 Q48 28 32 24" fill="#1f2937"/></svg>'},
  {id:'owl',cat:'school',name:'Owl',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="24" fill="#92400e"/><circle cx="22" cy="28" r="10" fill="white"/><circle cx="42" cy="28" r="10" fill="white"/><circle cx="22" cy="28" r="5" fill="#1f2937"/><circle cx="42" cy="28" r="5" fill="#1f2937"/><polygon points="32,34 28,42 36,42" fill="#f59e0b"/><path d="M16 12 Q22 20 32 16 Q42 20 48 12" fill="#78350f"/></svg>'},
  
  // Mailing & Address (~12)
  {id:'mail',cat:'mailing',name:'Envelope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="56" height="36" rx="4" fill="#3b82f6"/><path d="M4 18 L32 36 L60 18" stroke="#1d4ed8" stroke-width="3" fill="none"/></svg>'},
  {id:'mailbox',cat:'mailing',name:'Mailbox',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 24 h48 v24 a8 8 0 0 1 -8 8 h-32 a8 8 0 0 1 -8 -8 z" fill="#3b82f6"/><path d="M8 24 a24 24 0 0 1 48 0" fill="#2563eb"/><rect x="28" y="56" width="8" height="8" fill="#6b7280"/><rect x="44" y="20" width="8" height="16" fill="#ef4444"/></svg>'},
  {id:'stamp',cat:'mailing',name:'Stamp',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="48" height="48" fill="#f5f5f4"/><rect x="12" y="12" width="40" height="40" fill="#3b82f6"/><circle cx="32" cy="32" r="12" fill="#1d4ed8"/><text x="32" y="37" text-anchor="middle" fill="white" font-size="12" font-weight="bold">USA</text></svg>'},
  {id:'home',cat:'mailing',name:'House',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 8 L4 32 L12 32 L12 56 L52 56 L52 32 L60 32 Z" fill="#78716c"/><rect x="26" y="38" width="12" height="18" fill="#292524"/><rect x="18" y="32" width="8" height="8" fill="#7dd3fc"/><rect x="38" y="32" width="8" height="8" fill="#7dd3fc"/></svg>'},
  {id:'pin',cat:'mailing',name:'Location Pin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 58 Q8 34 8 24 A24 24 0 1 1 56 24 Q56 34 32 58z" fill="#ef4444"/><circle cx="32" cy="24" r="10" fill="white"/></svg>'},
  {id:'airplane',cat:'mailing',name:'Airplane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 20 L58 28 L36 32 L36 52 L44 58 L36 56 L32 62 L28 56 L20 58 L28 52 L28 32 L6 28 L28 20 Z" fill="#6b7280"/></svg>'},
  {id:'package',cat:'mailing',name:'Package',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/><rect x="24" y="32" width="16" height="8" fill="white"/></svg>'},
  {id:'fragile',cat:'mailing',name:'Fragile',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8 L44 8 L44 28 Q44 48 32 56 Q20 48 20 28 Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20 L32 32 L28 32 L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'heart',cat:'mailing',name:'Heart',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56 C16 44 4 32 4 20 C4 10 12 4 22 4 C28 4 32 8 32 8 C32 8 36 4 42 4 C52 4 60 10 60 20 C60 32 48 44 32 56Z" fill="#ef4444"/></svg>'},
  {id:'paw',cat:'mailing',name:'Paw Print',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="16" ry="14" fill="#78350f"/><ellipse cx="18" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="46" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="12" cy="36" rx="6" ry="8" fill="#78350f"/><ellipse cx="52" cy="36" rx="6" ry="8" fill="#78350f"/></svg>'},
  {id:'certified',cat:'mailing',name:'Certified',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'priority',cat:'mailing',name:'Priority',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="32" fill="#ef4444"/><text x="32" y="38" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PRIORITY</text></svg>'},
  
  // Winter Holidays (~12)
  {id:'snowflake',cat:'winter',name:'Snowflake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g stroke="#3b82f6" stroke-width="3" fill="none"><line x1="32" y1="4" x2="32" y2="60"/><line x1="8" y1="18" x2="56" y2="46"/><line x1="8" y1="46" x2="56" y2="18"/><line x1="32" y1="12" x2="26" y2="6"/><line x1="32" y1="12" x2="38" y2="6"/><line x1="32" y1="52" x2="26" y2="58"/><line x1="32" y1="52" x2="38" y2="58"/></g></svg>'},
  {id:'tree',cat:'winter',name:'Christmas Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="26" y="50" width="12" height="10" fill="#78350f"/><polygon points="32,4 8,50 56,50" fill="#16a34a"/><polygon points="32,14 14,42 50,42" fill="#22c55e"/><circle cx="32" cy="8" r="4" fill="#fbbf24"/><circle cx="24" cy="32" r="3" fill="#ef4444"/><circle cx="40" cy="36" r="3" fill="#3b82f6"/><circle cx="32" cy="44" r="3" fill="#fbbf24"/></svg>'},
  {id:'candycane',cat:'winter',name:'Candy Cane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="#ef4444" stroke-width="8" stroke-linecap="round"/><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" stroke-dasharray="8 8"/></svg>'},
  {id:'gift',cat:'winter',name:'Gift Box',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="8" fill="#ef4444"/><rect x="12" y="32" width="40" height="24" fill="#fca5a5"/><rect x="28" y="24" width="8" height="32" fill="#dc2626"/><ellipse cx="24" cy="20" rx="8" ry="6" fill="#fbbf24"/><ellipse cx="40" cy="20" rx="8" ry="6" fill="#fbbf24"/></svg>'},
  {id:'ornament',cat:'winter',name:'Ornament',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="36" r="24" fill="#ef4444"/><rect x="28" y="8" width="8" height="8" fill="#fbbf24"/><circle cx="32" cy="12" r="4" fill="#fbbf24" fill-opacity="0.5"/><path d="M20 28 Q32 44 44 28" stroke="#fca5a5" stroke-width="3" fill="none"/></svg>'},
  {id:'stocking',cat:'winter',name:'Stocking',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 4 L44 4 L44 32 Q44 52 28 56 Q12 52 12 40 L12 32 L20 32 Z" fill="#ef4444"/><rect x="16" y="4" width="32" height="8" fill="white"/></svg>'},
  {id:'gingerbread',cat:'winter',name:'Gingerbread',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="14" r="10" fill="#d4a574"/><rect x="22" y="22" width="20" height="20" fill="#d4a574"/><rect x="8" y="26" width="16" height="8" fill="#d4a574"/><rect x="40" y="26" width="16" height="8" fill="#d4a574"/><rect x="24" y="42" width="6" height="16" fill="#d4a574"/><rect x="34" y="42" width="6" height="16" fill="#d4a574"/><circle cx="28" cy="12" r="2" fill="#1f2937"/><circle cx="36" cy="12" r="2" fill="#1f2937"/><path d="M28 18 Q32 22 36 18" stroke="#ef4444" stroke-width="2" fill="none"/></svg>'},
  {id:'menorah',cat:'winter',name:'Menorah',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="24" width="8" height="32" fill="#fbbf24"/><g fill="#fbbf24"><rect x="8" y="32" width="4" height="16"/><rect x="16" y="32" width="4" height="16"/><rect x="24" y="32" width="4" height="16"/><rect x="36" y="32" width="4" height="16"/><rect x="44" y="32" width="4" height="16"/><rect x="52" y="32" width="4" height="16"/></g><rect x="4" y="48" width="56" height="4" fill="#fbbf24"/><g fill="#f97316"><ellipse cx="10" cy="28" rx="3" ry="5"/><ellipse cx="18" cy="28" rx="3" ry="5"/><ellipse cx="26" cy="28" rx="3" ry="5"/><ellipse cx="32" cy="20" rx="3" ry="5"/><ellipse cx="38" cy="28" rx="3" ry="5"/><ellipse cx="46" cy="28" rx="3" ry="5"/><ellipse cx="54" cy="28" rx="3" ry="5"/></g></svg>'},
  {id:'snowman',cat:'winter',name:'Snowman',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="48" r="16" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="26" r="12" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="10" r="8" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="29" cy="8" r="2" fill="#1f2937"/><circle cx="35" cy="8" r="2" fill="#1f2937"/><polygon points="32,10 40,14 32,14" fill="#f97316"/><rect x="24" y="2" width="16" height="4" fill="#1f2937"/><rect x="28" y="0" width="8" height="4" fill="#1f2937"/></svg>'},
  {id:'wreath',cat:'winter',name:'Wreath',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="24" fill="none" stroke="#16a34a" stroke-width="12"/><circle cx="32" cy="8" r="6" fill="#ef4444"/><path d="M28 6 Q32 2 36 6" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'santahat',cat:'winter',name:'Santa Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 52 Q32 32 56 52 L32 8 Z" fill="#ef4444"/><ellipse cx="32" cy="54" rx="28" ry="6" fill="white"/><circle cx="32" cy="10" r="6" fill="white"/></svg>'},
  {id:'mittens',cat:'winter',name:'Mittens',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 24 L12 52 a8 8 0 0 0 8 8 h8 a8 8 0 0 0 8 -8 v-28" fill="#3b82f6"/><path d="M12 32 L4 28 L4 40 L12 40" fill="#3b82f6"/><rect x="12" y="20" width="24" height="8" fill="#93c5fd"/></svg>'},
  
  // Spring (~10)
  {id:'egg',cat:'spring',name:'Easter Egg',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="20" ry="26" fill="#c4b5fd"/><path d="M12 32 Q22 40 32 32 Q42 24 52 32" stroke="#8b5cf6" stroke-width="3" fill="none"/><path d="M12 42 Q22 50 32 42 Q42 34 52 42" stroke="#a78bfa" stroke-width="3" fill="none"/></svg>'},
  {id:'bunny',cat:'spring',name:'Bunny',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="20" ry="18" fill="#fdf4ff"/><circle cx="32" cy="28" r="14" fill="#fdf4ff"/><ellipse cx="22" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="42" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="22" cy="8" rx="3" ry="10" fill="#fbcfe8"/><ellipse cx="42" cy="8" rx="3" ry="10" fill="#fbcfe8"/><circle cx="26" cy="26" r="3" fill="#1f2937"/><circle cx="38" cy="26" r="3" fill="#1f2937"/><ellipse cx="32" cy="34" rx="4" ry="3" fill="#fbcfe8"/></svg>'},
  {id:'flower',cat:'spring',name:'Flower',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><line x1="32" y1="32" x2="32" y2="60" stroke="#22c55e" stroke-width="4"/><circle cx="32" cy="20" r="8" fill="#fbbf24"/><circle cx="20" cy="20" r="8" fill="#f472b6"/><circle cx="44" cy="20" r="8" fill="#f472b6"/><circle cx="24" cy="30" r="8" fill="#f472b6"/><circle cx="40" cy="30" r="8" fill="#f472b6"/><circle cx="32" cy="8" r="8" fill="#f472b6"/></svg>'},
  {id:'butterfly',cat:'spring',name:'Butterfly',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="18" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="46" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="18" cy="44" rx="10" ry="14" fill="#a78bfa"/><ellipse cx="46" cy="44" rx="10" ry="14" fill="#a78bfa"/><rect x="30" y="12" width="4" height="44" fill="#1f2937"/><path d="M30 12 Q24 4 20 8" stroke="#1f2937" stroke-width="2" fill="none"/><path d="M34 12 Q40 4 44 8" stroke="#1f2937" stroke-width="2" fill="none"/></svg>'},
  {id:'chick',cat:'spring',name:'Chick',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="20" ry="20" fill="#fbbf24"/><circle cx="32" cy="24" r="14" fill="#fbbf24"/><circle cx="26" cy="22" r="3" fill="#1f2937"/><circle cx="38" cy="22" r="3" fill="#1f2937"/><polygon points="32,26 28,32 36,32" fill="#f97316"/><path d="M24 10 Q32 4 40 10" stroke="#fbbf24" stroke-width="4" fill="none"/></svg>'},
  {id:'basket',cat:'spring',name:'Basket',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 28 Q8 56 32 56 Q56 56 56 28" fill="#d4a574"/><path d="M8 28 L56 28" stroke="#92400e" stroke-width="2"/><path d="M8 36 L56 36" stroke="#92400e" stroke-width="2"/><path d="M16 28 Q16 8 32 8 Q48 8 48 28" fill="none" stroke="#d4a574" stroke-width="6"/></svg>'},
  {id:'shamrock',cat:'spring',name:'Shamrock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="18" r="12" fill="#22c55e"/><circle cx="20" cy="30" r="12" fill="#22c55e"/><circle cx="44" cy="30" r="12" fill="#22c55e"/><rect x="30" y="38" width="4" height="22" fill="#16a34a"/></svg>'},
  {id:'rainbow',cat:'spring',name:'Rainbow',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 56 Q4 8 60 56" fill="none" stroke="#ef4444" stroke-width="6"/><path d="M10 56 Q10 18 54 56" fill="none" stroke="#f97316" stroke-width="5"/><path d="M16 56 Q16 26 48 56" fill="none" stroke="#fbbf24" stroke-width="5"/><path d="M22 56 Q22 34 42 56" fill="none" stroke="#22c55e" stroke-width="5"/><path d="M28 56 Q28 42 36 56" fill="none" stroke="#3b82f6" stroke-width="5"/></svg>'},
  {id:'umbrella',cat:'spring',name:'Umbrella',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 32 Q4 8 60 32" fill="#ef4444"/><line x1="32" y1="8" x2="32" y2="56" stroke="#78350f" stroke-width="4"/><path d="M32 56 Q24 56 24 48" fill="none" stroke="#78350f" stroke-width="4"/></svg>'},
  {id:'ladybug',cat:'spring',name:'Ladybug',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="22" fill="#ef4444"/><line x1="32" y1="14" x2="32" y2="58" stroke="#1f2937" stroke-width="2"/><circle cx="20" cy="28" r="4" fill="#1f2937"/><circle cx="44" cy="28" r="4" fill="#1f2937"/><circle cx="24" cy="44" r="4" fill="#1f2937"/><circle cx="40" cy="44" r="4" fill="#1f2937"/><circle cx="32" cy="12" r="8" fill="#1f2937"/></svg>'},
  
  // Summer/Fall (~10)
  {id:'sun',cat:'summer',name:'Sun',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="14" fill="#fbbf24"/><g stroke="#fbbf24" stroke-width="3"><line x1="32" y1="4" x2="32" y2="12"/><line x1="32" y1="52" x2="32" y2="60"/><line x1="4" y1="32" x2="12" y2="32"/><line x1="52" y1="32" x2="60" y2="32"/><line x1="12" y1="12" x2="18" y2="18"/><line x1="46" y1="46" x2="52" y2="52"/><line x1="12" y1="52" x2="18" y2="46"/><line x1="46" y1="18" x2="52" y2="12"/></g></svg>'},
  {id:'palm',cat:'summer',name:'Palm Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="28" width="8" height="32" fill="#92400e"/><path d="M32 28 Q16 8 8 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q48 8 56 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q24 4 32 8 Q40 4 32 28" fill="#16a34a"/></svg>'},
  {id:'fireworks',cat:'summer',name:'Fireworks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="4" fill="#ef4444"/><g stroke="#ef4444" stroke-width="2"><line x1="32" y1="24" x2="32" y2="8"/><line x1="32" y1="24" x2="32" y2="40"/><line x1="32" y1="24" x2="16" y2="24"/><line x1="32" y1="24" x2="48" y2="24"/><line x1="32" y1="24" x2="20" y2="12"/><line x1="32" y1="24" x2="44" y2="36"/><line x1="32" y1="24" x2="44" y2="12"/><line x1="32" y1="24" x2="20" y2="36"/></g><circle cx="16" cy="44" r="3" fill="#3b82f6"/><g stroke="#3b82f6" stroke-width="1.5"><line x1="16" y1="44" x2="16" y2="36"/><line x1="16" y1="44" x2="8" y2="44"/><line x1="16" y1="44" x2="24" y2="44"/><line x1="16" y1="44" x2="10" y2="38"/><line x1="16" y1="44" x2="22" y2="50"/></g></svg>'},
  {id:'flag',cat:'summer',name:'Flag',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="4" height="48" fill="#78350f"/><rect x="14" y="8" width="42" height="8" fill="#ef4444"/><rect x="14" y="24" width="42" height="8" fill="#ef4444"/><rect x="14" y="16" width="42" height="8" fill="white"/><rect x="14" y="8" width="16" height="16" fill="#1e40af"/></svg>'},
  {id:'pumpkin',cat:'summer',name:'Pumpkin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="28" ry="20" fill="#f97316"/><ellipse cx="20" cy="40" rx="12" ry="20" fill="#ea580c"/><ellipse cx="44" cy="40" rx="12" ry="20" fill="#ea580c"/><rect x="28" y="8" width="8" height="12" fill="#16a34a"/><path d="M32 8 Q40 4 44 12" stroke="#22c55e" stroke-width="3" fill="none"/></svg>'},
  {id:'ghost',cat:'summer',name:'Ghost',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32 A20 20 0 1 1 52 32 L52 56 L44 48 L36 56 L28 48 L20 56 L12 48 Z" fill="white"/><circle cx="24" cy="28" r="4" fill="#1f2937"/><circle cx="40" cy="28" r="4" fill="#1f2937"/><ellipse cx="32" cy="40" rx="6" ry="4" fill="#1f2937"/></svg>'},
  {id:'bat',cat:'summer',name:'Bat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 24 Q8 16 4 40 Q12 32 20 40 Q16 28 32 32 Q48 28 44 40 Q52 32 60 40 Q56 16 32 24" fill="#1f2937"/><circle cx="28" cy="28" r="2" fill="#ef4444"/><circle cx="36" cy="28" r="2" fill="#ef4444"/></svg>'},
  {id:'witch',cat:'summer',name:'Witch Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,48 56,48" fill="#1f2937"/><ellipse cx="32" cy="48" rx="28" ry="8" fill="#1f2937"/><rect x="20" y="36" width="24" height="6" fill="#f97316"/></svg>'},
  {id:'turkey',cat:'summer',name:'Turkey',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="16" ry="14" fill="#92400e"/><circle cx="24" cy="36" r="10" fill="#78350f"/><circle cx="20" cy="34" r="2" fill="#1f2937"/><polygon points="16,38 8,36 16,34" fill="#f97316"/><path d="M40 12 Q60 8 56 32 Q52 12 40 16" fill="#ef4444"/><path d="M44 12 Q60 12 52 28 Q48 16 44 16" fill="#f97316"/><path d="M48 16 Q56 16 48 28" fill="#fbbf24"/></svg>'},
  {id:'leaf',cat:'summer',name:'Maple Leaf',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 16 L48 12 L40 24 L56 28 L40 36 L48 52 L32 44 L16 52 L24 36 L8 28 L24 24 L16 12 L28 16 Z" fill="#ef4444"/><line x1="32" y1="44" x2="32" y2="60" stroke="#78350f" stroke-width="3"/></svg>'},
  
  // Occasions (~10)
  {id:'cake',cat:'occasion',name:'Birthday Cake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="28" width="48" height="28" rx="4" fill="#f472b6"/><rect x="8" y="28" width="48" height="8" fill="#ec4899"/><rect x="12" y="36" width="40" height="4" fill="#fbbf24"/><rect x="30" y="16" width="4" height="12" fill="#fbbf24"/><ellipse cx="32" cy="12" rx="4" ry="6" fill="#f97316"/></svg>'},
  {id:'balloon',cat:'occasion',name:'Balloon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="24" rx="18" ry="22" fill="#ef4444"/><polygon points="32,44 28,50 36,50" fill="#ef4444"/><path d="M32 50 Q28 56 32 60 Q36 56 32 50" fill="none" stroke="#6b7280" stroke-width="2"/></svg>'},
  {id:'party',cat:'occasion',name:'Party Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,56 56,56" fill="#8b5cf6"/><circle cx="32" cy="8" r="6" fill="#fbbf24"/><circle cx="24" cy="32" r="4" fill="#22c55e"/><circle cx="40" cy="40" r="4" fill="#f472b6"/><circle cx="28" cy="48" r="4" fill="#3b82f6"/></svg>'},
  {id:'ribbon',cat:'occasion',name:'Ribbon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="16" fill="#3b82f6"/><path d="M24 38 L16 60 L32 50 L48 60 L40 38" fill="#2563eb"/><circle cx="32" cy="24" r="8" fill="#1d4ed8"/></svg>'},
  {id:'trophy',cat:'occasion',name:'Trophy',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="20" y="8" width="24" height="28" rx="4" fill="#fbbf24"/><path d="M20 16 Q8 16 8 28 Q8 36 20 36" fill="#f59e0b"/><path d="M44 16 Q56 16 56 28 Q56 36 44 36" fill="#f59e0b"/><rect x="28" y="36" width="8" height="12" fill="#fbbf24"/><rect x="20" y="48" width="24" height="8" fill="#92400e"/></svg>'},
  {id:'medal',cat:'occasion',name:'Medal',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M24 4 L24 28 L32 20 L40 28 L40 4" fill="#3b82f6"/><circle cx="32" cy="40" r="18" fill="#fbbf24"/><circle cx="32" cy="40" r="12" fill="#f59e0b"/><text x="32" y="46" text-anchor="middle" fill="white" font-size="16" font-weight="bold">1</text></svg>'},
  {id:'rattle',cat:'occasion',name:'Baby Rattle',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="20" r="16" fill="#f472b6"/><rect x="28" y="36" width="8" height="20" rx="4" fill="#fbbf24"/><circle cx="26" cy="16" r="4" fill="#fdf4ff"/><circle cx="38" cy="16" r="4" fill="#fdf4ff"/><circle cx="32" cy="24" r="4" fill="#fdf4ff"/></svg>'},
  {id:'rings',cat:'occasion',name:'Wedding Rings',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="32" r="16" fill="none" stroke="#fbbf24" stroke-width="6"/><circle cx="40" cy="32" r="16" fill="none" stroke="#d1d5db" stroke-width="6"/></svg>'},
  {id:'diploma',cat:'occasion',name:'Diploma',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="32" fill="#fef3c7"/><rect x="8" y="16" width="48" height="6" fill="#fcd34d"/><line x1="16" y1="28" x2="48" y2="28" stroke="#92400e" stroke-width="2"/><line x1="16" y1="36" x2="40" y2="36" stroke="#92400e" stroke-width="2"/><circle cx="44" cy="44" r="8" fill="#ef4444"/></svg>'},
  {id:'confetti',cat:'occasion',name:'Confetti',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="8" height="8" fill="#ef4444" transform="rotate(15 12 12)"/><rect x="28" y="4" width="8" height="8" fill="#3b82f6" transform="rotate(-20 32 8)"/><rect x="48" y="12" width="8" height="8" fill="#22c55e" transform="rotate(30 52 16)"/><rect x="4" y="32" width="8" height="8" fill="#f472b6" transform="rotate(-15 8 36)"/><rect x="20" y="28" width="8" height="8" fill="#fbbf24" transform="rotate(25 24 32)"/><rect x="44" y="36" width="8" height="8" fill="#8b5cf6" transform="rotate(-30 48 40)"/><rect x="12" y="48" width="8" height="8" fill="#14b8a6" transform="rotate(10 16 52)"/><rect x="32" y="52" width="8" height="8" fill="#f97316" transform="rotate(-25 36 56)"/></svg>'},
  
  // Symbols & Decorative (~12)
  {id:'arrow',cat:'symbol',name:'Arrow Right',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L48 32 M36 20 L48 32 L36 44" stroke="#1f2937" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'check',cat:'symbol',name:'Checkmark',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="#fff" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'warning',cat:'symbol',name:'Warning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L4 56 L60 56 Z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>'},
  {id:'info',cat:'symbol',name:'Info',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#3b82f6"/><circle cx="32" cy="18" r="4" fill="white"/><rect x="28" y="26" width="8" height="24" fill="white"/></svg>'},
  {id:'phone',cat:'symbol',name:'Phone',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 4 L24 4 L28 16 L20 24 Q28 40 40 48 L48 40 L60 44 L60 56 Q60 60 56 60 Q12 56 8 12 Q8 8 12 4" fill="#22c55e"/></svg>'},
  {id:'at',cat:'symbol',name:'Email @',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="8" fill="none" stroke="#3b82f6" stroke-width="4"/><path d="M40 32 Q40 44 48 44 A20 20 0 1 1 48 20" fill="none" stroke="#3b82f6" stroke-width="4"/></svg>'},
  {id:'web',cat:'symbol',name:'Globe/Web',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="26" fill="none" stroke="#3b82f6" stroke-width="3"/><ellipse cx="32" cy="32" rx="10" ry="26" fill="none" stroke="#3b82f6" stroke-width="3"/><line x1="6" y1="32" x2="58" y2="32" stroke="#3b82f6" stroke-width="3"/><path d="M10 18 Q32 24 54 18" fill="none" stroke="#3b82f6" stroke-width="2"/><path d="M10 46 Q32 40 54 46" fill="none" stroke="#3b82f6" stroke-width="2"/></svg>'},
  {id:'clock',cat:'symbol',name:'Clock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="white" stroke="#1f2937" stroke-width="4"/><line x1="32" y1="32" x2="32" y2="16" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><line x1="32" y1="32" x2="44" y2="32" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><circle cx="32" cy="32" r="3" fill="#ef4444"/></svg>'},
  {id:'camera',cat:'symbol',name:'Camera',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="40" rx="4" fill="#1f2937"/><circle cx="32" cy="36" r="14" fill="#374151"/><circle cx="32" cy="36" r="10" fill="#3b82f6"/><rect x="24" y="8" width="16" height="8" fill="#1f2937"/></svg>'},
  {id:'key',cat:'symbol',name:'Key',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="14" fill="none" stroke="#fbbf24" stroke-width="4"/><line x1="30" y1="26" x2="56" y2="52" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="48" y1="44" x2="56" y2="44" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="40" y1="36" x2="48" y2="36" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/></svg>'},
  {id:'lock',cat:'symbol',name:'Lock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="28" width="40" height="32" rx="4" fill="#6b7280"/><path d="M20 28 v-8 a12 12 0 1 1 24 0 v8" fill="none" stroke="#6b7280" stroke-width="6"/><circle cx="32" cy="44" r="6" fill="#1f2937"/></svg>'},
  {id:'bolt',cat:'symbol',name:'Lightning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="36,4 16,32 28,32 24,60 48,28 36,28" fill="#fbbf24"/></svg>'}
];

// Show a read-only preview modal for built-in templates
function showBuiltinTemplatePreview(templateId) {
  const tpl = getBuiltinTemplate(templateId);
  if (!tpl) {
    showToast('Template not found', 'error');
    return;
  }
  
  const lines = deserializeLines(tpl.text);
  const tokens = tpl.tokens || [];
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  
  // Build preview lines with sample data
  const sampleData = {
    name: 'John Smith',
    first_name: 'John',
    last_name: 'Smith',
    street: '123 Main St',
    city: 'Anytown',
    state: 'CA',
    zip: '12345',
    country: 'USA',
    student_name: 'Emma Johnson',
    room: '101',
    teacher: 'Ms. Wilson',
    level: 'Grade 3',
    company: 'Acme Corp',
    title: 'Software Engineer',
    table_number: '5',
    dish_name: 'Caesar Salad',
    description: 'Contains dairy'
  };
  
  // Replace tokens with sample values for preview
  const previewLines = lines.map(line => {
    let text = line.text;
    tokens.forEach(token => {
      const regex = new RegExp('\\{' + token + '\\}', 'gi');
      text = text.replace(regex, sampleData[token] || '{' + token + '}');
    });
    return { ...line, text };
  });
  
  // Build simple preview HTML
  const previewLinesHtml = previewLines.filter(l => l.text.trim()).map(line => {
    const align = line.align || 'left';
    const fontSize = line.fontSize || 11;
    return `<div style="text-align:${align};font-size:${fontSize}px;line-height:1.3;margin:2px 0;">${escapeHtml(line.text)}</div>`;
  }).join('');
  
  // Calculate preview dimensions
  const aspectRatio = spec.labelW / spec.labelH;
  const previewWidth = Math.min(280, spec.labelW * 72);
  const previewHeight = previewWidth / aspectRatio;
  
  // Build modal content
  const modalContent = `
    <div style="text-align: center; padding: 10px 0 20px;">
      <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px;">${escapeHtml(tpl.name)}</div>
      <div style="font-size: 12px; color: var(--text-muted);">Built-in Template Â· ${spec?.name || labelType}</div>
    </div>
    
    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
      <div style="width:${previewWidth}px;min-height:${previewHeight}px;background:#fff;border:2px solid #888;border-radius:4px;padding:8px 12px;display:flex;flex-direction:column;justify-content:center;color:#000;">
        ${previewLinesHtml || '<div style="color:#888;font-style:italic;">Empty template</div>'}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Template Structure</div>
      <div style="font-family: var(--mono); font-size: 12px; color: var(--text-muted); line-height: 1.6;">
        ${lines.map((l, i) => `<div>Line ${i + 1}: ${escapeHtml(l.text) || '<em style="opacity:0.5">(empty)</em>'}</div>`).join('')}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 20px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Tokens (${tokens.length})</div>
      <div style="display: flex; flex-wrap: wrap; gap: 6px;">
        ${tokens.map(tk => `<span style="background: var(--accent-bg); color: var(--accent-text); padding: 3px 8px; border-radius: 4px; font-size: 12px; font-family: var(--mono);">{${tk}}</span>`).join('')}
      </div>
    </div>
    
    <div style="display: flex; justify-content: center; gap: 12px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeBuiltinPreviewModal()">Close</button>
      <button class="wizard-btn wizard-btn-primary" onclick="closeBuiltinPreviewModal(); showBatchImportModal('${templateId}')">ðŸ“Š Use for Batch Print</button>
    </div>
  `;
  
  showGenericModal('Template Preview', modalContent, 'builtinPreviewModal');
}

function closeBuiltinPreviewModal() {
  closeGenericModal('builtinPreviewModal');
}

function openFullEditor(textId, isTemplate = false) {
  feEditingId = textId;
  feIsTemplate = isTemplate;
  
  // Reset state
  resetFullEditorState();
  
  // Determine preview label type (from source sheet or settings)
  if (window._editorSourceSheetId && sheets[window._editorSourceSheetId]) {
    fePreviewLabelType = sheets[window._editorSourceSheetId].labelType;
  } else {
    fePreviewLabelType = settings.lastLabelType || '5160';
  }
  document.getElementById('fePreviewType').value = fePreviewLabelType;
  
  if (textId) {
    // Load existing text
    const text = getSavedText(textId);
    if (text) {
      document.getElementById('fullEditorTitle').textContent = 'Edit Label';
      document.getElementById('feNameRow').style.display = 'none';
      document.getElementById('feNameEditRow').style.display = 'flex';
      document.getElementById('feNameEdit').value = text.name;
      loadTextIntoFullEditor(text);
      
      // Store original state for dirty tracking
      feOriginalState = captureEditorState();
    }
  } else {
    // New text
    document.getElementById('fullEditorTitle').textContent = isTemplate ? 'New Template' : 'New Label';
    document.getElementById('feNameRow').style.display = 'flex';
    document.getElementById('feNameEditRow').style.display = 'none';
    document.getElementById('feName').value = '';
    feOriginalState = null;
  }
  
  // Reset dirty state
  feDirty = false;
  updateDirtyIndicator();
  
  // Show/hide Back to Wizard button
  const backToWizardBtn = document.getElementById('feBackToWizardBtn');
  if (backToWizardBtn) {
    backToWizardBtn.style.display = feOpenedFromWizard ? 'inline-flex' : 'none';
  }
  
  document.getElementById('fullEditorSubtitle').textContent = isTemplate ? 'Template with tokens' : 'Full formatting options';
  document.getElementById('fullEditorOverlay').classList.add('visible');
  updateTokenToggleVisibility(); // Show/hide token panel toggle for templates
  updateFullEditorPreview();
}

// Track if editor was opened from wizard (for return navigation)
let feOpenedFromWizard = false;

// Capture current editor state for dirty comparison
function captureEditorState() {
  return JSON.stringify({
    lines: feLines,
    alignV: feAlignV,
    graphics: feGraphics,
    border: feBorder,
    name: document.getElementById('feNameEdit')?.value || ''
  });
}

// Check if editor is dirty and update indicator
function checkEditorDirty() {
  if (!feOriginalState) {
    // New text - dirty if any content
    const hasContent = feLines.some(l => l.text.trim());
    feDirty = hasContent;
  } else {
    // Existing - compare to original
    feDirty = captureEditorState() !== feOriginalState;
  }
  updateDirtyIndicator();
}

function updateDirtyIndicator() {
  const indicator = document.getElementById('feDirtyIndicator');
  if (indicator) {
    indicator.classList.toggle('visible', feDirty);
  }
}

function closeFullEditor() {
  // Check for unsaved changes
  if (feDirty) {
    if (!confirm('You have unsaved changes. Discard them?')) {
      return;
    }
  }
  
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  feDirty = false;
  feOriginalState = null;
  closeFeStylePopovers();
  
  // Clear editor source sheet reference
  window._editorSourceSheetId = null;
  
  // Refresh current tab to ensure data is current (especially for sheet print)
  renderCurrentTab();
}

// Close full editor and return to wizard with content
function closeFullEditorToWizard() {
  // Check if we came from WF1
  if (wf1_fullEditorActive) {
    // Save Full Editor snapshot â€” preserves ALL styles (bold, italic, color, graphics, borders)
    wf1FeSnapshot = {
      lines: JSON.parse(JSON.stringify(feLines)),
      graphics: JSON.parse(JSON.stringify(feGraphics)),
      alignV: feAlignV,
      border: JSON.parse(JSON.stringify(feBorder))
    };
    
    // Transfer content back to WF1 editor (text, align, fontSize only â€” wizard can display these)
    for (let i = 1; i <= 4; i++) {
      const feInput = document.getElementById('feLine' + i);
      const wf1Input = document.getElementById('wf1Line' + (i));
      if (feInput && wf1Input) {
        wf1Input.value = feInput.value;
        wf1LineAligns[i - 1] = feLines[i - 1].align || 'left';
        wf1LineSizes[i - 1] = feLines[i - 1].fontSize || 11;
      }
    }
    
    // Close full editor
    document.getElementById('fullEditorOverlay').classList.remove('visible');
    feEditingId = null;
    feOpenedFromWizard = false;
    wf1_fullEditorActive = false;
    closeFeStylePopovers();
    
    // Re-open WF1 wizard at step 6
    showWizard('wf1Wizard');
    wf1ShowStep('wf1Step6');
    
    // Update WF1 align/size button states and preview
    for (let i = 1; i <= 4; i++) {
      document.querySelectorAll('.editor-align-btn[data-wf1line="' + i + '"]').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.align === wf1LineAligns[i - 1]);
      });
      document.querySelectorAll('.editor-size-btn[data-wf1line="' + i + '"]').forEach(function(btn) {
        btn.classList.toggle('active', parseInt(btn.dataset.size) === wf1LineSizes[i - 1]);
      });
    }
    wf1UpdateEditorPreview();
    showToast('Returned to print wizard', 'info');
    return;
  }
  
  // Fallback: close full editor and return to home
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  closeFeStylePopovers();
  showToast('Editor closed', 'info');
}

// ========== TOKEN PANEL FOR TEMPLATES ==========
let feLastFocusedLine = null; // Track which line input was last focused

function toggleFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  const toggle = document.getElementById('feTokenToggle');
  
  if (panel.classList.contains('visible')) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  } else {
    renderFeTokenPanel();
    panel.classList.add('visible');
    toggle.classList.add('active');
  }
}

function renderFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  let html = '';
  
  // Built-in categories
  for (const [category, tokens] of Object.entries(BUILTIN_TOKENS)) {
    html += '<div class="fe-token-category">' + escapeHtml(category) + '</div>';
    html += '<div class="fe-token-grid">';
    tokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Custom tokens
  if (customTokens.length) {
    html += '<div class="fe-token-category">Custom</div>';
    html += '<div class="fe-token-grid">';
    customTokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Add custom token row
  html += '<div class="fe-token-custom-row">';
  html += '<input type="text" id="feCustomTokenInput" placeholder="custom_field" maxlength="30" onkeydown="if(event.key===\'Enter\')addFeCustomToken()">';
  html += '<button onclick="addFeCustomToken()">+ Add</button>';
  html += '</div>';
  
  panel.innerHTML = html;
}

function insertFeToken(tokenName) {
  // Find which line input to insert into
  let input = null;
  
  // Use last focused line, or default to line 1
  if (feLastFocusedLine) {
    input = document.getElementById('feLine' + feLastFocusedLine);
  }
  if (!input) {
    input = document.getElementById('feLine1');
  }
  
  if (!input) return;
  
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const val = input.value;
  const insert = '{' + tokenName + '}';
  
  input.value = val.substring(0, start) + insert + val.substring(end);
  input.selectionStart = input.selectionEnd = start + insert.length;
  input.focus();
  
  // Update feLines state
  const lineNum = parseInt(input.id.replace('feLine', ''));
  if (lineNum >= 1 && lineNum <= 4) {
    feLines[lineNum - 1].text = input.value;
  }
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function addFeCustomToken() {
  const inp = document.getElementById('feCustomTokenInput');
  if (!inp) return;
  
  // Clean the token name: lowercase, underscores for spaces, alphanumeric only
  let name = inp.value.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/^_+|_+$/g, '');
  
  if (!name || !/^[a-z]/.test(name)) {
    inp.style.borderColor = 'var(--error-border)';
    showToast('Token must start with a letter', 'error');
    return;
  }
  
  // Check for duplicates across builtins and custom
  const allBuiltin = Object.values(BUILTIN_TOKENS).flat();
  if (allBuiltin.includes(name) || customTokens.includes(name)) {
    // Already exists - just insert it
    insertFeToken(name);
    inp.value = '';
    inp.style.borderColor = '';
    return;
  }
  
  // Add new custom token
  customTokens.push(name);
  saveCustomTokens();
  renderFeTokenPanel();
  insertFeToken(name);
  inp.value = '';
  inp.style.borderColor = '';
  showToast('Custom token {' + name + '} added', 'success');
}

// Show/hide token toggle based on template mode
function updateTokenToggleVisibility() {
  const tokenToggleRow = document.getElementById('feTokenToggleRow');
  if (tokenToggleRow) {
    tokenToggleRow.style.display = feIsTemplate ? 'flex' : 'none';
  }
  // Close token panel when switching away from template mode
  if (!feIsTemplate) {
    const panel = document.getElementById('feTokenPanel');
    const toggle = document.getElementById('feTokenToggle');
    if (panel) panel.classList.remove('visible');
    if (toggle) toggle.classList.remove('active');
  }
}

// ========== EMOJI PANEL (Full Editor) ==========
function toggleFeEmojiPanel() {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  
  const show = !panel.classList.contains('visible');
  panel.classList.toggle('visible', show);
  toggle.classList.toggle('active', show);
  
  if (show) {
    renderFeEmojiPanel();
    const search = document.getElementById('feEmojiSearch');
    if (search) {
      search.value = '';
      search.focus();
    }
  }
}

function renderFeEmojiPanel(filter) {
  const scroll = document.getElementById('feEmojiScroll');
  const q = (filter || '').toLowerCase().trim();
  let html = '';
  
  EMOJI_DATA.forEach(cat => {
    const filtered = q ? cat.emojis.filter(em => em.n.includes(q) || em.e === q) : cat.emojis;
    if (!filtered.length) return;
    html += '<div class="fe-emoji-category"><div class="fe-emoji-category-label">' + escapeHtml(cat.cat) + '</div><div class="fe-emoji-grid">';
    filtered.forEach(em => {
      html += '<button class="fe-emoji-btn" onclick="insertFeEmoji(\'' + em.e + '\')" title="' + escapeAttr(em.n) + '">' + em.e + '</button>';
    });
    html += '</div></div>';
  });
  
  if (!html) html = '<div style="padding: 16px; text-align: center; font-size: 12px; color: var(--text-muted);">No matches</div>';
  scroll.innerHTML = html;
}

function filterFeEmojis() {
  const search = document.getElementById('feEmojiSearch');
  renderFeEmojiPanel(search ? search.value : '');
}

function insertFeEmoji(emoji) {
  // Determine which input to insert into
  const lineNum = feLastFocusedLine || 1;
  const input = document.getElementById('feLine' + lineNum);
  if (!input) return;
  
  const start = input.selectionStart || input.value.length;
  const end = input.selectionEnd || start;
  input.value = input.value.slice(0, start) + emoji + input.value.slice(end);
  input.focus();
  const pos = start + emoji.length;
  input.setSelectionRange(pos, pos);
  updateFullEditorPreview();
}

// Close emoji panel on click outside
document.addEventListener('click', e => {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  if (panel && panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== toggle && !toggle.contains(e.target)) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  }
});

// ========== OCR SCANNING ==========
async function loadTesseract() {
  if (window.Tesseract) return;
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(script);
  });
}

function openOcrModal() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  
  // Reset UI
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loadingâ€¦';
  document.getElementById('ocrResultLines').innerHTML = '';
  document.getElementById('ocrHint').textContent = '';
  document.getElementById('ocrModal').classList.add('visible');
}

function closeOcrModal() {
  document.getElementById('ocrModal').classList.remove('visible');
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
}

// Paste clipboard text directly into editor line inputs (like v1.2)
async function pasteToEditor() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // Route based on content:
  // - Tabular data (Excel-style with tabs+newlines): always import modal
  // - 8+ plain lines: import modal for bulk processing
  // - 1-7 plain lines: paste first 4 into editor
  if (isTabular || rows.length > 7) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // Paste into editor lines (up to 4 lines)
  const maxLines = Math.min(rows.length, 4);
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('feLine' + (i + 1));
    if (input) {
      input.value = i < maxLines ? rows[i] : '';
    }
  }
  
  updateFePreview();
  markFeDirty();
  
  if (rows.length > 4) {
    showToast('Pasted first 4 of ' + rows.length + ' lines (label limit)', 'success');
  } else {
    showToast('Pasted ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard', 'success');
  }
}

// Clear text lines in the editor
// If a specific line is focused, clear only that line
// If no line is focused, clear all lines
function clearEditorLines() {
  const focusedLine = feLastFocusedLine;
  
  if (focusedLine && focusedLine >= 1 && focusedLine <= 4) {
    // Clear only the focused line
    const input = document.getElementById('feLine' + focusedLine);
    if (input) {
      input.value = '';
      input.focus();
      showToast('Line ' + focusedLine + ' cleared', 'info');
    }
  } else {
    // Clear all lines
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('feLine' + i);
      if (input) {
        input.value = '';
      }
    }
    showToast('All lines cleared', 'info');
  }
  
  updateFePreview();
  markFeDirty();
}

function ocrImageAreaClick() {
  if (!ocrImageBlob) {
    document.getElementById('ocrFileInput').click();
  }
}

function handleOcrFile(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  event.target.value = '';
  processOcrImage(file);
}

// Handle paste events for screenshot paste in OCR modal
document.addEventListener('paste', e => {
  const modal = document.getElementById('ocrModal');
  if (!modal || !modal.classList.contains('visible')) return;
  const items = e.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      if (blob) processOcrImage(blob);
      return;
    }
  }
});

function processOcrImage(fileOrBlob) {
  ocrImageBlob = fileOrBlob;
  ocrRotation = 0;
  
  const img = document.getElementById('ocrPreviewImg');
  const url = URL.createObjectURL(fileOrBlob);
  img.onload = () => URL.revokeObjectURL(url);
  img.src = url;
  img.style.display = '';
  img.style.transform = '';
  document.getElementById('ocrPlaceholder').style.display = 'none';
  document.getElementById('ocrImageArea').classList.add('has-image');
  
  document.getElementById('ocrRotationBar').style.display = 'flex';
  document.getElementById('ocrRotationLabel').textContent = '';
  
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  
  runOcr(fileOrBlob);
}

function rotateOcrImage(delta) {
  ocrRotation = ((ocrRotation || 0) + delta + 360) % 360;
  const img = document.getElementById('ocrPreviewImg');
  img.style.transform = 'rotate(' + ocrRotation + 'deg)';
  document.getElementById('ocrRotationLabel').textContent = ocrRotation ? ocrRotation + 'Â°' : '';
}

async function runOcr(imageBlob) {
  document.getElementById('ocrProgressArea').style.display = '';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loading OCR engineâ€¦';
  
  try {
    await loadTesseract();
    document.getElementById('ocrProgressText').textContent = 'Preprocessingâ€¦';
    document.getElementById('ocrProgressFill').style.width = '15%';
    
    const processed = await preprocessOcrImage(imageBlob, ocrRotation);
    
    document.getElementById('ocrProgressText').textContent = 'Scanningâ€¦';
    document.getElementById('ocrProgressFill').style.width = '30%';
    
    const result = await Tesseract.recognize(processed, 'eng', {
      logger: m => {
        if (m.status === 'recognizing text' && m.progress) {
          const pct = 30 + Math.round(m.progress * 65);
          document.getElementById('ocrProgressFill').style.width = pct + '%';
          document.getElementById('ocrProgressText').textContent = Math.round(m.progress * 100) + '%';
        }
      }
    });
    
    document.getElementById('ocrProgressFill').style.width = '100%';
    document.getElementById('ocrProgressText').textContent = 'Done!';
    
    parseOcrResult(result);
    
  } catch (err) {
    document.getElementById('ocrProgressText').textContent = 'Error: ' + err.message;
    document.getElementById('ocrProgressFill').style.background = 'var(--error-text)';
    console.error('OCR error:', err);
  }
}

function preprocessOcrImage(imageBlob, rotation) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(imageBlob);
    img.onload = () => {
      URL.revokeObjectURL(url);
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let w = img.naturalWidth;
        let h = img.naturalHeight;
        const rot = ((rotation || 0) % 360 + 360) % 360;
        const swapDims = (rot === 90 || rot === 270);
        
        // Scale up small images for better OCR
        const minDim = 1500;
        if (w < minDim && h < minDim) {
          const scale = minDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        // Cap very large images
        const maxDim = 4000;
        if (w > maxDim || h > maxDim) {
          const scale = maxDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        
        canvas.width = swapDims ? h : w;
        canvas.height = swapDims ? w : h;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rot * Math.PI / 180);
        ctx.translate(-w / 2, -h / 2);
        ctx.drawImage(img, 0, 0, w, h);
        
        canvas.toBlob(blob => {
          if (blob) resolve(blob);
          else reject(new Error('Failed to preprocess image'));
        }, 'image/png');
        
      } catch (e) {
        reject(e);
      }
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };
    img.src = url;
  });
}

function parseOcrResult(result) {
  ocrResults = [];
  
  if (!result?.data?.lines) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
    renderOcrResults();
    return;
  }
  
  const lines = result.data.lines;
  let totalConf = 0;
  
  for (const line of lines) {
    const text = (line.text || '').trim();
    if (!text) continue;
    const conf = Math.round(line.confidence || 0);
    totalConf += conf;
    ocrResults.push({ text, confidence: conf });
  }
  
  // Show hint based on line count
  if (ocrResults.length === 0) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
  } else if (ocrResults.length > 7) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. Will open import modal for bulk processing.';
  } else if (ocrResults.length > 4) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. First 4 will be used (label limit).';
  } else {
    const avgConf = totalConf / ocrResults.length;
    if (avgConf < 70) {
      document.getElementById('ocrHint').textContent = 'Low confidence results. Check for errors.';
    } else {
      document.getElementById('ocrHint').textContent = '';
    }
  }
  
  renderOcrResults();
}

function renderOcrResults() {
  const container = document.getElementById('ocrResultLines');
  let html = '';
  
  ocrResults.forEach((r, idx) => {
    const isLow = r.confidence < 70;
    html += '<div class="ocr-result-line">' +
      '<input type="text" value="' + escapeAttr(r.text) + '" ' +
        'class="' + (isLow ? 'low-confidence' : '') + '" ' +
        'oninput="updateOcrLine(' + idx + ', this.value)">' +
      '<span class="ocr-conf ' + (isLow ? 'low' : '') + '">' + r.confidence + '%</span>' +
      '<button class="ocr-line-remove" onclick="removeOcrLine(' + idx + ')" title="Remove line">Ã—</button>' +
    '</div>';
  });
  
  container.innerHTML = html;
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = '';
  document.getElementById('ocrConfirmBtn').style.display = ocrResults.length > 0 ? '' : 'none';
  document.getElementById('ocrRescanBtn').style.display = '';
  document.getElementById('ocrNewImageBtn').style.display = '';
}

function updateOcrLine(idx, value) {
  if (ocrResults[idx]) ocrResults[idx].text = value;
}

function removeOcrLine(idx) {
  ocrResults.splice(idx, 1);
  renderOcrResults();
}

function ocrRescan() {
  if (ocrImageBlob) runOcr(ocrImageBlob);
}

function ocrNewImage() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrFileInput').click();
}

function confirmOcr() {
  // Get text from editable OCR result inputs
  const rows = [];
  document.querySelectorAll('#ocrResultLines input').forEach(input => {
    const text = input.value.trim();
    if (text) rows.push(text);
  });
  
  if (rows.length === 0) {
    showToast('No text to import', 'warning');
    return;
  }
  
  closeOcrModal();
  
  // Route based on line count (same rules as paste)
  if (rows.length > 7) {
    // 8+ lines: open import modal for bulk processing
    showImportModal(rows, false);
  } else if (rows.length <= 4) {
    // 1-4 lines: direct to editor (simple case, no mapping needed)
    ocrLmApplyDirect(rows);
  } else {
    // 5-7 lines: show line-mapping UI â€” let user pick which lines go where
    ocrLmShow(rows);
  }
}

// ---- OCR Line-Mapping UI ----
let ocrLmSourceLines = [];
let ocrLmSlots = [null, null, null, null]; // 4 label line slots
let ocrLmSelectedSource = -1;
let ocrLmTargetContext = 'fe'; // 'fe' (Full Editor) or 'wf1' (WF1 editor)

function ocrLmDetectContext() {
  // Determine which editor is active
  const wf1Wizard = document.getElementById('wf1Wizard');
  if (wf1Wizard && (wf1Wizard.classList.contains('active') || wf1Wizard.style.display !== 'none')) {
    return 'wf1';
  }
  return 'fe';
}

function ocrLmShow(rows) {
  ocrLmSourceLines = rows.map(function(text, idx) { return { text: text, idx: idx, assigned: -1 }; });
  ocrLmSlots = [null, null, null, null];
  ocrLmSelectedSource = -1;
  ocrLmTargetContext = ocrLmDetectContext();
  
  // Build and show the line-mapping modal
  let html = '<div class="ocr-line-mapper">' +
    '<div class="ocr-lm-title">Assign scanned lines to label lines</div>' +
    '<div class="ocr-lm-hint">Click a scanned line, then click a label slot to assign it. Or click two scanned lines to merge them.</div>' +
    '<div class="ocr-lm-layout">' +
      '<div class="ocr-lm-source">' +
        '<div class="ocr-lm-label">Scanned Text</div>' +
        '<div class="ocr-lm-source-list" id="ocrLmSourceList"></div>' +
      '</div>' +
      '<div class="ocr-lm-target">' +
        '<div class="ocr-lm-label">Label Lines</div>' +
        '<div class="ocr-lm-target-slots" id="ocrLmTargetSlots"></div>' +
      '</div>' +
    '</div>' +
    '<div class="ocr-lm-actions">' +
      '<button class="btn btn-secondary" onclick="ocrLmAutoAssign()">Auto-fill top 4</button>' +
      '<button class="btn btn-secondary" onclick="ocrLmClearAll()">Clear all</button>' +
    '</div>' +
  '</div>';
  
  showGenericModal('ðŸ“· Map Scanned Text', html, 'ocrLineMapModal', function() {
    // On confirm â€” apply the mapped lines
    ocrLmApplyMapped();
  }, 'Use Mapped Lines');
  
  // Render initial state
  ocrLmRender();
}

function ocrLmRender() {
  const sourceList = document.getElementById('ocrLmSourceList');
  const targetSlots = document.getElementById('ocrLmTargetSlots');
  if (!sourceList || !targetSlots) return;
  
  // Render source lines
  let srcHtml = '';
  ocrLmSourceLines.forEach(function(line, idx) {
    const selected = ocrLmSelectedSource === idx;
    const assigned = line.assigned >= 0;
    srcHtml += '<div class="ocr-lm-source-item' + (selected ? ' selected' : '') + (assigned ? ' assigned' : '') + '" onclick="ocrLmClickSource(' + idx + ')">' +
      '<span class="lm-grip">â˜°</span>' +
      '<span class="lm-text">' + escapeHtml(line.text) + '</span>' +
      (assigned ? '<span class="lm-conf">â†’ Line ' + (line.assigned + 1) + '</span>' : '') +
    '</div>';
  });
  sourceList.innerHTML = srcHtml;
  
  // Render target slots
  let tgtHtml = '';
  for (let i = 0; i < 4; i++) {
    const slot = ocrLmSlots[i];
    const filled = slot !== null;
    const highlight = ocrLmSelectedSource >= 0;
    tgtHtml += '<div class="ocr-lm-slot' + (filled ? ' filled' : '') + (highlight && !filled ? ' highlight' : '') + '" onclick="ocrLmClickSlot(' + i + ')">' +
      '<span class="slot-label">Line ' + (i + 1) + '</span>';
    if (filled) {
      tgtHtml += '<span class="slot-content">' + escapeHtml(slot.text) + '</span>' +
        '<button class="slot-clear" onclick="event.stopPropagation(); ocrLmClearSlot(' + i + ');">Ã—</button>';
    } else {
      tgtHtml += '<span class="slot-placeholder">' + (i === 0 ? 'Click a scanned line, then click here' : 'optional') + '</span>';
    }
    tgtHtml += '</div>';
  }
  targetSlots.innerHTML = tgtHtml;
}

function ocrLmClickSource(idx) {
  if (ocrLmSelectedSource >= 0 && ocrLmSelectedSource !== idx) {
    // Two source lines selected â†’ merge them
    const line1 = ocrLmSourceLines[ocrLmSelectedSource];
    const line2 = ocrLmSourceLines[idx];
    // If either is assigned, unassign first
    if (line1.assigned >= 0) ocrLmClearSlot(line1.assigned);
    if (line2.assigned >= 0) ocrLmClearSlot(line2.assigned);
    // Merge: combine text, remove second line
    line1.text = line1.text + ' ' + line2.text;
    ocrLmSourceLines.splice(idx, 1);
    ocrLmSelectedSource = -1;
    showToast('Lines merged', 'success');
    ocrLmRender();
    return;
  }
  
  if (ocrLmSelectedSource === idx) {
    // Deselect
    ocrLmSelectedSource = -1;
  } else {
    ocrLmSelectedSource = idx;
  }
  ocrLmRender();
}

function ocrLmClickSlot(slotIdx) {
  if (ocrLmSelectedSource < 0) return; // nothing selected
  
  const srcLine = ocrLmSourceLines[ocrLmSelectedSource];
  
  // If this slot already has content, unassign the old source
  if (ocrLmSlots[slotIdx] !== null) {
    const oldSrcIdx = ocrLmSourceLines.findIndex(function(l) { return l.assigned === slotIdx; });
    if (oldSrcIdx >= 0) ocrLmSourceLines[oldSrcIdx].assigned = -1;
  }
  
  // If this source was already assigned to a different slot, clear that slot
  if (srcLine.assigned >= 0) {
    ocrLmSlots[srcLine.assigned] = null;
  }
  
  // Assign
  ocrLmSlots[slotIdx] = { text: srcLine.text, sourceIdx: ocrLmSelectedSource };
  srcLine.assigned = slotIdx;
  ocrLmSelectedSource = -1;
  ocrLmRender();
}

function ocrLmClearSlot(slotIdx) {
  const slot = ocrLmSlots[slotIdx];
  if (slot !== null) {
    // Un-assign the source line
    const srcLine = ocrLmSourceLines.find(function(l) { return l.assigned === slotIdx; });
    if (srcLine) srcLine.assigned = -1;
    ocrLmSlots[slotIdx] = null;
  }
  ocrLmRender();
}

function ocrLmClearAll() {
  ocrLmSlots = [null, null, null, null];
  ocrLmSourceLines.forEach(function(l) { l.assigned = -1; });
  ocrLmSelectedSource = -1;
  ocrLmRender();
}

function ocrLmAutoAssign() {
  ocrLmClearAll();
  const limit = Math.min(ocrLmSourceLines.length, 4);
  for (let i = 0; i < limit; i++) {
    ocrLmSlots[i] = { text: ocrLmSourceLines[i].text, sourceIdx: i };
    ocrLmSourceLines[i].assigned = i;
  }
  ocrLmRender();
}

function ocrLmApplyDirect(rows) {
  // Simple case: 1-4 lines â†’ paste directly into editor
  if (ocrLmDetectContext() === 'wf1') {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('wf1Line' + (i + 1));
      if (input) input.value = i < rows.length ? rows[i] : '';
    }
    wf1UpdateEditorPreview();
    showToast('Imported ' + Math.min(rows.length, 4) + ' line' + (rows.length !== 1 ? 's' : '') + ' from scan', 'success');
  } else {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = i < rows.length ? rows[i] : '';
    }
    updateFePreview();
    markFeDirty();
    showToast('Imported ' + Math.min(rows.length, 4) + ' line' + (rows.length !== 1 ? 's' : '') + ' from scan', 'success');
  }
}

function ocrLmApplyMapped() {
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push(ocrLmSlots[i] ? ocrLmSlots[i].text : '');
  }
  
  if (lines.every(function(l) { return !l; })) {
    showToast('No lines mapped â€” assign at least one', 'warning');
    return;
  }
  
  if (ocrLmTargetContext === 'wf1') {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('wf1Line' + (i + 1));
      if (input) input.value = lines[i];
    }
    wf1UpdateEditorPreview();
  } else {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = lines[i];
    }
    updateFePreview();
    markFeDirty();
  }
  
  closeGenericModal('ocrLineMapModal');
  const mapped = lines.filter(function(l) { return l; }).length;
  showToast('Imported ' + mapped + ' line' + (mapped !== 1 ? 's' : '') + ' from scan', 'success');
}

function resetFullEditorState() {
  feLines = [
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
  ];
  feAlignV = 'center';
  feGraphics = { left: null, right: null };
  feLastFocusedLine = null; // Reset token insertion target
  
  // Close token panel if open
  const tokenPanel = document.getElementById('feTokenPanel');
  const tokenToggle = document.getElementById('feTokenToggle');
  if (tokenPanel) tokenPanel.classList.remove('visible');
  if (tokenToggle) tokenToggle.classList.remove('active');
  
  // Close emoji panel if open
  const emojiPanel = document.getElementById('feEmojiPanel');
  const emojiToggle = document.getElementById('feEmojiToggle');
  if (emojiPanel) emojiPanel.classList.remove('visible');
  if (emojiToggle) emojiToggle.classList.remove('active');
  
  // Reset inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) input.value = '';
    document.getElementById('feSize' + i).textContent = '11';
    
    // Reset align buttons
    document.querySelectorAll(`.fe-align-btn[data-line="${i}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === 'left');
    });
    
    // Reset style button
    const styleBtn = document.getElementById('feStyleBtn' + i);
    if (styleBtn) styleBtn.classList.remove('has-styles');
  }
  
  // Reset valign buttons
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === 'center');
  });
  
  // Reset border state
  feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  document.getElementById('feBorderTop').classList.remove('active');
  document.getElementById('feBorderBottom').classList.remove('active');
  document.getElementById('feBorderLeft').classList.remove('active');
  document.getElementById('feBorderRight').classList.remove('active');
  document.getElementById('feBorderAll').classList.remove('active');
  document.getElementById('feBorderColor').value = '#000000';
  
  // Reset graphics display
  renderFeGraphics();
}

function loadTextIntoFullEditor(text) {
  const lines = deserializeLines(text.text);
  
  for (let i = 0; i < 4; i++) {
    const line = lines[i] || { text: '', align: 'left', fontSize: 11 };
    feLines[i] = {
      text: line.text || '',
      align: line.align || 'left',
      fontSize: line.fontSize || 11,
      bold: line.bold || false,
      italic: line.italic || false,
      underline: line.underline || false,
      strikethrough: line.strikethrough || false,
      color: line.color || '',
      fillColor: line.fillColor || '',
      borders: line.borders || ''
    };
    
    // Update inputs
    const input = document.getElementById('feLine' + (i + 1));
    if (input) input.value = feLines[i].text;
    document.getElementById('feSize' + (i + 1)).textContent = feLines[i].fontSize;
    
    // Update align buttons
    document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === feLines[i].align);
    });
    
    // Update style button indicator
    updateFeStyleButtonIndicator(i + 1);
  }
  
  // Load vertical alignment
  feAlignV = text.alignV || 'center';
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === feAlignV);
  });
  
  // Load graphics
  feGraphics = text.graphics ? { ...text.graphics } : { left: null, right: null };
  renderFeGraphics();
  
  // Load border state
  if (text.border) {
    feBorder = { ...text.border };
  } else {
    feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  }
  updateBorderUI();
}

function updateBorderUI() {
  document.getElementById('feBorderTop').classList.toggle('active', feBorder.top);
  document.getElementById('feBorderBottom').classList.toggle('active', feBorder.bottom);
  document.getElementById('feBorderLeft').classList.toggle('active', feBorder.left);
  document.getElementById('feBorderRight').classList.toggle('active', feBorder.right);
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  document.getElementById('feBorderAll').classList.toggle('active', allActive);
  document.getElementById('feBorderColor').value = feBorder.color || '#000000';
}

function updateFeStyleButtonIndicator(lineNum) {
  const s = feLines[lineNum - 1];
  const hasStyles = s.bold || s.italic || s.underline || s.strikethrough || s.color || s.fillColor;
  const btn = document.getElementById('feStyleBtn' + lineNum);
  if (btn) btn.classList.toggle('has-styles', hasStyles);
}

// Alignment
function setFeAlign(lineNum, align) {
  feLines[lineNum - 1].align = align;
  document.querySelectorAll(`.fe-align-btn[data-line="${lineNum}"]`).forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// Font size
function stepFeSize(lineNum, delta) {
  const sizes = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24];
  const current = feLines[lineNum - 1].fontSize;
  const idx = sizes.indexOf(current);
  const newIdx = Math.max(0, Math.min(sizes.length - 1, idx + delta));
  feLines[lineNum - 1].fontSize = sizes[newIdx];
  document.getElementById('feSize' + lineNum).textContent = sizes[newIdx];
  updateFullEditorPreview();
  checkEditorDirty();
}

// Vertical alignment
function setFeValign(valign) {
  feAlignV = valign;
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === valign);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== GLOBAL STYLE CONTROLS ==========

function toggleGlobalStyle(styleProp) {
  // Check if all lines have this style
  const allHaveStyle = feLines.every(l => l[styleProp]);
  const newValue = !allHaveStyle;
  
  // Apply to all lines
  for (let i = 0; i < 4; i++) {
    feLines[i][styleProp] = newValue;
    updateFeStyleButtonIndicator(i + 1);
  }
  
  // Update global button
  const btn = document.getElementById('feGlobal' + styleProp.charAt(0).toUpperCase() + styleProp.slice(1));
  if (btn) btn.classList.toggle('active', newValue);
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalAlign(align) {
  for (let i = 0; i < 4; i++) {
    feLines[i].align = align;
    document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === align);
    });
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalFontSize(size) {
  for (let i = 0; i < 4; i++) {
    feLines[i].fontSize = size;
    document.getElementById('feSize' + (i + 1)).textContent = size;
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== BORDER CONTROLS ==========

function toggleFeBorder(side) {
  feBorder[side] = !feBorder[side];
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function toggleAllBorders() {
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  const newValue = !allActive;
  feBorder.top = newValue;
  feBorder.bottom = newValue;
  feBorder.left = newValue;
  feBorder.right = newValue;
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function updateFeBorderColor(color) {
  feBorder.color = color;
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== PREVIEW TYPE SELECTOR ==========

function changeFePreviewType(labelType) {
  fePreviewLabelType = labelType;
  updateFullEditorPreview();
}

// Style popover
function toggleFeStylePopover(lineNum) {
  const popover = document.getElementById('feStylePopover' + lineNum);
  const btn = document.getElementById('feStyleBtn' + lineNum);
  
  if (popover.classList.contains('open')) {
    closeFeStylePopovers();
  } else {
    closeFeStylePopovers();
    renderFeStylePopover(lineNum);
    popover.classList.add('open');
    btn.classList.add('popover-open');
    feActiveStylePopover = lineNum;
  }
}

function closeFeStylePopovers() {
  for (let i = 1; i <= 4; i++) {
    const popover = document.getElementById('feStylePopover' + i);
    const btn = document.getElementById('feStyleBtn' + i);
    if (popover) popover.classList.remove('open');
    if (btn) btn.classList.remove('popover-open');
  }
  feActiveStylePopover = null;
}

function renderFeStylePopover(lineNum) {
  const s = feLines[lineNum - 1];
  const popover = document.getElementById('feStylePopover' + lineNum);
  
  let html = '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Style</div>';
  html += '<div class="fe-style-toggles">';
  html += `<button class="fe-style-toggle${s.bold ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'bold')"><span class="lbl-b">B</span></button>`;
  html += `<button class="fe-style-toggle${s.italic ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'italic')"><span class="lbl-i">I</span></button>`;
  html += `<button class="fe-style-toggle${s.underline ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'underline')"><span class="lbl-u">U</span></button>`;
  html += `<button class="fe-style-toggle${s.strikethrough ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'strikethrough')"><span class="lbl-s">S</span></button>`;
  html += '</div></div>';
  
  // Text color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Text Color</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.color ? ' active' : ''}" onclick="setFeColor(${lineNum},'color','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.color === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'color','${c}')"></div>`;
  }
  html += '</div></div>';
  
  // Fill color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Background</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.fillColor ? ' active' : ''}" onclick="setFeColor(${lineNum},'fillColor','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.fillColor === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'fillColor','${c}')"></div>`;
  }
  html += '</div></div>';
  
  popover.innerHTML = html;
}

function toggleFeStyle(lineNum, prop) {
  const s = feLines[lineNum - 1];
  s[prop] = !s[prop];
  
  // Underline and strikethrough are mutually exclusive
  if (prop === 'underline' && s.underline) s.strikethrough = false;
  if (prop === 'strikethrough' && s.strikethrough) s.underline = false;
  
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

function setFeColor(lineNum, prop, color) {
  feLines[lineNum - 1][prop] = color;
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

// Graphics
function renderFeGraphics() {
  renderFeGraphicSide('left');
  renderFeGraphicSide('right');
}

function renderFeGraphicSide(side) {
  const container = document.getElementById('feGraphic' + (side === 'left' ? 'Left' : 'Right') + 'Content');
  const g = feGraphics[side];
  
  if (!g || !g.data) {
    container.innerHTML = `<button class="fe-graphic-add" onclick="openFeGraphicPicker('${side}')">ðŸ–¼ Add Graphic</button>`;
  } else {
    let html = `<div class="fe-graphic-thumb" onclick="openFeGraphicPicker('${side}')"><img src="${g.data}"></div>`;
    html += '<div class="fe-graphic-size-pills">';
    for (const size of ['S', 'M', 'L']) {
      html += `<button class="fe-graphic-size-pill${g.size === size ? ' active' : ''}" onclick="setFeGraphicSize('${side}','${size}')">${size}</button>`;
    }
    html += '</div>';
    html += `<button class="fe-graphic-remove" onclick="removeFeGraphic('${side}')">âœ•</button>`;
    container.innerHTML = html;
  }
}

function setFeGraphicSize(side, size) {
  if (feGraphics[side]) {
    feGraphics[side].size = size;
    renderFeGraphicSide(side);
    updateFullEditorPreview();
  }
}

function removeFeGraphic(side) {
  feGraphics[side] = null;
  renderFeGraphicSide(side);
  updateFullEditorPreview();
}

// Graphic picker
function openFeGraphicPicker(side) {
  feGraphicPickerSide = side;
  document.getElementById('feGraphicPicker').classList.add('visible');
  switchFeGpTab('library');
}

function closeFeGraphicPicker() {
  document.getElementById('feGraphicPicker').classList.remove('visible');
  feGraphicPickerSide = null;
}

function switchFeGpTab(tab) {
  document.querySelectorAll('.fe-gp-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  
  const body = document.getElementById('feGpBody');
  
  if (tab === 'library') {
    // Build category filter
    let html = '<div style="margin-bottom:12px;"><select id="feGpCategoryFilter" onchange="renderFeGpLibrary()" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--input-bg);color:var(--text);font-size:14px;">';
    html += '<option value="all">All Categories</option>';
    Object.entries(FE_GRAPHICS_CATEGORIES).sort((a,b) => a[1].order - b[1].order).forEach(([key, cat]) => {
      html += `<option value="${key}">${cat.label}</option>`;
    });
    html += '</select></div>';
    html += '<div id="feGpIconGrid" class="fe-gp-grid"></div>';
    body.innerHTML = html;
    renderFeGpLibrary();
  } else {
    body.innerHTML = `
      <div class="fe-gp-upload-area">
        <button class="fe-gp-upload-btn" onclick="document.getElementById('feGraphicFileInput').click()">
          ðŸ“ Choose Image File
        </button>
        <div style="margin-top:12px;font-size:12px;color:var(--text-muted)">PNG, JPG, or SVG</div>
      </div>
    `;
  }
}

function renderFeGpLibrary() {
  const filter = document.getElementById('feGpCategoryFilter')?.value || 'all';
  const grid = document.getElementById('feGpIconGrid');
  if (!grid) return;
  
  let icons = FE_GRAPHICS_LIBRARY;
  if (filter !== 'all') {
    icons = icons.filter(i => i.cat === filter);
  }
  
  let html = '';
  for (const icon of icons) {
    html += `<div class="fe-gp-icon" onclick="selectFeLibraryGraphic('${icon.id}')" title="${icon.name}">${icon.svg}</div>`;
  }
  grid.innerHTML = html || '<div style="padding:20px;text-align:center;color:var(--text-muted)">No icons in this category</div>';
}

function selectFeLibraryGraphic(iconId) {
  const icon = FE_GRAPHICS_LIBRARY.find(i => i.id === iconId);
  if (icon && feGraphicPickerSide) {
    const dataUrl = 'data:image/svg+xml;base64,' + btoa(icon.svg);
    feGraphics[feGraphicPickerSide] = { data: dataUrl, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  }
}

function handleFeGraphicUpload(event) {
  const file = event.target.files[0];
  if (!file || !feGraphicPickerSide) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    feGraphics[feGraphicPickerSide] = { data: e.target.result, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  };
  reader.readAsDataURL(file);
  event.target.value = '';
}

// Preview
function updateFullEditorPreview() {
  // Get current text from inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) feLines[i - 1].text = input.value;
  }
  
  // Also check for dirty state on text input
  checkEditorDirty();
  
  const previewLabel = document.getElementById('fePreviewLabel');
  const nonEmptyLines = feLines.filter(l => l.text.trim());
  
  if (nonEmptyLines.length === 0 && !feGraphics.left && !feGraphics.right) {
    previewLabel.className = 'fe-preview-label empty-preview';
    previewLabel.innerHTML = '<span>Type above to preview</span>';
    previewLabel.style.borderTop = '';
    previewLabel.style.borderBottom = '';
    previewLabel.style.borderLeft = '';
    previewLabel.style.borderRight = '';
    return;
  }
  
  previewLabel.className = 'fe-preview-label';
  
  // Calculate dimensions based on selected preview label type
  const labelType = fePreviewLabelType || settings.lastLabelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const aspectRatio = spec.labelW / spec.labelH;
  const maxWidth = 300;
  const width = Math.min(maxWidth, spec.labelW * 72);
  const height = width / aspectRatio;
  
  previewLabel.style.width = width + 'px';
  previewLabel.style.minHeight = height + 'px';
  
  // Apply border styles
  const borderStyle = '2px solid ' + (feBorder.color || '#000000');
  const noBorder = '2px solid #888';
  previewLabel.style.borderTop = feBorder.top ? borderStyle : noBorder;
  previewLabel.style.borderBottom = feBorder.bottom ? borderStyle : noBorder;
  previewLabel.style.borderLeft = feBorder.left ? borderStyle : noBorder;
  previewLabel.style.borderRight = feBorder.right ? borderStyle : noBorder;
  
  // Set vertical alignment
  if (feAlignV === 'top') {
    previewLabel.style.justifyContent = 'flex-start';
  } else if (feAlignV === 'bottom') {
    previewLabel.style.justifyContent = 'flex-end';
  } else if (feAlignV === 'spread') {
    previewLabel.style.justifyContent = 'space-between';
  } else {
    previewLabel.style.justifyContent = 'center';
  }
  
  // Build preview HTML
  let html = '';
  
  // Add graphics wrapper if needed
  const hasGraphics = feGraphics.left || feGraphics.right;
  if (hasGraphics) {
    html += '<div style="display:flex;align-items:center;width:100%;height:100%;">';
    
    // Left graphic
    if (feGraphics.left) {
      const size = feGraphics.left.size === 'S' ? 24 : feGraphics.left.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-right:6px;"><img src="${feGraphics.left.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '<div style="flex:1;min-width:0;">';
  }
  
  // Render lines
  for (const line of feLines) {
    if (!line.text.trim()) continue;
    
    const style = buildLineStyleStr(line);
    const align = line.align === 'center' ? 'center' : line.align === 'right' ? 'right' : 'left';
    const parsed = parseLine(line.text);
    
    if (parsed.type === 'split-fill') {
      // Render split layout with fill-lines
      let leftHtml, rightHtml;
      if (parsed.left.type === 'fill') {
        leftHtml = '<span>' + escapeHtml(parsed.left.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>' + (parsed.left.trailing ? '<span>' + escapeHtml(parsed.left.trailing) + '</span>' : '');
      } else {
        leftHtml = '<span>' + escapeHtml(parsed.left.text) + '</span>';
      }
      if (parsed.right.type === 'fill') {
        rightHtml = '<span>' + escapeHtml(parsed.right.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>' + (parsed.right.trailing ? '<span>' + escapeHtml(parsed.right.trailing) + '</span>' : '');
      } else {
        rightHtml = '<span>' + escapeHtml(parsed.right.text) + '</span>';
      }
      html += `<div class="preview-line" style="display:flex;justify-content:space-between;align-items:flex-end;gap:12px;${style}"><div style="display:flex;align-items:flex-end;gap:3px;flex:1;">${leftHtml}</div><div style="display:flex;align-items:flex-end;gap:3px;flex:1;justify-content:flex-end;">${rightHtml}</div></div>`;
    } else if (parsed.type === 'split') {
      html += `<div class="preview-line" style="display:flex;justify-content:space-between;${style}"><span>${escapeHtml(parsed.left)}</span><span>${escapeHtml(parsed.right)}</span></div>`;
    } else if (parsed.type === 'fill') {
      html += `<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;${style}"><span>${escapeHtml(parsed.label)}</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>${parsed.trailing ? '<span>' + escapeHtml(parsed.trailing) + '</span>' : ''}</div>`;
    } else {
      html += `<div class="preview-line align-${align}" style="${style}">${escapeHtml(parsed.text)}</div>`;
    }
  }
  
  if (hasGraphics) {
    html += '</div>';
    
    // Right graphic
    if (feGraphics.right) {
      const size = feGraphics.right.size === 'S' ? 24 : feGraphics.right.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-left:6px;"><img src="${feGraphics.right.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '</div>';
  }
  
  previewLabel.innerHTML = html;
  
  // Update dimensions text
  document.getElementById('fePreviewDimensions').textContent = `Avery ${labelType} Â· ${spec.sizeDisplay}`;
}

// Save
function saveFromFullEditor() {
  // Get lines from state
  const lines = feLines.filter(l => l.text.trim());
  
  if (lines.length === 0) {
    showToast('Enter some text first', 'warning');
    return;
  }
  
  // Serialize lines
  const serialized = serializeLines(feLines.filter(l => l.text.trim()));
  
  // Check if any border is enabled
  const hasBorder = feBorder.top || feBorder.bottom || feBorder.left || feBorder.right;
  
  if (feEditingId) {
    // Update existing
    const text = getSavedText(feEditingId);
    if (text) {
      // Update name if changed
      const newName = document.getElementById('feNameEdit').value.trim();
      if (newName) {
        text.name = newName;
      }
      
      text.text = serialized;
      text.alignV = feAlignV;
      text.graphics = feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined;
      text.border = hasBorder ? { ...feBorder } : undefined;
      saveSavedTexts();
      showToast('Saved changes', 'success');
      renderCurrentTab();
    }
  } else {
    // Create new
    const name = document.getElementById('feName').value.trim();
    if (!name) {
      document.getElementById('feName').style.borderColor = 'var(--error-border)';
      document.getElementById('feName').focus();
      return;
    }
    
    const newText = {
      id: generateId('st'),
      name: name,
      text: serialized,
      isTemplate: feIsTemplate,
      alignV: feAlignV,
      graphics: feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined,
      border: hasBorder ? { ...feBorder } : undefined,
      tokens: feIsTemplate ? extractTokens(serialized) : []
    };
    
    savedTexts.push(newText);
    saveSavedTexts();
    showToast('Created "' + name + '"', 'success');
    renderCurrentTab();
  }
  
  // Reset dirty state before closing
  feDirty = false;
  feOriginalState = null;
  
  // If opened from WF1 wizard, return to wizard instead of closing
  if (wf1_fullEditorActive) {
    closeFullEditorToWizard();
  } else {
    closeFullEditor();
  }
}

// Close popover on click outside
document.addEventListener('click', function(e) {
  if (feActiveStylePopover && !e.target.closest('.fe-style-popover') && !e.target.closest('.fe-style-btn')) {
    closeFeStylePopovers();
  }
});

// Open full editor from wizard (transfers current wizard content)
function openFullEditorFromWizard() {
  // Check if coming from WF1
  if (wf1_fullEditorActive) {
    closeWizard('wf1Wizard');
    feOpenedFromWizard = true;
    openFullEditor(null, false);
    
    // Transfer from WF1 inputs
    for (let i = 1; i <= 4; i++) {
      const wf1Input = document.getElementById('wf1Line' + i);
      const feInput = document.getElementById('feLine' + i);
      if (wf1Input && feInput && wf1Input.value) {
        feInput.value = wf1Input.value;
        feLines[i - 1].text = wf1Input.value;
        feLines[i - 1].align = wf1LineAligns[i - 1] || 'left';
        feLines[i - 1].fontSize = wf1LineSizes[i - 1] || 11;
      }
    }
    updateFullEditorPreview();
    showToast('Switched to full editor. Use "Back to Wizard" when done.', 'info');
    return;
  }
  
  // Fallback: open full editor standalone
  feOpenedFromWizard = false;
  openFullEditor(null, false);
  showToast('Opened full editor', 'info');
}

// ========== TAB NAVIGATION ==========
function switchTab(tabId) {
  currentTab = tabId;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabId);
  });
  
  // Handle workflows tab (workflow hub) vs other tabs (panels)
  const workflowHub = document.getElementById('workflowHub');
  if (tabId === 'workflows') {
    workflowHub.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.remove('active');
    });
    // Refresh Quick Actions when returning to workflow hub
    renderQuickActions();
  } else {
    workflowHub.classList.remove('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.toggle('active', panel.id === 'panel-' + tabId);
    });
    renderCurrentTab();
  }
}

// T10-T11: Quick Actions section - shows last N actions from print history
function renderQuickActions() {
  const container = document.getElementById('quickActionsSection');
  if (!container) return;
  
  const count = settings.quickActionsCount ?? 5;
  
  // If count is 0, hide the section entirely
  if (count === 0) {
    container.style.display = 'none';
    return;
  }
  container.style.display = '';
  
  // Get unique recent actions (deduplicate by content)
  const uniqueActions = [];
  const seenContent = new Set();
  
  for (const entry of printHistory) {
    // Create a key based on the content to deduplicate
    const contentKey = (entry.lines || []).join('|') + '::' + entry.labelType;
    if (!seenContent.has(contentKey)) {
      seenContent.add(contentKey);
      uniqueActions.push(entry);
      if (uniqueActions.length >= count) break;
    }
  }
  
  let html = '<div class="quick-actions-header">' +
    '<span class="quick-actions-label">âš¡ Quick reprint:</span>' +
  '</div>';
  
  if (uniqueActions.length === 0) {
    html += '<div class="quick-actions-empty">Print something to see quick actions here</div>';
  } else {
    html += '<div class="quick-actions-list">';
    
    for (const action of uniqueActions) {
      const lines = action.lines || [];
      const preview = lines[0] ? escapeHtml(lines[0].substring(0, 40)) : 'Untitled';
      const labelType = action.labelType || '5160';
      const spec = LABEL_TYPES[labelType];
      
      // Format timestamp
      const date = new Date(action.timestamp);
      const timeAgo = formatTimeAgo(date);
      
      // Icon based on label type category
      let icon = 'ðŸ·ï¸';
      if (spec && spec.category === 'badge') icon = 'ðŸ‘‹';
      else if (spec && spec.category === 'tent') icon = 'â›º';
      
      html += '<div class="quick-action-item" onclick="quickActionReprint(\'' + action.id + '\')">' +
        '<div class="quick-action-icon">' + icon + '</div>' +
        '<div class="quick-action-content">' +
          '<div class="quick-action-title">' + preview + (lines.length > 1 ? '...' : '') + '</div>' +
          '<div class="quick-action-meta">' + labelType + ' Â· ' + timeAgo + '</div>' +
        '</div>' +
        '<div class="quick-action-badge">Reprint</div>' +
      '</div>';
    }
    
    html += '</div>';
  }
  
  container.innerHTML = html;
}

// Helper: format relative time
function formatTimeAgo(date) {
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return diffMins + 'm ago';
  if (diffHours < 24) return diffHours + 'h ago';
  if (diffDays < 7) return diffDays + 'd ago';
  
  // Format as date
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

// T10: Quick action reprint - launches WF2 with the selected history item
function quickActionReprint(historyId) {
  const entry = printHistory.find(e => e.id === historyId);
  if (!entry) return;
  
  // If entry has a textId, try to launch WF2 with that saved content
  if (entry.textId) {
    const savedText = savedTexts.find(t => t.id === entry.textId);
    if (savedText) {
      wf2Start();
      // Auto-select the saved content
      setTimeout(() => {
        wf2SelectItem({
          type: 'saved',
          id: savedText.id,
          name: savedText.name,
          lines: savedText.lines,
          labelType: savedText.labelType || entry.labelType
        });
        wf2ToStep2();
      }, 50);
      return;
    }
  }
  
  // Otherwise, route through reprint from history (falls back to WF2)
  reprintFromHistory(historyId);
}

function goToTab(tabId) {
  switchTab(tabId);
}

// Navigate to Sheets tab and expand a specific sheet card
function navigateToSheet(sheetId) {
  switchTab('sheets');
  // Give DOM time to render, then scroll to and highlight the sheet
  setTimeout(() => {
    const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + sheetId + '"]');
    if (sheetCard) {
      sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Add highlight animation
      sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
      setTimeout(() => {
        sheetCard.style.boxShadow = '';
      }, 2000);
    }
  }, 100);
}

function renderCurrentTab() {
  // Placeholder â€” each tab will have its own render function
  const stats = getDataStats();
  
  switch(currentTab) {
    case 'sheets':
      renderSheetsTab(stats);
      break;
    case 'saved':
      renderSavedTab(stats);
      break;
    case 'templates':
      renderTemplatesTab(stats);
      break;
    case 'inventory':
      renderInventoryTab(stats);
      break;
    case 'history':
      renderHistoryTab(stats);
      break;
  }
}

// Placeholder render functions â€” will be expanded in future sessions
function renderSheetsTab(stats) {
  const panel = document.getElementById('panel-sheets');
  const sheetList = Object.values(sheets).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
  
  // Separate job sheets from regular sheets, split active vs retired
  const regularSheets = sheetList.filter(s => !s.jobId);
  const activeSheets = regularSheets.filter(s => !s.retired);
  const retiredSheets = regularSheets.filter(s => s.retired);
  const jobSheets = sheetList.filter(s => s.jobId && activeJob && s.jobId === activeJob.id);
  
  let html = '';
  
  // Job banner if active job exists
  if (activeJob) {
    const totalRows = activeJob.list.length;
    const printedRows = activeJob.printedRowIndices.length;
    const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;
    let sheetsComplete = 0;
    activeJob.sheetIds.forEach(shId => {
      const sh = sheets[shId];
      if (!sh) return;
      const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
      const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
      if (printedOnSheet >= rowsOnSheet) sheetsComplete++;
    });
    
    html += '<div class="job-banner">' +
      '<div class="job-banner-header">' +
        '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
        '<div class="job-banner-actions">' +
          '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
          '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
        '</div>' +
      '</div>' +
      '<div class="job-banner-progress">' +
        '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
        '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
      '</div>' +
      '<div class="job-banner-info">' +
        '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
        '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
      '</div>' +
    '</div>';
  }
  
  html += '<div class="tab-header">' +
    '<div class="tab-title">Sheets (' + activeSheets.length + (retiredSheets.length ? ' + ' + retiredSheets.length + ' retired' : '') + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openNewSheetModal()">+ New Sheet</button>' +
    '</div>' +
  '</div>';
  
  if (activeSheets.length === 0 && retiredSheets.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“„</div><div class="panel-placeholder-text">No sheets yet. Create one to start tracking labels.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const sh of activeSheets) {
    const spec = LABEL_TYPES[sh.labelType];
    const lps = spec.cols * spec.rows;
    const total = getPoolSize(sh);
    const printed = getPrintedCount(sh);
    const remaining = total - printed;
    const isActive = sh.id === activeSheetId;
    const sheetCount = sh.sheetCount || 1;
    
    // Get assignments for color-coded grid
    const { assignments, errors } = buildAssignments(sh);
    
    // Build index map for quick lookup: index -> { textId, colorIdx }
    const indexMap = {};
    const textIds = sh.texts ? Object.keys(sh.texts) : [];
    textIds.forEach((textId, colorIdx) => {
      const indices = assignments[textId] || [];
      indices.forEach(idx => { 
        indexMap[idx] = { textId, colorIdx: colorIdx % 8 }; 
      });
    });
    
    // Build grid(s) - show multiple grids for pooled sheets
    let gridHtml = '';
    const printedSet = new Set(sh.printed || []);
    
    if (sheetCount <= 3) {
      // Show all grids side by side
      gridHtml = '<div class="sheet-grids-container">';
      for (let p = 0; p < sheetCount; p++) {
        gridHtml += '<div class="sheet-grid-wrapper">';
        if (sheetCount > 1) {
          gridHtml += '<div class="sheet-grid-label">Sheet ' + (p + 1) + '</div>';
        }
        gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
        for (let i = 0; i < lps; i++) {
          const poolIdx = p * lps + i;
          let cellClass = 'clickable';
          let cellTitle = 'Click to mark as used';
          if (printedSet.has(poolIdx)) {
            cellClass = 'printed clickable';
            cellTitle = 'Click to mark as available';
          } else if (indexMap[poolIdx]) {
            cellClass += ' cell-color-' + indexMap[poolIdx].colorIdx;
          }
          const cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="' + cellTitle + '"';
          gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
        }
        gridHtml += '</div></div>';
      }
      gridHtml += '</div>';
    } else {
      // Show first grid with page controls
      const currentPage = sheetGridPages[sh.id] || 0;
      gridHtml = '<div class="sheet-grids-container">';
      gridHtml += '<div class="sheet-grid-wrapper">';
      gridHtml += '<div class="sheet-grid-label">Sheet ' + (currentPage + 1) + ' of ' + sheetCount + '</div>';
      gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
      for (let i = 0; i < lps; i++) {
        const poolIdx = currentPage * lps + i;
        let cellClass = 'clickable';
        let cellTitle = 'Click to mark as used';
        if (printedSet.has(poolIdx)) {
          cellClass = 'printed clickable';
          cellTitle = 'Click to mark as available';
        } else if (indexMap[poolIdx]) {
          cellClass += ' cell-color-' + indexMap[poolIdx].colorIdx;
        }
        const cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="' + cellTitle + '"';
        gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
      }
      gridHtml += '</div>';
      gridHtml += '<div class="sheet-grid-pagination">' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', -1)"' + (currentPage === 0 ? ' disabled' : '') + '>â†</button>' +
        '<span class="sheet-grid-page-info">' + (currentPage + 1) + ' / ' + sheetCount + '</span>' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', 1)"' + (currentPage >= sheetCount - 1 ? ' disabled' : '') + '>â†’</button>' +
      '</div>';
      gridHtml += '</div></div>';
    }
    
    // Build assigned texts section (only for active sheet)
    let assignedHtml = '';
    let printActionsHtml = '';
    if (isActive) {
      assignedHtml = buildAssignedTextsHtml(sh, assignments, errors);
      printActionsHtml = buildPrintActionsHtml(sh, assignments, errors);
    }
    
    // Build note display if present
    const noteHtml = sh.note ? '<div class="sheet-note-display">' + escapeHtml(sh.note) + '</div>' : '';
    
    html += '<div class="sheet-card' + (isActive ? ' active' : '') + '" data-sheet-id="' + sh.id + '" onclick="selectSheet(\'' + sh.id + '\')">' +
      '<div class="sheet-card-header">' +
        '<div class="sheet-card-info">' +
          '<div class="sheet-card-name">' + escapeHtml(sh.name) + '</div>' +
          '<div class="sheet-card-type">' + spec.name + ' Â· ' + spec.sizeDisplay + '</div>' +
        '</div>' +
        '<div class="sheet-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showSyncSheetModal(\'' + sh.id + '\')" title="Sync grid â€” mark labels as used or available">ðŸ”„</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); printSheetLabel(\'' + sh.id + '\')" title="Print sheet label on back">ðŸ·ï¸</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSheet(\'' + sh.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); openEditSheetModal(\'' + sh.id + '\')" title="Edit">âœï¸</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); retireSheet(\'' + sh.id + '\')" title="Retire â€” hide from print workflows">ðŸ“¦</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSheet(\'' + sh.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
      noteHtml +
      gridHtml +
      '<div class="sheet-stats">' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + remaining + '</span> available</div>' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + printed + '</span> printed</div>' +
        (sheetCount > 1 ? '<div class="sheet-stat"><span class="sheet-stat-value">' + sheetCount + '</span> sheets pooled</div>' : '') +
      '</div>' +
      assignedHtml +
      printActionsHtml +
    '</div>';
  }
  
  // Retired sheets section (collapsible)
  if (retiredSheets.length > 0) {
    html += '<div style="margin-top:16px;border-top:1px solid var(--border);padding-top:12px;">' +
      '<button onclick="document.getElementById(\'retiredSheetsSection\').style.display = document.getElementById(\'retiredSheetsSection\').style.display === \'none\' ? \'block\' : \'none\'; this.querySelector(\'span\').textContent = document.getElementById(\'retiredSheetsSection\').style.display === \'none\' ? \'â–¸\' : \'â–¾\';" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:13px;padding:4px 0;display:flex;align-items:center;gap:6px;">' +
        '<span>â–¸</span> ðŸ“¦ ' + retiredSheets.length + ' retired sheet' + (retiredSheets.length !== 1 ? 's' : '') +
      '</button>' +
      '<div id="retiredSheetsSection" style="display:none;margin-top:8px;">';
    for (const sh of retiredSheets) {
      const spec = LABEL_TYPES[sh.labelType];
      const total = getPoolSize(sh);
      const printed = getPrintedCount(sh);
      const remaining = total - printed;
      const retiredDate = sh.retiredAt ? new Date(sh.retiredAt).toLocaleDateString() : '';
      html += '<div class="sheet-card" style="opacity:0.65;" onclick="event.stopPropagation()">' +
        '<div class="sheet-card-header">' +
          '<div class="sheet-card-info">' +
            '<div class="sheet-card-name" style="text-decoration:line-through;">' + escapeHtml(sh.name) + '</div>' +
            '<div class="sheet-card-type">' + spec.name + ' Â· Retired' + (retiredDate ? ' ' + retiredDate : '') + '</div>' +
          '</div>' +
          '<div class="sheet-card-actions">' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); unretireSheet(\'' + sh.id + '\')" title="Restore to active">â™»ï¸</button>' +
            '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSheet(\'' + sh.id + '\')" title="Delete permanently">ðŸ—‘ï¸</button>' +
          '</div>' +
        '</div>' +
        '<div class="sheet-stats">' +
          '<div class="sheet-stat"><span class="sheet-stat-value">' + remaining + '</span> available</div>' +
          '<div class="sheet-stat"><span class="sheet-stat-value">' + printed + '</span> printed</div>' +
        '</div>' +
      '</div>';
    }
    html += '</div></div>';
  }
  
  html += '</div>';
  panel.innerHTML = html;
}

// Build HTML for assigned texts section
function buildAssignedTextsHtml(sh, assignments, errors) {
  if (!sh.texts) sh.texts = {};
  const textIds = Object.keys(sh.texts);
  const spec = LABEL_TYPES[sh.labelType];
  
  // Build error lookup
  const errorMap = {};
  if (errors) {
    errors.forEach(e => { errorMap[e.textId] = e.message; });
  }
  
  let html = '<div class="assigned-texts-section">' +
    '<div class="assigned-texts-header">' +
      '<span class="assigned-texts-title">Assigned Content</span>' +
      '<button class="btn btn-primary assigned-add-btn" onclick="event.stopPropagation(); showAddTextToSheetModal(\'' + sh.id + '\')">+ Add</button>' +
    '</div>' +
    '<div class="assigned-texts-list">';
  
  if (textIds.length === 0) {
    html += '<div class="assigned-texts-empty">No content assigned. Click "+ Add" to assign content to this sheet.</div>';
  } else {
    textIds.forEach((textId, idx) => {
      const st = getSavedText(textId);
      if (!st) return;
      
      const entry = sh.texts[textId];
      const qty = entry.qty || 0;
      const placement = entry.placement || 'next';
      const colorIdx = idx % 8;
      const assignedCount = assignments && assignments[textId] ? assignments[textId].length : 0;
      const error = errorMap[textId];
      
      // Build placement options
      let placementHtml = '<select class="assigned-text-placement" onclick="event.stopPropagation()" onchange="setTextPlacement(\'' + sh.id + '\', \'' + textId + '\', this.value)">';
      placementHtml += '<option value="next"' + (placement === 'next' ? ' selected' : '') + '>Next Avail</option>';
      for (let c = 1; c <= spec.cols; c++) {
        const val = 'col:' + c;
        placementHtml += '<option value="' + val + '"' + (placement === val ? ' selected' : '') + '>Col ' + c + '</option>';
      }
      placementHtml += '</select>';
      
      const rowClass = error ? 'assigned-text-row has-error' : 'assigned-text-row';
      
      html += '<div class="' + rowClass + '" ondblclick="event.stopPropagation(); openContentEditorFromSheet(\'' + textId + '\', \'' + sh.id + '\')">' +
        '<div class="assigned-text-color text-color-' + colorIdx + '"></div>' +
        '<div class="assigned-text-info">' +
          '<div class="assigned-text-name">' + escapeHtml(st.name) + '</div>' +
          '<div class="assigned-text-spots">' + (error ? '<span style="color:var(--error-text)">' + error + '</span>' : assignedCount + ' label' + (assignedCount !== 1 ? 's' : '')) + '</div>' +
        '</div>' +
        '<div class="assigned-text-controls" ondblclick="event.stopPropagation()">' +
          placementHtml +
          '<div class="assigned-text-qty">' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', -1)">âˆ’</button>' +
            '<span class="qty-val">' + qty + '</span>' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', 1)">+</button>' +
          '</div>' +
        '</div>' +
        '<button class="assigned-text-remove" onclick="event.stopPropagation(); removeTextFromSheet(\'' + sh.id + '\', \'' + textId + '\')" ondblclick="event.stopPropagation()" title="Remove">âœ•</button>' +
      '</div>';
    });
  }
  
  html += '</div></div>';
  return html;
}

// Build print actions HTML for sheet
function buildPrintActionsHtml(sh, assignments, errors) {
  // Count total labels to print
  let totalToPrint = 0;
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  textIds.forEach(textId => {
    if (assignments && assignments[textId]) {
      totalToPrint += assignments[textId].length;
    }
  });
  
  const hasErrors = errors && errors.length > 0;
  const canPrint = totalToPrint > 0 && !hasErrors;
  const printedCount = (sh.printed || []).length;
  const hasUndo = lastPrintJob && lastPrintJob.sheetId === sh.id;
  
  if (textIds.length === 0 && printedCount === 0 && !hasUndo) {
    return ''; // No print section if no content and nothing to reset/undo
  }
  
  let html = '<div class="sheet-print-actions">';
  
  // Print button (only if content is assigned)
  if (textIds.length > 0) {
    html += '<button class="sheet-print-btn" onclick="event.stopPropagation(); printFromSheet(\'' + sh.id + '\')"' + (canPrint ? '' : ' disabled') + '>ðŸ–¨ï¸ Print ' + totalToPrint + ' Label' + (totalToPrint !== 1 ? 's' : '') + '</button>';
    
    if (hasErrors) {
      html += '<span class="sheet-print-summary" style="color:var(--error-text)">Fix placement errors first</span>';
    } else if (totalToPrint === 0) {
      html += '<span class="sheet-print-summary">Set quantities to print</span>';
    }
  }
  
  // Calculate remaining for split button
  const spec = LABEL_TYPES[sh.labelType];
  const poolSize = spec.cols * spec.rows * (sh.sheetCount || 1);
  const remainingCount = poolSize - printedCount;
  const canSplit = printedCount > 0 && remainingCount > 0;
  
  // Secondary actions row (Reset, Undo, Split)
  if (printedCount > 0 || hasUndo) {
    html += '<div class="sheet-secondary-actions">';
    
    // Reset button (if there are printed positions)
    if (printedCount > 0) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); resetSheet(\'' + sh.id + '\')" title="Reset all labels to available">ðŸ”„ Reset Sheet</button>';
    }
    
    // Undo button (if last print was on this sheet)
    if (hasUndo) {
      const undoCount = lastPrintJob.indices.length;
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); undoLastPrint()" title="Undo last print">â†©ï¸ Undo (' + undoCount + ' label' + (undoCount !== 1 ? 's' : '') + ')</button>';
    }
    
    // Split button (if there are both printed and remaining positions)
    if (canSplit) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); showSplitDialog(\'' + sh.id + '\')" title="Split remaining labels into new sheet">âœ‚ï¸ Split (' + remainingCount + ')</button>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  return html;
}

// Select a sheet (make it active)
function selectSheet(sheetId) {
  if (activeSheetId === sheetId) return; // Already selected
  activeSheetId = sheetId;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Set text placement on a sheet
function setTextPlacement(sheetId, textId, value) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  sh.texts[textId].placement = value;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Adjust assigned quantity
function adjustAssignedQty(sheetId, textId, delta) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  const current = sh.texts[textId].qty || 0;
  const newQty = Math.max(0, current + delta);
  sh.texts[textId].qty = newQty;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Remove text from sheet
function removeTextFromSheet(sheetId, textId) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts) return;
  delete sh.texts[textId];
  saveSheets();
  showToast('Content removed from sheet', 'info');
  renderSheetsTab(getDataStats());
}

// Add text to sheet modal
function showAddTextToSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const texts = getTexts();
  const existingIds = new Set(Object.keys(sh.texts || {}));
  const available = texts.filter(t => !existingIds.has(t.id));
  
  if (available.length === 0) {
    showToast('No content available to add. Create new content first.', 'warning');
    return;
  }
  
  // Store sheetId for use in addTextToSheetFromPicker
  window._addTextSheetId = sheetId;
  
  // Build picker content
  const modal = document.getElementById('addTextPickerModal');
  const content = document.getElementById('addTextPickerContent');
  document.getElementById('addTextPickerTitle').textContent = 'Add to "' + sh.name + '"';
  
  let html = '';
  for (const t of available) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 40);
    html += '<div class="saved-card" style="cursor: pointer;" onclick="addTextToSheetFromPicker(\'' + t.id + '\')">' +
      '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="saved-card-preview">' + escapeHtml(preview) + '</div>' +
    '</div>';
  }
  
  content.innerHTML = html;
  modal.classList.add('visible');
}

function closeAddTextPickerModal() {
  document.getElementById('addTextPickerModal').classList.remove('visible');
  window._addTextSheetId = null;
}

// Add text to sheet from picker
function addTextToSheetFromPicker(textId) {
  const sheetId = window._addTextSheetId;
  if (!sheetId) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  if (!sh.texts) sh.texts = {};
  
  if (sh.texts[textId]) {
    showToast('Content already assigned to this sheet', 'warning');
    return;
  }
  
  sh.texts[textId] = { qty: 0, placement: 'next' }; // Default to 0, user sets qty
  saveSheets();
  closeAddTextPickerModal();
  showToast('Content added. Set quantity to see it on the grid.', 'success');
  renderSheetsTab(getDataStats());
}

// Change sheet grid page (for multi-sheet pools)
function changeSheetPage(sheetId, delta) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const sheetCount = sh.sheetCount || 1;
  const current = sheetGridPages[sheetId] || 0;
  const newPage = Math.max(0, Math.min(sheetCount - 1, current + delta));
  sheetGridPages[sheetId] = newPage;
  renderSheetsTab(getDataStats());
}

// Open content editor from sheet (double-click)
function openContentEditorFromSheet(textId, sheetId) {
  const st = getSavedText(textId);
  if (!st) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  // Store the source sheet so we can set the preview label type
  window._editorSourceSheetId = sheetId;
  
  // Open the full editor with this content
  openFullEditor(textId, st.type === 'template');
}

// Print from sheet - the main print flow
function printFromSheet(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  // Reload sheets from localStorage to ensure fresh data
  loadSheets();
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const { assignments, errors } = buildAssignments(sh);
  
  if (errors && errors.length > 0) {
    showToast('Fix placement errors before printing', 'error');
    return;
  }
  
  // Collect all positions and their content
  const printManifest = [];
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  
  textIds.forEach(textId => {
    const indices = assignments[textId] || [];
    const st = getSavedText(textId);
    if (!st || indices.length === 0) return;
    
    const lines = deserializeLines(st.text);
    const graphics = st.graphics || { left: null, right: null };
    const alignV = st.alignV || 'center';
    const border = st.border || null;
    
    indices.forEach(idx => {
      printManifest.push({ idx, lines, graphics, alignV, border, textId });
    });
  });
  
  if (printManifest.length === 0) {
    showToast('Nothing to print. Set quantities first.', 'warning');
    return;
  }
  
  // Sort by position
  printManifest.sort((a, b) => a.idx - b.idx);
  
  // Build print HTML
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Use iframe for printing (like v1.2)
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  
  // Wait for iframe to render, then print
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  // After print dialog closes, ask user to confirm
  const totalLabels = printManifest.length;
  showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer.\n\nDid the print complete successfully?',
    'ðŸ–¨ï¸ Confirm Print',
    'Yes, printed OK',
    false,
    (confirmed) => {
      if (confirmed) {
        // Mark positions as printed
        const positionsPrinted = printManifest.map(m => m.idx);
        markPositionsPrinted(sheetId, positionsPrinted);
        
        // Store quantities before resetting (for undo)
        const prevQtys = {};
        textIds.forEach(textId => {
          if (sh.texts[textId]) {
            prevQtys[textId] = sh.texts[textId].qty || 0;
            sh.texts[textId].qty = 0;
          }
        });
        saveSheets();
        
        // Stash for undo (from v1.2)
        lastPrintJob = {
          sheetId: sheetId,
          indices: positionsPrinted,
          textQtys: prevQtys
        };
        
        // Add to print history
        // Build a name from the texts being printed
        const textNames = textIds.map(tid => {
          const t = getSavedText(tid);
          return t ? t.name : 'Unknown';
        }).join(', ');
        addPrintHistoryEntry({
          textName: textNames || 'Mixed labels',
          sheetId: sh.id,
          sheetName: sh.name,
          labelType: sh.labelType,
          count: totalLabels,
          textIds: textIds
        });
        
        // Show success and refresh
        const remaining = getRemainingCount(sh);
        if (remaining > 0) {
          showToast('Printed! ' + remaining + ' spots left on "' + sh.name + '"', 'success');
        } else {
          showToast('"' + sh.name + '" is now full. Select or create another sheet.', 'success');
        }
        renderSheetsTab(getDataStats());
      } else {
        // User cancelled - no changes
        showToast('Print cancelled â€” no labels marked as used', 'warning');
        renderSheetsTab(getDataStats());
      }
    }
  );
}

// ========== UNDO/RESET FUNCTIONS (ported from v1.2) ==========

// Undo the last print job - restores printed positions and quantities
function undoLastPrint() {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  if (!lastPrintJob) {
    showToast('Nothing to undo', 'warning');
    return;
  }
  
  const sh = sheets[lastPrintJob.sheetId];
  if (!sh) {
    lastPrintJob = null;
    showToast('Sheet no longer exists', 'error');
    return;
  }
  
  const count = lastPrintJob.indices.length;
  showConfirm(
    'Undo the last print on "' + sh.name + '"?\n\nThis will unmark ' + count + ' position' + (count !== 1 ? 's' : '') + ' as used and restore the quantities.',
    'â†©ï¸ Undo Last Print',
    'Undo',
    false,
    (confirmed) => {
      if (!confirmed) return;
      
      // Remove printed indices
      const undoSet = new Set(lastPrintJob.indices);
      sh.printed = (sh.printed || []).filter(i => !undoSet.has(i));
      
      // Restore text quantities
      if (lastPrintJob.textQtys && sh.texts) {
        for (const [textId, qty] of Object.entries(lastPrintJob.textQtys)) {
          if (sh.texts[textId]) {
            sh.texts[textId].qty = qty;
          }
        }
      }
      
      saveSheets();
      const undoneSheetId = lastPrintJob.sheetId;
      const undoneName = sh.name;
      lastPrintJob = null; // Clear undo state
      
      // Refresh view
      renderSheetsTab(getDataStats());
      showToast('Print undone â€” positions restored on "' + undoneName + '"', 'success');
    }
  );
}

// Reset all printed positions on a sheet
function resetSheet(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const printedCount = (sh.printed || []).length;
  if (printedCount === 0) {
    showToast('No used labels to reset on "' + sh.name + '"', 'warning');
    return;
  }
  
  showConfirm(
    'Reset "' + sh.name + '" to all labels available?\n\nThis will unmark ' + printedCount + ' used position' + (printedCount !== 1 ? 's' : '') + ' and set all quantities to 0.\n\nThis is useful when you replace the physical sheet with a fresh one.',
    'ðŸ”„ Reset Sheet',
    'Reset All',
    true,
    (confirmed) => {
      if (!confirmed) return;
      
      sh.printed = [];
      
      // Reset all text quantities to 0
      if (sh.texts) {
        for (const entry of Object.values(sh.texts)) {
          entry.qty = 0;
        }
      }
      
      saveSheets();
      lastPrintJob = null; // Undo no longer relevant
      
      const spec = LABEL_TYPES[sh.labelType] || LABEL_TYPES['5160'];
      const total = spec.cols * spec.rows * (sh.sheetCount || 1);
      
      renderSheetsTab(getDataStats());
      showToast('"' + sh.name + '" reset â€” all ' + total + ' labels available', 'success');
    }
  );
}

// Toggle a printed cell back to available (click on printed cell)
function toggleCellPrinted(sheetId, idx) {
  const sh = sheets[sheetId];
  if (!sh) return;
  if (!sh.printed) sh.printed = [];
  
  const pos = sh.printed.indexOf(idx);
  if (pos === -1) {
    // Not printed â€” mark as used
    sh.printed.push(idx);
    showToast('Position marked as used', 'success');
  } else {
    // Printed â€” mark as available
    sh.printed.splice(pos, 1);
    showToast('Position marked as available', 'success');
  }
  
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Show sync sheet modal for bulk editing grid state
function showSyncSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const total = getPoolSize(sh);
  const printedCount = getPrintedCount(sh);
  const availableCount = total - printedCount;
  
  let content = '<div style="margin-bottom:16px;">' +
    '<p style="margin:0 0 8px;color:var(--text-muted);">Use this to sync LabelKeeper with the physical sheet if they\'ve gotten out of sync.</p>' +
    '<p style="margin:0;font-size:13px;"><strong>Current state:</strong> ' + availableCount + ' available, ' + printedCount + ' used</p>' +
  '</div>';
  
  content += '<div style="display:flex;flex-direction:column;gap:8px;">';
  
  // Quick actions
  content += '<div style="font-weight:600;margin-bottom:4px;">Quick Actions</div>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetMarkAllUsed(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">â¬›</span> Mark all as used (sheet is full)' +
  '</button>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetMarkAllAvailable(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">â¬œ</span> Mark all as available (fresh sheet)' +
  '</button>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetSetUsedCount(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">ðŸ”¢</span> Set number of used labels...' +
  '</button>';
  
  content += '</div>';
  
  content += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);font-size:12px;color:var(--text-muted);">' +
    '<strong>Tip:</strong> You can also click individual cells in the grid to toggle them.' +
  '</div>';
  
  showGenericModal('Sync Sheet: ' + escapeHtml(sh.name), content, 'syncSheetModal');
}

// Mark all positions as used
function syncSheetMarkAllUsed(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const total = getPoolSize(sh);
  
  sh.printed = Array.from({ length: total }, (_, i) => i);
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast('All ' + total + ' labels marked as used', 'success');
}

// Mark all positions as available
function syncSheetMarkAllAvailable(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const total = getPoolSize(sh);
  sh.printed = [];
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast('All ' + total + ' labels marked as available', 'success');
}

// Set a specific number of used labels (marks from position 0)
function syncSheetSetUsedCount(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const total = getPoolSize(sh);
  const currentUsed = getPrintedCount(sh);
  
  const input = prompt('How many labels have been used? (0-' + total + ')', currentUsed.toString());
  if (input === null) return;
  
  const count = parseInt(input);
  if (isNaN(count) || count < 0 || count > total) {
    showToast('Please enter a number between 0 and ' + total, 'warning');
    return;
  }
  
  // Mark first N positions as used (row-by-row order)
  sh.printed = Array.from({ length: count }, (_, i) => i);
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast(count + ' labels marked as used, ' + (total - count) + ' available', 'success');
}

// ========== SPLIT REMAINING LABELS (ported from v1.2) ==========

// Show the split remaining labels dialog
function showSplitDialog(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  // Count open positions and physical sheets with open spots
  let openCount = 0;
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    let sheetOpen = 0;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!printed.has(i)) sheetOpen++;
    }
    if (sheetOpen > 0) {
      sheetsWithOpen.push({ physicalSheet: p, open: sheetOpen });
      openCount += sheetOpen;
    }
  }
  
  if (openCount === 0) {
    showToast('No remaining labels to split', 'warning');
    return;
  }
  
  document.getElementById('splitSummary').textContent = openCount + ' open label' + (openCount !== 1 ? 's' : '') + ' across ' + sheetsWithOpen.length + ' physical sheet' + (sheetsWithOpen.length !== 1 ? 's' : '');
  
  // Default name suggestion
  const specName = spec.name.split(' /')[0];
  document.getElementById('splitName').value = 'Leftover ' + specName + ' - ' + new Date().toLocaleDateString('en-US', { month: 'short' });
  
  // If only one physical sheet with open spots, hide split/together choice
  const splitModeGroup = document.getElementById('splitModeGroup');
  if (sheetsWithOpen.length <= 1) {
    splitModeGroup.style.display = 'none';
  } else {
    splitModeGroup.style.display = '';
  }
  
  // Store current sheet ID for execute
  document.getElementById('splitModal').dataset.sheetId = sheetId;
  
  document.getElementById('splitModal').classList.add('visible');
  document.getElementById('splitName').focus();
}

// Execute the split operation
function executeSplit() {
  const sheetId = document.getElementById('splitModal').dataset.sheetId;
  const sh = sheets[sheetId];
  if (!sh) {
    closeSimpleModal('splitModal');
    return;
  }
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  const name = document.getElementById('splitName').value.trim();
  if (!name) {
    document.getElementById('splitName').style.borderColor = 'var(--danger)';
    return;
  }
  
  const splitMode = document.querySelector('input[name="splitMode"]:checked').value;
  const textMode = document.querySelector('input[name="splitTexts"]:checked').value;
  
  // Identify physical sheets with open positions
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    const localPrinted = [];
    let hasOpen = false;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (printed.has(i)) {
        localPrinted.push(i % lps); // remap to local index
      } else {
        hasOpen = true;
      }
    }
    if (hasOpen) {
      sheetsWithOpen.push({ physicalSheet: p, localPrinted });
    }
  }
  
  if (sheetsWithOpen.length === 0) {
    closeSimpleModal('splitModal');
    return;
  }
  
  // Build text associations if keeping
  const textsToCarry = {};
  if (textMode === 'keep' && sh.texts) {
    for (const [textId, entry] of Object.entries(sh.texts)) {
      textsToCarry[textId] = { qty: 0, placement: entry.placement || 'next' };
    }
  }
  
  if (splitMode === 'separate' && sheetsWithOpen.length > 1) {
    // Create one new sheet per physical sheet with open spots
    sheetsWithOpen.forEach((info, idx) => {
      const newId = generateId('sheet');
      const suffix = sheetsWithOpen.length > 1 ? ' #' + (idx + 1) : '';
      sheets[newId] = {
        id: newId,
        name: name + suffix,
        printed: [...info.localPrinted],
        labelType: sh.labelType,
        sheetCount: 1,
        texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
        createdAt: Date.now() + idx
      };
    });
  } else {
    // Keep together as one pool
    const newId = generateId('sheet');
    const newCount = sheetsWithOpen.length;
    // Remap printed positions to new contiguous pool
    const newPrinted = [];
    sheetsWithOpen.forEach((info, newPage) => {
      info.localPrinted.forEach(localIdx => {
        newPrinted.push(newPage * lps + localIdx);
      });
    });
    sheets[newId] = {
      id: newId,
      name: name,
      printed: newPrinted,
      labelType: sh.labelType,
      sheetCount: newCount,
      texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
      createdAt: Date.now()
    };
  }
  
  // Reduce original sheet or delete it entirely
  const fullyConsumed = count - sheetsWithOpen.length;
  if (fullyConsumed === 0) {
    // All physical sheets had open positions â€” original is now empty, delete it
    delete sheets[sheetId];
    // Switch active sheet to the first newly created one
    const newIds = Object.keys(sheets).filter(id => sheets[id].createdAt >= Date.now() - 1000);
    activeSheetId = newIds.length > 0 ? newIds[0] : Object.keys(sheets)[0] || null;
  } else if (fullyConsumed > 0 && fullyConsumed < count) {
    // Keep only the consumed physical sheets in the original
    sh.sheetCount = fullyConsumed;
    // Remove printed indices that belong to split-off sheets
    const keepRange = fullyConsumed * lps;
    sh.printed = sh.printed.filter(i => i < keepRange);
  }
  
  saveSheets();
  closeSimpleModal('splitModal');
  
  renderSheetsTab(getDataStats());
  showToast('Split remaining labels into new sheet' + (splitMode === 'separate' && sheetsWithOpen.length > 1 ? 's' : ''), 'success');
}

// ========== CLIPBOARD IMPORT (ported from v1.2) ==========

let importRows = [];           // Raw clipboard rows
let importIsTabular = false;   // Tabular mode (tabs + newlines)
let importLinesPerLabel = 1;   // Plain list: lines per label
let importColMap = [];         // Tabular: column â†’ line mapping
let importTemplateTokenMap = []; // Per-column: token name (string) or null (skip)

// Paste data handler - detects images (routes to OCR) or text (opens import modal)
async function pasteData() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // If >4 rows or tabular data with multiple rows, open import modal
  if (rows.length > 4 || (isTabular && rows.length > 1)) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // â‰¤4 plain rows: show quick import (create single text from clipboard)
  showQuickImportModal(rows);
}

// Show quick import for small clipboard data (1-4 lines)
function showQuickImportModal(rows) {
  const maxLines = Math.min(rows.length, 4);
  const lines = [];
  for (let i = 0; i < maxLines; i++) {
    lines.push({ text: rows[i], align: 'left', fontSize: 11 });
  }
  
  // Create temporary text for preview
  const previewHtml = renderMiniPreview(lines, false, null);
  
  showConfirm(
    'Import ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard?\n\nPreview:\n' + rows.slice(0, maxLines).join('\n'),
    'ðŸ“‹ Import from Clipboard',
    'Import as New Content',
    false,
    (confirmed) => {
      if (confirmed) {
        // Create new saved text
        const newText = {
          id: generateId('text'),
          name: 'Imported ' + new Date().toLocaleTimeString(),
          text: serializeLines(lines),
          alignV: 'center',
          type: 'text',
          graphics: null,
          createdAt: Date.now()
        };
        savedTexts.push(newText);
        saveTexts();
        showToast('Created "' + newText.name + '" from clipboard', 'success');
        renderSavedTab(getDataStats());
      }
    }
  );
}

// Show full import modal for larger datasets
function showImportModal(rows, isTabular) {
  importRows = rows;
  importIsTabular = isTabular;
  importLinesPerLabel = 1;
  importColMap = [];
  importTemplateTokenMap = [];
  
  // Populate template dropdown
  const tplSelect = document.getElementById('importTemplateSelect');
  let tplOpts = '<option value="">No Template (manual)</option>';
  const templates = getTemplates();
  templates.forEach(t => {
    tplOpts += '<option value="' + t.id + '">' + escapeHtml(t.name) + '</option>';
  });
  tplSelect.innerHTML = tplOpts;
  
  if (isTabular) {
    const parsed = rows.map(r => r.split('\t').map(c => c.trim()));
    const colCount = Math.max(...parsed.map(r => r.length));
    importColMap = new Array(colCount).fill(0);
    
    document.getElementById('importSummary').textContent = parsed.length + ' rows Ã— ' + colCount + ' columns detected';
    document.getElementById('importPlainControls').style.display = 'none';
    document.getElementById('importTabularControls').style.display = '';
    buildImportColMappingUI();
  } else {
    document.getElementById('importSummary').textContent = rows.length + ' lines detected from clipboard';
    document.getElementById('importPlainControls').style.display = '';
    document.getElementById('importTabularControls').style.display = 'none';
    document.getElementById('linesPerLabelVal').textContent = '1';
  }
  
  // Populate sheet dropdown
  const sheetSelect = document.getElementById('importSheetAssign');
  let sheetOpts = '<option value="">â€” Don\'t assign â€”</option>';
  for (const [id, sh] of Object.entries(sheets)) {
    const spec = LABEL_TYPES[sh.labelType];
    const pool = spec.cols * spec.rows * (sh.sheetCount || 1);
    const used = (sh.printed || []).length;
    const assigned = Object.values(sh.texts || {}).reduce((s, t) => s + (t.qty || 0), 0);
    const avail = pool - used - assigned;
    sheetOpts += '<option value="' + id + '">' + escapeHtml(sh.name) + ' (' + avail + ' spots)</option>';
  }
  sheetSelect.innerHTML = sheetOpts;
  if (activeSheetId && sheets[activeSheetId]) sheetSelect.value = activeSheetId;
  
  document.getElementById('importBaseName').value = '';
  updateImportPreview();
  
  document.getElementById('importTextModal').classList.add('visible');
  document.getElementById('importBaseName').focus();
}

// Build column mapping UI for tabular data
function buildImportColMappingUI() {
  if (!importIsTabular) return;
  const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
  const colCount = Math.max(...parsed.map(r => r.length));
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  let mapHtml = '';
  if (tpl && tpl.tokens && tpl.tokens.length) {
    // Template mode: map columns to tokens
    document.getElementById('importColMappingTitle').textContent = 'Map columns to template tokens:';
    const headers = parsed.length > 0 ? parsed[0] : [];
    const autoMap = autoMapColumns(headers.map(h => h || ''), tpl.tokens);
    importTemplateTokenMap = [];
    
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      const autoToken = autoMap[c] || null;
      importTemplateTokenMap.push(autoToken);
      
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportTokenMap(' + c + ', this.value)">';
      mapHtml += '<option value="">Skip</option>';
      tpl.tokens.forEach(t => {
        mapHtml += '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>';
      });
      mapHtml += '</select></div>';
    }
  } else {
    // Manual mode: map columns to line numbers
    document.getElementById('importColMappingTitle').textContent = 'Map columns to label lines:';
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportColMap(' + c + ', this.value)">';
      mapHtml += '<option value="0"' + (importColMap[c] === 0 ? ' selected' : '') + '>Skip</option>';
      for (let ln = 1; ln <= 4; ln++) {
        mapHtml += '<option value="' + ln + '"' + (importColMap[c] === ln ? ' selected' : '') + '>â†’ Line ' + ln + '</option>';
      }
      mapHtml += '</select></div>';
    }
  }
  document.getElementById('importColMapping').innerHTML = mapHtml;
}

function onImportTemplateChange() {
  if (importIsTabular) {
    buildImportColMappingUI();
  }
  updateImportPreview();
}

function updateImportTokenMap(colIdx, tokenName) {
  importTemplateTokenMap[colIdx] = tokenName || null;
  updateImportPreview();
}

function stepLinesPerLabel(delta) {
  importLinesPerLabel = Math.max(1, Math.min(4, importLinesPerLabel + delta));
  document.getElementById('linesPerLabelVal').textContent = importLinesPerLabel;
  updateImportPreview();
}

function updateImportColMap(colIdx, val) {
  importColMap[colIdx] = parseInt(val);
  updateImportPreview();
}

// Generate preview records from import data
function getImportRecords() {
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  const records = [];
  
  if (importIsTabular) {
    const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
    
    if (tpl && tpl.tokens && tpl.tokens.length) {
      // Template mode: generate records by filling tokens
      parsed.forEach(row => {
        const tokenValues = {};
        importTemplateTokenMap.forEach((token, colIdx) => {
          if (token && row[colIdx]) {
            tokenValues[token] = row[colIdx];
          }
        });
        if (Object.keys(tokenValues).length > 0) {
          // Apply template
          const filledLines = applyTemplateTokens(tpl, tokenValues);
          records.push({ lines: filledLines, alignV: tpl.alignV || 'center' });
        }
      });
    } else {
      // Manual mode: map columns to lines
      parsed.forEach(row => {
        const lines = [];
        importColMap.forEach((lineNum, colIdx) => {
          if (lineNum > 0 && row[colIdx]) {
            while (lines.length < lineNum) {
              lines.push({ text: '', align: 'left', fontSize: 11 });
            }
            lines[lineNum - 1] = { text: row[colIdx], align: 'left', fontSize: 11 };
          }
        });
        if (lines.some(l => l.text)) {
          records.push({ lines, alignV: 'center' });
        }
      });
    }
  } else {
    // Plain list mode: group by lines per label
    for (let i = 0; i < importRows.length; i += importLinesPerLabel) {
      const lines = [];
      for (let j = 0; j < importLinesPerLabel && i + j < importRows.length; j++) {
        lines.push({ text: importRows[i + j], align: 'left', fontSize: 11 });
      }
      records.push({ lines, alignV: 'center' });
    }
  }
  
  return records;
}

// Apply template tokens to generate lines
function applyTemplateTokens(tpl, tokenValues) {
  const sourceLines = deserializeLines(tpl.text);
  return sourceLines.map(line => {
    let text = line.text;
    for (const [token, value] of Object.entries(tokenValues)) {
      text = text.replace(new RegExp('\\{' + token + '\\}', 'g'), value);
    }
    // Remove any unfilled tokens
    text = text.replace(/\{[^}]+\}/g, '').trim();
    return { ...line, text };
  });
}

function updateImportPreview() {
  const records = getImportRecords();
  const previewArea = document.getElementById('importPreviewArea');
  
  if (records.length === 0) {
    previewArea.innerHTML = '<span style="color:var(--text-muted)">No records to preview</span>';
    document.getElementById('importRecordCount').textContent = '';
    return;
  }
  
  // Show first 3 records
  let html = '';
  for (let i = 0; i < Math.min(3, records.length); i++) {
    html += '<div class="import-preview-label">';
    records[i].lines.forEach(line => {
      if (line.text) {
        html += '<div style="text-align:' + line.align + '">' + escapeHtml(line.text) + '</div>';
      }
    });
    html += '</div>';
  }
  if (records.length > 3) {
    html += '<div style="display:flex;align-items:center;color:var(--text-muted);font-size:12px">+' + (records.length - 3) + ' more</div>';
  }
  previewArea.innerHTML = html;
  
  document.getElementById('importRecordCount').textContent = records.length + ' record' + (records.length !== 1 ? 's' : '');
  
  // Update name preview
  const baseName = document.getElementById('importBaseName').value.trim() || 'Text';
  document.getElementById('importNamePreview').textContent = 'Will create: "' + baseName + ' 1", "' + baseName + ' 2", etc.';
}

// Execute import - create saved texts from parsed data
function executeImport() {
  const records = getImportRecords();
  if (!records.length) {
    closeModal('importTextModal');
    return;
  }
  
  const baseName = document.getElementById('importBaseName').value.trim() || 'Imported';
  const sheetId = document.getElementById('importSheetAssign').value;
  
  // Create saved texts
  const newIds = [];
  records.forEach((rec, idx) => {
    const newText = {
      id: generateId('text'),
      name: baseName + ' ' + (idx + 1),
      text: serializeLines(rec.lines),
      alignV: rec.alignV || 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now() + idx
    };
    savedTexts.push(newText);
    newIds.push(newText.id);
  });
  saveTexts();
  
  // Assign to sheet if selected
  if (sheetId && sheets[sheetId]) {
    const sh = sheets[sheetId];
    if (!sh.texts) sh.texts = {};
    newIds.forEach(id => {
      sh.texts[id] = { qty: 1, placement: 'next' };
    });
    saveSheets();
  }
  
  closeModal('importTextModal');
  
  showToast('Imported ' + records.length + ' text' + (records.length !== 1 ? 's' : ''), 'success');
  
  // Refresh tabs
  renderSavedTab(getDataStats());
  if (sheetId) {
    renderSheetsTab(getDataStats());
  }
}

// Build inline style string for a line object (bold, italic, color, etc.)
function buildLineStyleStr(line) {
  let style = 'font-size:' + (line.fontSize || 11) + 'pt;';
  if (line.bold) style += 'font-weight:bold;';
  if (line.italic) style += 'font-style:italic;';
  if (line.underline && line.strikethrough) style += 'text-decoration:underline line-through;';
  else if (line.underline) style += 'text-decoration:underline;';
  else if (line.strikethrough) style += 'text-decoration:line-through;';
  if (line.color) style += 'color:' + line.color + ';';
  if (line.fillColor) style += 'background-color:' + line.fillColor + ';';
  return style;
}

// Render a single line object to print-ready HTML (handles split, fill, split-fill syntax)
function renderPrintLineHtml(line) {
  if (!line.text && line.text !== '') return '';
  const text = line.text || '';
  if (!text.trim()) return '';

  const style = buildLineStyleStr(line);
  const parsed = parseLine(text);

  if (parsed.type === 'split-fill') {
    // Split with fill-lines on one or both sides
    let leftHtml, rightHtml;
    if (parsed.left.type === 'fill') {
      leftHtml = '<span class="fill-label">' + escapeHtml(parsed.left.label) + '</span><span class="fill-rule"></span>' + (parsed.left.trailing ? '<span class="fill-label">' + escapeHtml(parsed.left.trailing) + '</span>' : '');
    } else {
      leftHtml = '<span>' + escapeHtml(parsed.left.text) + '</span>';
    }
    if (parsed.right.type === 'fill') {
      rightHtml = '<span class="fill-label">' + escapeHtml(parsed.right.label) + '</span><span class="fill-rule"></span>' + (parsed.right.trailing ? '<span class="fill-label">' + escapeHtml(parsed.right.trailing) + '</span>' : '');
    } else {
      rightHtml = '<span>' + escapeHtml(parsed.right.text) + '</span>';
    }
    return '<div class="print-line align-split-fill" style="' + style + '"><div class="split-fill-left">' + leftHtml + '</div><div class="split-fill-right">' + rightHtml + '</div></div>';
  }
  if (parsed.type === 'split') {
    return '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
  }
  if (parsed.type === 'fill') {
    return '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
  }
  // Normal text
  const alignClass = 'align-' + (line.align || 'left');
  return '<div class="print-line ' + alignClass + '" style="' + style + '">' + escapeHtml(text) + '</div>';
}

// Build print HTML for sheet-based printing
function buildSheetPrintHtml(sh, manifest) {
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const isTentCard = spec.category === 'tent';
  
  // Build CSS
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; }';
  html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; }';
  html += '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }';
  html += '.print-label-gfx { flex-direction:row; align-items:stretch; }';
  html += '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }';
  html += '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }';
  html += '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }';
  html += '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }';
  html += '.print-line.align-left { justify-content:flex-start; text-align:left; }';
  html += '.print-line.align-center { justify-content:center; text-align:center; }';
  html += '.print-line.align-right { justify-content:flex-end; text-align:right; }';
  html += '.print-line.align-split { justify-content:space-between; text-align:left; }';
  html += '.print-line.align-split > span { min-width:0; overflow:hidden; text-overflow:ellipsis; }';
  html += '.print-line.align-split-fill { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; }';
  html += '.print-line.align-split-fill .split-fill-left, .print-line.align-split-fill .split-fill-right { display:flex; align-items:flex-end; gap:3px; flex:1; }';
  html += '.print-line.align-split-fill .split-fill-right { justify-content:flex-end; }';
  html += '.print-line.align-split-fill .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  html += '.print-line.align-split-fill .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }';
  html += '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  // Tent card fold line styling
  if (isTentCard) {
    html += '.print-label.tent-card { position:relative; padding:0; }';
    html += '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #ccc; z-index:1; }';
    html += '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }';
    html += '.tent-top { top:0; height:50%; }';
    html += '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }';
  }
  // Label boundary debugging rectangles
  if (settings.showLabelBoundaries) {
    html += '.label-boundary { position:absolute; border:1px solid #ccc; box-sizing:border-box; pointer-events:none; }';
  }
  html += '</style></head><body>';
  
  // Group manifest by physical page
  const pages = {};
  manifest.forEach(item => {
    const pageNum = Math.floor(item.idx / lps);
    if (!pages[pageNum]) pages[pageNum] = [];
    pages[pageNum].push(item);
  });
  
  // Helper to get flex alignment string
  function getFlexAlign(alignV) {
    if (alignV === 'top') return 'flex-start';
    if (alignV === 'bottom') return 'flex-end';
    if (alignV === 'spread') return 'space-between';
    return 'center';
  }
  
  // Render each page
  Object.keys(pages).sort((a, b) => parseInt(a) - parseInt(b)).forEach((pageNum, pi, arr) => {
    const breakStyle = pi < arr.length - 1 ? 'page-break-after:always;' : '';
    html += '<div class="print-sheet" style="' + breakStyle + '">';
    
    // Get manual print offsets from settings
    const offsetTop = settings.printOffsetTop || 0;
    const offsetLeft = settings.printOffsetLeft || 0;
    
    // Safari vertical compression - reduces vertical positions to fit Safari's smaller printable area
    const safariVScale = isSafari ? (settings.safariVScale ?? 1.0) : 1.0;
    
    // Draw label boundaries for ALL positions if enabled (for alignment testing)
    if (settings.showLabelBoundaries) {
      for (let idx = 0; idx < lps; idx++) {
        const row = Math.floor(idx / spec.cols);
        const col = idx % spec.cols;
        const bTop = (spec.topMargin + row * (spec.labelH + spec.vGutter)) * safariVScale + offsetTop;
        const bHeight = spec.labelH * safariVScale;
        const bLeft = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
        html += '<div class="label-boundary" style="top:' + bTop + 'in;left:' + bLeft + 'in;width:' + spec.labelW + 'in;height:' + bHeight + 'in;"></div>';
      }
    }
    
    pages[pageNum].forEach(item => {
      const localIdx = item.idx % lps;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;
      
      const top = (spec.topMargin + row * (spec.labelH + spec.vGutter)) * safariVScale + offsetTop;
      const labelH = spec.labelH * safariVScale;
      const left = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
      
      // Use renderPrintLineHtml for each line (same as v1.2)
      const linesHtml = item.lines.map(l => renderPrintLineHtml(l)).join('');
      const gfx = item.graphics;
      const hasGfx = gfx && (gfx.left || gfx.right);
      
      if (isTentCard) {
        // Tent card rendering
        html += '<div class="print-label tent-card" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;">';
        html += '<div class="fold-line"></div>';
        html += '<div class="tent-top"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '<div class="tent-bottom"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '</div>';
      } else if (hasGfx) {
        // Graphics layout (same as v1.2)
        const usableW = spec.labelW - 0.24;
        let innerHtml = '';
        if (gfx.left && gfx.left.data) {
          const leftW = (usableW * (gfx.left.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + leftW + 'in;"><img src="' + gfx.left.data + '"></div>';
        }
        innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
        if (gfx.right && gfx.right.data) {
          const rightW = (usableW * (gfx.right.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + rightW + 'in;"><img src="' + gfx.right.data + '"></div>';
        }
        html += '<div class="print-label print-label-gfx" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.08in 0.12in;">' + innerHtml + '</div>';
      } else {
        // Standard label (same as v1.2)
        html += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.08in 0.12in;justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
      }
    });
    
    // Close print-sheet
    html += '</div>';
  });
  
  html += '</body></html>';
  return html;
}

function renderSavedTab(stats) {
  const panel = document.getElementById('panel-saved');
  const texts = getTexts();
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Content (' + texts.length + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openFullEditor(null, false)">+ New</button>' +
    '</div>' +
  '</div>';
  
  if (texts.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ’¾</div><div class="panel-placeholder-text">No saved content yet. Create one or save text from the Print workflow.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const t of texts) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 60);
    
    // Find sheets this content is assigned to
    const assignedSheets = Object.values(sheets).filter(sh => sh.texts && sh.texts[t.id]);
    
    // Build clickable sheet links
    let sheetLinksHtml = '';
    if (assignedSheets.length > 0) {
      const links = assignedSheets.map(sh => 
        '<a href="#" onclick="event.stopPropagation(); event.preventDefault(); navigateToSheet(\'' + sh.id + '\');" style="color:var(--accent-text);text-decoration:underline;">' + escapeHtml(sh.name) + '</a>'
      ).join(', ');
      sheetLinksHtml = '<div class="saved-card-sheets" style="font-size:11px;color:var(--text-muted);margin-top:4px;">ðŸ“„ ' + links + '</div>';
    }
    
    html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', false)">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
          '<div class="saved-card-preview">' + escapeHtml(preview) + (preview.length >= 60 ? 'â€¦' : '') + '</div>' +
          sheetLinksHtml +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

function renderTemplatesTab(stats) {
  const panel = document.getElementById('panel-templates');
  const templates = getTemplates();
  const userTemplates = templates.filter(t => !t.builtin);
  const builtinTemplates = templates.filter(t => t.builtin);
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Templates (' + templates.length + ')</div>' +
  '</div>';
  
  html += '<div class="tab-content-list">';
  
  // User templates first
  for (const t of userTemplates) {
    const tokens = t.tokens || [];
    html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', true)">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
          '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  
  // Built-in templates
  for (const t of builtinTemplates) {
    const tokens = t.tokens || [];
    html += '<div class="saved-card" style="opacity: 0.85; cursor: pointer;" onclick="showBuiltinTemplatePreview(\'' + t.id + '\')">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + ' <span class="badge">Built-in</span></div>' +
          '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  
  html += '</div>';
  panel.innerHTML = html;
}

// G8: Build burn rate display HTML for inventory card
function buildBurnRateHtml(typeId) {
  const burn = getInventoryBurnRate(typeId);
  if (!burn) return '';

  let html = '<div class="inventory-burn-rate">';
  html += '<div class="inventory-burn-stat">ðŸ“ˆ <strong>' + burn.totalConsumed + '</strong> sheets used in ' + formatDuration(burn.daysSinceStart) + '</div>';

  if (burn.ratePerMonth >= 0.1) {
    html += '<div class="inventory-burn-stat">ðŸ”¥ <strong>~' + burn.ratePerMonth + '</strong>/month</div>';
  }

  if (burn.weeksLeft !== null && burn.ratePerMonth >= 0.1) {
    const cls = burn.weeksLeft <= 2 ? ' danger' : burn.weeksLeft <= 6 ? ' warn' : '';
    if (burn.weeksLeft <= 0) {
      html += '<div class="inventory-burn-stat danger">âš ï¸ Out of stock now</div>';
    } else {
      html += '<div class="inventory-burn-stat' + cls + '">â³ <strong>~' + burn.weeksLeft + ' week' + (burn.weeksLeft !== 1 ? 's' : '') + '</strong> left at this rate</div>';
    }
  }

  html += '</div>';
  return html;
}

function formatDuration(days) {
  if (days < 7) return days + ' day' + (days !== 1 ? 's' : '');
  if (days < 30) { const w = Math.floor(days / 7); return w + ' week' + (w !== 1 ? 's' : ''); }
  const m = Math.round(days / 30);
  return m + ' month' + (m !== 1 ? 's' : '');
}

function renderInventoryTab(stats) {
  const panel = document.getElementById('panel-inventory');
  const types = Object.keys(inventory);
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Inventory</div>' +
    '<div class="tab-actions"><button class="tab-action-btn" onclick="showAddInventoryModal()">+ Add Label Type</button></div>' +
  '</div>';
  
  if (types.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“¦</div><div class="panel-placeholder-text">Inventory tracking not set up yet.<br>Click "Add Label Type" above to get started.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const typeId of types) {
    const spec = LABEL_TYPES[typeId];
    const summary = getInventorySummary(typeId);
    if (!spec || !summary) continue;
    
    const statusClass = summary.stock === 0 && summary.partialSheets === 0 ? 'inv-empty' : summary.isLow ? 'inv-low' : 'inv-ok';
    const statusIcon = summary.stock === 0 && summary.partialSheets === 0 ? 'ðŸ”´' : summary.isLow ? 'ðŸŸ¡' : 'ðŸŸ¢';
    const statusText = summary.stock === 0 && summary.partialSheets === 0 ? 'Out of stock' : summary.isLow ? 'Low stock' : 'In stock';
    
    // Calculate breakdown bar percentages
    const totalSheetCount = summary.stock + summary.assignedUnusedSheets + summary.assignedPartialSheets;
    const shelfPct = totalSheetCount > 0 ? (summary.stock / totalSheetCount * 100) : 0;
    const assignedPct = totalSheetCount > 0 ? (summary.assignedUnusedSheets / totalSheetCount * 100) : 0;
    const partialPct = totalSheetCount > 0 ? (summary.assignedPartialSheets / totalSheetCount * 100) : 0;
    
    html += '<div class="inventory-card">' +
      '<div class="inventory-card-header">' +
        '<div class="inventory-card-type">' +
          '<span class="inventory-card-name">' + typeId + '</span>' +
          '<span class="inventory-card-desc">' + spec.desc + ' Â· ' + spec.sizeDisplay + '</span>' +
        '</div>' +
        '<div class="inventory-card-status ' + statusClass + '">' + statusIcon + ' ' + statusText + '</div>' +
      '</div>' +
      
      // Breakdown bar
      '<div class="inventory-breakdown">' +
        '<div class="inventory-breakdown-bar">' +
          (shelfPct > 0 ? '<div class="inventory-breakdown-segment shelf" style="width:' + shelfPct + '%"></div>' : '') +
          (assignedPct > 0 ? '<div class="inventory-breakdown-segment assigned" style="width:' + assignedPct + '%"></div>' : '') +
          (partialPct > 0 ? '<div class="inventory-breakdown-segment partial" style="width:' + partialPct + '%"></div>' : '') +
        '</div>' +
        '<div class="inventory-breakdown-legend">' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot shelf"></span>' +
            '<span>Shelf stock: <span class="inventory-breakdown-value">' + summary.stock + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot assigned"></span>' +
            '<span>Assigned (unused): <span class="inventory-breakdown-value">' + summary.assignedUnusedSheets + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot partial"></span>' +
            '<span>Assigned (partial): <span class="inventory-breakdown-value">' + summary.assignedPartialSheets + '</span></span>' +
          '</div>' +
        '</div>' +
      '</div>' +
      
      '<div class="inventory-card-body">' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalSheets + '</div>' +
          '<div class="inventory-stat-label">Total sheets</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalLabels + '</div>' +
          '<div class="inventory-stat-label">Available labels</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.fullyConsumed + '</div>' +
          '<div class="inventory-stat-label">Consumed sheets</div>' +
        '</div>' +
      '</div>' +
      buildBurnRateHtml(typeId) +
      '<div class="inventory-card-actions">' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', -1)" title="Remove 1 sheet">âˆ’</button>' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', 1)" title="Add 1 sheet">+</button>' +
        '<button class="inventory-adjust-btn wide" onclick="showAdjustInventoryModal(\'' + typeId + '\')">Set Stock</button>' +
        '<button class="inventory-adjust-btn danger" onclick="confirmRemoveInventory(\'' + typeId + '\')" title="Remove from tracking">ðŸ—‘ï¸</button>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

function renderHistoryTab(stats) {
  const panel = document.getElementById('panel-history');
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Print History</div>' +
    (printHistory.length > 0 ? '<div class="tab-actions"><button class="tab-action-btn-secondary tab-action-btn" onclick="confirmClearHistory()">Clear History</button></div>' : '') +
  '</div>';
  
  if (printHistory.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“œ</div><div class="panel-placeholder-text">No print history yet. Print some labels to see them here.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  // Get unique label types for filter dropdown
  const labelTypes = [...new Set(printHistory.map(e => e.labelType || '5160'))].sort();
  
  // Filters
  html += '<div class="history-filters">' +
    '<input type="text" class="history-search" id="historySearch" placeholder="Search by nameâ€¦" value="' + escapeAttr(historySearchQuery) + '" oninput="updateHistorySearch(this.value)">' +
    '<select class="history-filter-select" id="historyTypeFilter" onchange="updateHistoryTypeFilter(this.value)">' +
      '<option value="all"' + (historyTypeFilter === 'all' ? ' selected' : '') + '>All Types</option>' +
      labelTypes.map(t => '<option value="' + t + '"' + (historyTypeFilter === t ? ' selected' : '') + '>' + t + '</option>').join('') +
    '</select>' +
  '</div>';
  
  // Bulk actions bar (shown when items selected)
  if (historySelectedIds.size > 0) {
    html += '<div class="history-bulk-actions">' +
      '<span class="history-bulk-count">' + historySelectedIds.size + ' selected</span>' +
      '<button class="history-bulk-btn secondary" onclick="clearHistorySelection()">Clear</button>' +
      '<button class="history-bulk-btn" onclick="bulkReprintHistory()">Reprint Selected</button>' +
    '</div>';
  }
  
  // Filter entries
  const filtered = printHistory.filter(entry => {
    if (historyTypeFilter !== 'all' && (entry.labelType || '5160') !== historyTypeFilter) return false;
    if (historySearchQuery) {
      const q = historySearchQuery.toLowerCase();
      const name = (entry.textName || 'Labels').toLowerCase();
      if (!name.includes(q)) return false;
    }
    return true;
  }).slice(0, 100);
  
  if (filtered.length === 0) {
    html += '<div class="history-no-results">No matching entries found</div>';
    panel.innerHTML = html;
    return;
  }
  
  // Group by date
  const groups = {};
  for (const entry of filtered) {
    const date = new Date(entry.timestamp);
    const dateKey = getDateGroupKey(date);
    if (!groups[dateKey]) groups[dateKey] = { label: getDateGroupLabel(date), entries: [] };
    groups[dateKey].entries.push(entry);
  }
  
  // Render groups
  for (const key of Object.keys(groups).sort().reverse()) {
    const group = groups[key];
    html += '<div class="history-date-group">' +
      '<div class="history-date-header">' + escapeHtml(group.label) + '</div>' +
      '<div class="history-group-list">';
    
    for (const entry of group.entries) {
      const date = new Date(entry.timestamp);
      const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      const isSelected = historySelectedIds.has(entry.id);
      
      html += '<div class="history-card' + (isSelected ? ' selected' : '') + '">' +
        '<input type="checkbox" class="history-card-checkbox" ' + (isSelected ? 'checked' : '') + ' onchange="toggleHistorySelection(\'' + entry.id + '\', this.checked)">' +
        '<div class="history-card-icon">ðŸ·ï¸</div>' +
        '<div class="history-card-info">' +
          '<div class="history-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
          '<div class="history-card-meta">' + timeStr + ' Â· ' + (entry.count || 1) + ' label' + ((entry.count || 1) !== 1 ? 's' : '') + ' Â· ' + (entry.labelType || '5160') + '</div>' +
        '</div>' +
        '<button class="history-card-action" onclick="reprintFromHistory(\'' + entry.id + '\')">Reprint</button>' +
      '</div>';
    }
    
    html += '</div></div>';
  }
  
  panel.innerHTML = html;
}

// History filter helpers
function getDateGroupKey(date) {
  return date.toISOString().split('T')[0]; // YYYY-MM-DD
}

function getDateGroupLabel(date) {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
  
  if (dateOnly.getTime() === todayOnly.getTime()) return 'Today';
  if (dateOnly.getTime() === yesterdayOnly.getTime()) return 'Yesterday';
  
  // Check if this week
  const weekAgo = new Date(todayOnly);
  weekAgo.setDate(weekAgo.getDate() - 7);
  if (dateOnly > weekAgo) {
    return date.toLocaleDateString('en-US', { weekday: 'long' });
  }
  
  return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
}

function updateHistorySearch(query) {
  historySearchQuery = query;
  renderHistoryTab();
}

function updateHistoryTypeFilter(type) {
  historyTypeFilter = type;
  renderHistoryTab();
}

function toggleHistorySelection(id, checked) {
  if (checked) {
    historySelectedIds.add(id);
  } else {
    historySelectedIds.delete(id);
  }
  renderHistoryTab();
}

function clearHistorySelection() {
  historySelectedIds.clear();
  renderHistoryTab();
}

function bulkReprintHistory() {
  if (historySelectedIds.size === 0) return;
  
  // Get selected entries
  const entries = printHistory.filter(e => historySelectedIds.has(e.id));
  if (entries.length === 0) return;
  
  // For now, just reprint the first one and show a message
  // Future enhancement: batch reprint all selected
  if (entries.length === 1) {
    reprintFromHistory(entries[0].id);
  } else {
    showToast('Reprinting first selected item. Batch reprint coming soon!', 'info');
    reprintFromHistory(entries[0].id);
  }
  
  clearHistorySelection();
}

// ============================================================================
// WF1: PRINT SOMETHING NEW â€” Unified Print Workflow
// ============================================================================
// Replaces both "Print Labels" and "Print a Mailing List" wizards.
// Steps: 1=LabelType, 2=Inventory, 3=ContentType+Qty, 4=Feasibility,
//        5=SheetPicker, 6=Content, 7=Preview, 8=PostPrint

let wf1Step = 1;
let wf1LabelType = null;
let wf1JobType = null; // 'individual' | 'batch'
let wf1Quantity = 1;
let wf1TargetSheet = null;
let wf1ContentLines = [];
let wf1BatchContent = [];
let wf1InvAddVisible = false;

// Full Editor round-trip snapshot â€” preserves rich styles (bold, color, graphics, etc.)
let wf1FeSnapshot = null; // { lines: [...], graphics: {...}, alignV: '...', border: {...} }

const WF1_TOTAL_STEPS = 8;

function wf1Start() {
  // Block satellite from printing
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  // Reset state
  wf1Step = 1;
  wf1LabelType = settings.lastLabelType || '5160';
  wf1JobType = null;
  wf1Quantity = 1;
  wf1TargetSheet = null;
  wf1ContentLines = [];
  wf1BatchContent = [];
  wf1InvAddVisible = false;
  wf1SelectedSheet = null;
  wf1MultiSheetPlan = null;
  wf1Orientation = 'next'; // T3: Reset orientation
  wf1SelectedSavedTextId = null;
  wf1PrintResult = null;
  wf1_aiActive = false;
  wf1_fullEditorActive = false;
  wf1FeSnapshot = null;
  wf1LineAligns = ['left', 'left', 'left', 'left'];
  wf1LineSizes = [11, 11, 11, 11];
  
  // Render Step 1
  wf1RenderTypeGrid();
  wf1UpdateProgress();
  
  // Show wizard
  showWizard('wf1Wizard');
  wf1ShowStep('wf1Step1');
}

function wf1Close() {
  // Process any checked post-print options before closing
  wf1ProcessPostPrintOptions();
  
  closeWizard('wf1Wizard');
  wf1Step = 1;
}

// Process checked post-print options
function wf1ProcessPostPrintOptions() {
  const result = wf1PrintResult;
  if (!result || result.isMultiSheet) return;
  
  // Check if link content was selected
  const linkCheckbox = document.getElementById('wf1PostLinkContent');
  if (linkCheckbox && linkCheckbox.checked) {
    wf1DoLinkContent();
  }
  
  // Check if split sheet was selected
  const splitCheckbox = document.getElementById('wf1PostSplitSheet');
  if (splitCheckbox && splitCheckbox.checked) {
    wf1DoSplitRemaining();
  }
}

// Link content to sheet (silent version for checkbox flow)
function wf1DoLinkContent() {
  const result = wf1PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  let textId = wf1SelectedSavedTextId;
  
  // Save content if not already saved
  if (!textId) {
    const newText = {
      id: generateId('text'),
      name: generateContentName(wf1ContentLines, wf1LabelType),
      text: serializeLines(wf1ContentLines.map(function(l) {
        return { text: l.text, align: l.align, fontSize: l.fontSize, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' };
      })),
      alignV: 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now()
    };
    savedTexts.push(newText);
    saveSavedTexts();
    textId = newText.id;
  }
  
  // Link to sheet
  if (!sh.texts) sh.texts = {};
  if (!sh.texts[textId]) {
    sh.texts[textId] = { qty: 0, placement: 'next' };
  }
  saveSheets();
  
  showToast('Content linked to sheet', 'success');
}

// Split remaining labels into new sheet (silent version for checkbox flow)
function wf1DoSplitRemaining() {
  const result = wf1PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const remaining = getRemainingCount(sh);
  
  if (remaining <= 0 || remaining >= lps) return;
  
  // Find unused positions
  const printedSet = new Set(sh.printed || []);
  const unusedPositions = [];
  for (let i = 0; i < lps; i++) {
    if (!printedSet.has(i)) unusedPositions.push(i);
  }
  
  // Create new sheet with these positions pre-marked as "available"
  // Actually, we mark the USED positions as printed, so new sheet starts fresh
  // and original sheet gets all unused marked as printed (sheet is "done")
  
  // Mark all remaining positions as printed on original sheet
  sh.printed = Array.from({ length: lps }, (_, i) => i);
  saveSheets();
  
  // Create new sheet  
  const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
  const newSheetName = spec.desc + ' #' + (existingCount + 1) + ' (split)';
  const newSheetId = createSheet(newSheetName, wf1LabelType, 1);
  
  // Mark positions that were already used on the original as printed on new sheet
  // (inverse of what we want available)
  const newSheet = sheets[newSheetId];
  const usedOnOriginal = [];
  for (let i = 0; i < lps; i++) {
    if (!unusedPositions.includes(i)) usedOnOriginal.push(i);
  }
  newSheet.printed = usedOnOriginal;
  saveSheets();
  
  showToast('Split ' + remaining + ' labels into "' + newSheetName + '"', 'success');
}

function wf1ShowStep(stepId) {
  const wizard = document.getElementById('wf1Wizard');
  wizard.querySelectorAll('.wizard-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
  wf1UpdateProgress();
}

function wf1UpdateProgress() {
  const container = document.getElementById('wf1Progress');
  let html = '';
  for (let i = 1; i <= WF1_TOTAL_STEPS; i++) {
    let cls = 'wf1-progress-dot';
    if (i === wf1Step) cls += ' active';
    else if (i < wf1Step) cls += ' done';
    html += '<div class="' + cls + '"></div>';
  }
  container.innerHTML = html;
}

function wf1Back() {
  if (wf1Step <= 1) {
    wf1Close();
    return;
  }
  
  // Special handling for batch sub-steps within step 6
  if (wf1Step === 6 && wf1JobType === 'batch') {
    if (wf1BatchSubStep === 'preview') {
      wf1BatchSubStep = 'map';
      wf1RenderBatchMapStep();
      return;
    } else if (wf1BatchSubStep === 'map') {
      wf1BatchSubStep = 'template';
      wf1RenderBatchTemplateStep();
      return;
    } else if (wf1BatchSubStep === 'template') {
      wf1BatchSubStep = 'upload';
      wf1RenderBatchUpload(document.getElementById('wf1ContentArea'));
      return;
    }
  }
  
  wf1Step--;
  wf1ShowStep('wf1Step' + wf1Step);
}

// ---- STEP 1: Label Type Picker ----

function wf1RenderTypeGrid() {
  const grid = document.getElementById('wf1TypeGrid');
  const lastUsed = settings.lastLabelType;
  
  let html = '';
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === wf1LabelType;
    const isLast = typeId === lastUsed;
    
    // Inventory badge
    const inv = inventory[typeId];
    let invBadge = '';
    if (inv && inv.stock > 0) {
      invBadge = '<div class="wf1-type-card-badge">ðŸ“¦ ' + inv.stock + ' sheet' + (inv.stock !== 1 ? 's' : '') + '</div>';
    }
    
    // Category badge
    let catBadge = '';
    if (spec.category === 'badge') catBadge = ' ðŸ·ï¸';
    else if (spec.category === 'tent') catBadge = ' â›º';
    
    html += '<div class="wf1-type-card' + (selected ? ' selected' : '') + (isLast ? ' last-used' : '') + '" data-type="' + typeId + '" onclick="wf1SelectType(\'' + typeId + '\')" ondblclick="wf1SelectTypeAndAdvance(\'' + typeId + '\')">' +
      '<div class="wf1-type-card-id">' + typeId + catBadge + '</div>' +
      '<div class="wf1-type-card-desc">' + spec.desc + '</div>' +
      '<div class="wf1-type-card-meta">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet</div>' +
      invBadge +
    '</div>';
  }
  grid.innerHTML = html;
}

function wf1SelectType(typeId) {
  wf1LabelType = typeId;
  
  // Update visual selection
  document.querySelectorAll('#wf1TypeGrid .wf1-type-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.type === typeId);
  });
}

// T1: Double-click to select AND advance to next step
function wf1SelectTypeAndAdvance(typeId) {
  wf1SelectType(typeId);
  wf1ToStep2();
}

function wf1ToStep2() {
  if (!wf1LabelType) return;
  
  // Save as last used
  settings.lastLabelType = wf1LabelType;
  saveSettings();
  
  wf1Step = 2;
  wf1RenderInventoryCheck();
  wf1ShowStep('wf1Step2');
}

// ---- STEP 2: Inventory Check ----

function wf1RenderInventoryCheck() {
  const content = document.getElementById('wf1InventoryContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const summary = getInventorySummary(wf1LabelType);
  const inv = getInventoryForType(wf1LabelType);
  
  wf1InvAddVisible = false;
  
  let html = '';
  
  if (inv && summary.stock > 0) {
    // Scenario A: Has stock
    const totalLabels = summary.totalLabels;
    const stockLabels = summary.stockLabels;
    
    if (summary.isLow) {
      // Low stock warning â€” still double-clickable to continue
      html += '<div class="wf1-inventory-status low-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
        '<div class="wf1-inventory-icon">âš ï¸</div>' +
        '<div class="wf1-inventory-msg">You\'re running low on ' + wf1LabelType + '</div>' +
        '<div class="wf1-inventory-detail">' + summary.stock + ' sheet' + (summary.stock !== 1 ? 's' : '') + ' in stock (' + stockLabels + ' labels)';
      
      if (summary.partialLabels > 0) {
        html += ', plus ' + summary.partialLabels + ' available on existing sheets';
      }
      html += '.</div>' +
        '<div class="wf1-inventory-actions">' +
          '<button class="wf1-inv-btn" onclick="event.stopPropagation(); wf1ShowInlineAdd()">Add more stock</button>' +
        '</div>' +
      '</div>';
    } else {
      // Plenty of stock â€” double-click to advance
      html += '<div class="wf1-inventory-status has-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
        '<div class="wf1-inventory-icon">âœ…</div>' +
        '<div class="wf1-inventory-msg">You have ' + summary.stock + ' sheet' + (summary.stock !== 1 ? 's' : '') + ' of ' + wf1LabelType + '</div>' +
        '<div class="wf1-inventory-detail">' + totalLabels + ' labels available';
      
      if (summary.partialLabels > 0) {
        html += ' (' + stockLabels + ' in stock + ' + summary.partialLabels + ' on existing sheets)';
      }
      html += '.</div></div>';
    }
  } else if (inv && summary.stock === 0 && summary.partialLabels > 0) {
    // No stock but has partial sheets with spots â€” still clickable
    html += '<div class="wf1-inventory-status low-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-inventory-icon">âš ï¸</div>' +
      '<div class="wf1-inventory-msg">No sheets of ' + wf1LabelType + ' in stock</div>' +
      '<div class="wf1-inventory-detail">You have ' + summary.partialLabels + ' labels available on existing sheets, but no fresh sheets.</div>' +
      '<div class="wf1-inventory-actions">' +
        '<button class="wf1-inv-btn" onclick="event.stopPropagation(); wf1ShowInlineAdd()">Add stock</button>' +
      '</div>' +
    '</div>';
  } else {
    // Scenario B: No stock recorded at all
    html += '<div class="wf1-inventory-status no-stock">' +
      '<div class="wf1-inventory-icon">ðŸ“¦</div>' +
      '<div class="wf1-inventory-msg">I don\'t show you having any Avery ' + wf1LabelType + ' labels on hand.</div>' +
      '<div class="wf1-inventory-detail">' + spec.desc + ' â€” ' + spec.sizeDisplay + ', ' + lps + ' labels per sheet</div>' +
      '<div class="wf1-inventory-actions">' +
        '<button class="wf1-inv-btn primary" onclick="wf1ShowInlineAdd()">Yes, I have some â€” add to inventory</button>' +
        '<button class="wf1-inv-btn" onclick="wf1SkipInventory()">Continue without tracking</button>' +
      '</div>' +
    '</div>';
  }
  
  // Inline add area (hidden initially)
  html += '<div class="wf1-inv-add-inline" id="wf1InvAddInline" style="display:none;">' +
    '<label for="wf1InvAddQty">How many sheets of ' + wf1LabelType + ' do you have?</label>' +
    '<input type="number" id="wf1InvAddQty" min="1" max="500" value="10" inputmode="numeric">' +
    '<div class="wf1-inv-add-actions">' +
      '<button class="wf1-inv-btn primary" onclick="wf1SaveInlineInventory()">Save</button>' +
      '<button class="wf1-inv-btn" onclick="wf1HideInlineAdd()">Cancel</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
}

function wf1ShowInlineAdd() {
  wf1InvAddVisible = true;
  document.getElementById('wf1InvAddInline').style.display = 'block';
  document.getElementById('wf1InvAddQty').focus();
}

function wf1HideInlineAdd() {
  wf1InvAddVisible = false;
  document.getElementById('wf1InvAddInline').style.display = 'none';
}

function wf1SaveInlineInventory() {
  const qty = parseInt(document.getElementById('wf1InvAddQty').value) || 0;
  if (qty <= 0) {
    showToast('Enter a number of sheets', 'warning');
    return;
  }
  
  // Save to inventory
  const existing = inventory[wf1LabelType];
  const oldStock = existing ? existing.stock : 0;
  inventory[wf1LabelType] = {
    stock: qty,
    lowThreshold: existing ? existing.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  addInventoryEvent(wf1LabelType, 'add', qty - oldStock, inventory[wf1LabelType].stock);
  
  showToast(qty + ' sheet' + (qty !== 1 ? 's' : '') + ' of ' + wf1LabelType + ' added to inventory', 'success');
  
  // Re-render the inventory check with updated data
  wf1RenderInventoryCheck();
}

function wf1SkipInventory() {
  // User chose to continue without tracking inventory
  // Just advance to step 3
  wf1ToStep3();
}

function wf1ToStep3() {
  wf1Step = 3;
  wf1JobType = null; // Reset in case coming back
  
  // Reset quantity display
  document.getElementById('wf1QtyRow').style.display = 'none';
  document.getElementById('wf1QtyHint').style.display = 'none';
  document.getElementById('wf1Step3Actions').style.display = 'none';
  
  // Reset visual selection on content choices
  document.querySelectorAll('.wf1-content-choice').forEach(c => {
    c.style.borderColor = '';
    c.style.background = '';
  });
  
  wf1ShowStep('wf1Step3');
}

// ---- STEP 3: Content Type + Quantity ----

function wf1SetJobType(type) {
  wf1JobType = type;
  
  // Highlight selected choice
  const choices = document.querySelectorAll('.wf1-content-choice');
  choices.forEach(c => {
    c.style.borderColor = '';
    c.style.background = '';
  });
  const idx = type === 'individual' ? 0 : 1;
  choices[idx].style.borderColor = 'var(--accent)';
  choices[idx].style.background = 'var(--accent-bg)';
  
  if (type === 'individual') {
    // Show quantity picker for individual
    const spec = LABEL_TYPES[wf1LabelType];
    const lps = spec.cols * spec.rows;
    document.getElementById('wf1QtyRow').style.display = 'flex';
    document.getElementById('wf1QtyHint').style.display = 'block';
    document.getElementById('wf1QtyHint').textContent = lps + ' labels per sheet of ' + wf1LabelType;
    document.getElementById('wf1QtyValue').textContent = wf1Quantity;
    document.getElementById('wf1QtyMinus').disabled = wf1Quantity <= 1;
  } else {
    // Batch â€” quantity determined by list, hide picker
    document.getElementById('wf1QtyRow').style.display = 'none';
    document.getElementById('wf1QtyHint').style.display = 'none';
  }
  
  // Show next button
  document.getElementById('wf1Step3Actions').style.display = 'flex';
}

// T1: Double-click to set job type and advance
function wf1SetJobTypeAndAdvance(type) {
  wf1SetJobType(type);
  // For batch, advance immediately. For individual, user may want to adjust quantity first.
  if (type === 'batch') {
    setTimeout(() => wf1ToStep3B(), 100);
  }
}

// Step 3B: CSV Upload for batch (happens before feasibility so we know the qty)
function wf1ToStep3B() {
  // Reset batch state
  wf1BatchCsvData = [];
  wf1BatchCsvColumns = [];
  wf1BatchContent = [];
  wf1BatchSelectedTemplate = null;
  wf1BatchColumnMap = {};
  wf1BatchSubStep = 'upload';
  
  // Render CSV upload in Step 3's area (reuse the step visually)
  const contentArea = document.getElementById('wf1Step3Content');
  const question = document.getElementById('wf1Step3Question');
  
  question.textContent = 'Import your list';
  
  let html = '<div class="wf1-batch-upload">';
  html += '<div class="wf1-batch-upload-zone" id="wf1BatchDropZone">';
  html += '<div class="wf1-batch-upload-icon">ðŸ“„</div>';
  html += '<div class="wf1-batch-upload-text">Drop a CSV or Excel file here</div>';
  html += '<div class="wf1-batch-upload-or">or</div>';
  html += '<button class="wf1-inv-btn" onclick="document.getElementById(\'wf1BatchFileInput\').click()">Choose File</button>';
  html += '<input type="file" id="wf1BatchFileInput" accept=".csv,.xlsx,.xls,.txt" style="display:none" onchange="wf1HandleBatchFile(this.files[0])">';
  html += '</div>';
  html += '<div class="wf1-batch-paste-option" style="margin-top:12px;text-align:center;">';
  html += '<button class="wf1-inv-btn" onclick="wf1ShowPasteArea()">ðŸ“‹ Paste from clipboard</button>';
  html += '</div>';
  html += '<div id="wf1BatchPasteArea" style="display:none;margin-top:12px;">';
  html += '<textarea id="wf1BatchPasteText" placeholder="Paste your data here (tab or comma separated)" style="width:100%;height:100px;font-family:monospace;font-size:12px;padding:8px;border:2px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);color:var(--text);"></textarea>';
  html += '<button class="wf1-inv-btn primary" onclick="wf1ProcessPastedData()" style="margin-top:8px;">Process Data</button>';
  html += '</div>';
  html += '</div>';
  
  contentArea.innerHTML = html;
  
  // Setup drag and drop
  const dropZone = document.getElementById('wf1BatchDropZone');
  dropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    dropZone.style.borderColor = 'var(--accent)';
    dropZone.style.background = 'var(--accent-bg)';
  });
  dropZone.addEventListener('dragleave', function(e) {
    dropZone.style.borderColor = '';
    dropZone.style.background = '';
  });
  dropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    dropZone.style.borderColor = '';
    dropZone.style.background = '';
    if (e.dataTransfer.files.length > 0) {
      wf1HandleBatchFile(e.dataTransfer.files[0]);
    }
  });
  
  // Hide qty row and update actions
  document.getElementById('wf1QtyRow').style.display = 'none';
  document.getElementById('wf1QtyHint').style.display = 'none';
  document.getElementById('wf1Step3Actions').style.display = 'none';
}

function wf1ShowPasteArea() {
  document.getElementById('wf1BatchPasteArea').style.display = 'block';
  document.getElementById('wf1BatchPasteText').focus();
}

function wf1ProcessPastedData() {
  const text = document.getElementById('wf1BatchPasteText').value.trim();
  if (!text) {
    showToast('Please paste some data first', 'warning');
    return;
  }
  wf1ParseBatchData(text, 'pasted data');
}

// After CSV is loaded in Step 3B, proceed to feasibility
function wf1CsvLoadedProceed() {
  if (wf1BatchCsvData.length === 0) {
    showToast('No data loaded', 'warning');
    return;
  }
  // Now proceed to Step 4 (feasibility) - we have the real qty now
  wf1ToStep4();
}

function wf1AdjustQty(delta) {
  const newQty = wf1Quantity + delta;
  if (newQty < 1 || newQty > 999) return;
  wf1Quantity = newQty;
  document.getElementById('wf1QtyValue').textContent = wf1Quantity;
  document.getElementById('wf1QtyMinus').disabled = wf1Quantity <= 1;
}

function wf1ToStep4() {
  if (!wf1JobType) return;
  
  wf1Step = 4;
  wf1RenderFeasibility();
  wf1ShowStep('wf1Step4');
}

// ---- STEP 4: Feasibility Check ----

function wf1RenderFeasibility() {
  const content = document.getElementById('wf1FeasibilityContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // T6: For batch jobs, if content isn't loaded yet, show a different message
  // BatchContent is populated at Step 6 (after this step), so we can't do a real check yet
  if (wf1JobType === 'batch' && wf1BatchContent.length === 0) {
    // Gather inventory info for display
    const matchingSheets = Object.values(sheets).filter(s => s.labelType === wf1LabelType && !s.retired);
    let spotsOnSheets = 0;
    for (const sh of matchingSheets) {
      spotsOnSheets += getRemainingCount(sh);
    }
    const inv = inventory[wf1LabelType];
    const stockSheets = (inv && inv.stock > 0) ? inv.stock : 0;
    const stockLabels = stockSheets * lps;
    const totalAvailable = spotsOnSheets + stockLabels;
    
    let html = '<div class="wf1-feasibility ok" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">ðŸ“‹</div>' +
      '<div class="wf1-feas-msg">Ready for your list</div>' +
      '<div class="wf1-feas-detail">You\'ll import a list next. Currently you have ' + totalAvailable + ' label' + (totalAvailable !== 1 ? 's' : '') + ' available';
    
    if (spotsOnSheets > 0 && stockLabels > 0) {
      html += ' (' + spotsOnSheets + ' on existing sheets + ' + stockLabels + ' in stock)';
    } else if (spotsOnSheets > 0) {
      html += ' on existing sheets';
    } else if (stockLabels > 0) {
      html += ' in stock';
    }
    html += '.</div></div>';
    
    content.innerHTML = html;
    return;
  }
  
  const qty = wf1JobType === 'batch' ? wf1BatchContent.length : wf1Quantity;
  
  // Gather available spots across existing sheets + inventory
  const matchingSheets = Object.values(sheets).filter(s => s.labelType === wf1LabelType && !s.retired);
  let spotsOnSheets = 0;
  for (const sh of matchingSheets) {
    spotsOnSheets += getRemainingCount(sh);
  }
  
  const inv = inventory[wf1LabelType];
  const stockSheets = (inv && inv.stock > 0) ? inv.stock : 0;
  const stockLabels = stockSheets * lps;
  const totalAvailable = spotsOnSheets + stockLabels;
  
  let html = '';
  
  if (totalAvailable >= qty && (spotsOnSheets >= qty || stockSheets > 0)) {
    // Scenario A: Plenty of room â€” double-click to advance
    html += '<div class="wf1-feasibility ok" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">âœ…</div>' +
      '<div class="wf1-feas-msg">You have enough labels</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + '. You have ' + totalAvailable + ' available';
    
    if (spotsOnSheets > 0 && stockLabels > 0) {
      html += ' (' + spotsOnSheets + ' on existing sheets + ' + stockLabels + ' in stock)';
    } else if (spotsOnSheets > 0) {
      html += ' on existing sheets';
    } else {
      html += ' in stock';
    }
    html += '.</div></div>';
    
  } else if (totalAvailable >= qty) {
    // Scenario B: Tight but doable â€” double-click to advance
    const sheetsNeededFromStock = Math.ceil(Math.max(0, qty - spotsOnSheets) / lps);
    html += '<div class="wf1-feasibility warn" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">âš ï¸</div>' +
      '<div class="wf1-feas-msg">Tight, but doable</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + '. ' +
      'You have ' + spotsOnSheets + ' spots on existing sheets and ' + stockSheets + ' fresh sheet' + (stockSheets !== 1 ? 's' : '') + ' (' + stockLabels + ' labels) in stock. ' +
      'That\'s ' + totalAvailable + ' total â€” enough, but it\'ll use ' + sheetsNeededFromStock + ' sheet' + (sheetsNeededFromStock !== 1 ? 's' : '') + ' from stock.</div></div>';
    
  } else {
    // Scenario C: Not enough
    const deficit = qty - totalAvailable;
    const extraSheetsNeeded = Math.ceil(deficit / lps);
    html += '<div class="wf1-feasibility error">' +
      '<div class="wf1-feas-icon">âš ï¸</div>' +
      '<div class="wf1-feas-msg">Not enough labels</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + ' but only have ' + totalAvailable + ' available. ' +
      'You\'ll need about ' + extraSheetsNeeded + ' more sheet' + (extraSheetsNeeded !== 1 ? 's' : '') + ' of ' + wf1LabelType + '.</div>' +
      '<div class="wf1-feas-actions">' +
        '<button class="wf1-inv-btn" onclick="wf1FeasAdjustQty()">Adjust quantity</button>' +
        '<button class="wf1-inv-btn" onclick="wf1FeasAddStock()">Add more stock</button>' +
        '<button class="wf1-inv-btn" onclick="wf1ToStep5()">Continue with what I have</button>' +
      '</div></div>';
  }
  
  content.innerHTML = html;
}

function wf1FeasAdjustQty() {
  // Go back to step 3 to adjust quantity
  wf1Step = 3;
  wf1ShowStep('wf1Step3');
}

function wf1FeasAddStock() {
  // Show inline add within the feasibility step
  const content = document.getElementById('wf1FeasibilityContent');
  content.innerHTML += '<div class="wf1-inv-add-inline" style="display:block; margin-top: 12px;">' +
    '<label for="wf1FeasAddQty">How many sheets of ' + wf1LabelType + ' to add?</label>' +
    '<input type="number" id="wf1FeasAddQty" min="1" max="500" value="10" inputmode="numeric">' +
    '<div class="wf1-inv-add-actions">' +
      '<button class="wf1-inv-btn primary" onclick="wf1FeasSaveStock()">Save</button>' +
      '<button class="wf1-inv-btn" onclick="wf1RenderFeasibility()">Cancel</button>' +
    '</div>' +
  '</div>';
  document.getElementById('wf1FeasAddQty').focus();
}

function wf1FeasSaveStock() {
  const qty = parseInt(document.getElementById('wf1FeasAddQty').value) || 0;
  if (qty <= 0) { showToast('Enter a number of sheets', 'warning'); return; }
  
  const existing = inventory[wf1LabelType];
  const currentStock = (existing && existing.stock) ? existing.stock : 0;
  inventory[wf1LabelType] = {
    stock: currentStock + qty,
    lowThreshold: existing ? existing.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  addInventoryEvent(wf1LabelType, 'add', qty, inventory[wf1LabelType].stock);
  showToast(qty + ' sheets added to inventory', 'success');
  wf1RenderFeasibility();
}

// ---- STEP 5: Sheet Selection ----

function wf1ToStep5() {
  wf1Step = 5;
  wf1SelectedSheet = null;
  wf1RenderSheetPicker();
  wf1ShowStep('wf1Step5');
}

let wf1SelectedSheet = null; // { id, isNew } or { id: '__multi__', plan }
let wf1MultiSheetPlan = null;
let wf1Orientation = 'next'; // 'next' | 'col1' | 'col2' (T3)

// T3: Get position indices in order based on orientation
// orientation: 'next' = sequential (0,1,2,3...), 'col1' = column 1 first, 'col2' = column 2 first
function wf1GetPositionOrder(cols, rows, orientation) {
  const positions = [];
  const lps = cols * rows;
  
  // Check if orientation is a column preference (col1, col2, col3, etc.)
  const colMatch = orientation.match(/^col(\d+)$/);
  if (colMatch) {
    const startCol = parseInt(colMatch[1]) - 1; // Convert to 0-indexed (col1 â†’ 0, col2 â†’ 1, etc.)
    
    // Start from the specified column, then cycle through remaining columns
    for (let offset = 0; offset < cols; offset++) {
      const c = (startCol + offset) % cols;
      for (let r = 0; r < rows; r++) {
        positions.push(r * cols + c);
      }
    }
  } else {
    // 'next' = sequential row-by-row
    for (let i = 0; i < lps; i++) {
      positions.push(i);
    }
  }
  
  return positions;
}

// T3: Find next N available positions respecting orientation
function wf1FindNextPositions(sh, spec, qty, orientation) {
  const lps = spec.cols * spec.rows;
  const printedSet = new Set(sh.printed || []);
  const positionOrder = wf1GetPositionOrder(spec.cols, spec.rows, orientation);
  
  const nextPositions = [];
  for (const idx of positionOrder) {
    if (!printedSet.has(idx)) {
      nextPositions.push(idx);
      if (nextPositions.length >= qty) break;
    }
  }
  return nextPositions;
}

function wf1BuildMultiSheetPlan(matchingSheets, lps, totalQty, hasStock, inv) {
  const steps = [];
  let remaining = totalQty;
  let newSheetsNeeded = 0;
  
  // First, fill existing sheets (sorted by most remaining capacity)
  const sortedSheets = matchingSheets.slice().sort(function(a, b) { return b.remaining - a.remaining; });
  for (const sh of sortedSheets) {
    if (remaining <= 0) break;
    const use = Math.min(sh.remaining, remaining);
    if (use > 0) {
      steps.push({ sheetId: sh.id, sheetName: sh.name, count: use, isNew: false, remaining: sh.remaining });
      remaining -= use;
    }
  }
  
  // Then, create new sheets from stock as needed
  const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
  while (remaining > 0) {
    const use = Math.min(lps, remaining);
    steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
    remaining -= use;
    newSheetsNeeded++;
  }
  
  return { steps: steps, totalLabels: totalQty, newSheetsNeeded: newSheetsNeeded, stockAvail: stockAvail };
}

// Build a compact mini-grid showing used/available/next-print positions for a sheet
function wf1BuildMiniGrid(sh, spec, qty) {
  const lps = spec.cols * spec.rows;
  const printedSet = new Set(sh.printed || []);
  
  // T3: Use orientation-aware position finding
  const nextPositionsList = wf1FindNextPositions(sh, spec, qty, wf1Orientation);
  const nextPositions = new Set(nextPositionsList);
  
  // Only show first physical page for simplicity
  let html = '<div class="wf1-sheet-mini-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 10) + 'px;">';
  for (let i = 0; i < lps; i++) {
    let cls = 'wf1-sheet-mini-cell';
    if (printedSet.has(i)) {
      cls += ' used';
    } else if (nextPositions.has(i)) {
      cls += ' next';
    }
    html += '<div class="' + cls + '"></div>';
  }
  html += '</div>';
  html += '<div class="wf1-sheet-grid-legend">' +
    '<span class="leg-avail">Available</span>' +
    '<span class="leg-used">Used</span>' +
    '<span class="leg-next">Next print</span>' +
  '</div>';
  return html;
}

// Build mini-grid for a new (empty) sheet â€” shows orientation-aware next positions
function wf1BuildMiniGridForNew(spec, qty) {
  const lps = spec.cols * spec.rows;
  // Create a fake empty sheet to reuse position finding logic
  const fakeSheet = { printed: [], sheetCount: 1 };
  const nextPositionsList = wf1FindNextPositions(fakeSheet, spec, qty, wf1Orientation);
  const nextPositions = new Set(nextPositionsList);
  
  let html = '<div class="wf1-sheet-mini-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 10) + 'px;">';
  for (let i = 0; i < lps; i++) {
    let cls = 'wf1-sheet-mini-cell';
    if (nextPositions.has(i)) {
      cls += ' next';
    }
    html += '<div class="' + cls + '"></div>';
  }
  html += '</div>';
  return html;
}

function wf1RenderSheetPicker() {
  const content = document.getElementById('wf1SheetPickerContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const qty = wf1JobType === 'batch' ? (wf1BatchContent.length || wf1Quantity) : wf1Quantity;
  
  // Check if we're in "mixed" mode - picking a sheet for remainder only
  const isMixedMode = wf1MultiSheetPlan && wf1MultiSheetPlan.pendingRemainder > 0;
  const remainderQty = isMixedMode ? wf1MultiSheetPlan.pendingRemainder : qty;
  
  // Find matching non-retired sheets with spots
  const matchingSheets = Object.values(sheets)
    .filter(s => s.labelType === wf1LabelType && !s.retired)
    .map(sh => {
      const remaining = getRemainingCount(sh);
      const isDedicated = sh.texts && Object.keys(sh.texts).length > 0;
      const daysSinceUse = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / 86400000) : null;
      const isStale = daysSinceUse !== null && daysSinceUse > 30;
      return { ...sh, remaining, isDedicated, daysSinceUse, isStale };
    })
    .filter(sh => sh.remaining > 0)
    .sort((a, b) => {
      // Sort: sheets with enough room first, then by most recently used
      const targetQty = isMixedMode ? remainderQty : qty;
      const aFits = a.remaining >= targetQty ? 1 : 0;
      const bFits = b.remaining >= targetQty ? 1 : 0;
      if (aFits !== bFits) return bFits - aFits;
      return (b.lastUsedAt || 0) - (a.lastUsedAt || 0);
    });
  
  const inv = inventory[wf1LabelType];
  const hasStock = inv && inv.stock > 0;
  
  let html = '';
  
  // Show mixed mode header if applicable
  if (isMixedMode) {
    html += '<div class="wf1-mixed-mode-header">';
    html += '<div class="wf1-mixed-mode-icon">ðŸ”€</div>';
    html += '<div class="wf1-mixed-mode-text">';
    html += '<strong>' + wf1MultiSheetPlan.newSheetsNeeded + ' new sheet' + (wf1MultiSheetPlan.newSheetsNeeded !== 1 ? 's' : '') + '</strong> will print ' + (wf1MultiSheetPlan.newSheetsNeeded * lps) + ' labels.';
    html += '<br>Pick an existing sheet for the <strong>remaining ' + remainderQty + '</strong>:';
    html += '</div>';
    html += '</div>';
  }
  
  html += '<div class="wf1-sheet-list">';
  
  // Existing sheets
  for (const sh of matchingSheets) {
    const selected = wf1SelectedSheet && wf1SelectedSheet.id === sh.id;
    let metaStr = '';
    if (sh.isDedicated) {
      metaStr += '<span class="wf1-sheet-badge dedicated">Dedicated</span>';
    } else {
      metaStr += '<span class="wf1-sheet-badge open">Open</span>';
    }
    if (sh.lastUsedAt) {
      metaStr += ' Â· Last used: ' + new Date(sh.lastUsedAt).toLocaleDateString();
    } else {
      metaStr += ' Â· Created: ' + new Date(sh.createdAt || sh.created || Date.now()).toLocaleDateString();
    }
    
    let warningHtml = '';
    if (sh.isStale) {
      warningHtml = '<div class="wf1-sheet-warning">âš ï¸ Not used in ' + sh.daysSinceUse + ' days. Can you confirm you still have it?';
      if (!sh.hasBackLabel) {
        warningHtml += ' <button onclick="event.stopPropagation(); wf1PrintIdLabel(\'' + sh.id + '\')" style="background:none;border:none;color:var(--accent);cursor:pointer;font-size:11px;text-decoration:underline;padding:0;margin-left:4px;">Print ID label</button>';
      }
      warningHtml += '</div>';
    }
    if (sh.remaining < qty) {
      warningHtml += '<div class="wf1-sheet-warning">Only ' + sh.remaining + ' spots â€” you need ' + qty + '. Will need another sheet too.</div>';
    }
    
    html += '<div class="wf1-sheet-card' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'' + sh.id + '\')" ondblclick="wf1SelectSheetAndAdvance(\'' + sh.id + '\')">' +
      '<div class="wf1-sheet-icon">ðŸ“„</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">' + escapeHtml(sh.name) + '</div>' +
        '<div class="wf1-sheet-meta">' + metaStr + '</div>' +
        warningHtml +
        wf1BuildMiniGrid(sh, spec, qty) +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + sh.remaining + '/' + (lps * (sh.sheetCount || 1)) + '</div>' +
    '</div>';
  }
  
  // Create new sheet option
  if (hasStock) {
    const selected = wf1SelectedSheet && wf1SelectedSheet.isNew;
    const emptyGridHtml = wf1BuildMiniGridForNew(spec, qty);
    html += '<div class="wf1-sheet-card create-new' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'__new__\')" ondblclick="wf1SelectSheetAndAdvance(\'__new__\')">' +
      '<div class="wf1-sheet-icon">âž•</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">Create new sheet from stock</div>' +
        '<div class="wf1-sheet-meta">' + inv.stock + ' sheet' + (inv.stock !== 1 ? 's' : '') + ' available in inventory</div>' +
        emptyGridHtml +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + lps + '/' + lps + '</div>' +
    '</div>';
  } else if (matchingSheets.length === 0) {
    // No sheets and no stock
    const selected = wf1SelectedSheet && wf1SelectedSheet.isNew;
    const emptyGridHtml = wf1BuildMiniGridForNew(spec, qty);
    html += '<div class="wf1-sheet-card create-new' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'__new__\')" ondblclick="wf1SelectSheetAndAdvance(\'__new__\')" style="border-color:var(--warning, #ca8a04);">' +
      '<div class="wf1-sheet-icon">âž•</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">Create new sheet</div>' +
        '<div class="wf1-sheet-meta" style="color:var(--warning,#ca8a04);">No stock tracked â€” will create without deducting inventory</div>' +
        emptyGridHtml +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + lps + '/' + lps + '</div>' +
    '</div>';
  }
  
  html += '</div>';
  
  // Multi-sheet spanning plan: if qty exceeds any single sheet's capacity, show a plan
  const bestSingleRemaining = Math.max(0, ...matchingSheets.map(s => s.remaining), hasStock ? lps : 0);
  if (qty > bestSingleRemaining && qty > 0) {
    // Build a multi-sheet plan
    const plan = wf1BuildMultiSheetPlan(matchingSheets, lps, qty, hasStock, inv);
    if (plan.steps.length > 1) {
      wf1MultiSheetPlan = plan;
      html += '<div class="wf1-multisheet-plan">';
      html += '<div class="wf1-multisheet-title">ðŸ“‹ Multi-sheet print plan</div>';
      html += '<div style="font-size:12px;color:var(--text);margin-bottom:8px;">This job needs ' + qty + ' labels across ' + plan.steps.length + ' sheets:</div>';
      html += '<div class="wf1-multisheet-steps">';
      plan.steps.forEach(function(step, i) {
        const label = step.isNew ? 'âž• New sheet from stock' : escapeHtml(step.sheetName);
        html += '<div class="wf1-multisheet-step">' +
          '<div class="step-num">' + (i + 1) + '</div>' +
          '<div class="step-detail">' + label + '</div>' +
          '<div class="step-count">' + step.count + ' labels</div>' +
        '</div>';
      });
      html += '</div>';
      if (plan.newSheetsNeeded > 0) {
        html += '<div class="wf1-multisheet-note">Will use ' + plan.newSheetsNeeded + ' sheet' + (plan.newSheetsNeeded !== 1 ? 's' : '') + ' from inventory. You\'ll print one page at a time.</div>';
      }
      html += '</div>';
      // Auto-select the multi-sheet plan
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: plan };
    }
  }
  
  // "Can't find a sheet?" link for retiring lost sheets (G5)
  if (matchingSheets.length > 0) {
    html += '<div style="text-align:center;margin-top:10px;">' +
      '<button onclick="wf1ShowRetirePrompt()" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:12px;text-decoration:underline;">Can\'t find one of these sheets?</button>' +
    '</div>';
  }
  
  content.innerHTML = html;
  
  // Auto-select if only one option (and not multi-sheet)
  if (!wf1SelectedSheet) {
    if (matchingSheets.length === 1 && !hasStock) {
      wf1SelectSheet(matchingSheets[0].id);
    } else if (matchingSheets.length === 0) {
      wf1SelectSheet('__new__');
    }
  }
  
  document.getElementById('wf1SheetNextBtn').disabled = !wf1SelectedSheet;
}

// T3: Build orientation picker HTML for in-card display (only for multi-column labels)
function wf1BuildOrientationPicker(spec) {
  if (spec.cols < 2) return '';
  
  let html = '<div class="wf1-orientation-section" onclick="event.stopPropagation()">' +
    '<div class="wf1-orientation-label">Print order</div>' +
    '<div class="wf1-orientation-options">' +
      '<div class="wf1-orientation-opt' + (wf1Orientation === 'next' ? ' selected' : '') + '" onclick="event.stopPropagation(); wf1SetOrientation(\'next\')">' +
        '<div class="wf1-orientation-opt-icon">â†’</div>' +
        '<div class="wf1-orientation-opt-text">Row by row</div>' +
      '</div>';
  
  // Add a column option for each column in the label type
  for (let c = 1; c <= spec.cols; c++) {
    const colKey = 'col' + c;
    html += '<div class="wf1-orientation-opt' + (wf1Orientation === colKey ? ' selected' : '') + '" onclick="event.stopPropagation(); wf1SetOrientation(\'' + colKey + '\')">' +
      '<div class="wf1-orientation-opt-icon">â†“' + c + '</div>' +
      '<div class="wf1-orientation-opt-text">Col ' + c + ' first</div>' +
    '</div>';
  }
  
  html += '</div></div>';
  return html;
}

// T3: Set print orientation and re-render to update mini-grids
function wf1SetOrientation(orientation) {
  wf1Orientation = orientation;
  wf1RenderSheetPicker();
}

// G3: Print sheet ID label from the sheet picker
function wf1PrintIdLabel(sheetId) {
  printSheetLabel(sheetId);
  if (sheets[sheetId]) {
    sheets[sheetId].hasBackLabel = true;
    saveSheets();
  }
  showToast('Sheet ID label sent to printer', 'success');
  // Re-render to remove the "Print ID label" link
  wf1RenderSheetPicker();
}

function wf1SelectSheet(idOrNew) {
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec ? spec.cols * spec.rows : 30;
  const qty = wf1JobType === 'batch' ? (wf1BatchContent.length || wf1Quantity) : wf1Quantity;
  
  // Check if we're in mixed mode (picking sheet for remainder only)
  const isMixedMode = wf1MultiSheetPlan && wf1MultiSheetPlan.pendingRemainder > 0;
  
  if (isMixedMode && idOrNew !== '__new__' && idOrNew !== '__multi__') {
    // User picked an existing sheet for the remainder - complete the plan
    const sh = sheets[idOrNew];
    if (!sh) return;
    
    const remainder = wf1MultiSheetPlan.pendingRemainder;
    const sheetRemaining = getRemainingCount(sh);
    
    if (sheetRemaining < remainder) {
      showToast('This sheet only has ' + sheetRemaining + ' spots, need ' + remainder, 'warning');
      return;
    }
    
    // Add this sheet to the plan for the remainder
    wf1MultiSheetPlan.steps.push({
      sheetId: sh.id,
      sheetName: sh.name,
      count: remainder,
      isNew: false,
      remaining: sheetRemaining
    });
    delete wf1MultiSheetPlan.pendingRemainder; // Plan is complete
    
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
    wf1RenderSheetPicker();
    document.getElementById('wf1SheetNextBtn').disabled = false;
    return;
  }
  
  // Clear multi-sheet plan when user explicitly picks a single sheet (not in mixed mode)
  if (idOrNew !== '__multi__' && !isMixedMode) {
    wf1MultiSheetPlan = null;
  }
  
  if (idOrNew === '__new__') {
    // Check if batch needs multiple sheets
    if (wf1JobType === 'batch' && qty > lps) {
      const sheetsNeeded = Math.ceil(qty / lps);
      const inv = inventory[wf1LabelType];
      const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
      
      if (sheetsNeeded > stockAvail) {
        showToast('Not enough sheets in stock. Need ' + sheetsNeeded + ', have ' + stockAvail, 'warning');
        return;
      }
      
      // Build a multi-sheet plan using new sheets
      const steps = [];
      let remaining = qty;
      for (let i = 0; i < sheetsNeeded; i++) {
        const use = Math.min(lps, remaining);
        steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
        remaining -= use;
      }
      wf1MultiSheetPlan = { steps: steps, totalLabels: qty, newSheetsNeeded: sheetsNeeded, stockAvail: stockAvail };
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
      showToast('This job will use ' + sheetsNeeded + ' sheets from stock', 'info');
    } else {
      wf1SelectedSheet = { isNew: true, id: null };
    }
  } else if (idOrNew === '__multi__') {
    // Multi-sheet plan already set
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
  } else {
    // User selected a specific existing sheet
    const sh = sheets[idOrNew];
    const sheetRemaining = sh ? getRemainingCount(sh) : 0;
    
    // Check if batch job exceeds this sheet's capacity
    if (wf1JobType === 'batch' && qty > sheetRemaining) {
      // Build a multi-sheet plan starting with their selected sheet
      const matchingSheets = Object.values(sheets)
        .filter(function(s) { return s.labelType === wf1LabelType && !s.retired && s.id !== idOrNew; })
        .map(function(s) { return { id: s.id, name: s.name, remaining: getRemainingCount(s) }; })
        .filter(function(s) { return s.remaining > 0; });
      
      const inv = inventory[wf1LabelType];
      const hasStock = inv && inv.stock > 0;
      
      // Start plan with selected sheet
      const steps = [];
      let remaining = qty;
      
      if (sheetRemaining > 0) {
        steps.push({ sheetId: idOrNew, sheetName: sh.name, count: Math.min(sheetRemaining, remaining), isNew: false, remaining: sheetRemaining });
        remaining -= sheetRemaining;
      }
      
      // Add other existing sheets
      const sortedSheets = matchingSheets.slice().sort(function(a, b) { return b.remaining - a.remaining; });
      for (const other of sortedSheets) {
        if (remaining <= 0) break;
        const use = Math.min(other.remaining, remaining);
        if (use > 0) {
          steps.push({ sheetId: other.id, sheetName: other.name, count: use, isNew: false, remaining: other.remaining });
          remaining -= use;
        }
      }
      
      // Add new sheets from stock as needed
      let newSheetsNeeded = 0;
      while (remaining > 0) {
        const use = Math.min(lps, remaining);
        steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
        remaining -= use;
        newSheetsNeeded++;
      }
      
      // Check if we have enough stock
      const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
      if (newSheetsNeeded > stockAvail) {
        showToast('Not enough labels. Need ' + newSheetsNeeded + ' more sheet(s), have ' + stockAvail + ' in stock.', 'warning');
        return;
      }
      
      wf1MultiSheetPlan = { steps: steps, totalLabels: qty, newSheetsNeeded: newSheetsNeeded, stockAvail: stockAvail };
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
      showToast('Job spans ' + steps.length + ' sheet(s), starting with "' + sh.name + '"', 'info');
    } else {
      wf1SelectedSheet = { isNew: false, id: idOrNew };
    }
  }
  
  // Re-render to show orientation picker in selected card
  wf1RenderSheetPicker();
  
  document.getElementById('wf1SheetNextBtn').disabled = !wf1SelectedSheet;
}

// T1: Double-click to select sheet and advance
function wf1SelectSheetAndAdvance(idOrNew) {
  wf1SelectSheet(idOrNew);
  setTimeout(() => wf1ToStep6(), 100);
}

// G5: "Can't find this sheet?" â€” retire directly from workflow
async function wf1ShowRetirePrompt() {
  const matchingSheets = Object.values(sheets)
    .filter(function(s) { return s.labelType === wf1LabelType && !s.retired && getRemainingCount(s) > 0; });
  
  if (matchingSheets.length === 0) return;
  
  let pickHtml = '<p style="margin-bottom:12px;">Select the sheet you can\'t find. It will be retired (hidden from print workflows) but not deleted â€” you can restore it later from the Sheets tab.</p>';
  matchingSheets.forEach(function(sh) {
    pickHtml += '<button onclick="wf1RetireFromPicker(\'' + sh.id + '\')" style="display:block;width:100%;text-align:left;padding:10px 12px;margin-bottom:6px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-sm);cursor:pointer;color:var(--text);font-size:13px;">' +
      '<strong>' + escapeHtml(sh.name) + '</strong> â€” ' + getRemainingCount(sh) + ' spots remaining' +
    '</button>';
  });
  
  showGenericModal('Can\'t Find a Sheet?', pickHtml, 'retireFromWfModal');
}

function wf1RetireFromPicker(id) {
  closeGenericModal('retireFromWfModal');
  retireSheet(id);
  // Re-render the sheet picker with updated list
  wf1RenderSheetPicker();
}

// ---- STEP 6: Content Creation ----

function wf1ToStep6() {
  if (!wf1SelectedSheet) return;
  
  wf1Step = 6;
  wf1RenderContentStep();
  wf1ShowStep('wf1Step6');
  
  // Check if AI conversational layer has pending content to fill
  setTimeout(function() { aiConvFillContentIfPending(); }, 150);
}

// WF1 batch state
let wf1BatchCsvData = [];
let wf1BatchCsvColumns = [];
let wf1BatchSelectedTemplate = null;
let wf1BatchColumnMap = {};
let wf1BatchSubStep = 'upload'; // 'upload' | 'template' | 'map' | 'preview'

function wf1RenderContentStep() {
  const area = document.getElementById('wf1ContentArea');
  const actions = document.getElementById('wf1Step6Actions');
  
  if (wf1JobType === 'individual') {
    wf1RenderIndividualEditor(area);
    actions.style.display = 'flex';
  } else {
    // Batch â€” CSV is already loaded from Step 3B, go straight to template selection
    if (wf1BatchCsvData.length > 0) {
      wf1BatchSubStep = 'template';
      wf1RenderBatchTemplateStep();
    } else {
      // Fallback: if somehow we got here without data, show upload
      wf1BatchSubStep = 'upload';
      wf1RenderBatchUpload(area);
    }
    actions.style.display = 'flex';
    document.getElementById('wf1ContentNextBtn').disabled = true;
  }
}

function wf1RenderIndividualEditor(area) {
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'What should the labels say?';
  
  let html = '<div class="wf1-editor-wrapper">';
  
  // Tool buttons
  html += '<div class="wf1-editor-tools">';
  if (typeof openAIGenerate === 'function' && localStorage.getItem('lk_ai_key')) {
    html += '<button class="wf1-editor-tool-btn" onclick="wf1UseAI()">âœ¨ Ask AI</button>';
  }
  html += '<button class="wf1-editor-tool-btn" onclick="wf1UseSaved()">ðŸ“‚ Use Saved</button>';
  html += '<button class="wf1-editor-tool-btn" onclick="wf1UseFullEditor()">ðŸŽ¨ Full Editor</button>';
  html += '<button class="wf1-editor-tool-btn" onclick="openOcrModal()">ðŸ“· Scan</button>';
  html += '</div>';
  
  // 4-line editor
  html += '<div class="editor-lines">';
  for (let i = 1; i <= 4; i++) {
    const placeholder = i === 1 ? 'Line 1' : 'Line ' + i + ' (optional)';
    html += '<div class="editor-line">' +
      '<input type="text" class="editor-line-input" id="wf1Line' + i + '" placeholder="' + placeholder + '" maxlength="100" oninput="wf1UpdateEditorPreview()" onpaste="setTimeout(wf1UpdateEditorPreview,0)">' +
      '<div class="editor-controls">' +
        '<button class="editor-align-btn active" data-wf1line="' + i + '" data-align="left" onclick="wf1SetAlign(' + i + ',\'left\')" title="Left">â—€</button>' +
        '<button class="editor-align-btn" data-wf1line="' + i + '" data-align="center" onclick="wf1SetAlign(' + i + ',\'center\')" title="Center">â—†</button>' +
        '<button class="editor-align-btn" data-wf1line="' + i + '" data-align="right" onclick="wf1SetAlign(' + i + ',\'right\')" title="Right">â–¶</button>' +
        '<button class="editor-size-btn size-s" data-wf1line="' + i + '" data-size="9" onclick="wf1SetSize(' + i + ',9)" title="Small">A</button>' +
        '<button class="editor-size-btn size-m active" data-wf1line="' + i + '" data-size="11" onclick="wf1SetSize(' + i + ',11)" title="Medium">A</button>' +
        '<button class="editor-size-btn size-l" data-wf1line="' + i + '" data-size="14" onclick="wf1SetSize(' + i + ',14)" title="Large">A</button>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  
  // Preview
  html += '<div class="editor-preview-section">' +
    '<div class="editor-preview-label">Preview</div>' +
    '<div class="editor-preview-frame">' +
      '<div class="editor-preview-label-box" id="wf1PreviewBox">' +
        '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>' +
      '</div>' +
    '</div>' +
  '</div>';
  
  html += '</div>';
  area.innerHTML = html;
  
  // If we already have content lines (from AI, saved, full editor), populate them
  if (wf1ContentLines.length > 0) {
    wf1PopulateEditorFromLines(wf1ContentLines);
  }
  
  // Set up paste listeners on the WF1 editor inputs
  setTimeout(function() {
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('wf1Line' + i);
      if (input) {
        input.addEventListener('paste', function(e) {
          setTimeout(function() { wf1HandlePaste(); }, 50);
        });
      }
    }
  }, 100);
  
  wf1UpdateContentNextBtn();
}

// WF1 editor alignment/size state
let wf1LineAligns = ['left', 'left', 'left', 'left'];
let wf1LineSizes = [11, 11, 11, 11];

function wf1SetAlign(lineNum, align) {
  wf1LineAligns[lineNum - 1] = align;
  // Update button states
  document.querySelectorAll('.editor-align-btn[data-wf1line="' + lineNum + '"]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  wf1UpdateEditorPreview();
}

function wf1SetSize(lineNum, size) {
  wf1LineSizes[lineNum - 1] = size;
  document.querySelectorAll('.editor-size-btn[data-wf1line="' + lineNum + '"]').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
  });
  wf1UpdateEditorPreview();
}

function wf1UpdateEditorPreview() {
  const box = document.getElementById('wf1PreviewBox');
  if (!box) return;
  
  let hasContent = false;
  let html = '';
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wf1Line' + i);
    if (!input) continue;
    const text = input.value.trim();
    if (!text) continue;
    hasContent = true;
    
    const align = wf1LineAligns[i - 1];
    const size = wf1LineSizes[i - 1];
    const parsed = parseLine(text);
    
    if (parsed.type === 'fill') {
      html += '<div class="preview-line align-left" style="font-size:' + size + 'px;">' + escapeHtml(parsed.label) + ' ___________</div>';
    } else if (parsed.type === 'split') {
      html += '<div class="preview-line align-split" style="font-size:' + size + 'px; display:flex; justify-content:space-between;">' +
        '<span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
    } else {
      html += '<div class="preview-line align-' + align + '" style="font-size:' + size + 'px; text-align:' + align + ';">' + escapeHtml(text) + '</div>';
    }
  }
  
  if (!hasContent) {
    html = '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>';
  }
  
  // Show rich formatting badge if Full Editor snapshot has advanced styles AND text still matches
  if (hasContent && wf1FeSnapshot) {
    let anyRichPreserved = false;
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('wf1Line' + i);
      const snap = wf1FeSnapshot.lines[i - 1];
      if (input && snap && input.value === snap.text && input.value.trim()) {
        if (snap.bold || snap.italic || snap.underline || snap.strikethrough || snap.color || snap.fillColor || snap.borders) {
          anyRichPreserved = true;
          break;
        }
      }
    }
    const hasGfx = wf1FeSnapshot.graphics && (wf1FeSnapshot.graphics.left || wf1FeSnapshot.graphics.right);
    const hasBorder = wf1FeSnapshot.border && (wf1FeSnapshot.border.top || wf1FeSnapshot.border.bottom || wf1FeSnapshot.border.left || wf1FeSnapshot.border.right);
    if (anyRichPreserved || hasGfx || hasBorder) {
      html += '<div class="wf1-rich-badge">ðŸŽ¨ Rich formatting from Full Editor will be applied when printed</div>';
    }
  }
  
  box.innerHTML = html;
  
  wf1UpdateContentNextBtn();
}

function wf1GetEditorLines() {
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wf1Line' + i);
    if (!input) continue;
    const text = input.value;
    if (text.trim()) {
      // If we have a Full Editor snapshot and this line's text hasn't changed,
      // preserve the rich styles (bold, italic, color, etc.) from the snapshot
      const snap = wf1FeSnapshot && wf1FeSnapshot.lines[i - 1];
      if (snap && snap.text === text) {
        lines.push({
          text: text,
          align: wf1LineAligns[i - 1],
          fontSize: wf1LineSizes[i - 1],
          bold: snap.bold || false,
          italic: snap.italic || false,
          underline: snap.underline || false,
          strikethrough: snap.strikethrough || false,
          color: snap.color || '',
          fillColor: snap.fillColor || '',
          borders: snap.borders || ''
        });
      } else {
        lines.push({
          text: text,
          align: wf1LineAligns[i - 1],
          fontSize: wf1LineSizes[i - 1],
          bold: false, italic: false, underline: false, strikethrough: false,
          color: '', fillColor: '', borders: ''
        });
      }
    }
  }
  return lines;
}

function wf1PopulateEditorFromLines(lines) {
  // Reset aligns/sizes
  wf1LineAligns = ['left', 'left', 'left', 'left'];
  wf1LineSizes = [11, 11, 11, 11];
  
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('wf1Line' + (i + 1));
    if (!input) continue;
    if (i < lines.length) {
      input.value = lines[i].text || '';
      wf1LineAligns[i] = lines[i].align || 'left';
      wf1LineSizes[i] = lines[i].fontSize || 11;
    } else {
      input.value = '';
    }
    
    // Update button states
    document.querySelectorAll('.editor-align-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === wf1LineAligns[i]);
    });
    document.querySelectorAll('.editor-size-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
      btn.classList.toggle('active', parseInt(btn.dataset.size) === wf1LineSizes[i]);
    });
  }
  wf1UpdateEditorPreview();
}

function wf1HandlePaste() {
  // Check if pasted content is LabelKeeper format
  const line1 = document.getElementById('wf1Line1');
  if (!line1) return;
  const text = line1.value;
  const parsed = parseLabelKeeperFormat(text);
  if (parsed && parsed.lines) {
    wf1ContentLines = parsed.lines;
    if (parsed.qty) wf1Quantity = parsed.qty;
    if (parsed.type) wf1LabelType = parsed.type;
    wf1PopulateEditorFromLines(wf1ContentLines);
    showToast('LabelKeeper content pasted!', 'success');
  }
}

function wf1UpdateContentNextBtn() {
  const btn = document.getElementById('wf1ContentNextBtn');
  if (!btn) return;
  
  if (wf1JobType === 'individual') {
    const lines = wf1GetEditorLines();
    btn.disabled = lines.length === 0;
  } else {
    btn.disabled = wf1BatchContent.length === 0;
  }
}

// Tool buttons for individual editor
function wf1UseAI() {
  // Use the existing AI generate flow â€” it populates wizLine1-4
  // We need to bridge: AI writes to wizLine1-4, we read from wf1Line1-4
  // Simplest: temporarily wire AI to write to wf1Line inputs
  wf1_aiActive = true;
  openAIGenerate();
}

let wf1_aiActive = false;

function wf1UseSaved() {
  // Show a quick picker modal of saved texts
  const savedList = savedTexts.filter(t => t.type !== 'template');
  if (savedList.length === 0) {
    showToast('No saved content yet', 'info');
    return;
  }
  
  let html = '<div style="max-height:300px; overflow-y:auto;">';
  for (const t of savedList) {
    const lines = deserializeLines(t.text);
    const preview = lines.map(l => l.text).join(' Â· ');
    html += '<div class="wf1-batch-template-item" onclick="wf1LoadSaved(\'' + t.id + '\'); closeGenericModal(\'wf1UseSavedModal\');">' +
      '<div class="wf1-batch-template-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="wf1-batch-template-preview">' + escapeHtml(preview.substring(0, 60)) + '</div>' +
    '</div>';
  }
  html += '</div>';
  
  showGenericModal('ðŸ“‚ Choose Saved Content', html, 'wf1UseSavedModal');
}

function wf1LoadSaved(textId) {
  const t = savedTexts.find(s => s.id === textId);
  if (!t) return;
  wf1ContentLines = deserializeLines(t.text);
  wf1SelectedSavedTextId = textId;
  wf1PopulateEditorFromLines(wf1ContentLines);
  // Close the confirm dialog if open
  const modal = document.getElementById('confirmModal');
  if (modal) modal.style.display = 'none';
  showToast('Loaded: ' + t.name, 'success');
}

let wf1SelectedSavedTextId = null;

function wf1UseFullEditor() {
  // Populate the classic wizard inputs first so Full Editor can read them
  for (let i = 1; i <= 4; i++) {
    const wf1Input = document.getElementById('wf1Line' + i);
    const wizInput = document.getElementById('wizLine' + i);
    if (wf1Input && wizInput) {
      wizInput.value = wf1Input.value;
    }
  }
  
  // Flag that we're coming from WF1
  wf1_fullEditorActive = true;
  openFullEditorFromWizard();
}

let wf1_fullEditorActive = false;

// ---- BATCH PATH (Step 6) ----

function wf1RenderBatchUpload(area) {
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Import your list';
  
  let html = '<div class="wf1-batch-section">' +
    '<div class="wf1-batch-upload" onclick="document.getElementById(\'wf1BatchFileInput\').click()">' +
      '<div class="wf1-batch-upload-icon">ðŸ“</div>' +
      '<div class="wf1-batch-upload-text">Click to upload a CSV or TSV file</div>' +
    '</div>' +
  '</div>';
  
  // Also offer paste
  html += '<div style="text-align:center; font-size:12px; color:var(--text-muted); margin: 8px 0;">â€” or â€”</div>';
  html += '<div class="wf1-batch-section">' +
    '<textarea id="wf1BatchPasteArea" placeholder="Paste your data here (tab-separated or comma-separated)" ' +
    'style="width:100%; min-height:80px; padding:10px; border:2px solid var(--border); border-radius:var(--radius-sm); font-family:inherit; font-size:13px; resize:vertical; background:var(--surface); color:var(--text); box-sizing:border-box;" ' +
    'onchange="wf1HandleBatchPaste()"></textarea>' +
    '<button class="wf1-inv-btn" style="margin-top:8px;" onclick="wf1HandleBatchPaste()">Parse pasted data</button>' +
  '</div>';
  
  if (area) area.innerHTML = html;
}

function wf1HandleBatchFile(fileOrInput) {
  // Accept either a File object or an input element
  const file = fileOrInput instanceof File ? fileOrInput : (fileOrInput.files ? fileOrInput.files[0] : null);
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    wf1ParseBatchData(e.target.result, file.name);
  };
  reader.readAsText(file);
}

function wf1HandleBatchPaste() {
  const textarea = document.getElementById('wf1BatchPasteArea');
  if (!textarea) return;
  const text = textarea.value.trim();
  if (!text) { showToast('Nothing to parse', 'warning'); return; }
  wf1ParseBatchData(text, 'pasted data');
}

// Parse a single CSV/TSV line with support for quoted fields
function parseCSVLine(line, delimiter) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (ch === delimiter && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += ch;
    }
  }
  result.push(current);
  return result;
}

function wf1ParseBatchData(text, sourceName) {
  // Detect delimiter
  const firstLine = text.split('\n')[0];
  const tabCount = (firstLine.match(/\t/g) || []).length;
  const commaCount = (firstLine.match(/,/g) || []).length;
  const delimiter = tabCount > commaCount ? '\t' : ',';
  
  const lines = text.trim().split('\n').filter(l => l.trim());
  if (lines.length < 2) {
    showToast('Need at least a header row and one data row', 'warning');
    return;
  }
  
  // Parse header
  const header = parseCSVLine(lines[0], delimiter);
  wf1BatchCsvColumns = header.map(h => h.trim());
  
  // Parse data rows
  wf1BatchCsvData = [];
  for (let i = 1; i < lines.length; i++) {
    const vals = parseCSVLine(lines[i], delimiter);
    const record = {};
    for (let c = 0; c < wf1BatchCsvColumns.length; c++) {
      record[wf1BatchCsvColumns[c]] = (vals[c] || '').trim();
    }
    wf1BatchCsvData.push(record);
  }
  
  showToast('Parsed ' + wf1BatchCsvData.length + ' rows from ' + sourceName, 'success');
  wf1Quantity = wf1BatchCsvData.length;
  
  // If we're in Step 3B (early batch flow), show success and proceed button
  if (wf1BatchSubStep === 'upload') {
    wf1ShowBatchLoadedSuccess();
  } else {
    // Old flow (if called from step 6) - go to template
    wf1BatchSubStep = 'template';
    wf1RenderBatchTemplateStep();
  }
}

// Show success message after CSV loaded in Step 3B
function wf1ShowBatchLoadedSuccess() {
  const contentArea = document.getElementById('wf1Step3Content');
  if (!contentArea) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const totalNeeded = wf1BatchCsvData.length;
  const fullSheetsNeeded = Math.floor(totalNeeded / lps);
  const remainder = totalNeeded % lps;
  const totalSheetsNeeded = remainder > 0 ? fullSheetsNeeded + 1 : fullSheetsNeeded;
  const leftoverOnLastSheet = remainder > 0 ? lps - remainder : 0;
  
  // Check inventory
  const inv = inventory[wf1LabelType];
  const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
  
  // Check existing sheets with space
  const existingSheets = Object.values(sheets)
    .filter(s => s.labelType === wf1LabelType && !s.retired)
    .map(s => ({ id: s.id, name: s.name, remaining: getRemainingCount(s) }))
    .filter(s => s.remaining > 0)
    .sort((a, b) => b.remaining - a.remaining);
  
  const spotsOnExisting = existingSheets.reduce((sum, s) => sum + s.remaining, 0);
  const totalAvailable = (stockAvail * lps) + spotsOnExisting;
  
  // Update question
  const question = document.getElementById('wf1Step3Question');
  question.textContent = 'Plan your print job';
  
  let html = '<div class="wf1-batch-planning">';
  
  // Summary
  html += '<div class="wf1-plan-summary">';
  html += '<div class="wf1-plan-count">' + totalNeeded + ' labels</div>';
  html += '<div class="wf1-plan-detail">Columns: ' + wf1BatchCsvColumns.join(', ') + '</div>';
  html += '</div>';
  
  // Check if we can handle it at all
  if (totalAvailable < totalNeeded) {
    html += '<div class="wf1-plan-warning">';
    html += '<div class="wf1-feas-icon">âš ï¸</div>';
    html += '<div class="wf1-feas-msg">Not enough labels!</div>';
    html += '<div class="wf1-feas-detail">You need ' + totalNeeded + ' but only have ' + totalAvailable + ' available (' + stockAvail + ' sheets in stock + ' + spotsOnExisting + ' on existing sheets).</div>';
    html += '<button class="wf1-inv-btn" onclick="wf1ToStep3B()" style="margin-top:12px;">Load different file</button>';
    html += '</div>';
    contentArea.innerHTML = html + '</div>';
    return;
  }
  
  // Show planning options
  html += '<div class="wf1-plan-options">';
  
  // Option A: All new sheets from stock (if we have enough)
  if (stockAvail >= totalSheetsNeeded) {
    html += '<div class="wf1-plan-option" onclick="wf1SelectPlanOption(\'allnew\')">';
    html += '<div class="wf1-plan-option-icon">ðŸ“¦</div>';
    html += '<div class="wf1-plan-option-content">';
    html += '<div class="wf1-plan-option-title">Use ' + totalSheetsNeeded + ' new sheet' + (totalSheetsNeeded !== 1 ? 's' : '') + ' from stock</div>';
    html += '<div class="wf1-plan-option-desc">';
    if (leftoverOnLastSheet > 0) {
      html += 'Last sheet will have ' + leftoverOnLastSheet + ' unused spot' + (leftoverOnLastSheet !== 1 ? 's' : '');
    } else {
      html += 'Sheets will be completely filled';
    }
    html += '</div></div></div>';
  }
  
  // Option B: Mix of new + existing (if we have existing sheets and remainder fits)
  if (existingSheets.length > 0 && remainder > 0 && stockAvail >= fullSheetsNeeded) {
    // Find sheets that could fit the remainder
    const fittingSheets = existingSheets.filter(s => s.remaining >= remainder);
    
    if (fittingSheets.length > 0) {
      html += '<div class="wf1-plan-option" onclick="wf1SelectPlanOption(\'mixed\')">';
      html += '<div class="wf1-plan-option-icon">ðŸ”€</div>';
      html += '<div class="wf1-plan-option-content">';
      html += '<div class="wf1-plan-option-title">Use ' + fullSheetsNeeded + ' new sheet' + (fullSheetsNeeded !== 1 ? 's' : '') + ' + existing sheet</div>';
      html += '<div class="wf1-plan-option-desc">Put remaining ' + remainder + ' labels on a sheet you already have (' + fittingSheets.length + ' sheet' + (fittingSheets.length !== 1 ? 's' : '') + ' can fit)</div>';
      html += '</div></div>';
    }
  }
  
  // Option C: Use only existing sheets (if they have enough capacity)
  if (spotsOnExisting >= totalNeeded) {
    html += '<div class="wf1-plan-option" onclick="wf1SelectPlanOption(\'existing\')">';
    html += '<div class="wf1-plan-option-icon">ðŸ“„</div>';
    html += '<div class="wf1-plan-option-content">';
    html += '<div class="wf1-plan-option-title">Use existing sheets only</div>';
    html += '<div class="wf1-plan-option-desc">You have ' + spotsOnExisting + ' spots across ' + existingSheets.length + ' sheet' + (existingSheets.length !== 1 ? 's' : '') + '</div>';
    html += '</div></div>';
  }
  
  // Option D: Let me pick (always available)
  html += '<div class="wf1-plan-option" onclick="wf1SelectPlanOption(\'manual\')">';
  html += '<div class="wf1-plan-option-icon">âœ‹</div>';
  html += '<div class="wf1-plan-option-content">';
  html += '<div class="wf1-plan-option-title">Let me choose sheets</div>';
  html += '<div class="wf1-plan-option-desc">Pick exactly which sheets to use</div>';
  html += '</div></div>';
  
  html += '</div>'; // end options
  
  // Load different file link
  html += '<div style="text-align:center;margin-top:16px;">';
  html += '<button class="wf1-inv-btn" onclick="wf1ToStep3B()">â† Load different file</button>';
  html += '</div>';
  
  html += '</div>'; // end planning
  
  contentArea.innerHTML = html;
}

// Handle plan option selection
function wf1SelectPlanOption(option) {
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const totalNeeded = wf1BatchCsvData.length;
  const fullSheetsNeeded = Math.floor(totalNeeded / lps);
  const remainder = totalNeeded % lps;
  const totalSheetsNeeded = remainder > 0 ? fullSheetsNeeded + 1 : fullSheetsNeeded;
  
  if (option === 'allnew') {
    // Build plan using all new sheets
    const steps = [];
    let remaining = totalNeeded;
    for (let i = 0; i < totalSheetsNeeded; i++) {
      const use = Math.min(lps, remaining);
      steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
      remaining -= use;
    }
    wf1MultiSheetPlan = { steps: steps, totalLabels: totalNeeded, newSheetsNeeded: totalSheetsNeeded };
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
    
    // Skip sheet picker, go directly to template/mapping (Step 6)
    wf1ToStep6();
    
  } else if (option === 'mixed') {
    // Use new sheets for full sheets, then pick existing for remainder
    // Build partial plan, user will pick the existing sheet
    const steps = [];
    for (let i = 0; i < fullSheetsNeeded; i++) {
      steps.push({ sheetId: null, sheetName: null, count: lps, isNew: true, remaining: lps });
    }
    // Store partial plan, let user pick the final sheet
    wf1MultiSheetPlan = { steps: steps, totalLabels: totalNeeded, newSheetsNeeded: fullSheetsNeeded, pendingRemainder: remainder };
    wf1ToStep5(); // Go to sheet picker to select the existing sheet for remainder
    
  } else if (option === 'existing') {
    // Go to sheet picker, system will build plan from existing sheets only
    wf1MultiSheetPlan = null;
    wf1ToStep5();
    
  } else {
    // manual - go to sheet picker with no preset plan
    wf1MultiSheetPlan = null;
    wf1ToStep5();
  }
}

function wf1RenderBatchTemplateStep() {
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Choose a template for your labels';
  
  // Find templates that match the label type or are generic
  const templates = savedTexts.filter(t => t.type === 'template');
  
  // Auto-detect best template based on CSV columns
  const bestTemplate = wf1DetectBestTemplate(wf1BatchCsvColumns, templates);
  
  let html = '<div class="wf1-batch-status success">' +
    'âœ… ' + wf1BatchCsvData.length + ' rows loaded. Columns: ' + wf1BatchCsvColumns.join(', ') +
  '</div>';
  
  html += '<div class="wf1-batch-section" style="margin-top:16px;">';
  html += '<div class="wf1-batch-section-title">Select a template</div>';
  html += '<div class="wf1-batch-template-list">';
  
  // Built-in address template
  const addressMatch = bestTemplate === '__address__' ? ' style="border-color:var(--accent);background:var(--accent-light,rgba(99,102,241,0.1));"' : '';
  html += '<div class="wf1-batch-template-item"' + addressMatch + ' onclick="wf1SelectBatchTemplate(\'__address__\')">' +
    '<div class="wf1-batch-template-name">ðŸ“¬ Standard Address' + (bestTemplate === '__address__' ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
    '<div class="wf1-batch-template-preview">{name} Â· {address} Â· {city}, {state} {zip}</div>' +
  '</div>';
  
  // Built-in name tag template
  const nametagMatch = bestTemplate === '__nametag__' ? ' style="border-color:var(--accent);background:var(--accent-light,rgba(99,102,241,0.1));"' : '';
  html += '<div class="wf1-batch-template-item"' + nametagMatch + ' onclick="wf1SelectBatchTemplate(\'__nametag__\')">' +
    '<div class="wf1-batch-template-name">ðŸ‘‹ Name Tag' + (bestTemplate === '__nametag__' ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
    '<div class="wf1-batch-template-preview">{name} Â· {title}</div>' +
  '</div>';
  
  // User templates
  for (const t of templates) {
    const lines = deserializeLines(t.text);
    const preview = lines.map(l => l.text).join(' Â· ');
    const isMatch = bestTemplate === t.id ? ' style="border-color:var(--accent);background:var(--accent-light,rgba(99,102,241,0.1));"' : '';
    html += '<div class="wf1-batch-template-item"' + isMatch + ' onclick="wf1SelectBatchTemplate(\'' + t.id + '\')">' +
      '<div class="wf1-batch-template-name">' + escapeHtml(t.name) + (bestTemplate === t.id ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
      '<div class="wf1-batch-template-preview">' + escapeHtml(preview.substring(0, 80)) + '</div>' +
    '</div>';
  }
  
  html += '</div></div>';
  area.innerHTML = html;
  document.getElementById('wf1ContentNextBtn').disabled = true;
  
  // If we have a clear best match, auto-select it after a short delay
  if (bestTemplate) {
    setTimeout(function() {
      wf1SelectBatchTemplate(bestTemplate);
    }, 500);
  }
}

// Detect the best template based on CSV column names
function wf1DetectBestTemplate(columns, userTemplates) {
  const colsLower = columns.map(c => c.toLowerCase().trim());
  
  // Address template tokens and aliases
  const addressTokens = {
    'name': ['name', 'full name', 'recipient', 'contact'],
    'address': ['address', 'street', 'street address', 'addr'],
    'city': ['city', 'town'],
    'state': ['state', 'province', 'st'],
    'zip': ['zip', 'zipcode', 'postal', 'postal code', 'postcode']
  };
  
  // Name tag tokens
  const nametagTokens = {
    'name': ['name', 'full name', 'guest', 'attendee'],
    'title': ['title', 'position', 'role', 'job title', 'company']
  };
  
  // Score each template
  let bestId = null;
  let bestScore = 0;
  
  // Score address template
  let addressScore = 0;
  for (const [token, aliases] of Object.entries(addressTokens)) {
    if (colsLower.some(c => aliases.includes(c) || aliases.some(a => c.includes(a)))) {
      addressScore++;
    }
  }
  if (addressScore >= 3) { // Need at least name + address + city to be confident
    if (addressScore > bestScore) {
      bestScore = addressScore;
      bestId = '__address__';
    }
  }
  
  // Score name tag template
  let nametagScore = 0;
  for (const [token, aliases] of Object.entries(nametagTokens)) {
    if (colsLower.some(c => aliases.includes(c) || aliases.some(a => c.includes(a)))) {
      nametagScore++;
    }
  }
  if (nametagScore === 2) { // Need both name and title
    if (nametagScore > bestScore || (nametagScore === bestScore && addressScore < 3)) {
      bestScore = nametagScore;
      bestId = '__nametag__';
    }
  }
  
  // Score user templates
  for (const t of userTemplates) {
    const tokens = extractTokens(t.text);
    let score = 0;
    for (const token of tokens) {
      const tokenLower = token.toLowerCase();
      if (colsLower.some(c => c === tokenLower || c.includes(tokenLower) || tokenLower.includes(c))) {
        score++;
      }
    }
    // Prefer templates where most tokens match
    const matchRatio = tokens.length > 0 ? score / tokens.length : 0;
    if (matchRatio >= 0.5 && score > bestScore) {
      bestScore = score;
      bestId = t.id;
    }
  }
  
  return bestId;
}

function wf1SelectBatchTemplate(templateId) {
  // Resolve template
  if (templateId === '__address__') {
    wf1BatchSelectedTemplate = {
      text: '{name}\n{address}\n{city}, {state} {zip}',
      lines: [
        { text: '{name}', align: 'left', fontSize: 11 },
        { text: '{address}', align: 'left', fontSize: 11 },
        { text: '{city}, {state} {zip}', align: 'left', fontSize: 11 }
      ],
      tokens: ['name', 'address', 'city', 'state', 'zip']
    };
  } else if (templateId === '__nametag__') {
    wf1BatchSelectedTemplate = {
      text: '{name}\n{title}',
      lines: [
        { text: '{name}', align: 'center', fontSize: 14 },
        { text: '{title}', align: 'center', fontSize: 11 }
      ],
      tokens: ['name', 'title']
    };
  } else {
    const t = savedTexts.find(s => s.id === templateId);
    if (!t) return;
    const lines = deserializeLines(t.text);
    const tokens = extractTokens(t.text);
    wf1BatchSelectedTemplate = { text: t.text, lines, tokens };
  }
  
  // Highlight selected
  document.querySelectorAll('.wf1-batch-template-item').forEach(item => {
    item.classList.remove('selected');
  });
  event.currentTarget.classList.add('selected');
  
  // Auto-map columns to tokens (returns token->column object)
  wf1BatchColumnMap = wf1AutoMapColumnsToTokens(wf1BatchCsvColumns, wf1BatchSelectedTemplate.tokens);
  
  wf1BatchSubStep = 'map';
  setTimeout(function() { wf1RenderBatchMapStep(); }, 200);
}

// Auto-map CSV columns to template tokens, returning {token: column} object
function wf1AutoMapColumnsToTokens(columns, tokens) {
  const mapping = {};
  const usedColumns = new Set();
  
  // Expanded aliases for better matching
  const aliases = {
    'name': ['name', 'full name', 'fullname', 'full_name', 'student name', 'student_name', 'guest', 'guest name', 'recipient', 'contact'],
    'address': ['address', 'street', 'street address', 'address1', 'address_1', 'street_address', 'addr', 'mailing address'],
    'city': ['city', 'town', 'municipality'],
    'state': ['state', 'province', 'region', 'st'],
    'zip': ['zip', 'zip code', 'zipcode', 'postal', 'postal code', 'postal_code', 'postcode'],
    'title': ['title', 'job title', 'position', 'role'],
    'company': ['company', 'organization', 'org', 'employer', 'business'],
    'phone': ['phone', 'telephone', 'tel', 'mobile', 'cell', 'phone number'],
    'email': ['email', 'email address', 'e-mail'],
    'first_name': ['first name', 'first', 'fname', 'given name', 'given_name', 'firstname'],
    'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name', 'lastname']
  };
  
  for (const token of tokens) {
    const tokenLower = token.toLowerCase().replace(/_/g, ' ');
    const tokenAliases = aliases[token] || [tokenLower];
    
    // Try to find a matching column
    for (const col of columns) {
      if (usedColumns.has(col)) continue;
      const colLower = col.toLowerCase().trim();
      
      // Exact match
      if (colLower === tokenLower || colLower === token) {
        mapping[token] = col;
        usedColumns.add(col);
        break;
      }
      
      // Alias match
      if (tokenAliases.some(a => a === colLower || colLower.includes(a) || a.includes(colLower))) {
        mapping[token] = col;
        usedColumns.add(col);
        break;
      }
    }
  }
  
  return mapping;
}

function wf1RenderBatchMapStep() {
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Map your columns to the template';
  
  let html = '<div class="wf1-batch-mapping">';
  
  for (const token of wf1BatchSelectedTemplate.tokens) {
    html += '<div class="wf1-batch-map-row">' +
      '<label>{' + token + '}</label>' +
      '<select onchange="wf1UpdateBatchMap(\'' + token + '\', this.value)">';
    
    html += '<option value="">â€” skip â€”</option>';
    for (const col of wf1BatchCsvColumns) {
      const selected = wf1BatchColumnMap[token] === col ? ' selected' : '';
      html += '<option value="' + escapeHtml(col) + '"' + selected + '>' + escapeHtml(col) + '</option>';
    }
    html += '</select></div>';
  }
  
  html += '</div>';
  
  // Preview button
  html += '<div style="margin-top:16px; text-align:center;">' +
    '<button class="wf1-inv-btn primary" onclick="wf1RenderBatchPreview()">Preview labels â†’</button>' +
    '<button class="wf1-inv-btn" onclick="wf1BatchSubStep=\'template\'; wf1RenderBatchTemplateStep();" style="margin-left:8px;">Change template</button>' +
  '</div>';
  
  area.innerHTML = html;
}

function wf1UpdateBatchMap(token, col) {
  if (col) {
    wf1BatchColumnMap[token] = col;
  } else {
    delete wf1BatchColumnMap[token];
  }
}

function wf1RenderBatchPreview() {
  // Build batch content from CSV + template + mapping
  wf1BatchContent = [];
  
  for (const record of wf1BatchCsvData) {
    const lines = [];
    for (const tl of wf1BatchSelectedTemplate.lines) {
      let text = tl.text;
      text = text.replace(/\{([a-z][a-z0-9_]*)\}/gi, function(match, token) {
        const key = token.toLowerCase();
        const mappedCol = wf1BatchColumnMap[key];
        if (mappedCol && record[mappedCol]) {
          return record[mappedCol];
        }
        return '';
      });
      if (text.trim()) {
        lines.push({ ...tl, text: text });
      }
    }
    if (lines.length > 0) {
      wf1BatchContent.push(lines);
    }
  }
  
  wf1Quantity = wf1BatchContent.length;
  wf1BatchSubStep = 'preview';
  
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Preview your labels';
  
  let html = '<div class="wf1-batch-preview-count">' + wf1BatchContent.length + ' label' + (wf1BatchContent.length !== 1 ? 's' : '') + ' from your list</div>';
  html += '<div class="wf1-batch-preview-scroll">';
  
  const showCount = Math.min(wf1BatchContent.length, 10);
  for (let i = 0; i < showCount; i++) {
    html += '<div class="wf1-batch-preview-label">';
    for (const line of wf1BatchContent[i]) {
      html += '<div style="text-align:' + (line.align || 'left') + '; font-size:' + (line.fontSize || 11) + 'px;">' + escapeHtml(line.text) + '</div>';
    }
    html += '</div>';
  }
  if (wf1BatchContent.length > showCount) {
    html += '<div style="font-size:12px; color:var(--text-muted); text-align:center; padding:8px;">...and ' + (wf1BatchContent.length - showCount) + ' more</div>';
  }
  html += '</div>';
  
  // Edit mapping button
  html += '<div style="margin-top:12px; text-align:center;">' +
    '<button class="wf1-inv-btn" onclick="wf1BatchSubStep=\'map\'; wf1RenderBatchMapStep();">Edit mapping</button>' +
  '</div>';
  
  area.innerHTML = html;
  
  document.getElementById('wf1ContentNextBtn').disabled = wf1BatchContent.length === 0;
}

// ---- STEP 7: Preview & Print ----

function wf1ToStep7() {
  if (wf1JobType === 'individual') {
    wf1ContentLines = wf1GetEditorLines();
    if (wf1ContentLines.length === 0) {
      showToast('Enter some text first', 'warning');
      return;
    }
  } else {
    if (wf1BatchContent.length === 0) {
      showToast('No batch content to print', 'warning');
      return;
    }
  }
  
  wf1Step = 7;
  wf1RenderPreview();
  wf1ShowStep('wf1Step7');
}

function wf1RenderPreview() {
  const content = document.getElementById('wf1PreviewContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const qty = wf1JobType === 'batch' ? wf1BatchContent.length : wf1Quantity;
  
  // Sheet info
  let sheetName = 'New sheet';
  let sheetHasBackLabel = false;
  if (wf1SelectedSheet && !wf1SelectedSheet.isNew) {
    const sh = sheets[wf1SelectedSheet.id];
    if (sh) {
      sheetName = sh.name;
      sheetHasBackLabel = sh.hasBackLabel || false;
    }
  }
  
  let html = '<div class="wf1-preview-summary">' +
    'Printing <strong>' + qty + ' label' + (qty !== 1 ? 's' : '') + '</strong> on <strong>' + escapeHtml(sheetName) + '</strong> (' + wf1LabelType + ')' +
  '</div>';
  
  if (wf1JobType === 'individual') {
    // Show label preview with rich styles
    html += '<div class="wf1-preview-frame"><div class="wf1-preview-label-box">';
    for (const line of wf1ContentLines) {
      const parsed = parseLine(line.text);
      // Build inline style including rich formatting
      let style = 'font-size:' + (line.fontSize || 11) + 'px;';
      if (line.bold) style += ' font-weight:bold;';
      if (line.italic) style += ' font-style:italic;';
      if (line.underline) style += ' text-decoration:underline;';
      if (line.strikethrough) style += ' text-decoration:line-through;';
      if (line.color) style += ' color:' + line.color + ';';
      if (line.fillColor) style += ' background:' + line.fillColor + ';';
      
      if (parsed.type === 'fill') {
        html += '<div class="preview-line" style="' + style + ' text-align:left;">' + escapeHtml(parsed.label) + ' ___________</div>';
      } else if (parsed.type === 'split') {
        html += '<div class="preview-line" style="' + style + ' display:flex; justify-content:space-between;">' +
          '<span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
      } else {
        html += '<div class="preview-line" style="' + style + ' text-align:' + (line.align || 'left') + ';">' + escapeHtml(line.text) + '</div>';
      }
    }
    html += '</div></div>';
  } else {
    // Batch preview â€” show first few
    html += '<div class="wf1-batch-preview-count">' + qty + ' unique labels from your list</div>';
    html += '<div class="wf1-batch-preview-scroll">';
    const showCount = Math.min(qty, 5);
    for (let i = 0; i < showCount; i++) {
      html += '<div class="wf1-batch-preview-label">';
      for (const line of wf1BatchContent[i]) {
        html += '<div style="text-align:' + (line.align || 'left') + '; font-size:' + (line.fontSize || 11) + 'px;">' + escapeHtml(line.text) + '</div>';
      }
      html += '</div>';
    }
    if (qty > showCount) {
      html += '<div style="font-size:12px; color:var(--text-muted); text-align:center; padding:8px;">...and ' + (qty - showCount) + ' more</div>';
    }
    html += '</div>';
  }
  
  // Option to print ID label on back first (only for sheets without one)
  if (!sheetHasBackLabel) {
    html += '<div class="wf1-preview-option" style="margin-top:16px; padding:12px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm);">' +
      '<label style="display:flex; align-items:flex-start; gap:10px; cursor:pointer;">' +
        '<input type="checkbox" id="wf1PrintBackFirst" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">Also print ID label on back</div>' +
          '<div style="font-size:12px; color:var(--text-muted); margin-top:2px;">Prints a 2-page job: labels on front, sheet identifier on back. Works automatically with duplex printers.</div>' +
        '</div>' +
      '</label>' +
    '</div>';
  }
  
  // Safari print preview warning
  if (isSafari) {
    html += '<div class="safari-print-notice">ðŸŽ Safari\'s print preview may show labels slightly shifted â€” this is a Safari limitation. The actual printed output will be positioned correctly.</div>';
  }
  
  content.innerHTML = html;
}

// ---- PRINT EXECUTION ----

function wf1ExecutePrint() {
  // Check if user wants to print ID label on back first
  const printBackFirst = document.getElementById('wf1PrintBackFirst');
  if (printBackFirst && printBackFirst.checked) {
    wf1PrintBackLabelFirst();
    return;
  }
  
  if (wf1JobType === 'individual') {
    wf1ExecuteIndividualPrint();
  } else {
    wf1ExecuteBatchPrint();
  }
}

// Print ID label on back first, then prompt to flip and print labels
function wf1PrintBackLabelFirst() {
  // Create sheet if needed (so we have an ID to print)
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const spec = LABEL_TYPES[wf1LabelType];
    const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
    const sheetName = spec.desc + ' #' + (existingCount + 1);
    sheetId = createSheet(sheetName, wf1LabelType, 1);
    // Update selection to point to new sheet
    wf1SelectedSheet = { isNew: false, id: sheetId };
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  // Mark sheet as having back label
  if (sheets[sheetId]) {
    sheets[sheetId].hasBackLabel = true;
    saveSheets();
  }
  
  // Build combined 2-page print: Page 1 = labels (front), Page 2 = ID label (back)
  // This works with duplex printers automatically
  if (wf1JobType === 'individual') {
    wf1ExecuteCombinedPrint(sheetId, isNewSheet);
  } else {
    wf1ExecuteCombinedBatchPrint(sheetId, isNewSheet);
  }
}

// Execute combined print job: labels on page 1, ID label on page 2
function wf1ExecuteCombinedPrint(sheetId, isNewSheet) {
  const spec = LABEL_TYPES[wf1LabelType];
  const sh = sheets[sheetId];
  
  // Find positions respecting orientation
  const positions = wf1FindNextPositions(sh, spec, wf1Quantity, wf1Orientation);
  
  // Build print manifest
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let resolvedLines = wf1ContentLines;
  
  if (wf1SelectedSavedTextId) {
    const savedText = getSavedText(wf1SelectedSavedTextId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
    }
  } else if (wf1FeSnapshot) {
    graphics = wf1FeSnapshot.graphics || { left: null, right: null };
    alignV = wf1FeSnapshot.alignV || 'center';
    border = wf1FeSnapshot.border || null;
  }
  
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border };
  });
  
  // Build combined HTML: labels page + ID label page
  const printHtml = buildCombinedPrintHtml(sh, printManifest, sheetId);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store for post-print
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: positions.length };
  
  // Move to post-print confirmation
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

// Build combined print HTML: Page 1 = labels, Page 2 = ID label on back
function buildCombinedPrintHtml(sh, manifest, sheetId) {
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const isTentCard = spec.category === 'tent';
  const printed = new Set(sh.printed || []);
  const remaining = lps - printed.size;
  const createdDate = new Date(sh.createdAt || Date.now()).toLocaleDateString();
  
  // Build CSS (same as buildSheetPrintHtml)
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; }';
  html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; page-break-after: always; }';
  html += '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }';
  html += '.print-label-gfx { flex-direction:row; align-items:stretch; }';
  html += '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }';
  html += '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }';
  html += '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }';
  html += '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }';
  html += '.print-line.align-left { justify-content:flex-start; text-align:left; }';
  html += '.print-line.align-center { justify-content:center; text-align:center; }';
  html += '.print-line.align-right { justify-content:flex-end; text-align:right; }';
  html += '.print-line.align-split { justify-content:space-between; text-align:left; }';
  html += '.print-line.align-split > span { min-width:0; overflow:hidden; text-overflow:ellipsis; }';
  html += '.print-line.align-split-fill { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; }';
  html += '.print-line.align-split-fill .split-fill-left, .print-line.align-split-fill .split-fill-right { display:flex; align-items:flex-end; gap:3px; flex:1; }';
  html += '.print-line.align-split-fill .split-fill-right { justify-content:flex-end; }';
  html += '.print-line.align-split-fill .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  html += '.print-line.align-split-fill .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }';
  html += '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  if (isTentCard) {
    html += '.print-label.tent-card { position:relative; padding:0; }';
    html += '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #ccc; z-index:1; }';
    html += '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }';
    html += '.tent-top { top:0; height:50%; }';
    html += '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }';
  }
  // ID label page styles
  html += '.id-page { width: 8.5in; height: 11in; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif; }';
  html += '.id-label { border: 2px solid #333; border-radius: 8px; padding: 24px 32px; text-align: center; max-width: 4in; }';
  html += '.id-label h2 { margin: 0 0 6px; font-size: 18px; }';
  html += '.id-label .type { font-size: 14px; color: #555; margin-bottom: 12px; }';
  html += '.id-label .details { font-size: 11px; color: #777; margin-top: 10px; line-height: 1.5; }';
  html += '.id-label .id-code { font-family: monospace; font-size: 10px; color: #999; margin-top: 8px; word-break: break-all; }';
  html += '</style></head><body>';
  
  // PAGE 1: Labels (front of sheet)
  html += '<div class="print-sheet">';
  
  // Use the same label rendering logic as buildSheetPrintHtml
  manifest.forEach(function(item) {
    const idx = item.idx % lps;
    const row = Math.floor(idx / spec.cols);
    const col = idx % spec.cols;
    
    const top = spec.topMargin + row * (spec.labelH + spec.vGutter);
    const left = spec.leftMargin + col * (spec.labelW + spec.hGutter);
    
    const hasGraphics = item.graphics && (item.graphics.left || item.graphics.right);
    const alignV = item.alignV || 'center';
    const flexAlign = alignV === 'top' ? 'flex-start' : alignV === 'bottom' ? 'flex-end' : alignV === 'spread' ? 'space-between' : 'center';
    
    let borderStyle = '';
    if (item.border) {
      const bc = item.border.color || '#000';
      if (item.border.top) borderStyle += 'border-top:2px solid ' + bc + ';';
      if (item.border.bottom) borderStyle += 'border-bottom:2px solid ' + bc + ';';
      if (item.border.left) borderStyle += 'border-left:2px solid ' + bc + ';';
      if (item.border.right) borderStyle += 'border-right:2px solid ' + bc + ';';
    }
    
    html += '<div class="print-label' + (hasGraphics ? ' print-label-gfx' : '') + '" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.05in;justify-content:' + flexAlign + ';' + borderStyle + '">';
    
    if (hasGraphics && item.graphics.left) {
      const size = item.graphics.left.size === 'S' ? 0.3 : item.graphics.left.size === 'L' ? 0.6 : 0.45;
      html += '<div class="print-graphic" style="width:' + size + 'in;height:' + size + 'in;margin-right:0.05in;"><img src="' + item.graphics.left.data + '"></div>';
    }
    
    html += '<div class="print-text-zone" style="justify-content:' + flexAlign + ';">';
    for (const line of item.lines) {
      if (!line.text) continue;
      const parsed = parseLine(line.text);
      let style = 'font-size:' + (line.fontSize || 11) + 'px;';
      if (line.bold) style += 'font-weight:bold;';
      if (line.italic) style += 'font-style:italic;';
      if (line.underline) style += 'text-decoration:underline;';
      if (line.color) style += 'color:' + line.color + ';';
      
      if (parsed.type === 'fill') {
        html += '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span></div>';
      } else if (parsed.type === 'split') {
        html += '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
      } else {
        html += '<div class="print-line align-' + (line.align || 'left') + '" style="' + style + '">' + escapeHtml(line.text) + '</div>';
      }
    }
    html += '</div>';
    
    if (hasGraphics && item.graphics.right) {
      const size = item.graphics.right.size === 'S' ? 0.3 : item.graphics.right.size === 'L' ? 0.6 : 0.45;
      html += '<div class="print-graphic" style="width:' + size + 'in;height:' + size + 'in;margin-left:0.05in;"><img src="' + item.graphics.right.data + '"></div>';
    }
    
    html += '</div>';
  });
  
  html += '</div>';
  
  // PAGE 2: ID label (back of sheet)
  html += '<div class="id-page">';
  html += '<div class="id-label">';
  html += '<h2>' + escapeHtml(sh.name) + '</h2>';
  html += '<div class="type">' + sh.labelType + ' â€” ' + escapeHtml(spec.desc) + '</div>';
  html += '<div style="font-size:13px;">' + remaining + ' of ' + lps + ' labels available</div>';
  html += '<div class="details">Created: ' + createdDate + '<br>Sheet count: ' + (sh.sheetCount || 1) + '</div>';
  html += '<div class="id-code">' + sheetId + '</div>';
  html += '</div>';
  html += '</div>';
  
  html += '</body></html>';
  return html;
}

// Combined batch print with ID label on back
function wf1ExecuteCombinedBatchPrint(sheetId, isNewSheet) {
  // For now, just call the regular batch print flow
  // Multi-page batch with back label is complex - would need significant refactoring
  // Fall back to the simpler two-step approach for batch
  wf1ExecuteBatchPrint();
}

// Continue printing labels after ID label was printed on back (legacy - kept for safety)
function wf1ContinuePrintAfterBack() {
  if (wf1JobType === 'individual') {
    wf1ExecuteIndividualPrint();
  } else {
    wf1ExecuteBatchPrint();
  }
}

function wf1ExecuteIndividualPrint() {
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // Create or get sheet
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
    const sheetName = spec.desc + ' #' + (existingCount + 1);
    sheetId = createSheet(sheetName, wf1LabelType, 1);
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  const sh = sheets[sheetId];
  
  // T3: Find positions respecting orientation
  const positions = wf1FindNextPositions(sh, spec, wf1Quantity, wf1Orientation);
  
  // Build print manifest matching the canonical printFromSheet pattern
  // This ensures graphics, alignV, borders, and Safari compression all work
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let resolvedLines = wf1ContentLines;
  
  if (wf1SelectedSavedTextId) {
    const savedText = getSavedText(wf1SelectedSavedTextId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
    }
  } else if (wf1FeSnapshot) {
    // Use Full Editor snapshot for graphics, alignV, border when returning from Full Editor
    graphics = wf1FeSnapshot.graphics || { left: null, right: null };
    alignV = wf1FeSnapshot.alignV || 'center';
    border = wf1FeSnapshot.border || null;
  }
  
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border };
  });
  
  // Use the canonical buildSheetPrintHtml (same as sheets tab print button)
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store for post-print
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: positions.length };
  
  // Move to post-print confirmation
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

function wf1ExecuteBatchPrint() {
  // Check if this is a multi-sheet plan
  if (wf1SelectedSheet && wf1SelectedSheet.id === '__multi__' && wf1MultiSheetPlan) {
    wf1ExecuteMultiSheetBatchPrint();
    return;
  }
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const count = wf1BatchContent.length;
  const sheetsNeeded = Math.ceil(count / lps);
  
  // Create sheet for batch
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const sheetName = 'Batch ' + new Date().toLocaleDateString();
    sheetId = createSheet(sheetName, wf1LabelType, sheetsNeeded);
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  const sh = sheets[sheetId];
  
  // Resolve template graphics/alignV/border if a template was used
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  if (wf1BatchSelectedTemplate) {
    const tpl = getBuiltinTemplate(wf1BatchSelectedTemplate.id) || savedTexts.find(function(s) { return s.id === wf1BatchSelectedTemplate.id; });
    if (tpl) {
      graphics = tpl.graphics || { left: null, right: null };
      alignV = tpl.alignV || 'center';
      border = tpl.border || null;
    }
  }
  
  // Build print manifest using the canonical format (G10: same path as individual prints)
  // T3: Use orientation-aware position order
  const positionOrder = wf1GetPositionOrder(spec.cols, spec.rows, wf1Orientation);
  const printed = new Set(sh.printed || []);
  const printManifest = [];
  let orderIdx = 0;
  for (let i = 0; i < count; i++) {
    // Find next available position in orientation order
    while (orderIdx < positionOrder.length && printed.has(positionOrder[orderIdx])) orderIdx++;
    // Handle multi-page sheets by extending into next page if needed
    let posIdx;
    if (orderIdx < positionOrder.length) {
      posIdx = positionOrder[orderIdx];
    } else {
      // For multi-page sheets, continue into subsequent pages sequentially
      posIdx = lps + (orderIdx - positionOrder.length);
      while (printed.has(posIdx)) posIdx++;
    }
    printManifest.push({ idx: posIdx, lines: wf1BatchContent[i], graphics: graphics, alignV: alignV, border: border });
    orderIdx++;
  }
  
  // Use canonical buildSheetPrintHtml â€” gets graphics, styles, Safari compression, borders
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Build positions array for post-print
  const positions = printManifest.map(function(item) { return item.idx; });
  
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: count, isBatch: true };
  
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

// Multi-sheet batch print: prints across multiple existing + new sheets
function wf1ExecuteMultiSheetBatchPrint() {
  const plan = wf1MultiSheetPlan;
  if (!plan || !plan.steps.length) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // Resolve template graphics/alignV/border
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  if (wf1BatchSelectedTemplate) {
    const tpl = getBuiltinTemplate(wf1BatchSelectedTemplate.id) || savedTexts.find(function(s) { return s.id === wf1BatchSelectedTemplate.id; });
    if (tpl) {
      graphics = tpl.graphics || { left: null, right: null };
      alignV = tpl.alignV || 'center';
      border = tpl.border || null;
    }
  }
  
  // Build combined print HTML across all sheets
  let fullHtml = '';
  let contentIdx = 0; // tracks position in wf1BatchContent
  const sheetResults = []; // track what was printed on each sheet
  
  for (let si = 0; si < plan.steps.length; si++) {
    const step = plan.steps[si];
    let sheetId;
    let isNew = step.isNew;
    
    if (isNew) {
      const sheetName = 'Batch ' + new Date().toLocaleDateString() + (plan.steps.length > 1 ? ' (' + (si + 1) + ')' : '');
      sheetId = createSheet(sheetName, wf1LabelType, 1);
    } else {
      sheetId = step.sheetId;
    }
    
    const sh = sheets[sheetId];
    const printed = new Set(sh.printed || []);
    const manifest = [];
    let posIdx = 0;
    
    for (let li = 0; li < step.count && contentIdx < wf1BatchContent.length; li++) {
      while (posIdx < lps * sh.sheetCount && printed.has(posIdx)) posIdx++;
      manifest.push({ idx: posIdx, lines: wf1BatchContent[contentIdx], graphics: graphics, alignV: alignV, border: border });
      posIdx++;
      contentIdx++;
    }
    
    // Build this sheet's print HTML
    const sheetHtml = buildSheetPrintHtml(sh, manifest);
    
    // Extract body content (strip the DOCTYPE/head/body wrapper) for combining
    if (si === 0) {
      fullHtml = sheetHtml; // first sheet gets the full document
    } else {
      // Extract the print-sheet divs from subsequent sheets and append before </body>
      const bodyMatch = sheetHtml.match(/<body>([\s\S]*)<\/body>/);
      if (bodyMatch) {
        fullHtml = fullHtml.replace('</body>', bodyMatch[1] + '</body>');
      }
    }
    
    sheetResults.push({
      sheetId: sheetId,
      sheetName: sh.name,
      positions: manifest.map(function(m) { return m.idx; }),
      isNew: isNew,
      count: manifest.length
    });
  }
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(fullHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store multi-sheet result for post-print
  wf1PrintResult = {
    isMultiSheet: true,
    sheetResults: sheetResults,
    totalLabels: wf1BatchContent.length,
    isBatch: true
  };
  
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

let wf1PrintResult = null;

// ---- STEP 8: Post-Print ----

function wf1RenderPostPrint() {
  const content = document.getElementById('wf1PostPrintContent');
  const result = wf1PrintResult;
  if (!result) { content.innerHTML = '<p>Error: no print result</p>'; return; }
  
  let sheetDetailHtml = '';
  if (result.isMultiSheet) {
    sheetDetailHtml = '<div class="wf1-postprint-detail">Printed across ' + result.sheetResults.length + ' sheets:</div>' +
      '<div class="wf1-postprint-sheets">';
    result.sheetResults.forEach(function(sr) {
      const sh = sheets[sr.sheetId];
      sheetDetailHtml += '<div class="wf1-postprint-sheet-row"><span class="sheet-icon">ðŸ“„</span> "' + escapeHtml(sh ? sh.name : sr.sheetName) + '" â€” ' + sr.count + ' labels</div>';
    });
    sheetDetailHtml += '</div>';
  } else {
    const sh = sheets[result.sheetId];
    const sheetName = sh ? sh.name : 'Unknown';
    sheetDetailHtml = '<div class="wf1-postprint-detail">Printing on "' + escapeHtml(sheetName) + '"</div>';
  }
  
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">ðŸ–¨ï¸</div>' +
    '<div class="wf1-postprint-msg">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' sent to printer</div>' +
    sheetDetailHtml +
    '<div class="wf1-postprint-actions">' +
      '<button class="wf1-postprint-btn primary" onclick="wf1ConfirmPrint(true)">' +
        '<span>âœ…</span><span>Yes, it printed correctly</span>' +
      '</button>' +
      '<button class="wf1-postprint-btn" onclick="wf1ConfirmPrint(false)">' +
        '<span>âŒ</span><span>No, something went wrong â€” don\'t mark as used</span>' +
      '</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
  
  // Hide the Done button until they confirm
  document.getElementById('wf1Step8Actions').style.display = 'none';
}

function wf1ConfirmPrint(success) {
  const result = wf1PrintResult;
  if (!result) return;
  
  if (success) {
    if (result.isMultiSheet) {
      // Multi-sheet: mark positions on all sheets, adjust inventory for new sheets
      let newSheetCount = 0;
      for (const sr of result.sheetResults) {
        markPositionsPrinted(sr.sheetId, sr.positions);
        if (sr.isNew) newSheetCount++;
      }
      // Decrement inventory for all new sheets used
      if (newSheetCount > 0 && inventory[wf1LabelType] && inventory[wf1LabelType].stock > 0) {
        inventory[wf1LabelType].stock = Math.max(0, inventory[wf1LabelType].stock - newSheetCount);
        saveInventory();
        addInventoryEvent(wf1LabelType, 'print', -newSheetCount, inventory[wf1LabelType].stock);
      }
      // Add to print history
      addPrintHistoryEntry({
        textName: 'Batch (' + result.totalLabels + ') across ' + result.sheetResults.length + ' sheets',
        count: result.totalLabels,
        labelType: wf1LabelType,
        sheetId: result.sheetResults[0].sheetId,
        sheetName: result.sheetResults.map(function(sr) { return sheets[sr.sheetId] ? sheets[sr.sheetId].name : sr.sheetName; }).join(', '),
        lines: null,
        textId: null
      });
    } else {
      const sh = sheets[result.sheetId];
      
      // Decrement inventory on new sheet
      if (result.isNewSheet && inventory[wf1LabelType] && inventory[wf1LabelType].stock > 0) {
        inventory[wf1LabelType].stock--;
        saveInventory();
        addInventoryEvent(wf1LabelType, 'print', -1, inventory[wf1LabelType].stock);
      }
      
      // Mark positions as printed
      markPositionsPrinted(result.sheetId, result.positions);
      
      // Add to print history
      let textName;
      if (result.isBatch) {
        textName = 'Batch (' + result.totalLabels + ')';
      } else {
        textName = wf1SelectedSavedTextId ? (getSavedText(wf1SelectedSavedTextId)?.name) : generateContentName(wf1ContentLines, wf1LabelType);
      }
      addPrintHistoryEntry({
        textName: textName || 'Custom text',
        count: result.totalLabels,
        labelType: wf1LabelType,
        sheetId: result.sheetId,
        sheetName: sh ? sh.name : 'Unknown',
        lines: result.isBatch ? null : wf1ContentLines,
        textId: wf1SelectedSavedTextId || null
      });
    }
    
    // Show post-print options
    wf1ShowPostPrintOptions();
    
  } else {
    // Cancelled
    if (result.isMultiSheet) {
      // Delete all newly created sheets
      for (const sr of result.sheetResults) {
        if (sr.isNew) {
          delete sheets[sr.sheetId];
        }
      }
      saveSheets();
    } else if (result.isNewSheet) {
      delete sheets[result.sheetId];
      saveSheets();
    }
    
    const content = document.getElementById('wf1PostPrintContent');
    content.innerHTML = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">â†©ï¸</div>' +
      '<div class="wf1-postprint-msg">Print cancelled</div>' +
      '<div class="wf1-postprint-detail">No labels were marked as used.</div>' +
    '</div>';
    
    document.getElementById('wf1Step8Actions').style.display = 'flex';
  }
}

function wf1ShowPostPrintOptions() {
  const result = wf1PrintResult;
  
  // For multi-sheet, show a summary of all sheets used
  if (result.isMultiSheet) {
    const content = document.getElementById('wf1PostPrintContent');
    let detailHtml = '';
    result.sheetResults.forEach(function(sr) {
      const sh = sheets[sr.sheetId];
      const rem = sh ? getRemainingCount(sh) : 0;
      detailHtml += '<div class="wf1-postprint-sheet-row"><span class="sheet-icon">ðŸ“„</span> "' + escapeHtml(sh ? sh.name : sr.sheetName) + '" â€” ' + rem + ' spots remaining</div>';
    });
    
    let html = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">âœ…</div>' +
      '<div class="wf1-postprint-msg">Print confirmed!</div>' +
      '<div class="wf1-postprint-detail">' + result.totalLabels + ' labels printed across ' + result.sheetResults.length + ' sheets.</div>' +
      '<div class="wf1-postprint-sheets">' + detailHtml + '</div>' +
    '</div>';
    content.innerHTML = html;
    document.getElementById('wf1Step8Actions').style.display = 'flex';
    return;
  }
  
  const sh = sheets[result.sheetId];
  const remaining = sh ? getRemainingCount(sh) : 0;
  const lps = LABEL_TYPES[wf1LabelType].cols * LABEL_TYPES[wf1LabelType].rows;
  
  const content = document.getElementById('wf1PostPrintContent');
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">âœ…</div>' +
    '<div class="wf1-postprint-msg">Print confirmed!</div>' +
    '<div class="wf1-postprint-detail">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' printed. "' + escapeHtml(sh ? sh.name : '') + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' remaining.</div>';
  
  // Build checkbox options
  const hasLinkOption = !result.isBatch && remaining > 0;
  const hasSplitOption = remaining > 0 && remaining < lps;
  
  if (hasLinkOption || hasSplitOption) {
    html += '<div class="wf1-postprint-options" style="margin-top:16px;">';
    
    if (hasLinkOption) {
      html += '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer; margin-bottom:8px;">' +
        '<input type="checkbox" id="wf1PostLinkContent" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">ðŸ”— Link content to this sheet</div>' +
          '<div style="font-size:12px; color:var(--text-muted);">Makes reprinting easier â€” use "Print Something Again" next time</div>' +
        '</div>' +
      '</label>';
    }
    
    if (hasSplitOption) {
      html += '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer;">' +
        '<input type="checkbox" id="wf1PostSplitSheet" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">âœ‚ï¸ Split remaining ' + remaining + ' labels into new sheet</div>' +
          '<div style="font-size:12px; color:var(--text-muted);">Physically cut off the unused labels and track them separately. Useful if you want to store the remaining labels in a different location or use them for a different purpose.</div>' +
        '</div>' +
      '</label>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  content.innerHTML = html;
  
  document.getElementById('wf1Step8Actions').style.display = 'flex';
}

function wf1LinkContent() {
  const result = wf1PrintResult;
  if (!result) return;
  
  // Use existing linkContentToSheet logic adapted for WF1
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  let textId = wf1SelectedSavedTextId;
  
  // Save content if not already saved
  if (!textId) {
    const newText = {
      id: generateId('text'),
      name: generateContentName(wf1ContentLines, wf1LabelType),
      text: serializeLines(wf1ContentLines.map(function(l) {
        return { text: l.text, align: l.align, fontSize: l.fontSize, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' };
      })),
      alignV: 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now()
    };
    savedTexts.push(newText);
    saveSavedTexts();
    textId = newText.id;
  }
  
  // Link to sheet
  if (!sh.texts) sh.texts = {};
  if (!sh.texts[textId]) {
    sh.texts[textId] = { qty: 0, placement: 'next' };
  }
  saveSheets();
  
  showToast('Content linked! Use "Print Something Again" next time.', 'success');
  
  // Update display
  wf1ShowPostPrintOptions();
}

// G3: Print a sheet identification label on the back of a physical sheet
function printSheetLabel(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) { showToast('Sheet not found', 'error'); return; }
  const spec = LABEL_TYPES[sh.labelType];
  if (!spec) return;

  const lps = spec.cols * spec.rows;
  const printed = new Set(sh.printed || []);
  const remaining = lps - printed.size;
  const createdDate = new Date(sh.createdAt || Date.now()).toLocaleDateString();

  // Build a simple centered identification label that prints on standard letter paper
  // Uses a centered box â€” user flips the sheet and feeds it back through
  const deepLinkUrl = window.location.origin + window.location.pathname + '?action=openSheet&sheetId=' + encodeURIComponent(sheetId);

  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; width: 8.5in; height: 11in; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif; }';
  html += '.id-label { border: 2px solid #333; border-radius: 8px; padding: 24px 32px; text-align: center; max-width: 4in; }';
  html += '.id-label h2 { margin: 0 0 6px; font-size: 18px; }';
  html += '.id-label .type { font-size: 14px; color: #555; margin-bottom: 12px; }';
  html += '.id-label .details { font-size: 11px; color: #777; margin-top: 10px; line-height: 1.5; }';
  html += '.id-label .id-code { font-family: monospace; font-size: 10px; color: #999; margin-top: 8px; word-break: break-all; }';
  html += '</style></head><body>';
  html += '<div class="id-label">';
  html += '<h2>' + escapeHtml(sh.name) + '</h2>';
  html += '<div class="type">' + sh.labelType + ' â€” ' + escapeHtml(spec.desc) + '</div>';
  html += '<div style="font-size:13px;">' + remaining + ' of ' + lps + ' labels available</div>';
  html += '<div class="details">Created: ' + createdDate + '<br>Sheet count: ' + (sh.sheetCount || 1) + '</div>';
  html += '<div class="id-code">' + sheetId + '</div>';
  html += '</div>';
  html += '</body></html>';

  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(html);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
}

function wf1PrintBackLabel() {
  const result = wf1PrintResult;
  if (!result) return;
  
  printSheetLabel(result.sheetId);
  
  // Mark as having back label
  if (sheets[result.sheetId]) {
    sheets[result.sheetId].hasBackLabel = true;
    saveSheets();
  }
  
  showToast('Sheet ID label sent to printer', 'success');
}

function wf1SplitRemaining() {
  const result = wf1PrintResult;
  if (!result) return;
  
  showSplitDialog(result.sheetId);
}

// ---- Data Model Updates (G1, G4, G5 fixes) ----

// Update markPositionsPrinted to also set lastUsedAt (G1 fix)
const _originalMarkPositionsPrinted = markPositionsPrinted;
markPositionsPrinted = function(sheetId, positions) {
  _originalMarkPositionsPrinted(sheetId, positions);
  if (sheets[sheetId]) {
    sheets[sheetId].lastUsedAt = Date.now();
    saveSheets();
  }
};

// Update createSheet to include new fields (G4, G5)
const _originalCreateSheet = createSheet;
createSheet = function(name, labelType, sheetCount = 1, note = '') {
  const id = _originalCreateSheet(name, labelType, sheetCount, note);
  if (sheets[id]) {
    sheets[id].lastUsedAt = null;
    sheets[id].hasBackLabel = false;
    sheets[id].retired = false;
    sheets[id].retiredAt = null;
    saveSheets();
  }
  return id;
};


// ============================================================================
// WF2: PRINT SOMETHING AGAIN â€” Reprint Workflow
// ============================================================================
// Steps: 1=SelectContent, 2=Quantity, 3=SheetValidation, 4=Preview, 5=PostPrint

let wf2Step = 1;
let wf2SelectedItem = null; // { type: 'dedicated'|'history'|'saved', id, textId, sheetId, labelType, lines, lastQty, textName }
let wf2Quantity = 1;
let wf2SelectedSheet = null; // { id, isNew }
let wf2LabelType = null;
let wf2ContentLines = [];
let wf2PrintResult = null;
let wf2SearchQuery = '';

const WF2_TOTAL_STEPS = 5;

function wf2Start() {
  // Block satellite
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  // Reset state
  wf2Step = 1;
  wf2SelectedItem = null;
  wf2Quantity = 1;
  wf2SelectedSheet = null;
  wf2LabelType = null;
  wf2ContentLines = [];
  wf2PrintResult = null;
  wf2SearchQuery = '';
  
  // Check if we have anything to reprint
  const hasDedicated = wf2GetDedicatedSheetItems().length > 0;
  const hasHistory = printHistory.length > 0;
  const hasSaved = getTexts().length > 0;
  
  if (!hasDedicated && !hasHistory && !hasSaved) {
    showToast('Nothing to reprint yet. Print something new first!', 'info');
    return;
  }
  
  // Render and show
  wf2RenderContentSelector();
  wf2UpdateProgress();
  showWizard('wf2Wizard');
  wf2ShowStep('wf2Step1');
}

function wf2Close() {
  closeWizard('wf2Wizard');
  wf2Step = 1;
}

function wf2ShowStep(stepId) {
  const wizard = document.getElementById('wf2Wizard');
  wizard.querySelectorAll('.wizard-step').forEach(s => s.classList.remove('active'));
  document.getElementById(stepId).classList.add('active');
  wf2UpdateProgress();
}

function wf2UpdateProgress() {
  let html = '';
  for (let i = 1; i <= WF2_TOTAL_STEPS; i++) {
    let cls = 'wf2-progress-dot';
    if (i === wf2Step) cls += ' active';
    else if (i < wf2Step) cls += ' done';
    html += '<div class="' + cls + '"></div>';
  }
  document.getElementById('wf2Progress').innerHTML = html;
}

function wf2Back() {
  if (wf2Step <= 1) {
    wf2Close();
    return;
  }
  wf2Step--;
  wf2ShowStep('wf2Step' + wf2Step);
}

// --- Helper: Get dedicated sheet items ---
function wf2GetDedicatedSheetItems() {
  const items = [];
  for (const sh of Object.values(sheets)) {
    if (sh.retired || !sh.texts) continue;
    const textIds = Object.keys(sh.texts);
    if (textIds.length === 0) continue;
    for (const textId of textIds) {
      const text = getSavedText(textId);
      if (!text) continue;
      const remaining = getRemainingCount(sh);
      items.push({
        type: 'dedicated',
        id: 'ded_' + sh.id + '_' + textId,
        textId: textId,
        sheetId: sh.id,
        sheetName: sh.name,
        labelType: sh.labelType,
        textName: text.name || getFlatTextFromSaved(text),
        remaining: remaining,
        lastUsedAt: sh.lastUsedAt,
        text: text
      });
    }
  }
  return items;
}

// Helper to get flat text preview from a saved text object
function getFlatTextFromSaved(t) {
  if (t.text) {
    // Parse serialized lines
    try {
      const lines = t.text.split('\n').map(l => {
        const parts = l.split('||');
        return parts[0] || '';
      });
      return lines.filter(l => l.trim()).join(' / ').substring(0, 40);
    } catch(e) { return t.text.substring(0, 40); }
  }
  return 'Label';
}

// --- Step 1: Select content ---
function wf2RenderContentSelector() {
  const container = document.getElementById('wf2ContentSelector');
  const dedicated = wf2GetDedicatedSheetItems();
  const allSaved = getTexts();
  
  let html = '';
  
  // Search bar (show if we have enough items)
  if (dedicated.length + printHistory.length + allSaved.length > 5) {
    html += '<div class="wf2-search-row">' +
      '<input type="text" class="wf2-search-input" placeholder="Search..." ' +
        'id="wf2SearchInput" oninput="wf2FilterContent(this.value)">' +
    '</div>';
  }
  
  html += '<div class="wf2-content-list" id="wf2ContentList">';
  html += wf2BuildContentListHtml('');
  html += '</div>';
  
  container.innerHTML = html;
  
  // Update next button state
  document.getElementById('wf2Step1NextBtn').disabled = !wf2SelectedItem;
}

function wf2BuildContentListHtml(filter) {
  const dedicated = wf2GetDedicatedSheetItems();
  const allSaved = getTexts();
  const f = filter.toLowerCase().trim();
  let html = '';
  let hasResults = false;
  
  // Section 1: Dedicated sheet assignments (quick reprints)
  const filteredDed = dedicated.filter(d => !f || d.textName.toLowerCase().includes(f) || d.sheetName.toLowerCase().includes(f));
  if (filteredDed.length > 0) {
    html += '<div class="wf2-section-label">ðŸ“Œ Quick Reprint â€” Linked to Sheets</div>';
    for (const item of filteredDed) {
      const selected = wf2SelectedItem && wf2SelectedItem.id === item.id ? ' selected' : '';
      const remaining = item.remaining;
      const spec = LABEL_TYPES[item.labelType];
      const typeName = spec ? spec.name : item.labelType;
      
      // Get last print info from history
      const histMatch = printHistory.find(e => e.textId === item.textId || e.sheetId === item.sheetId);
      const lastQty = histMatch ? histMatch.count : null;
      const lastDate = histMatch ? new Date(histMatch.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : null;
      
      // Build context line
      let contextLine = 'On "' + escapeHtml(item.sheetName) + '" Â· ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' left Â· ' + typeName;
      if (lastQty && lastDate) {
        contextLine += '<br><span style="color:var(--text-muted);">Last printed: ' + lastQty + ' on ' + lastDate + '</span>';
      }
      
      // Can we do quick reprint?
      const canQuickPrint = lastQty && remaining >= lastQty;
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(item.id) + '\', \'dedicated\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(item.id) + '\', \'dedicated\')">' +
        '<div class="wf2-content-card-icon">ðŸ·ï¸</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(item.textName) + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
        '<div class="wf2-content-card-actions">' +
          (canQuickPrint ? '<button class="wf2-quick-btn" onclick="event.stopPropagation(); wf2QuickReprint(\'' + escapeAttr(item.id) + '\', \'dedicated\', ' + lastQty + ')" title="Print ' + lastQty + ' label' + (lastQty !== 1 ? 's' : '') + ' immediately">âš¡ Print ' + lastQty + '</button>' : '') +
          '<div class="wf2-content-card-badge dedicated">Linked</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  // Section 2: Recent print history
  const filteredHist = printHistory.filter(e => !f || 
    (e.textName && e.textName.toLowerCase().includes(f)) ||
    (e.sheetName && e.sheetName.toLowerCase().includes(f))
  ).slice(0, 10);
  if (filteredHist.length > 0) {
    html += '<div class="wf2-section-label">ðŸ• Recent Prints</div>';
    for (const entry of filteredHist) {
      const id = 'hist_' + entry.id;
      const selected = wf2SelectedItem && wf2SelectedItem.id === id ? ' selected' : '';
      const date = new Date(entry.timestamp);
      const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      const count = entry.count || 1;
      const spec = LABEL_TYPES[entry.labelType];
      const typeName = spec ? spec.name : entry.labelType;
      
      // Check if same sheet still exists and has room
      const sh = entry.sheetId ? sheets[entry.sheetId] : null;
      const sheetRemaining = sh ? getRemainingCount(sh) : 0;
      const canQuickPrint = sh && !sh.retired && sheetRemaining >= count;
      
      // Build context
      let contextLine = dateStr + ' Â· ' + count + ' label' + (count !== 1 ? 's' : '') + ' Â· ' + typeName;
      if (sh && !sh.retired) {
        contextLine += '<br><span style="color:var(--text-muted);">Sheet: "' + escapeHtml(sh.name) + '" (' + sheetRemaining + ' spot' + (sheetRemaining !== 1 ? 's' : '') + ' left)</span>';
      }
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(id) + '\', \'history\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(id) + '\', \'history\')">' +
        '<div class="wf2-content-card-icon">ðŸ“œ</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
        '<div class="wf2-content-card-actions">' +
          (canQuickPrint ? '<button class="wf2-quick-btn" onclick="event.stopPropagation(); wf2QuickReprint(\'' + escapeAttr(id) + '\', \'history\', ' + count + ')" title="Print ' + count + ' label' + (count !== 1 ? 's' : '') + ' on same sheet">âš¡ Same</button>' : '') +
          '<div class="wf2-content-card-badge history">History</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  // Section 3: All saved content
  const filteredSaved = allSaved.filter(t => !f || 
    (t.name && t.name.toLowerCase().includes(f)) ||
    (t.text && t.text.toLowerCase().includes(f))
  );
  if (filteredSaved.length > 0) {
    html += '<div class="wf2-section-label">ðŸ’¾ Saved Content</div>';
    for (const t of filteredSaved) {
      const id = 'saved_' + t.id;
      const selected = wf2SelectedItem && wf2SelectedItem.id === id ? ' selected' : '';
      const preview = getFlatTextFromSaved(t);
      
      // Find last print for this content
      const histMatch = printHistory.find(e => e.textId === t.id);
      let contextLine = escapeHtml(preview);
      if (histMatch) {
        const histDate = new Date(histMatch.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        contextLine += '<br><span style="color:var(--text-muted);">Last printed: ' + histMatch.count + ' on ' + histDate + '</span>';
      }
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(id) + '\', \'saved\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(id) + '\', \'saved\')">' +
        '<div class="wf2-content-card-icon">ðŸ“</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(t.name || 'Untitled') + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  if (!hasResults) {
    html += '<div class="wf2-empty">' +
      '<div class="wf2-empty-icon">ðŸ”</div>' +
      '<div class="wf2-empty-text">' + (f ? 'No results for "' + escapeHtml(f) + '"' : 'Nothing to reprint yet') + '</div>' +
    '</div>';
  }
  
  return html;
}

// Quick reprint: skip all questions, go directly to preview with pre-filled values
function wf2QuickReprint(id, type, qty) {
  // Select the item first
  wf2SelectItem(id, type);
  
  // Set quantity
  wf2Quantity = qty;
  wf2ContentLines = wf2SelectedItem.lines;
  
  // Set the sheet
  if (wf2SelectedItem.sheetId && sheets[wf2SelectedItem.sheetId]) {
    wf2SelectedSheet = sheets[wf2SelectedItem.sheetId];
  } else {
    // Find a matching sheet with room
    const matchingSheets = Object.values(sheets).filter(s => 
      s.labelType === wf2LabelType && !s.retired && getRemainingCount(s) >= qty
    );
    wf2SelectedSheet = matchingSheets.length > 0 ? matchingSheets[0] : null;
  }
  
  if (!wf2SelectedSheet) {
    // No sheet available, fall back to regular flow
    showToast('No sheet with enough room available', 'warning');
    wf2ToStep2();
    return;
  }
  
  // Jump directly to preview (Step 4)
  wf2Step = 4;
  wf2RenderPreview();
  wf2ShowStep('wf2Step4');
}

function wf2FilterContent(query) {
  wf2SearchQuery = query;
  const list = document.getElementById('wf2ContentList');
  if (list) list.innerHTML = wf2BuildContentListHtml(query);
}

function wf2SelectItem(id, type) {
  if (type === 'dedicated') {
    const items = wf2GetDedicatedSheetItems();
    const item = items.find(d => d.id === id);
    if (!item) return;
    
    // Resolve content lines from saved text
    const text = item.text;
    const lines = wf2ResolveLinesFromSavedText(text);
    
    wf2SelectedItem = {
      type: 'dedicated',
      id: id,
      textId: item.textId,
      sheetId: item.sheetId,
      labelType: item.labelType,
      lines: lines,
      lastQty: null, // Look up from history
      textName: item.textName
    };
    
    // Try to find last quantity from print history for this text
    const histMatch = printHistory.find(e => e.textId === item.textId || e.sheetId === item.sheetId);
    if (histMatch) wf2SelectedItem.lastQty = histMatch.count;
    
  } else if (type === 'history') {
    const entryId = id.replace('hist_', '');
    const entry = printHistory.find(e => e.id === entryId);
    if (!entry) return;
    
    // Try to get full lines from history entry or reconstruct from saved text
    let lines;
    if (entry.lines && entry.lines.length > 0) {
      lines = entry.lines;
    } else if (entry.textId) {
      const text = getSavedText(entry.textId);
      if (text) lines = wf2ResolveLinesFromSavedText(text);
    }
    if (!lines || lines.length === 0) {
      lines = [{ text: entry.textName || 'Label', align: 'left', fontSize: 11 }];
    }
    
    wf2SelectedItem = {
      type: 'history',
      id: id,
      textId: entry.textId || null,
      sheetId: entry.sheetId || null,
      labelType: entry.labelType || '5160',
      lines: lines,
      lastQty: entry.count || 1,
      textName: entry.textName || 'Labels'
    };
    
  } else if (type === 'saved') {
    const textId = id.replace('saved_', '');
    const text = getSavedText(textId);
    if (!text) return;
    
    const lines = wf2ResolveLinesFromSavedText(text);
    
    // Find which label type this was last printed with
    const histMatch = printHistory.find(e => e.textId === textId);
    
    wf2SelectedItem = {
      type: 'saved',
      id: id,
      textId: textId,
      sheetId: histMatch ? histMatch.sheetId : null,
      labelType: histMatch ? histMatch.labelType : (settings.lastLabelType || '5160'),
      lines: lines,
      lastQty: histMatch ? histMatch.count : null,
      textName: text.name || getFlatTextFromSaved(text)
    };
  }
  
  wf2LabelType = wf2SelectedItem.labelType;
  
  // Re-render list to show selection
  const list = document.getElementById('wf2ContentList');
  if (list) list.innerHTML = wf2BuildContentListHtml(wf2SearchQuery);
  
  // Enable next button
  document.getElementById('wf2Step1NextBtn').disabled = false;
}

// Resolve a saved text object into lines array for printing
function wf2ResolveLinesFromSavedText(text) {
  if (!text || !text.text) return [{ text: 'Label', align: 'left', fontSize: 11 }];
  
  try {
    return text.text.split('\n').map(function(line) {
      const parts = line.split('||');
      const content = parts[0] || '';
      const align = parts[1] || 'left';
      const fontSize = parseInt(parts[2]) || 11;
      return { text: content, align: align, fontSize: fontSize };
    });
  } catch(e) {
    return [{ text: text.text.substring(0, 100), align: 'left', fontSize: 11 }];
  }
}

// T1: Double-click to select item and advance
function wf2SelectItemAndAdvance(id, type) {
  wf2SelectItem(id, type);
  setTimeout(() => wf2ToStep2(), 100);
}

// --- Step 2: Quantity check ---
function wf2ToStep2() {
  if (!wf2SelectedItem) return;
  
  wf2Step = 2;
  wf2Quantity = wf2SelectedItem.lastQty || 1;
  wf2ContentLines = wf2SelectedItem.lines;
  
  wf2RenderQuantityCheck();
  wf2ShowStep('wf2Step2');
}

function wf2RenderQuantityCheck() {
  const container = document.getElementById('wf2QuantityContent');
  const item = wf2SelectedItem;
  const spec = LABEL_TYPES[wf2LabelType];
  const labelsPerSheet = spec ? (spec.cols * spec.rows) : 30;
  
  let promptHtml = '';
  if (item.lastQty) {
    promptHtml = '<div class="wf2-qty-prompt">Last time you printed <strong>' + item.lastQty + '</strong> of these. Same amount?</div>';
  } else {
    promptHtml = '<div class="wf2-qty-prompt">How many copies of <strong>"' + escapeHtml(item.textName) + '"</strong>?</div>';
  }
  
  const html = '<div class="wf2-qty-section">' +
    promptHtml +
    '<div class="wf2-qty-controls">' +
      '<button class="wf2-qty-btn" id="wf2QtyMinus" onclick="wf2AdjustQty(-1)"' + (wf2Quantity <= 1 ? ' disabled' : '') + '>âˆ’</button>' +
      '<div class="wf2-qty-value" id="wf2QtyValue">' + wf2Quantity + '</div>' +
      '<button class="wf2-qty-btn" onclick="wf2AdjustQty(1)">+</button>' +
    '</div>' +
    '<div class="wf2-qty-hint" id="wf2QtyHint">' + wf2GetQtyHint() + '</div>' +
  '</div>';
  
  container.innerHTML = html;
}

function wf2AdjustQty(delta) {
  wf2Quantity = Math.max(1, wf2Quantity + delta);
  document.getElementById('wf2QtyValue').textContent = wf2Quantity;
  document.getElementById('wf2QtyMinus').disabled = wf2Quantity <= 1;
  document.getElementById('wf2QtyHint').textContent = wf2GetQtyHint();
}

function wf2GetQtyHint() {
  const spec = LABEL_TYPES[wf2LabelType];
  if (!spec) return '';
  const perSheet = spec.cols * spec.rows;
  if (wf2Quantity <= perSheet) {
    return wf2Quantity + ' label' + (wf2Quantity !== 1 ? 's' : '') + ' (' + spec.name + ', ' + perSheet + ' per sheet)';
  }
  const sheetsNeeded = Math.ceil(wf2Quantity / perSheet);
  return wf2Quantity + ' labels = ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : '') + ' of ' + spec.name;
}

// --- Step 3: Sheet validation ---
function wf2ToStep3() {
  // T8: Skip sheet picker if we already know the sheet and it's ready
  const item = wf2SelectedItem;
  if (item && item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    const sh = sheets[item.sheetId];
    const remaining = getRemainingCount(sh);
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    const isStale = daysSince !== null && daysSince > 30;
    
    // Auto-skip if: has room AND not stale
    if (remaining >= wf2Quantity && !isStale) {
      wf2SelectedSheet = { id: item.sheetId, isNew: false };
      wf2Step = 4; // Skip to preview
      wf2RenderPreview();
      wf2ShowStep('wf2Step4');
      return;
    }
  }
  
  wf2Step = 3;
  wf2RenderSheetCheck();
  wf2ShowStep('wf2Step3');
}

function wf2RenderSheetCheck() {
  const container = document.getElementById('wf2SheetContent');
  const item = wf2SelectedItem;
  
  // Find matching sheets for this label type
  // T9: Filter out dedicated sheets that are for OTHER content (not this textId)
  const matchingSheets = Object.values(sheets).filter(s => {
    if (s.labelType !== wf2LabelType || s.retired) return false;
    
    // Check if this is a dedicated sheet
    const isDedicated = s.texts && Object.keys(s.texts).length > 0;
    if (isDedicated) {
      // T9: Only show dedicated sheets if they contain THIS content
      // (i.e., the textId we're reprinting is already on this sheet)
      const textIds = Object.keys(s.texts);
      const isForThisContent = item.textId && textIds.includes(item.textId);
      if (!isForThisContent) return false; // Hide dedicated sheets for other content
    }
    
    return true;
  });
  
  // Pre-select logic:
  // 1. If dedicated, pre-select the dedicated sheet
  // 2. If history, pre-select last-used sheet
  // 3. Otherwise, let user pick
  let preSelectId = null;
  if (item.type === 'dedicated' && item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    preSelectId = item.sheetId;
  } else if (item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    preSelectId = item.sheetId;
  }
  
  let html = '';
  
  // Show status message for pre-selected dedicated sheet
  if (preSelectId) {
    const sh = sheets[preSelectId];
    const remaining = getRemainingCount(sh);
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    
    if (remaining >= wf2Quantity) {
      // Enough room
      if (daysSince !== null && daysSince > 30) {
        let staleExtra = '';
        if (!sh.hasBackLabel) {
          staleExtra = ' <button onclick="event.stopPropagation(); wf2PrintIdLabel(\'' + sh.id + '\')" style="background:none;border:none;color:var(--accent);cursor:pointer;font-size:11px;text-decoration:underline;padding:0;margin-left:4px;">Print ID label</button>';
        }
        html += '<div class="wf2-sheet-status warn">' +
          '<div class="wf2-sheet-status-icon">âš ï¸</div>' +
          '<div class="wf2-sheet-status-text">Sheet "' + escapeHtml(sh.name) + '" was last used ' + daysSince + ' days ago. Can you confirm you still have it?' + staleExtra + '</div>' +
        '</div>';
      } else {
        html += '<div class="wf2-sheet-status ok">' +
          '<div class="wf2-sheet-status-icon">âœ…</div>' +
          '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' available â€” plenty of room for ' + wf2Quantity + '.</div>' +
        '</div>';
      }
    } else if (remaining > 0) {
      html += '<div class="wf2-sheet-status warn">' +
        '<div class="wf2-sheet-status-icon">âš ï¸</div>' +
        '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" only has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' but you need ' + wf2Quantity + '. You can print what fits, or pick another sheet.</div>' +
      '</div>';
    } else {
      html += '<div class="wf2-sheet-status error">' +
        '<div class="wf2-sheet-status-icon">âŒ</div>' +
        '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" is full. Pick another sheet or create a new one.</div>' +
      '</div>';
      preSelectId = null; // Don't pre-select a full sheet
    }
  }
  
  // Sheet picker list (reuse WF1 sheet picker pattern)
  html += '<div class="wf2-content-list" style="max-height:280px;">';
  
  // Show matching sheets
  for (const sh of matchingSheets) {
    const remaining = getRemainingCount(sh);
    if (remaining <= 0) continue; // Skip full sheets
    
    const selected = (wf2SelectedSheet && wf2SelectedSheet.id === sh.id) || (!wf2SelectedSheet && sh.id === preSelectId) ? ' selected' : '';
    const isDedicated = sh.texts && Object.keys(sh.texts).length > 0;
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    
    let meta = remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' available';
    if (daysSince !== null) {
      meta += ' Â· Last used ' + (daysSince === 0 ? 'today' : daysSince + ' day' + (daysSince !== 1 ? 's' : '') + ' ago');
    }
    
    html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectSheet(\'' + sh.id + '\')">' +
      '<div class="wf2-content-card-icon">ðŸ“„</div>' +
      '<div class="wf2-content-card-info">' +
        '<div class="wf2-content-card-title">' + escapeHtml(sh.name) + '</div>' +
        '<div class="wf2-content-card-meta">' + meta + '</div>' +
      '</div>' +
      (isDedicated ? '<div class="wf2-content-card-badge dedicated">Dedicated</div>' : '') +
      (daysSince !== null && daysSince > 30 ? '<div class="wf2-content-card-badge history">Stale</div>' : '') +
    '</div>';
  }
  
  // "Create new from stock" option
  const inv = inventory[wf2LabelType];
  const stock = inv ? inv.stock : 0;
  if (stock > 0) {
    const newSelected = wf2SelectedSheet && wf2SelectedSheet.isNew ? ' selected' : '';
    html += '<div class="wf2-content-card' + newSelected + '" onclick="wf2SelectSheet(\'__new__\')">' +
      '<div class="wf2-content-card-icon">âž•</div>' +
      '<div class="wf2-content-card-info">' +
        '<div class="wf2-content-card-title">Create new sheet from stock</div>' +
        '<div class="wf2-content-card-meta">' + stock + ' sheet' + (stock !== 1 ? 's' : '') + ' of ' + wf2LabelType + ' available</div>' +
      '</div>' +
    '</div>';
  }
  
  // No sheets at all
  if (matchingSheets.filter(s => getRemainingCount(s) > 0).length === 0 && stock <= 0) {
    html += '<div class="wf2-empty">' +
      '<div class="wf2-empty-icon">ðŸ“­</div>' +
      '<div class="wf2-empty-text">No sheets available for ' + wf2LabelType + '. Add stock in the Inventory tab first.</div>' +
    '</div>';
  }
  
  html += '</div>';
  container.innerHTML = html;
  
  // Auto-select pre-selected sheet if we have one and haven't manually selected yet
  if (!wf2SelectedSheet && preSelectId && sheets[preSelectId] && getRemainingCount(sheets[preSelectId]) > 0) {
    wf2SelectedSheet = { id: preSelectId, isNew: false };
  }
  
  // If only one option and it fits, auto-select it
  const availableSheets = matchingSheets.filter(s => getRemainingCount(s) > 0);
  if (!wf2SelectedSheet && availableSheets.length === 1 && getRemainingCount(availableSheets[0]) >= wf2Quantity) {
    wf2SelectedSheet = { id: availableSheets[0].id, isNew: false };
  }
  
  document.getElementById('wf2SheetNextBtn').disabled = !wf2SelectedSheet;
}

// G3: Print sheet ID label from WF2 sheet check
function wf2PrintIdLabel(sheetId) {
  printSheetLabel(sheetId);
  if (sheets[sheetId]) {
    sheets[sheetId].hasBackLabel = true;
    saveSheets();
  }
  showToast('Sheet ID label sent to printer', 'success');
  wf2RenderSheetCheck();
}

function wf2SelectSheet(idOrNew) {
  if (idOrNew === '__new__') {
    // Create a new sheet from stock
    const spec = LABEL_TYPES[wf2LabelType];
    const typeName = spec ? spec.name : wf2LabelType;
    const sheetName = typeName + ' ' + new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const newId = createSheet(sheetName, wf2LabelType, 1, '');
    wf2SelectedSheet = { id: newId, isNew: true };
  } else {
    wf2SelectedSheet = { id: idOrNew, isNew: false };
  }
  
  // Re-render to show selection
  wf2RenderSheetCheck();
}

// --- Step 4: Preview & Print ---
function wf2ToStep4() {
  if (!wf2SelectedSheet) return;
  wf2Step = 4;
  wf2RenderPreview();
  wf2ShowStep('wf2Step4');
}

function wf2RenderPreview() {
  const container = document.getElementById('wf2PreviewContent');
  const sh = sheets[wf2SelectedSheet.id];
  if (!sh) { container.innerHTML = '<p>Error: sheet not found</p>'; return; }
  
  const spec = LABEL_TYPES[wf2LabelType];
  const typeName = spec ? spec.name : wf2LabelType;
  const lines = wf2ContentLines;
  
  let html = '<div class="wf1-preview-summary">' +
    '<div class="wf1-preview-stat"><span class="wf1-preview-stat-num">' + wf2Quantity + '</span> label' + (wf2Quantity !== 1 ? 's' : '') + '</div>' +
    '<div class="wf1-preview-stat">on <strong>"' + escapeHtml(sh.name) + '"</strong></div>' +
    '<div class="wf1-preview-stat">' + typeName + '</div>' +
  '</div>';
  
  // Label preview
  if (lines && lines.length > 0) {
    html += '<div class="wf1-preview-label">';
    for (const line of lines) {
      if (!line.text && !line.text === '') continue;
      const align = line.align || 'left';
      const size = line.fontSize || 11;
      html += '<div style="text-align:' + align + '; font-size:' + size + 'px; padding: 2px 0;">' +
        escapeHtml(line.text || '') +
      '</div>';
    }
    html += '</div>';
  }
  
  // Safari print preview warning
  if (isSafari) {
    html += '<div class="safari-print-notice">ðŸŽ Safari\'s print preview may show labels slightly shifted â€” this is a Safari limitation. The actual printed output will be positioned correctly.</div>';
  }
  
  container.innerHTML = html;
}

function wf2ExecutePrint() {
  const sh = sheets[wf2SelectedSheet.id];
  if (!sh) { showToast('Sheet not found', 'error'); return; }
  
  const spec = LABEL_TYPES[wf2LabelType];
  if (!spec) { showToast('Unknown label type', 'error'); return; }
  
  const lines = wf2ContentLines;
  const qty = wf2Quantity;
  const lps = spec.cols * spec.rows;
  
  // Find available positions
  const printed = new Set(sh.printed || []);
  const positions = [];
  for (let i = 0; i < lps && positions.length < qty; i++) {
    if (!printed.has(i)) positions.push(i);
  }
  
  if (positions.length === 0) {
    showToast('No available positions on this sheet', 'error');
    return;
  }
  
  // Resolve full content from saved text if available (for graphics, borders, alignV)
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let resolvedLines = lines;
  
  if (wf2SelectedItem && wf2SelectedItem.textId) {
    const savedText = getSavedText(wf2SelectedItem.textId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
    }
  }
  
  // Build manifest matching printFromSheet pattern
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border };
  });
  
  // Use the canonical buildSheetPrintHtml (same as sheets tab print button)
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store result for post-print
  wf2PrintResult = {
    sheetId: wf2SelectedSheet.id,
    isNewSheet: wf2SelectedSheet.isNew,
    positions: positions,
    totalLabels: positions.length,
    isBatch: false
  };
  
  // Go to post-print step
  wf2Step = 5;
  wf2RenderPostPrint();
  wf2ShowStep('wf2Step5');
}

// --- Step 5: Post-print ---
function wf2RenderPostPrint() {
  const content = document.getElementById('wf2PostPrintContent');
  const result = wf2PrintResult;
  if (!result) { content.innerHTML = '<p>Error: no print result</p>'; return; }
  
  const sh = sheets[result.sheetId];
  const sheetName = sh ? sh.name : 'Unknown';
  
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">ðŸ–¨ï¸</div>' +
    '<div class="wf1-postprint-msg">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' sent to printer</div>' +
    '<div class="wf1-postprint-detail">Printing on "' + escapeHtml(sheetName) + '"</div>' +
    '<div class="wf1-postprint-actions">' +
      '<button class="wf1-postprint-btn primary" onclick="wf2ConfirmPrint(true)">' +
        '<span>âœ…</span><span>Yes, it printed correctly</span>' +
      '</button>' +
      '<button class="wf1-postprint-btn" onclick="wf2ConfirmPrint(false)">' +
        '<span>âŒ</span><span>No, something went wrong â€” don\'t mark as used</span>' +
      '</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
  document.getElementById('wf2Step5Actions').style.display = 'none';
}

function wf2ConfirmPrint(success) {
  const result = wf2PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  
  if (success) {
    // Decrement inventory on new sheet
    if (result.isNewSheet && inventory[wf2LabelType] && inventory[wf2LabelType].stock > 0) {
      inventory[wf2LabelType].stock--;
      saveInventory();
      addInventoryEvent(wf2LabelType, 'print', -1, inventory[wf2LabelType].stock);
    }
    
    // Mark positions as printed
    markPositionsPrinted(result.sheetId, result.positions);
    
    // Add to print history (G6 fix: store full lines, G7 fix: store quantity)
    const textName = wf2SelectedItem ? wf2SelectedItem.textName : 'Reprint';
    addPrintHistoryEntry({
      textName: textName,
      count: result.totalLabels,
      labelType: wf2LabelType,
      sheetId: result.sheetId,
      sheetName: sh ? sh.name : 'Unknown',
      lines: wf2ContentLines,
      textId: wf2SelectedItem ? wf2SelectedItem.textId : null
    });
    
    wf2ShowPostPrintOptions();
    
  } else {
    // Cancelled â€” delete new sheet if we created one
    if (result.isNewSheet) {
      delete sheets[result.sheetId];
      saveSheets();
    }
    
    const content = document.getElementById('wf2PostPrintContent');
    content.innerHTML = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">â†©ï¸</div>' +
      '<div class="wf1-postprint-msg">Print cancelled</div>' +
      '<div class="wf1-postprint-detail">No labels were marked as used.</div>' +
    '</div>';
    
    document.getElementById('wf2Step5Actions').style.display = 'flex';
  }
}

function wf2ShowPostPrintOptions() {
  const result = wf2PrintResult;
  const sh = sheets[result.sheetId];
  const remaining = sh ? getRemainingCount(sh) : 0;
  
  const content = document.getElementById('wf2PostPrintContent');
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">âœ…</div>' +
    '<div class="wf1-postprint-msg">Print confirmed!</div>' +
    '<div class="wf1-postprint-detail">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' printed. "' + escapeHtml(sh ? sh.name : '') + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' remaining.</div>';
  
  html += '<div class="wf1-postprint-actions">';
  
  // Offer QR back label if sheet doesn't have one
  if (sh && !sh.hasBackLabel) {
    html += '<button class="wf1-postprint-btn" onclick="wf2PrintBackLabel()">' +
      '<span>ðŸ·ï¸</span><span>Print an ID label on the back of this sheet</span>' +
    '</button>';
  }
  
  // Offer split if partially used
  if (remaining > 0 && remaining < (LABEL_TYPES[wf2LabelType].cols * LABEL_TYPES[wf2LabelType].rows)) {
    html += '<button class="wf1-postprint-btn" onclick="wf2SplitRemaining()">' +
      '<span>âœ‚ï¸</span><span>Split remaining ' + remaining + ' labels into a new sheet</span>' +
    '</button>';
  }
  
  html += '</div></div>';
  content.innerHTML = html;
  
  document.getElementById('wf2Step5Actions').style.display = 'flex';
}

function wf2PrintBackLabel() {
  const result = wf2PrintResult;
  if (!result) return;
  
  printSheetLabel(result.sheetId);
  
  if (sheets[result.sheetId]) {
    sheets[result.sheetId].hasBackLabel = true;
    saveSheets();
  }
  
  showToast('Sheet ID label sent to printer', 'success');
}

function wf2SplitRemaining() {
  const result = wf2PrintResult;
  if (!result) return;
  showSplitDialog(result.sheetId);
}


// ========== WORKFLOWS ==========
// ============================================================================
// HISTORY REPRINT â€” Routes through WF2
// ============================================================================

function reprintFromHistory(entryId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  const entry = printHistory.find(function(e) { return e.id === entryId; });
  if (!entry) return;
  
  // Route through WF2 â€” start it, then auto-select this history entry
  wf2Start();
  setTimeout(function() {
    wf2SelectItem('hist_' + entry.id, 'history');
  }, 50);
}

// ============================================================================
// WORKFLOW ROUTING
// ============================================================================

function startWorkflow(type) {
  // Block satellite from print-related workflows
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  if (type === 'new') {
    wf1Start();
  } else if (type === 'existing') {
    wf2Start();
  } else if (type === 'setup') {
    // Direct to inventory tab for setup
    switchTab('inventory');
  }
}

function showWizard(wizardId) {
  document.getElementById(wizardId).classList.add('visible');
}

function closeWizard(wizardId) {
  document.getElementById(wizardId).classList.remove('visible');
}



// ============================================================================
// BATCH CSV IMPORT (ported from v1.2)
// ============================================================================

function showBatchImportModal(templateId) {
  if (hasActiveJob()) {
    showToast('A batch job is already active. Complete or cancel it before starting a new one.', 'error');
    return;
  }

  const tpl = getBuiltinTemplate(templateId) || savedTexts.find(s => s.id === templateId);
  if (!tpl || tpl.type !== 'template') {
    showToast('Template not found.', 'error');
    return;
  }

  batchTemplateId = templateId;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];

  document.getElementById('batchTemplateName').textContent = tpl.name;
  document.getElementById('batchFileZone').className = 'batch-file-zone';
  document.getElementById('batchFileZone').innerHTML = '<span class="file-icon">ðŸ“„</span><span class="file-prompt">Click to select a CSV file or drag & drop here</span>';
  document.getElementById('batchMappingSection').style.display = 'none';
  document.getElementById('batchCreateBtn').style.display = 'none';
  document.getElementById('batchFileInput').value = '';

  // Set default job name
  const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  document.getElementById('batchJobName').value = tpl.name + ' â€” ' + today;

  document.getElementById('batchImportModal').classList.add('visible');
}

function closeBatchImportModal() {
  document.getElementById('batchImportModal').classList.remove('visible');
  batchTemplateId = null;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];
}

// Handle CSV file selection
function handleBatchFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  processBatchFile(file);
}

function processBatchFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    const parsed = parseCSV(text);
    if (!parsed || !parsed.rows.length) {
      showToast('Could not parse CSV file. Please check the format.', 'error');
      return;
    }
    batchCsvData = parsed;
    batchCsvFileName = file.name;

    // Update file zone
    const zone = document.getElementById('batchFileZone');
    zone.className = 'batch-file-zone has-file';
    zone.innerHTML = '<span class="file-name">âœ… ' + escapeHtml(file.name) + '</span>' +
      '<span class="file-info">' + parsed.rows.length + ' rows Ã— ' + parsed.headers.length + ' columns</span>';

    // Build column mapping
    buildBatchColMapping();
    updateBatchSummary();
    updateBatchPreview();

    document.getElementById('batchMappingSection').style.display = '';
    document.getElementById('batchCreateBtn').style.display = '';
  };
  reader.readAsText(file);
}

// Parse CSV text into { headers: [], rows: [[]] }
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  if (lines.length < 2) return null; // Need header + at least 1 row

  // Simple CSV parse (handles quoted fields)
  function parseLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += ch;
      }
    }
    result.push(current.trim());
    return result;
  }

  const headers = parseLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const row = parseLine(lines[i]);
    if (row.some(c => c)) rows.push(row); // Skip empty rows
  }

  return { headers, rows };
}

// Auto-map CSV columns to template tokens
function autoMapColumns(columns, tokens) {
  const mapping = new Array(columns.length).fill(null);
  const usedTokens = new Set();

  for (let c = 0; c < columns.length; c++) {
    const colLower = (columns[c] || '').toLowerCase().trim();
    // Try exact match first
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      if (colLower === token || colLower === token.replace(/_/g, ' ')) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
    if (mapping[c]) continue;
    // Try alias match
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      const aliases = TOKEN_ALIASES[token] || [];
      if (aliases.some(a => a === colLower)) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
  }
  return mapping;
}

// Build column-to-token mapping UI
function buildBatchColMapping() {
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl || !batchCsvData) return;

  const tokens = tpl.tokens || [];
  const headers = batchCsvData.headers;

  // Auto-map using existing autoMapColumns
  const autoMap = autoMapColumns(headers, tokens);
  batchColTokenMap = autoMap.slice(); // Copy

  let html = '';
  headers.forEach((header, idx) => {
    const autoToken = autoMap[idx] || '';
    html += '<div class="batch-col-row">' +
      '<span class="batch-col-header">' + escapeHtml(header || '(Column ' + (idx + 1) + ')') + '</span>' +
      '<span class="batch-col-arrow">â†’</span>' +
      '<select class="batch-col-token" onchange="updateBatchColMap(' + idx + ',this.value)">' +
        '<option value="">â€” Skip â€”</option>' +
        tokens.map(t => '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>').join('') +
      '</select>' +
    '</div>';
  });

  document.getElementById('batchColMapping').innerHTML = html;
}

function updateBatchColMap(colIdx, tokenName) {
  batchColTokenMap[colIdx] = tokenName || null;
  updateBatchSummary();
  updateBatchPreview();
}

function updateBatchSummary() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  const labelType = tpl?.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const rowCount = batchCsvData.rows.length;
  const sheetsNeeded = Math.ceil(rowCount / lps);
  const remainder = rowCount % lps;
  const unusedOnLast = remainder ? lps - remainder : 0;

  let html = '<div class="batch-summary-row"><span class="label">Records:</span><span class="value">' + rowCount + '</span></div>' +
    '<div class="batch-summary-row"><span class="label">Label type:</span><span class="value">Avery ' + labelType + ' (' + lps + '/sheet)</span></div>' +
    '<div class="batch-summary-row"><span class="label">Sheets needed:</span><span class="value">' + sheetsNeeded + '</span></div>';
  if (unusedOnLast > 0) {
    html += '<div class="batch-summary-row"><span class="label">Unused on last sheet:</span><span class="value">' + unusedOnLast + '</span></div>';
  }
  document.getElementById('batchSummary').innerHTML = html;
}

// Apply a template with record data
function applyTemplate(template, record) {
  const lines = template.text.split('\n');
  return lines.map(line => {
    const colonIdx = line.indexOf(':');
    if (colonIdx === -1) return line;
    const prefix = line.substring(0, colonIdx + 1);
    let content = line.substring(colonIdx + 1);
    // Replace tokens
    content = content.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, tokenName) => {
      const val = record[tokenName.toLowerCase()];
      return val !== undefined && val !== null ? val : '';
    });
    return prefix + content;
  }).join('\n');
}

function updateBatchPreview() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  // Build preview for first 3 records
  const previewRecords = batchCsvData.rows.slice(0, 3);
  const headers = batchCsvData.headers;

  let html = previewRecords.map((row, ridx) => {
    // Build record object
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx]) {
        record[token] = row[cidx];
      }
    });

    // Apply template
    const renderedText = applyTemplate(tpl, record);
    const lines = deserializeLines(renderedText);

    // Render as mini preview
    let previewHtml = lines.map(l => {
      if (!l.text) return '';
      const alignClass = 'align-' + (l.align || 'left');
      return '<div class="preview-line ' + alignClass + '">' + escapeHtml(l.text) + '</div>';
    }).join('');

    return '<div class="batch-preview-card">' + previewHtml + '</div>';
  }).join('');

  if (batchCsvData.rows.length > 3) {
    html += '<div class="batch-preview-more">+' + (batchCsvData.rows.length - 3) + ' more</div>';
  }

  document.getElementById('batchPreviewCards').innerHTML = html;
}

// Create the batch job
async function createBatchJob() {
  if (!batchCsvData || !batchTemplateId) return;

  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  const jobName = document.getElementById('batchJobName').value.trim() || 'Batch Job';
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const headers = batchCsvData.headers;

  // Build list data
  const list = batchCsvData.rows.map(row => {
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx] !== undefined) {
        record[token] = row[cidx];
      }
    });
    return record;
  });

  const sheetsNeeded = Math.ceil(list.length / lps);

  // Create job object
  const jobId = 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  activeJob = {
    id: jobId,
    templateId: batchTemplateId,
    name: jobName,
    csvFileName: batchCsvFileName || 'unknown.csv',
    list: list,
    labelType: labelType,
    sheetIds: [],
    printedRowIndices: [],
    status: 'active',
    createdAt: Date.now()
  };

  // Create job sheets
  for (let i = 0; i < sheetsNeeded; i++) {
    const sheetId = 'sh_job_' + Date.now() + '_' + i + '_' + Math.random().toString(36).substr(2, 4);
    const rowStart = i * lps;
    const rowEnd = Math.min((i + 1) * lps, list.length);

    sheets[sheetId] = {
      id: sheetId,
      name: jobName + ' #' + (i + 1),
      labelType: labelType,
      sheetCount: 1,
      printed: [],
      texts: {},
      // Job-specific properties
      jobId: jobId,
      jobSheetIndex: i,
      jobRowStart: rowStart,
      jobRowEnd: rowEnd
    };

    activeJob.sheetIds.push(sheetId);

    // Inventory: deduct from stock if tracked
    if (inventory[labelType]) {
      recordInventoryUse(labelType, 1, 'batch');
    }
  }

  saveActiveJob();
  saveSheets();
  closeBatchImportModal();

  // Switch to Sheets tab and select first job sheet
  activeSheetId = activeJob.sheetIds[0];
  sheetGridPages = {};
  switchTab('sheets');
  renderCurrentTab();

  showToast('Job created: ' + list.length + ' labels across ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : ''), 'success');
}

// Render active job banner
function renderJobBanner() {
  const container = document.getElementById('jobBannerArea');
  if (!container) return;

  if (!activeJob) {
    container.innerHTML = '';
    return;
  }

  const totalRows = activeJob.list.length;
  const printedRows = activeJob.printedRowIndices.length;
  const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;

  // Count sheets complete vs pending
  let sheetsComplete = 0;
  activeJob.sheetIds.forEach(shId => {
    const sh = sheets[shId];
    if (!sh) return;
    const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
    const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
    if (printedOnSheet >= rowsOnSheet) {
      sheetsComplete++;
    }
  });

  const html = '<div class="job-banner">' +
    '<div class="job-banner-header">' +
      '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
      '<div class="job-banner-actions">' +
        '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
        '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
      '</div>' +
    '</div>' +
    '<div class="job-banner-progress">' +
      '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
      '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
    '</div>' +
    '<div class="job-banner-info">' +
      '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
      '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
    '</div>' +
  '</div>';

  container.innerHTML = html;
}

// Print all job sheets
async function printJobAll() {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  if (!activeJob) return;

  const tpl = getBuiltinTemplate(activeJob.templateId) || savedTexts.find(s => s.id === activeJob.templateId);
  if (!tpl) {
    showToast('Template not found for this job.', 'error');
    return;
  }

  const labelType = activeJob.labelType;
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;

  // Build print map across all job sheets
  const pageSheets = [];

  activeJob.sheetIds.forEach((shId, shIdx) => {
    const sh = sheets[shId];
    if (!sh) return;

    const pageLabels = [];
    for (let rowIdx = sh.jobRowStart; rowIdx < sh.jobRowEnd; rowIdx++) {
      if (activeJob.printedRowIndices.includes(rowIdx)) continue; // Already printed

      const record = activeJob.list[rowIdx];
      const renderedText = applyTemplate(tpl, record);
      const lines = deserializeLines(renderedText);
      const localIdx = rowIdx - sh.jobRowStart;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;

      pageLabels.push({
        row, col,
        data: { lines, alignV: tpl.alignV || 'center', graphics: tpl.graphics },
        rowIdx: rowIdx
      });
    }

    if (pageLabels.length > 0) {
      pageSheets.push({ sheetId: shId, physicalSheet: shIdx, labels: pageLabels });
    }
  });

  if (!pageSheets.length) {
    showToast('All labels have already been printed.', 'success');
    showJobCompleteModal();
    return;
  }

  const totalLabels = pageSheets.reduce((sum, pg) => sum + pg.labels.length, 0);

  // Build unified print HTML using canonical buildSheetPrintHtml per sheet (G10 fix)
  // Collect all manifests, build HTML once via the canonical path
  const graphics = tpl.graphics || { left: null, right: null };
  const alignV = tpl.alignV || 'center';
  const border = tpl.border || null;

  let fullHtml = '';
  pageSheets.forEach(function(pg) {
    const sh = sheets[pg.sheetId];
    if (!sh) return;
    const manifest = pg.labels.map(function(lbl) {
      const localIdx = lbl.rowIdx - sh.jobRowStart;
      return { idx: localIdx, lines: lbl.data.lines, graphics: graphics, alignV: alignV, border: border };
    });
    // buildSheetPrintHtml returns a full document â€” extract just the body content
    const sheetHtml = buildSheetPrintHtml(sh, manifest);
    fullHtml = sheetHtml; // For single-sheet, use directly
  });

  // For multi-sheet jobs, we need to combine pages â€” rebuild using canonical per-sheet manifests
  if (pageSheets.length > 1) {
    // Build a combined manifest across all sheets
    // Each sheet gets its own buildSheetPrintHtml call, then we combine pages
    let allPagesBody = '';
    pageSheets.forEach(function(pg) {
      const sh = sheets[pg.sheetId];
      if (!sh) return;
      const manifest = pg.labels.map(function(lbl) {
        const localIdx = lbl.rowIdx - sh.jobRowStart;
        return { idx: localIdx, lines: lbl.data.lines, graphics: graphics, alignV: alignV, border: border };
      });
      const sheetHtml = buildSheetPrintHtml(sh, manifest);
      // Extract body content from the full HTML document
      const bodyMatch = sheetHtml.match(/<body>([\s\S]*)<\/body>/);
      if (bodyMatch) {
        allPagesBody += bodyMatch[1];
      }
    });
    // Extract head/CSS from first sheet's HTML for the wrapper
    const firstHtml = buildSheetPrintHtml(sheets[pageSheets[0].sheetId], []);
    const headMatch = firstHtml.match(/<head>([\s\S]*)<\/head>/);
    const headContent = headMatch ? headMatch[1] : '';
    fullHtml = '<!DOCTYPE html><html><head>' + headContent + '</head><body>' + allPagesBody + '</body></html>';
  }

  // Create and print iframe using canonical HTML
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);

  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(fullHtml);
  iframeDoc.close();

  iframe.contentWindow.focus();
  iframe.contentWindow.print();

  // Ask user if print was successful
  setTimeout(async () => {
    const printed = await showConfirmDialog(
      'Did the print complete successfully?',
      'Print ' + totalLabels + ' labels',
      'Yes, printed OK',
      'No, discard'
    );

    if (printed) {
      // Mark all printed rows
      pageSheets.forEach(pg => {
        pg.labels.forEach(lbl => {
          if (!activeJob.printedRowIndices.includes(lbl.rowIdx)) {
            activeJob.printedRowIndices.push(lbl.rowIdx);
          }
          // Mark position on sheet as printed
          const sh = sheets[pg.sheetId];
          if (sh) {
            const localIdx = lbl.rowIdx - sh.jobRowStart;
            if (!sh.printed.includes(localIdx)) {
              sh.printed.push(localIdx);
            }
          }
        });
      });

      saveActiveJob();
      saveSheets();

      // Add to print history
      addPrintHistoryEntry({
        textName: activeJob.name,
        labelType: labelType,
        count: totalLabels,
        type: 'batch'
      });

      renderCurrentTab();
      renderJobBanner();

      // Check if job is complete
      if (activeJob.printedRowIndices.length >= activeJob.list.length) {
        showJobCompleteModal();
      } else {
        showToast('Printed ' + totalLabels + ' labels', 'success');
      }
    }

    document.body.removeChild(iframe);
  }, 500);
}

function showJobCompleteModal() {
  if (!activeJob) return;
  
  const totalPrinted = activeJob.printedRowIndices.length;
  document.getElementById('jobCompleteCount').textContent = totalPrinted;
  
  // Check if there are remainder positions on last sheet
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];
  const spec = LABEL_TYPES[activeJob.labelType];
  const lps = spec.cols * spec.rows;
  const labelsOnLastSheet = lastSheet ? (lastSheet.jobRowEnd - lastSheet.jobRowStart) : lps;
  const hasRemainder = labelsOnLastSheet < lps;
  
  document.getElementById('jobRemainderOptions').style.display = hasRemainder ? '' : 'none';
  document.getElementById('jobCompleteModal').classList.add('visible');
}

function completeJob() {
  if (!activeJob) return;

  const keepRemainder = document.querySelector('input[name="jobRemainder"]:checked')?.value === 'keep';
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];

  // Save to job history
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'completed',
    completedAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  if (jobHistory.length > 50) jobHistory = jobHistory.slice(0, 50);
  saveJobHistory();

  if (keepRemainder && lastSheet) {
    // Convert last job sheet to regular sheet
    delete lastSheet.jobId;
    delete lastSheet.jobSheetIndex;
    delete lastSheet.jobRowStart;
    delete lastSheet.jobRowEnd;
    lastSheet.name = lastSheet.name.replace(/ #\d+$/, ' (partial)');
    // Delete other job sheets
    activeJob.sheetIds.slice(0, -1).forEach(shId => {
      delete sheets[shId];
    });
  } else {
    // Delete all job sheets
    activeJob.sheetIds.forEach(shId => {
      delete sheets[shId];
    });
  }

  // Clear active job
  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Close modal and refresh UI
  document.getElementById('jobCompleteModal').classList.remove('visible');

  // Select a non-job sheet if available
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job completed successfully!', 'success');
}

// Cancel the active job
async function cancelJob() {
  if (!activeJob) return;

  const ok = await showConfirmDialog(
    'Cancel the batch job "' + activeJob.name + '"? This will delete all job sheets and discard the print data.',
    'Cancel Job',
    'Yes, cancel job',
    'Keep job'
  );

  if (!ok) return;

  // Save to history as cancelled
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'cancelled',
    cancelledAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  saveJobHistory();

  // Delete all job sheets
  activeJob.sheetIds.forEach(shId => {
    // Return inventory stock
    const sh = sheets[shId];
    if (sh && inventory[sh.labelType]) {
      adjustInventory(sh.labelType, 1);
    }
    delete sheets[shId];
  });

  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Select a non-job sheet
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job cancelled', 'info');
}

// Drag and drop for file upload
document.addEventListener('DOMContentLoaded', function() {
  // Batch file zone drag/drop
  const batchZone = document.getElementById('batchFileZone');
  if (batchZone) {
    batchZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = 'var(--accent)';
        batchZone.style.background = 'var(--accent-bg)';
      }
    });
    batchZone.addEventListener('dragleave', function() {
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = '';
        batchZone.style.background = '';
      }
    });
    batchZone.addEventListener('drop', function(e) {
      e.preventDefault();
      batchZone.style.borderColor = '';
      batchZone.style.background = '';
      if (e.dataTransfer.files.length > 0 && !batchZone.classList.contains('has-file')) {
        processBatchFile(e.dataTransfer.files[0]);
      }
    });
  }
});

function confirmClearHistory() {
  showConfirm('Clear all print history? This cannot be undone.', 'Clear History', 'Clear', true, (confirmed) => {
    if (confirmed) {
      printHistory = [];
      savePrintHistory();
      showToast('History cleared', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// INVENTORY MANAGEMENT
// ============================================================================

let adjustingInventoryType = null;

function adjustInventory(typeId, delta) {
  if (!inventory[typeId]) return;
  inventory[typeId].stock = Math.max(0, (inventory[typeId].stock || 0) + delta);
  saveInventory();
  addInventoryEvent(typeId, 'adjust', delta, inventory[typeId].stock);
  renderCurrentTab();
}

function showAddInventoryModal() {
  const select = document.getElementById('addInventoryTypeSelect');
  const existingTypes = Object.keys(inventory);
  
  let html = '';
  for (const typeId of TYPE_ORDER) {
    if (existingTypes.includes(typeId)) continue; // Skip types already in inventory
    const spec = LABEL_TYPES[typeId];
    html += '<option value="' + typeId + '">' + typeId + ' â€” ' + spec.desc + ' (' + spec.sizeDisplay + ')</option>';
  }
  
  if (!html) {
    showToast('All label types are already in your inventory', 'info');
    return;
  }
  
  select.innerHTML = html;
  document.getElementById('addInventoryStock').value = 10;
  document.getElementById('addInventoryThreshold').value = DEFAULT_LOW_THRESHOLD;
  document.getElementById('addInventoryModal').classList.add('visible');
}

function closeAddInventoryModal() {
  document.getElementById('addInventoryModal').classList.remove('visible');
}

function saveAddInventory() {
  const typeId = document.getElementById('addInventoryTypeSelect').value;
  const stock = parseInt(document.getElementById('addInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('addInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[typeId] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  addInventoryEvent(typeId, 'add', stock, inventory[typeId].stock);
  
  // Also save as last used type
  settings.lastLabelType = typeId;
  saveSettings();
  
  closeAddInventoryModal();
  showToast('Inventory type added', 'success');
  renderCurrentTab();
}

function showAdjustInventoryModal(typeId) {
  adjustingInventoryType = typeId;
  const inv = inventory[typeId];
  const spec = LABEL_TYPES[typeId];
  
  document.getElementById('adjustInventoryTitle').textContent = 'Adjust Stock â€” ' + typeId;
  document.getElementById('adjustInventoryStock').value = inv ? inv.stock : 0;
  document.getElementById('adjustInventoryThreshold').value = inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD;
  document.getElementById('adjustInventoryModal').classList.add('visible');
}

function closeAdjustInventoryModal() {
  document.getElementById('adjustInventoryModal').classList.remove('visible');
  adjustingInventoryType = null;
}

function saveAdjustInventory() {
  if (!adjustingInventoryType) return;
  
  const oldStock = inventory[adjustingInventoryType] ? inventory[adjustingInventoryType].stock : 0;
  const stock = parseInt(document.getElementById('adjustInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('adjustInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[adjustingInventoryType] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  addInventoryEvent(adjustingInventoryType, 'set', stock - oldStock, inventory[adjustingInventoryType].stock);
  
  closeAdjustInventoryModal();
  showToast('Inventory updated', 'success');
  renderCurrentTab();
}

function confirmRemoveInventory(typeId) {
  const spec = LABEL_TYPES[typeId];
  showConfirm('Remove ' + typeId + ' (' + spec.desc + ') from inventory tracking?', 'Remove from Inventory', 'Remove', true, (confirmed) => {
    if (confirmed) {
      delete inventory[typeId];
      saveInventory();
      showToast('Removed from inventory', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// CONFIRM DIALOG
// ============================================================================

let confirmCallback = null;

function showConfirm(message, title, okText, isDanger, callback, cancelText) {
  document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
  document.getElementById('confirmModalMessage').textContent = message;
  const okBtn = document.getElementById('confirmModalOkBtn');
  okBtn.textContent = okText || 'OK';
  okBtn.className = 'wizard-btn wizard-btn-primary' + (isDanger ? ' danger' : '');
  const cancelBtn = document.getElementById('confirmModalCancelBtn');
  cancelBtn.textContent = cancelText || 'Cancel';
  confirmCallback = callback;
  document.getElementById('confirmModal').classList.add('visible');
}

// Promise-based confirm dialog
function showConfirmDialog(message, title, okText, cancelText) {
  return new Promise(resolve => {
    document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
    document.getElementById('confirmModalMessage').textContent = message;
    const okBtn = document.getElementById('confirmModalOkBtn');
    okBtn.textContent = okText || 'OK';
    okBtn.className = 'wizard-btn wizard-btn-primary';
    confirmCallback = resolve;
    document.getElementById('confirmModal').classList.add('visible');
  });
}

function closeConfirmModal(result) {
  document.getElementById('confirmModal').classList.remove('visible');
  if (confirmCallback) {
    confirmCallback(result);
    confirmCallback = null;
  }
}

// Generic modal for custom content
function showGenericModal(title, contentHtml, modalId, confirmCallback, confirmLabel) {
  let modal = document.getElementById(modalId);
  if (!modal) {
    modal = document.createElement('div');
    modal.id = modalId;
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 520px;">
        <div class="modal-header">
          <div class="modal-title" id="${modalId}Title">${escapeHtml(title)}</div>
          <button class="modal-close" onclick="closeGenericModal('${modalId}')">Ã—</button>
        </div>
        <div class="modal-body" id="${modalId}Body"></div>
        <div class="modal-btns" id="${modalId}Btns" style="display:none;margin-top:12px;padding:0 20px 16px;"></div>
      </div>
    `;
    document.body.appendChild(modal);
  } else {
    document.getElementById(modalId + 'Title').textContent = title;
  }
  
  document.getElementById(modalId + 'Body').innerHTML = contentHtml;
  
  // Optional confirm button
  const btnsEl = document.getElementById(modalId + 'Btns');
  if (confirmCallback && confirmLabel) {
    window['__genericModalConfirm_' + modalId] = confirmCallback;
    btnsEl.innerHTML = '<button class="btn btn-secondary" onclick="closeGenericModal(\'' + modalId + '\')">Cancel</button>' +
      '<button class="btn btn-primary" onclick="window[\'__genericModalConfirm_' + modalId + '\']()">' + escapeHtml(confirmLabel) + '</button>';
    btnsEl.style.display = 'flex';
    btnsEl.style.justifyContent = 'flex-end';
    btnsEl.style.gap = '8px';
  } else {
    btnsEl.style.display = 'none';
  }
  
  modal.classList.add('visible');
}

function closeGenericModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.remove('visible');
  }
}

// Prompt dialog for text input
let promptCallback = null;
function showPrompt(message, title, defaultValue, callback) {
  // Create prompt modal if it doesn't exist
  let modal = document.getElementById('promptModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'promptModal';
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 400px;">
        <div class="modal-header">
          <div class="modal-title" id="promptModalTitle">Enter Value</div>
          <button class="modal-close" onclick="closePromptModal(null)">Ã—</button>
        </div>
        <div class="modal-body">
          <div id="promptModalMessage" style="margin-bottom: 12px;"></div>
          <input type="text" id="promptModalInput" class="modal-input" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--input-bg); color: var(--text); font-size: 14px;">
        </div>
        <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 16px;">
          <button class="wizard-btn wizard-btn-secondary" onclick="closePromptModal(null)">Cancel</button>
          <button class="wizard-btn wizard-btn-primary" onclick="closePromptModal(document.getElementById('promptModalInput').value)">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    // Handle Enter key
    document.getElementById('promptModalInput').addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        closePromptModal(document.getElementById('promptModalInput').value);
      }
    });
  }
  
  document.getElementById('promptModalTitle').textContent = title || 'Enter Value';
  document.getElementById('promptModalMessage').textContent = message;
  document.getElementById('promptModalInput').value = defaultValue || '';
  promptCallback = callback;
  modal.classList.add('visible');
  setTimeout(() => document.getElementById('promptModalInput').focus(), 100);
}

function closePromptModal(result) {
  document.getElementById('promptModal').classList.remove('visible');
  if (promptCallback) {
    promptCallback(result);
    promptCallback = null;
  }
}

// ============================================================================
// WELCOME / FIRST RUN
// ============================================================================

function checkFirstRun() {
  const firstRunDone = localStorage.getItem(FIRST_RUN_KEY);
  if (firstRunDone === 'done') {
    return false; // Not first run
  }
  return true;
}

function showWelcome() {
  const stats = getDataStats();
  const hasExistingData = stats.sheets > 0 || stats.savedTexts > 0 || stats.inventory > 0;
  
  // Show data status if there's existing data
  const statusEl = document.getElementById('welcomeDataStatus');
  const itemsEl = document.getElementById('welcomeDataItems');
  const setupBtn = document.getElementById('welcomeSetupBtn');
  
  if (hasExistingData) {
    statusEl.style.display = 'block';
    let html = '';
    if (stats.sheets > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“„ ' + stats.sheets + ' sheet' + (stats.sheets !== 1 ? 's' : '') + '</div>';
    }
    if (stats.savedTexts > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ’¾ ' + stats.savedTexts + ' saved text' + (stats.savedTexts !== 1 ? 's' : '') + '</div>';
    }
    if (stats.templates > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“ ' + stats.templates + ' template' + (stats.templates !== 1 ? 's' : '') + '</div>';
    }
    if (stats.inventory > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“¦ ' + stats.inventory + ' inventory type' + (stats.inventory !== 1 ? 's' : '') + '</div>';
    }
    itemsEl.innerHTML = html;
    setupBtn.style.display = 'none'; // Already has data
  } else {
    statusEl.style.display = 'none';
    setupBtn.style.display = 'block'; // Offer setup wizard
  }
  
  document.getElementById('welcomeModal').classList.add('visible');
}

function closeWelcome(markComplete) {
  document.getElementById('welcomeModal').classList.remove('visible');
  if (markComplete) {
    localStorage.setItem(FIRST_RUN_KEY, 'done');
  }
}

function showSetupWizardFromWelcome() {
  closeWelcome(true);
  setTimeout(() => {
    switchTab('inventory');
    showToast('Add your label types using the button above', 'info');
  }, 100);
}

// Keyboard Shortcuts Modal
function showShortcutsModal() {
  document.getElementById('shortcutsModal').classList.add('visible');
}

function closeShortcutsModal() {
  document.getElementById('shortcutsModal').classList.remove('visible');
}

// Reset welcome screen (for testing)
function resetWelcome() {
  localStorage.removeItem(FIRST_RUN_KEY);
  showWelcome();
}

// ============================================================================
// TOAST NOTIFICATIONS
// ============================================================================

function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  
  const icons = {
    success: 'âœ“',
    error: 'âœ•',
    warning: 'âš ',
    info: 'â„¹'
  };
  
  toast.innerHTML = '<span class="toast-icon">' + (icons[type] || icons.info) + '</span>' +
                    '<span class="toast-message">' + escapeHtml(message) + '</span>';
  
  container.appendChild(toast);
  
  // Auto remove
  setTimeout(() => {
    toast.classList.add('exiting');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, duration);
  
  return toast;
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

function safeExecute(fn, errorMessage) {
  try {
    return fn();
  } catch (e) {
    console.error(errorMessage || 'Error:', e);
    showToast(errorMessage || 'Something went wrong', 'error');
    return null;
  }
}

// Wrap localStorage operations with error handling
function safeSave(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (e) {
    console.error('Failed to save data:', e);
    if (e.name === 'QuotaExceededError') {
      showToast('Storage is full. Some data may not be saved.', 'error', 5000);
    } else {
      showToast('Failed to save data', 'error');
    }
    return false;
  }
}

function safeLoad(key, defaultValue) {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultValue;
  } catch (e) {
    console.error('Failed to load data:', e);
    return defaultValue;
  }
}

// ============================================================================
// DATA EXPORT / IMPORT
// ============================================================================

function exportAllData() {
  const data = {
    version: '3.17.0',
    exportedAt: new Date().toISOString(),
    settings: settings,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    printHistory: printHistory,
    customTokens: customTokens
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'labelkeeper-backup-' + new Date().toISOString().slice(0, 10) + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  showToast('Data exported successfully', 'success');
}

function importData(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      
      // Validate it's a LabelKeeper backup
      if (!data.version || !data.exportedAt) {
        showToast('Invalid backup file', 'error');
        return;
      }
      
      // Confirm import
      showConfirm(
        'Import will merge with existing data. Continue?',
        'Import Data',
        'Import',
        false,
        (confirmed) => {
          if (confirmed) {
            performImport(data);
          }
        }
      );
    } catch (err) {
      showToast('Failed to read backup file', 'error');
    }
  };
  reader.readAsText(file);
}

function performImport(data) {
  try {
    // Merge sheets
    if (data.sheets) {
      for (const [id, sheet] of Object.entries(data.sheets)) {
        if (!sheets[id]) {
          sheets[id] = sheet;
        }
      }
      saveSheets();
    }
    
    // Merge saved texts (by ID to avoid duplicates)
    if (data.savedTexts) {
      const existingIds = new Set(savedTexts.map(t => t.id));
      for (const text of data.savedTexts) {
        if (!existingIds.has(text.id)) {
          savedTexts.push(text);
        }
      }
      saveSavedTexts();
    }
    
    // Merge inventory
    if (data.inventory) {
      for (const [type, inv] of Object.entries(data.inventory)) {
        if (!inventory[type]) {
          inventory[type] = inv;
        }
      }
      saveInventory();
    }
    
    // Merge print history
    if (data.printHistory) {
      const existingIds = new Set(printHistory.map(p => p.id));
      for (const entry of data.printHistory) {
        if (!existingIds.has(entry.id)) {
          printHistory.push(entry);
        }
      }
      // Sort by timestamp descending
      printHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      savePrintHistory();
    }
    
    // Merge inventory history (G8)
    if (data.inventoryHistory && Array.isArray(data.inventoryHistory)) {
      const existingTs = new Set(inventoryHistory.map(e => e.ts));
      for (const entry of data.inventoryHistory) {
        if (!existingTs.has(entry.ts)) {
          inventoryHistory.push(entry);
        }
      }
      inventoryHistory.sort((a, b) => a.ts - b.ts);
      saveInventoryHistory();
    }
    
    showToast('Data imported successfully', 'success');
    renderCurrentTab();
  } catch (err) {
    console.error('Import error:', err);
    showToast('Failed to import data', 'error');
  }
}

// ============================================================================
// DEVICE SYNC (Firebase-based, no auth required)
// ============================================================================

const FIREBASE_SYNC_URL = 'https://word-boxing-default-rtdb.firebaseio.com/labelkeeper_sync';
const SYNC_CODE_LENGTH = 6;
const SYNC_EXPIRY_MS = 5 * 60 * 1000; // 5 minutes

// Generate a random sync code
function generateSyncCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Avoid confusing chars like 0/O, 1/I
  let code = '';
  for (let i = 0; i < SYNC_CODE_LENGTH; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Show sync modal
function showSyncModal(title, content) {
  document.getElementById('syncModalTitle').textContent = title;
  document.getElementById('syncModalBody').innerHTML = content;
  document.getElementById('syncModal').classList.add('visible');
}

function closeSyncModal() {
  document.getElementById('syncModal').classList.remove('visible');
}

// Start sharing data to another device
async function startSyncShare() {
  const code = generateSyncCode();
  
  // Show loading state
  showSyncModal('Share to Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare data
  const data = {
    version: '3.17.0',
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    customTokens: customTokens
  };
  
  try {
    // Upload to Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    // Show the code
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your other device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your other device:</strong><br>
          Settings â†’ Receive from Another Device â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    // Schedule cleanup after expiry
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Sync share error:', err);
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// Cleanup sync code from Firebase
async function cleanupSyncCode(code) {
  try {
    await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'DELETE'
    });
  } catch (err) {
    console.log('Cleanup failed (may already be deleted):', err);
  }
}

// Start receiving data from another device
function startSyncReceive() {
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your other device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receiveSyncData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receiveSyncData()">Receive Data</button>
    </div>
  `);
  
  // Focus the input
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Receive data using the entered code
async function receiveSyncData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  // Show loading
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data...</div>
    </div>
  `);
  
  try {
    // Fetch from Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    // Check expiry
    if (data.expiresAt && Date.now() > data.expiresAt) {
      // Clean up expired data
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate data structure
    if (!data.version || !data.exportedAt) {
      throw new Error('Invalid sync data');
    }
    
    // Show confirmation with stats
    const sheetCount = data.sheets ? Object.keys(data.sheets).length : 0;
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">ðŸ“¦</div>
        <div style="font-size: 16px; margin-bottom: 16px;">Ready to import:</div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ“„ ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} saved text${textCount !== 1 ? 's' : ''}</div>
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          This will merge with your existing data.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmSyncImport()">Import Data</button>
      </div>
    `);
    
    // Store data temporarily for confirmation
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Sync receive error:', err);
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
          Make sure the code is correct and hasn't expired.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="startSyncReceive()">Try Again</button>
      </div>
    `);
  }
}

// Confirm and perform the sync import
function confirmSyncImport() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  // Use existing import logic
  performImport(data);
  
  // Clean up the sync code from Firebase
  cleanupSyncCode(code);
  
  // Clear temp data
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  showToast('Data synced successfully!', 'success');
}

// ============================================================================
// PRIMARY/SATELLITE SYNC SYSTEM
// ============================================================================

// Set device role (called from settings UI)
function setDeviceRole(role) {
  if (role !== 'primary' && role !== 'satellite') return;
  
  const oldRole = settings.deviceRole;
  
  // Block switching from satellite to primary via toggle
  // Primary role can only be acquired via transfer code
  if (oldRole === 'satellite' && role === 'primary') {
    showToast('Primary role can only be received via Transfer from the current primary device', 'info');
    return;
  }
  
  // Switching from primary to satellite requires confirmation
  if (oldRole === 'primary' && role === 'satellite') {
    showConfirm(
      'Switch this device to satellite mode?\n\nYou will no longer be able to print. To get primary back, you\'ll need a transfer from whatever device holds the primary role.',
      'Switch to Satellite',
      'Switch',
      true,
      (confirmed) => {
        if (confirmed) {
          settings.deviceRole = 'satellite';
          saveSettings();
          updateDeviceRoleUI();
          updateWorkflowsForRole();
          showToast('Satellite mode: Content capture only, printing disabled', 'info');
        }
      }
    );
    return;
  }
}

// Update the device role selector UI
function updateDeviceRoleUI() {
  const role = settings.deviceRole || 'primary';
  
  // Update role selector buttons
  document.querySelectorAll('.device-role-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.role === role);
  });
  
  // Show/hide appropriate sync UI
  const primaryUI = document.getElementById('syncPrimaryUI');
  const satelliteUI = document.getElementById('syncSatelliteUI');
  
  if (primaryUI) primaryUI.style.display = role === 'primary' ? 'block' : 'none';
  if (satelliteUI) satelliteUI.style.display = role === 'satellite' ? 'block' : 'none';
  
  // Update satellite pending list if in satellite mode
  if (role === 'satellite') {
    updateSatellitePendingUI();
  }
}

// Update satellite pending list UI
function updateSatellitePendingUI() {
  const pending = getSatellitePending();
  const countEl = document.getElementById('satellitePendingCount');
  const listEl = document.getElementById('satellitePendingList');
  
  if (countEl) countEl.textContent = pending.length;
  
  if (listEl) {
    if (pending.length === 0) {
      listEl.innerHTML = '<div class="satellite-pending-empty">No pending items to sync</div>';
    } else {
      listEl.innerHTML = pending.map(id => {
        const text = savedTexts.find(t => t.id === id);
        const name = text ? (text.name || text.text.substring(0, 30) + '...') : id;
        return `
          <div class="satellite-pending-item">
            <span class="satellite-pending-name">${escapeHtml(name)}</span>
            <button class="satellite-pending-delete" onclick="deletePendingItem('${id}')" title="Delete">ðŸ—‘ï¸</button>
          </div>
        `;
      }).join('');
    }
  }
}

// Delete a pending item (only in satellite mode, before sync)
function deletePendingItem(id) {
  if (settings.deviceRole !== 'satellite') return;
  
  const pending = getSatellitePending();
  if (!pending.includes(id)) {
    showToast("Can't delete - already synced", 'error');
    return;
  }
  
  showConfirm(
    'Delete this item? It will be removed from the pending queue.',
    'Delete Pending Item',
    'Delete',
    true,
    (confirmed) => {
      if (confirmed) {
        deleteSavedText(id);
        updateSatellitePendingUI();
        renderCurrentTab();
        showToast('Item deleted', 'success');
      }
    }
  );
}

// Update workflows based on device role
function updateWorkflowsForRole() {
  const isSatellite = settings.deviceRole === 'satellite';
  
  // Find and update workflow cards
  const workflowCards = document.querySelectorAll('.workflow-card');
  workflowCards.forEach(card => {
    const onclick = card.getAttribute('onclick') || '';
    
    // Disable print, mailing, reprint, setup in satellite mode
    const isPrimaryOnly = onclick.includes("'print'") || 
                          onclick.includes("'mailing'") || 
                          onclick.includes("'reprint'") ||
                          onclick.includes("'setup'");
    
    if (isPrimaryOnly) {
      card.classList.toggle('disabled', isSatellite);
      
      // Add or update primary-only badge
      let badge = card.querySelector('.primary-only-badge');
      if (!badge && isSatellite) {
        badge = document.createElement('div');
        badge.className = 'primary-only-badge';
        badge.textContent = 'Primary device only';
        card.querySelector('.workflow-content').appendChild(badge);
      }
    }
  });
}

// SATELLITE: Share pending content to primary
async function satelliteShareToPrimary() {
  const pending = getSatellitePending();
  
  if (pending.length === 0) {
    showToast('No pending items to share', 'info');
    return;
  }
  
  const code = generateSyncCode();
  
  // Show loading state
  showSyncModal('Share to Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare data - only pending items
  const pendingTexts = savedTexts.filter(t => pending.includes(t.id));
  
  const data = {
    version: '3.17.0',
    type: 'satellite_contribution',
    storeId: getOrCreateStoreId(),
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    savedTexts: pendingTexts,
    pendingIds: pending
  };
  
  try {
    // Upload to Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    // Show the code
    showSyncModal('Share to Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your primary device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Sharing ${pendingTexts.length} item${pendingTexts.length !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your primary device:</strong><br>
          Settings â†’ Receive from Satellite â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    // Store code for potential clear after confirmed sync
    window._lastSatelliteShareCode = code;
    
    // Schedule cleanup after expiry
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Satellite share error:', err);
    showSyncModal('Share to Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// SATELLITE: Receive full state from primary
function satelliteReceiveFromPrimary() {
  showSyncModal('Receive from Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your primary device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receivePrimaryData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receivePrimaryData()">Receive Data</button>
    </div>
  `);
  
  // Focus the input
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Satellite receives data from primary
async function receivePrimaryData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  // Show loading
  showSyncModal('Receive from Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data from primary...</div>
    </div>
  `);
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    // Check expiry
    if (data.expiresAt && Date.now() > data.expiresAt) {
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate - should be primary share or transfer data
    if (data.type === 'satellite_contribution') {
      throw new Error('This is satellite data. Use "Receive from Satellite" on your primary device.');
    }
    
    // Check if this is a primary transfer
    const isTransfer = data.type === 'primary_transfer';
    
    // Check if this device has existing data that will be overwritten
    const localSheetCount = Object.keys(sheets).length;
    const localTextCount = savedTexts.length;
    const hasLocalData = localSheetCount > 0 || localTextCount > 0;
    
    // Show confirmation
    const sheetCount = data.sheets ? Object.keys(data.sheets).length : 0;
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    const pending = getSatellitePending();
    
    showSyncModal(isTransfer ? 'Receive Primary Transfer' : 'Receive from Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">${isTransfer ? 'ðŸ‘‘' : 'ðŸ“¦'}</div>
        <div style="font-size: 16px; margin-bottom: 16px;">
          ${isTransfer ? 'Ready to become the new primary device:' : 'Ready to import from primary:'}
        </div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ“„ ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} saved text${textCount !== 1 ? 's' : ''}</div>
        </div>
        ${hasLocalData ? `
          <div style="font-size: 13px; color: var(--error-text); background: var(--error-bg); padding: 10px; border-radius: var(--radius-sm); margin-bottom: 12px;">
            âš ï¸ <strong>Warning:</strong> This device has ${localSheetCount} sheet${localSheetCount !== 1 ? 's' : ''} and ${localTextCount} saved text${localTextCount !== 1 ? 's' : ''} that will be <strong>replaced</strong> by the incoming data.
          </div>
        ` : ''}
        ${isTransfer ? `
          <div style="font-size: 13px; color: var(--success-text); background: var(--success-bg); padding: 8px; border-radius: var(--radius-sm);">
            âœ… This device will become the PRIMARY and can print labels
          </div>
        ` : ''}
        ${pending.length > 0 && !isTransfer ? `
          <div style="font-size: 13px; color: var(--warning-text); background: var(--warning-bg); padding: 8px; border-radius: var(--radius-sm);">
            âš ï¸ Your ${pending.length} pending item${pending.length !== 1 ? 's' : ''} will be preserved
          </div>
        ` : ''}
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmSatelliteReceive()">
          ${isTransfer ? 'Accept Primary Role' : (hasLocalData ? 'Replace My Data' : 'Import Data')}
        </button>
      </div>
    `);
    
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Satellite receive error:', err);
    showSyncModal('Receive from Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="satelliteReceiveFromPrimary()">Try Again</button>
      </div>
    `);
  }
}

// Confirm satellite receive - merge primary data while preserving pending
function confirmSatelliteReceive() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  const isTransfer = data.type === 'primary_transfer';
  const pending = getSatellitePending();
  
  // Get pending items BEFORE we overwrite (only relevant if NOT a transfer)
  const pendingItems = isTransfer ? [] : savedTexts.filter(t => pending.includes(t.id));
  
  // Replace with primary data (full state)
  if (data.sheets) {
    sheets = data.sheets;
    saveSheets();
  }
  
  if (data.savedTexts) {
    savedTexts = [...data.savedTexts];
    // Add back pending items that aren't in primary yet (only if not a transfer)
    if (!isTransfer) {
      for (const item of pendingItems) {
        if (!savedTexts.find(t => t.id === item.id)) {
          savedTexts.push(item);
        }
      }
    }
    saveSavedTexts();
  }
  
  if (data.inventory) {
    inventory = data.inventory;
    saveInventory();
  }
  
  if (data.inventoryHistory) {
    inventoryHistory = data.inventoryHistory;
    saveInventoryHistory();
  }
  
  if (data.printHistory) {
    printHistory = data.printHistory;
    savePrintHistory();
  }
  
  if (data.activeSheetId) {
    activeSheetId = data.activeSheetId;
    localStorage.setItem(ACTIVE_KEY, activeSheetId);
  }
  
  // If this is a transfer, become primary and clear pending queue
  if (isTransfer) {
    settings.deviceRole = 'primary';
    saveSettings();
    saveSatellitePending([]); // Clear any pending items
  }
  
  // Cleanup
  cleanupSyncCode(code);
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  updateDeviceRoleUI();
  updateWorkflowsForRole();
  updateSatellitePendingUI();
  renderCurrentTab();
  
  if (isTransfer) {
    showToast('ðŸŽ‰ This device is now the primary! You can print labels.', 'success');
  } else {
    showToast('Data synced from primary!', 'success');
  }
}

// PRIMARY: Receive contributions from satellite
function primaryReceiveFromSatellite() {
  showSyncModal('Receive from Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your satellite device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receiveSatelliteData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receiveSatelliteData()">Receive Data</button>
    </div>
  `);
  
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Primary receives data from satellite
async function receiveSatelliteData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  showSyncModal('Receive from Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data from satellite...</div>
    </div>
  `);
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    if (data.expiresAt && Date.now() > data.expiresAt) {
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate - should be satellite contribution
    if (data.type !== 'satellite_contribution') {
      throw new Error('This is not satellite data. Make sure your satellite device used "Share to Primary".');
    }
    
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    const storeId = data.storeId || 'unknown';
    
    showSyncModal('Receive from Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">ðŸ“±</div>
        <div style="font-size: 16px; margin-bottom: 16px;">Content from satellite:</div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} new item${textCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 12px; color: var(--text-muted); margin-top: 4px;">From: ${storeId}</div>
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          This will add new content to your library.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmPrimaryReceive()">Import Content</button>
      </div>
    `);
    
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Primary receive error:', err);
    showSyncModal('Receive from Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="primaryReceiveFromSatellite()">Try Again</button>
      </div>
    `);
  }
}

// Confirm primary receive from satellite - append new content
function confirmPrimaryReceive() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  // Append satellite texts (don't replace)
  if (data.savedTexts) {
    const existingIds = new Set(savedTexts.map(t => t.id));
    let addedCount = 0;
    for (const text of data.savedTexts) {
      if (!existingIds.has(text.id)) {
        savedTexts.push(text);
        addedCount++;
      }
    }
    saveSavedTexts();
  }
  
  cleanupSyncCode(code);
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  renderCurrentTab();
  showToast('Content imported from satellite!', 'success');
}

// PRIMARY: Share full state to satellite
async function primaryShareToSatellite() {
  const code = generateSyncCode();
  
  showSyncModal('Share to Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare full state data
  const data = {
    version: '3.17.0',
    type: 'primary_share',
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    customTokens: customTokens
  };
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    const sheetCount = Object.keys(sheets).length;
    const textCount = savedTexts.length;
    
    showSyncModal('Share to Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your satellite device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Sharing ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}, ${textCount} text${textCount !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your satellite device:</strong><br>
          Settings â†’ Receive from Primary â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Primary share error:', err);
    showSyncModal('Share to Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// Clear satellite pending queue after successful sync confirmation
function clearSatellitePendingAfterSync() {
  saveSatellitePending([]);
  updateSatellitePendingUI();
}

// PRIMARY: Transfer primary role to another device
async function primaryTransferRole() {
  // Show confirmation first
  showConfirm(
    'This will transfer primary status to another device. After the transfer completes, THIS device will become a satellite and will no longer be able to print. Are you sure?',
    'Transfer Primary Role',
    'Transfer',
    true,
    async (confirmed) => {
      if (!confirmed) return;
      
      const code = generateSyncCode();
      
      showSyncModal('Transfer Primary Role', `
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
          <div>Preparing transfer code...</div>
        </div>
      `);
      
      // Prepare transfer data - includes full state + transfer flag
      const data = {
        version: '3.17.0',
        type: 'primary_transfer',
        exportedAt: new Date().toISOString(),
        expiresAt: Date.now() + SYNC_EXPIRY_MS,
        sheets: sheets,
        activeSheetId: activeSheetId,
        savedTexts: savedTexts,
        inventory: inventory,
        customTokens: customTokens,
        printHistory: printHistory
      };
      
      try {
        const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        if (!response.ok) {
          throw new Error('Failed to upload transfer data');
        }
        
        const sheetCount = Object.keys(sheets).length;
        const textCount = savedTexts.length;
        
        showSyncModal('Transfer Primary Role', `
          <div style="text-align: center; padding: 20px;">
            <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
              Enter this code on the device that will become the new primary:
            </div>
            <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
              ${code}
            </div>
            <div style="font-size: 13px; color: var(--text-muted);">
              Transferring ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}, ${textCount} text${textCount !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
            </div>
            <div style="margin-top: 16px; padding: 12px; background: var(--warning-bg); border-radius: var(--radius-sm);">
              <div style="font-size: 13px; color: var(--warning-text);">
                âš ï¸ After the new device receives this transfer, click "Complete Transfer" below to convert this device to satellite mode.
              </div>
            </div>
          </div>
          <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
            <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
            <button class="wizard-btn wizard-btn-primary" onclick="completeTransferToSatellite()">Complete Transfer</button>
          </div>
        `);
        
        setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
        
      } catch (err) {
        console.error('Primary transfer error:', err);
        showSyncModal('Transfer Primary Role', `
          <div style="text-align: center; padding: 20px;">
            <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
            <div style="color: var(--error-text);">Failed to create transfer code. Please try again.</div>
            <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
          </div>
          <div style="display: flex; justify-content: center; margin-top: 16px;">
            <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
          </div>
        `);
      }
    }
  );
}

// Complete transfer - convert this device to satellite
function completeTransferToSatellite() {
  settings.deviceRole = 'satellite';
  saveSettings();
  
  closeSyncModal();
  updateDeviceRoleUI();
  updateWorkflowsForRole();
  
  showToast('This device is now a satellite. Printing disabled.', 'info');
}

// ============================================================================
// CLEAR ALL DATA
// ============================================================================

function clearAllData() {
  showConfirm(
    'This will delete ALL your data including sheets, saved texts, and history. This cannot be undone.',
    'Clear All Data',
    'Delete Everything',
    true,
    (confirmed) => {
      if (confirmed) {
        // Clear all storage keys
        localStorage.removeItem(SHEETS_KEY);
        localStorage.removeItem(ACTIVE_KEY);
        localStorage.removeItem(TEXTS_KEY);
        localStorage.removeItem(INVENTORY_KEY);
        localStorage.removeItem(INVENTORY_HISTORY_KEY);
        localStorage.removeItem(PRINT_HISTORY_KEY);
        localStorage.removeItem(CUSTOM_TOKENS_KEY);
        localStorage.removeItem(ACTIVE_JOB_KEY);
        localStorage.removeItem(JOB_HISTORY_KEY);
        localStorage.removeItem(FIRST_RUN_KEY);
        
        // Reset state
        sheets = {};
        activeSheetId = null;
        savedTexts = [];
        inventory = {};
        inventoryHistory = [];
        printHistory = [];
        customTokens = [];
        
        showToast('All data cleared', 'success');
        renderCurrentTab();
      }
    }
  );
}

// ========== EVENT HANDLERS ==========
document.addEventListener('keydown', e => {
  // Don't trigger shortcuts when typing in input fields
  const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement?.tagName);
  
  if (e.key === 'Escape') {
    closeSettings();
    closeShortcutsModal();
    // Close any open workflows on Escape
    const wf1El = document.getElementById('wf1Wizard');
    const wf2El = document.getElementById('wf2Wizard');
    if (wf1El && wf1El.classList.contains('visible')) {
      wf1Close();
    } else if (wf2El && wf2El.classList.contains('visible')) {
      wf2Close();
    }
    // Close modals on Escape
    if (document.getElementById('splitModal').classList.contains('visible')) {
      closeSimpleModal('splitModal');
    }
    if (document.getElementById('importTextModal').classList.contains('visible')) {
      closeModal('importTextModal');
    }
  }
  
  // ? key shows shortcuts help (when not typing)
  if (e.key === '?' && !isTyping) {
    showShortcutsModal();
  }
});

// Split modal Enter key handler
document.getElementById('splitName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeSplit();
});

// Import modal Enter key handler  
document.getElementById('importBaseName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeImport();
});
document.getElementById('importBaseName').addEventListener('input', () => updateImportPreview());

document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', e => {
    if (e.target === overlay) {
      overlay.classList.remove('visible');
    }
  });
});

// ============================================================================
// INITIALIZATION
// ============================================================================

function init() {
  // Load all data
  loadSettings();
  loadSheets();
  loadSavedTexts();
  loadInventory();
  loadInventoryHistory();
  loadActiveJob();
  loadJobHistory();
  loadCustomTokens();
  loadPrintHistory();
  
  // Apply UI state
  applyTheme();
  
  // Update workflows based on device role (primary/satellite)
  updateWorkflowsForRole();
  
  // Render Quick Actions section (T10-T11)
  renderQuickActions();
  
  // Show AI prompt if key is configured
  updateAIKeyStatusUI();
  
  // Check for URL parameters (deep linking)
  const urlParams = parseUrlParams();
  if (urlParams.hasParams) {
    // Small delay to let UI render
    setTimeout(() => handleUrlDeepLink(urlParams), 150);
  } else {
    // Check for first run only if not deep linking
    if (checkFirstRun()) {
      // Small delay to let the UI render first
      setTimeout(showWelcome, 100);
    }
  }
  
  // Log stats for debugging
  const stats = getDataStats();
  console.log('LabelKeeper v3.17.0 initialized', stats);
}

/**
 * Handle URL deep link parameters
 * Opens print wizard with pre-filled data or navigates to a sheet
 */
function handleUrlDeepLink(params) {
  console.log('Deep link detected:', params);
  
  // Clear URL params to prevent re-triggering on reload
  if (window.history.replaceState) {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
  
  // Handle sheet deep link (from QR code)
  if (params.action === 'openSheet' && params.sheetId) {
    console.log('Opening sheet:', params.sheetId);
    const sh = sheets[params.sheetId];
    if (sh) {
      // Set active sheet first
      activeSheetId = params.sheetId;
      // Switch to sheets tab (this will render the tab)
      switchTab('sheets');
      // Give DOM more time to render, then scroll to the sheet
      setTimeout(() => {
        const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + params.sheetId + '"]');
        console.log('Found sheet card:', sheetCard);
        if (sheetCard) {
          sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add highlight animation
          sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
          setTimeout(() => {
            sheetCard.style.boxShadow = '';
          }, 2000);
        }
        showToast('Opened "' + sh.name + '"', 'success');
      }, 300);
    } else {
      console.log('Sheet not found in sheets object:', Object.keys(sheets));
      showToast('Sheet not found on this device. QR codes only work on the device where the sheet was created.', 'warning', 6000);
    }
    return;
  }
  
  // Handle print deep link â€” route through WF1
  // Set label type if provided
  if (params.type) {
    settings.lastLabelType = params.type;
    saveSettings();
  }
  
  // Start WF1 and let user proceed through the new workflow
  wf1Start();
  
  // If we have content lines from the deep link, populate the editor after WF1 opens
  if (params.lines && params.lines.some(function(l) { return l.trim(); })) {
    setTimeout(function() {
      // Build content lines from params
      const deepLinkLines = [];
      for (let i = 0; i < Math.min(params.lines.length, 4); i++) {
        deepLinkLines.push({
          text: params.lines[i] || '',
          align: 'left',
          fontSize: 11
        });
      }
      wf1PopulateEditorFromLines(deepLinkLines);
      showToast('Content loaded from link', 'success');
    }, 200);
  } else {
    showToast('Deep link opened â€” choose your label type to start', 'info');
  }
}

init();
</script>
</body>
</html>
