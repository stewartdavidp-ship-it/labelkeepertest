<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="gs-app-id" content="labelkeeper">
<meta name="version" content="3.27.7">

<!-- App Meta Tags -->
<meta name="description" content="Print labels without wasting a single position. Track which spots on your label sheets have been used.">
<meta name="theme-color" content="#1a1a1a">

<title>LabelKeeper</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&family=Dancing+Script:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Caveat:wght@400;700&family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Oswald:wght@400;600&family=Pacifico&family=Lobster&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f5f5f0;
  --surface: #ffffff;
  --surface-alt: #fafaf8;
  --text: #1a1a1a;
  --text-secondary: #4a4a4a;
  --text-muted: #777;
  --text-faint: #aaa;
  --border: #e0e0dc;
  --border-light: #eaeae6;
  --input-bg: #ffffff;
  --input-border: #d0d0cc;
  --heading: #0a0a0a;
  --accent: #2563eb;
  --accent-hover: #1d4ed8;
  --accent-bg: #eff4ff;
  --accent-text: #1e52c0;
  --success-bg: #ecfdf5;
  --success-text: #047a56;
  --success-border: #a7f3d0;
  --warning-bg: #fffbeb;
  --warning-text: #b45309;
  --warning-border: #fcd34d;
  --error-bg: #fef2f2;
  --error-text: #dc2626;
  --error-border: #fca5a5;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
  --radius: 12px;
  --radius-sm: 8px;
  --mono: 'JetBrains Mono', monospace;
}

[data-theme="dark"] {
  --bg: #0c0c10;
  --surface: #1a1a22;
  --surface-alt: #141418;
  --text: #eaeaee;
  --text-secondary: #b8b8c0;
  --text-muted: #8888a0;
  --text-faint: #606078;
  --border: #2e2e3a;
  --border-light: #242430;
  --input-bg: #1e1e28;
  --input-border: #3a3a48;
  --heading: #f8f8fc;
  --accent: #6c9eff;
  --accent-hover: #90b8ff;
  --accent-bg: #1c2440;
  --accent-text: #90b8ff;
  --success-bg: #0d2818;
  --success-text: #5cf0c0;
  --success-border: #208868;
  --warning-bg: #2d2006;
  --warning-text: #ffd85c;
  --warning-border: #c07820;
  --error-bg: #2d0a0a;
  --error-text: #ffa0a0;
  --error-border: #dc3838;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow: 0 2px 8px rgba(0,0,0,0.4);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.5);
}

body {
  font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

/* ===== APP SHELL ===== */
.app-shell {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* ===== HEADER ===== */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0 24px;
}

.app-title {
  font-size: 22px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 10px;
  letter-spacing: -0.02em;
}

.app-title .version {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-faint);
  font-family: var(--mono);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-btn {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--text-secondary);
  transition: all 0.15s;
  box-shadow: var(--shadow-sm);
}

.icon-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== WORKFLOW HUB ===== */
.workflow-hub {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.workflow-heading {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.workflow-cards-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

@media (max-width: 480px) {
  .workflow-cards-row {
    grid-template-columns: 1fr;
  }
}

.workflow-card-primary {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 24px 20px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  gap: 8px;
  box-shadow: var(--shadow-sm);
}

.workflow-card-primary:hover {
  border-color: var(--accent);
  box-shadow: var(--shadow);
  transform: translateY(-2px);
}

.workflow-card-primary:active {
  transform: translateY(0);
}

.workflow-card-primary:first-child {
  border-left: 3px solid var(--accent);
}

.workflow-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: var(--shadow-sm);
}

.workflow-card:hover {
  border-color: var(--accent);
  box-shadow: var(--shadow);
  transform: translateY(-1px);
}

.workflow-card:active {
  transform: translateY(0);
}

.workflow-icon {
  font-size: 32px;
  flex-shrink: 0;
}

.workflow-content {
  flex: 1;
  min-width: 0;
}

.workflow-title {
  font-size: 17px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.workflow-desc {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.4;
}

.workflow-arrow {
  font-size: 20px;
  color: var(--text-faint);
  transition: transform 0.2s, color 0.2s;
}

.workflow-card:hover .workflow-arrow,
.workflow-card-primary:hover .workflow-arrow {
  color: var(--accent);
  transform: translateX(4px);
}

/* ===== AI CONVERSATIONAL PROMPT ===== */
.workflow-ai-prompt {
  margin-top: 4px;
}

.ai-conv-input-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  transition: border-color 0.2s;
}

.ai-conv-input-row:focus-within {
  border-color: var(--accent);
}

.ai-conv-sparkle {
  font-size: 18px;
  flex-shrink: 0;
}

.ai-conv-input {
  flex: 1;
  border: none;
  background: transparent;
  font-family: inherit;
  font-size: 15px;
  color: var(--text-primary);
  outline: none;
  padding: 6px 0;
}

.ai-conv-input::placeholder {
  color: var(--text-faint);
  font-style: italic;
}

.ai-conv-send {
  flex-shrink: 0;
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: none;
  background: var(--accent);
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  font-size: 16px;
}

.ai-conv-send:hover {
  background: var(--accent-hover, var(--accent));
  transform: scale(1.05);
}

.ai-conv-send:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.ai-conv-send-icon {
  font-weight: 700;
}

.ai-conv-suggestions {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.ai-conv-chip {
  padding: 5px 12px;
  font-size: 12px;
  font-family: inherit;
  border: 1px solid var(--border);
  border-radius: 100px;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.ai-conv-chip:hover {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-bg);
}

.ai-conv-status {
  margin-top: 10px;
}

.ai-conv-thinking {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: var(--accent-bg);
  border-radius: var(--radius);
  font-size: 13px;
  color: var(--text-secondary);
}

.ai-conv-response {
  margin-top: 10px;
  padding: 14px 16px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-primary);
}

.ai-conv-response .ai-conv-msg {
  margin-bottom: 10px;
}

.ai-conv-response .ai-conv-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.ai-conv-action-btn {
  padding: 8px 16px;
  font-size: 13px;
  font-family: inherit;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-conv-action-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.ai-conv-action-btn.primary {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.ai-conv-action-btn.primary:hover {
  opacity: 0.9;
}

.ai-conv-error {
  color: var(--error-text, #ef4444);
  font-size: 13px;
  margin-top: 4px;
}

/* ===== QUICK LINKS ===== */
.workflow-quick-links {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  padding-top: 8px;
  border-top: 1px solid var(--border);
}

.workflow-quick-label {
  font-size: 12px;
  color: var(--text-faint);
  margin-right: 2px;
}

.workflow-quick-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 100px;
  padding: 5px 14px;
  font-size: 12px;
  font-family: inherit;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
}

.workflow-quick-btn:hover {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-bg);
}

/* Quick Actions section (T10-T11) */
.quick-actions-section {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}

.quick-actions-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 10px;
}

.quick-actions-label {
  font-size: 12px;
  color: var(--text-faint);
  font-weight: 500;
}

.quick-actions-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.quick-action-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.15s;
}

.quick-action-item:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.quick-action-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.quick-action-content {
  flex: 1;
  min-width: 0;
}

.quick-action-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.quick-action-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 1px;
}

.quick-action-badge {
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-bg);
  color: var(--accent);
  flex-shrink: 0;
}

.quick-actions-empty {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
  padding: 8px 0;
}

/* ===== AI CATEGORY MODAL ===== */
.ai-category-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  margin-bottom: 16px;
}

.ai-category-card {
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.ai-category-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: translateY(-2px);
}

.ai-category-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.ai-category-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.ai-category-desc {
  font-size: 11px;
  color: var(--text-muted);
  line-height: 1.3;
}

/* AI Category Form */
.ai-form-section {
  margin-bottom: 16px;
}

.ai-form-label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: block;
}

.ai-form-input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
}

.ai-form-input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-bg);
}

.ai-form-input::placeholder {
  color: var(--text-faint);
}

.ai-form-textarea {
  min-height: 80px;
  resize: vertical;
}

.ai-form-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-form-row {
  display: flex;
  gap: 12px;
}

.ai-form-row .ai-form-section {
  flex: 1;
}

/* AI Quick suggestions */
.ai-suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}

/* Generic button styles for AI modals */
.btn {
  padding: 12px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border-color: var(--border);
}

.btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ai-suggestion-chip {
  padding: 6px 10px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-size: 12px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-suggestion-chip:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent-text);
}

/* ===== TAB BAR (Power Mode) ===== */
/* Desktop: Top tab bar */
.tab-bar {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--border);
  margin-bottom: 24px;
  overflow-x: auto;
}

/* Mobile: Bottom tab bar */
@media (max-width: 767px) {
  .tab-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-bottom: none;
    border-top: 1px solid var(--border);
    margin-bottom: 0;
    padding: 0;
    padding-bottom: env(safe-area-inset-bottom, 0);
    z-index: 100;
    justify-content: space-around;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
  }
  
  .app-shell {
    padding-bottom: 70px; /* Space for bottom nav */
  }
}

/* Hide workflow hub when not on workflows tab */
.workflow-hub {
  display: none;
}

.workflow-hub.active {
  display: flex;
}

.tab-btn {
  padding: 12px 18px;
  border: none;
  background: none;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  position: relative;
  transition: color 0.2s;
  white-space: nowrap;
}

.tab-btn:hover {
  color: var(--text);
}

.tab-btn.active {
  color: var(--accent);
}

/* Desktop: underline indicator */
.tab-btn.active::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  height: 2px;
  background: var(--accent);
}

/* Mobile: icon-style tabs */
@media (max-width: 767px) {
  .tab-btn {
    flex: 1;
    padding: 10px 8px;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  
  .tab-btn::before {
    font-size: 20px;
  }
  
  .tab-btn[data-tab="workflows"]::before { content: 'ðŸ '; }
  .tab-btn[data-tab="sheets"]::before { content: 'ðŸ“„'; }
  .tab-btn[data-tab="saved"]::before { content: 'ðŸ’¾'; }
  .tab-btn[data-tab="templates"]::before { content: 'ðŸ“'; }
  .tab-btn[data-tab="inventory"]::before { content: 'ðŸ“¦'; }
  .tab-btn[data-tab="history"]::before { content: 'ðŸ“œ'; }
  
  .tab-btn.active::after {
    display: none;
  }
}

/* ===== TAB PANELS ===== */
.tab-panel {
  display: none;
  animation: fadeIn 0.2s ease;
}

.tab-panel.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}

.panel-placeholder {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-muted);
}

.panel-placeholder-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.panel-placeholder-text {
  font-size: 15px;
}

/* ===== TAB CONTENT LIST ===== */
.tab-content-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.list-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 18px;
  cursor: pointer;
  transition: all 0.15s;
}

.list-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.builtin {
  opacity: 0.8;
}

.list-card.low {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

.list-card.empty {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.list-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.list-card-meta {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.badge {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--text-faint);
  color: var(--surface);
}

/* ===== TAB HEADERS ===== */
.tab-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 12px;
}

.tab-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.tab-actions {
  display: flex;
  gap: 8px;
}

.tab-action-btn {
  padding: 8px 14px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: background 0.15s;
}

.tab-action-btn:hover {
  background: var(--accent-hover);
}

.tab-action-btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 2px solid var(--border);
}

/* Template filter tabs */
.template-filter-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.template-filter-btn {
  flex: 1;
  padding: 10px 16px;
  background: var(--surface);
  color: var(--text-muted);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.template-filter-btn:hover {
  background: var(--surface-hover);
  color: var(--text);
}

.template-filter-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.style-category-header {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  padding: 12px 0 6px 0;
  border-bottom: 1px solid var(--border);
  margin-bottom: 8px;
}

.tab-action-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

/* ===== SHEET CARDS (Enhanced) ===== */
.sheet-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  transition: all 0.15s;
}

.sheet-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.sheet-card.highlight-flash {
  animation: highlightFlash 1.5s ease-out;
}

@keyframes highlightFlash {
  0% { background: var(--accent); border-color: var(--accent); }
  100% { background: var(--surface); border-color: var(--border); }
}

.saved-card.highlight-flash {
  animation: highlightFlash 1.5s ease-out;
}

.sheet-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}

.sheet-card-info {
  flex: 1;
  min-width: 0;
}

.sheet-card-name {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 4px;
}

.sheet-card-type {
  font-size: 13px;
  color: var(--text-muted);
}

.sheet-note-display {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
  padding: 6px 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin: 8px 12px 0;
}

.sheet-card-actions {
  display: flex;
  gap: 4px;
}

.sheet-card-btn {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.sheet-card-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.sheet-card-btn.danger:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

/* Sheet Grid Preview */
.sheet-grid {
  display: grid;
  gap: 2px;
  background: var(--border);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 2px;
}

.sheet-grid-cell {
  background: var(--surface);
  aspect-ratio: 1;
  min-width: 8px;
  border-radius: 2px;
}

.sheet-grid-cell.clickable {
  cursor: pointer;
  transition: all 0.15s;
}

.sheet-grid-cell.clickable:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  background: var(--border);
}

.sheet-grid-cell.printed {
  background: var(--text-faint);
}

.sheet-grid-cell.printed.clickable:hover {
  background: var(--text-muted);
}

.sheet-grid-cell.queued {
  background: var(--accent);
}

.sheet-stats {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sheet-stat-value {
  font-weight: 600;
  color: var(--heading);
}

/* ===== ASSIGNED TEXTS (Sheet-Content Relationship) ===== */
.assigned-texts-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.assigned-texts-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.assigned-texts-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
}

.assigned-texts-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.assigned-text-row {
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface-alt);
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.15s;
}

.assigned-text-row:hover {
  border-color: var(--accent);
}

.assigned-text-row.has-error {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.assigned-text-color {
  width: 6px;
  height: 32px;
  border-radius: 3px;
  flex-shrink: 0;
}

.assigned-text-info {
  flex: 1;
  min-width: 0;
}

.assigned-text-name {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.assigned-text-spots {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.assigned-text-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.assigned-text-placement {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 12px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M3 5l3 3 3-3'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 6px center;
  padding-right: 24px;
}

.assigned-text-placement:focus {
  outline: none;
  border-color: var(--accent);
}

.assigned-text-qty {
  display: flex;
  align-items: center;
}

.assigned-text-qty .qty-btn {
  width: 28px;
  height: 28px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

.assigned-text-qty .qty-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.assigned-text-qty .qty-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.assigned-text-qty .qty-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.assigned-text-qty .qty-val {
  min-width: 36px;
  height: 28px;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--heading);
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.assigned-text-remove {
  background: var(--input-bg);
  border: 1px solid var(--border);
  font-size: 14px;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin-left: 8px;
}

.assigned-text-remove:hover {
  color: var(--error-text);
  background: var(--error-bg);
  border-color: var(--error-border);
}

.assigned-texts-empty {
  padding: 12px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  border: 1px dashed var(--border);
  border-radius: var(--radius-sm);
}

.assigned-add-btn {
  font-size: 12px;
  padding: 4px 10px;
}

/* Sheet Print Actions */
.sheet-print-actions {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sheet-print-actions > div:first-child:not(.sheet-secondary-actions) {
  display: flex;
  align-items: center;
  gap: 12px;
}

.sheet-secondary-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 4px;
}

.sheet-print-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.15s;
}

.sheet-print-btn:hover:not(:disabled) {
  background: var(--accent-hover);
}

.sheet-print-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.sheet-print-summary {
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-print-error {
  font-size: 12px;
  color: var(--error-text);
  margin-top: 8px;
}

/* Multi-sheet grid container */
.sheet-grids-container {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: flex-start;
}

.sheet-grid-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.sheet-grid-label {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 500;
}

/* Sheet grid pagination (for many sheets) */
.sheet-grid-pagination {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.sheet-grid-page-btn {
  background: var(--input-bg);
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.15s;
}

.sheet-grid-page-btn:hover:not(:disabled) {
  border-color: var(--accent);
  color: var(--accent);
}

.sheet-grid-page-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.sheet-grid-page-info {
  font-size: 12px;
  color: var(--text-muted);
}

/* Text colors for grid visualization */
.text-color-0 { background: #6366f1; }
.text-color-1 { background: #ec4899; }
.text-color-2 { background: #14b8a6; }
.text-color-3 { background: #f59e0b; }
.text-color-4 { background: #8b5cf6; }
.text-color-5 { background: #ef4444; }
.text-color-6 { background: #22c55e; }
.text-color-7 { background: #3b82f6; }

/* Cell colors for grid visualization (match text colors) */
.sheet-grid-cell.cell-color-0 { background: #6366f1; }
.sheet-grid-cell.cell-color-1 { background: #ec4899; }
.sheet-grid-cell.cell-color-2 { background: #14b8a6; }
.sheet-grid-cell.cell-color-3 { background: #f59e0b; }
.sheet-grid-cell.cell-color-4 { background: #8b5cf6; }
.sheet-grid-cell.cell-color-5 { background: #ef4444; }
.sheet-grid-cell.cell-color-6 { background: #22c55e; }
.sheet-grid-cell.cell-color-7 { background: #3b82f6; }

/* ===== SAVED CONTENT CARDS (Enhanced) ===== */
.saved-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  transition: all 0.15s;
  cursor: pointer;
}

.saved-card:hover {
  border-color: var(--accent);
}

.saved-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.saved-card-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.saved-card-preview {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.saved-card-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
}

.saved-card:hover .saved-card-actions {
  opacity: 1;
}

/* ===== HISTORY CARDS (Enhanced) ===== */
.history-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 14px;
  transition: all 0.15s;
}

.history-card:hover {
  border-color: var(--accent);
}

/* T2: Prominent multi-select indicator */
.history-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 2px var(--accent);
}

.history-card.selected .history-card-icon {
  opacity: 1;
}

.history-card-icon {
  font-size: 24px;
  opacity: 0.6;
}

.history-card-info {
  flex: 1;
  min-width: 0;
}

.history-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 2px;
}

.history-card-meta {
  font-size: 13px;
  color: var(--text-muted);
}

.history-card-action {
  padding: 8px 12px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.history-card-action:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== REPRINT LIST ===== */
.reprint-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 400px;
  overflow-y: auto;
  padding: 4px;
}

/* ===== INVENTORY CARDS ===== */
.inventory-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 12px;
}

.inventory-card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
}

.inventory-card-type {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.inventory-card-name {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.inventory-card-desc {
  font-size: 13px;
  color: var(--text-muted);
}

.inventory-card-status {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 20px;
}

.inventory-card-status.inv-ok {
  background: var(--success-bg);
  color: var(--success-text);
}

.inventory-card-status.inv-low {
  background: var(--warning-bg);
  color: var(--warning-text);
}

.inventory-card-status.inv-empty {
  background: var(--error-bg);
  color: var(--error-text);
}

.inventory-card-body {
  display: flex;
  gap: 24px;
  margin-bottom: 16px;
}

.inventory-stat {
  text-align: center;
}

.inventory-stat-value {
  font-size: 28px;
  font-weight: 700;
  font-family: var(--mono);
  color: var(--heading);
  line-height: 1;
}

.inventory-stat-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

.inventory-card-actions {
  display: flex;
  gap: 8px;
}

.inventory-adjust-btn {
  padding: 8px 14px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.inventory-adjust-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.inventory-adjust-btn.wide {
  flex: 1;
}

.inventory-adjust-btn.danger:hover {
  border-color: var(--error-text);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== PRINT INVENTORY WARNING ===== */
.print-inv-warning {
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  margin-top: 12px;
}

.print-inv-warning.warning {
  background: var(--warning-bg);
  color: var(--warning-text);
  border: 1px solid var(--warning-border);
}

.print-inv-warning.error {
  background: var(--error-bg);
  color: var(--error-text);
  border: 1px solid var(--error-border);
}

/* ===== SIMPLE MODAL (for edit/create) ===== */
.simple-modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.simple-modal-overlay.visible {
  display: flex;
}

.simple-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.simple-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.simple-modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.simple-modal-body {
  padding: 20px 24px;
}

.simple-modal-footer {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  padding: 16px 24px;
  border-top: 1px solid var(--border-light);
}

.form-group {
  margin-bottom: 16px;
}

.form-label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.form-input {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

.form-select {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.form-hint {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* ===== WELCOME / FIRST RUN ===== */
.welcome-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.welcome-overlay.visible {
  display: flex;
}

.welcome-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 480px;
  max-height: 90vh;
  overflow-y: auto;
  text-align: center;
}

.welcome-header {
  padding: 40px 30px 20px;
  background: linear-gradient(135deg, var(--accent-bg), transparent);
  border-bottom: 1px solid var(--border-light);
}

.welcome-icon {
  font-size: 56px;
  margin-bottom: 16px;
}

.welcome-title {
  font-size: 26px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.welcome-version {
  font-size: 13px;
  font-family: var(--mono);
  color: var(--text-muted);
}

.welcome-body {
  padding: 24px 30px;
}

.welcome-tagline {
  font-size: 16px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 24px;
}

.welcome-features {
  display: flex;
  flex-direction: column;
  gap: 12px;
  text-align: left;
  margin-bottom: 24px;
}

.welcome-feature {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.welcome-feature-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.welcome-feature-text {
  font-size: 14px;
  color: var(--text);
  line-height: 1.4;
}

.welcome-feature-text strong {
  color: var(--heading);
}

.welcome-data-status {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 20px;
  text-align: left;
}

.welcome-data-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.welcome-data-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.welcome-data-item {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 13px;
  color: var(--text-muted);
  background: var(--surface);
  padding: 4px 10px;
  border-radius: 12px;
  border: 1px solid var(--border-light);
}

.welcome-data-item.has-data {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.welcome-footer {
  padding: 20px 30px 30px;
}

.welcome-btn-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.welcome-btn {
  width: 100%;
  padding: 14px 20px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.welcome-btn-primary {
  background: var(--accent);
  color: #fff;
}

.welcome-btn-primary:hover {
  background: var(--accent-hover);
}

.welcome-btn-secondary {
  background: var(--surface);
  border: 2px solid var(--border);
  color: var(--text-secondary);
}

.welcome-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.welcome-skip {
  margin-top: 8px;
  font-size: 13px;
  color: var(--text-muted);
  cursor: pointer;
  background: none;
  border: none;
  font-family: inherit;
}

.welcome-skip:hover {
  color: var(--accent);
  text-decoration: underline;
}

/* ===== TOAST NOTIFICATIONS ===== */
.toast-container {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 3000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
}

.toast {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 20px;
  box-shadow: var(--shadow-lg);
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  color: var(--text);
  animation: toastSlideIn 0.3s ease;
  pointer-events: auto;
  max-width: 90vw;
}

.toast.success {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.toast.error {
  background: var(--error-bg);
  border-color: var(--error-border);
  color: var(--error-text);
}

.toast.warning {
  background: var(--warning-bg);
  border-color: var(--warning-border);
  color: var(--warning-text);
}

.toast-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.toast.exiting {
  animation: toastSlideOut 0.3s ease forwards;
}

@keyframes toastSlideIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes toastSlideOut {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(20px); }
}

/* ===== MOBILE TOUCH IMPROVEMENTS ===== */
@media (max-width: 600px) {
  .workflow-card {
    padding: 18px;
    min-height: 80px;
  }
  
  .wizard-btn {
    min-height: 48px;
    padding: 14px 20px;
  }
  
  .icon-btn {
    width: 44px;
    height: 44px;
  }
  
  .tab-btn {
    padding: 14px 16px;
  }
  
  .form-input, .form-select {
    padding: 14px 12px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  .secondary-link {
    padding: 12px 16px;
  }
  
  .setup-stock-btn {
    width: 52px;
    height: 52px;
    font-size: 22px;
  }
  
  .welcome-modal {
    max-width: 100%;
    border-radius: var(--radius-sm);
  }
  
  .welcome-header {
    padding: 30px 20px 16px;
  }
  
  .welcome-body {
    padding: 20px;
  }
  
  .welcome-footer {
    padding: 16px 20px 24px;
  }
}

/* ===== SAFE AREA (for notched devices) ===== */
@supports (padding: max(0px)) {
  .app-shell {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
  
  .toast-container {
    bottom: max(24px, calc(env(safe-area-inset-bottom) + 16px));
  }
}

/* ===== MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.visible {
  display: flex;
}

.modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 400px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.modal-close {
  width: 32px;
  height: 32px;
  border: none;
  background: none;
  font-size: 20px;
  color: var(--text-muted);
  cursor: pointer;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-close:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.modal-body {
  padding: 20px 24px;
}

/* ===== SETTINGS ===== */
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 0;
  border-bottom: 1px solid var(--border-light);
}

.setting-row:last-child {
  border-bottom: none;
}

.setting-label {
  font-size: 15px;
  font-weight: 500;
  color: var(--text);
}

.setting-desc {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* Toggle Switch */
.toggle {
  width: 48px;
  height: 28px;
  background: var(--border);
  border-radius: 14px;
  position: relative;
  cursor: pointer;
  transition: background 0.2s;
  flex-shrink: 0;
}

.toggle.active {
  background: var(--accent);
}

.toggle-thumb {
  width: 22px;
  height: 22px;
  background: white;
  border-radius: 50%;
  position: absolute;
  top: 3px;
  left: 3px;
  transition: transform 0.2s;
  box-shadow: var(--shadow-sm);
}

.toggle.active .toggle-thumb {
  transform: translateX(20px);
}

/* Barcode UI */
.barcode-analysis-box {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-size: 13px;
}

.barcode-analysis-box .analysis-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background 0.15s;
}

.barcode-analysis-box .analysis-item:hover:not(.disabled) {
  background: var(--surface);
}

.barcode-analysis-box .analysis-item.selected {
  background: var(--accent-bg);
}

.barcode-analysis-box .analysis-item.available {
  color: var(--text);
}

.barcode-analysis-box .analysis-item.unavailable,
.barcode-analysis-box .analysis-item.disabled {
  color: var(--text-muted);
  cursor: not-allowed;
  opacity: 0.6;
}

.barcode-analysis-box .barcode-type-radio {
  font-size: 14px;
  width: 16px;
  text-align: center;
  color: var(--accent);
}

.barcode-analysis-box .analysis-suggestion {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border);
  color: var(--accent-text);
  font-size: 12px;
}

.barcode-position-selector {
  display: flex;
  gap: 8px;
}

.barcode-pos-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 10px 8px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: 12px;
  color: var(--text-secondary);
  transition: all 0.15s;
}

.barcode-pos-btn:hover {
  border-color: var(--accent);
  color: var(--text);
}

.barcode-pos-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.barcode-pos-btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

.barcode-pos-btn .pos-icon {
  font-size: 18px;
}

.settings-divider {
  height: 1px;
  background: var(--border);
  margin: 20px 0;
}

.settings-section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 16px;
}

.settings-section-collapsible {
  cursor: pointer;
  padding: 8px 0;
  margin: -8px 0;
  border-radius: var(--radius-sm);
  transition: background 0.15s;
}

.settings-section-collapsible:hover {
  background: var(--surface-alt);
}

.settings-warning-box {
  display: flex;
  gap: 12px;
  padding: 12px 14px;
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  border-radius: var(--radius-sm);
  font-size: 12px;
  line-height: 1.5;
}

.settings-warning-icon {
  font-size: 16px;
  flex-shrink: 0;
}

.settings-warning-text {
  color: var(--warning-text);
}

.settings-warning-text strong {
  font-weight: 600;
}

.backup-status-box {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  border-radius: var(--radius-sm);
  font-size: 13px;
  margin-bottom: 12px;
}

.backup-status-box.status-ok {
  background: var(--success-bg);
  border: 1px solid var(--success-border);
  color: var(--success-text);
}

.backup-status-box.status-warning {
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  color: var(--warning-text);
}

.backup-status-box.status-never {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  color: var(--text-muted);
}

.backup-status-icon {
  font-size: 16px;
  flex-shrink: 0;
}

.backup-status-text {
  flex: 1;
  line-height: 1.4;
}

.backup-status-text strong {
  font-weight: 600;
}

.settings-data-stats {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-bottom: 16px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 13px;
  color: var(--text-muted);
}

.settings-data-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.settings-data-stat strong {
  color: var(--text);
  font-weight: 600;
}

.settings-btn-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.settings-action-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.settings-action-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.settings-action-btn.secondary {
  background: var(--surface-alt);
}

.settings-action-btn.danger:hover {
  border-color: var(--error-border);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== DEVICE ROLE SELECTOR ===== */
.device-role-selector {
  display: flex;
  gap: 12px;
  margin-top: 8px;
}

.device-role-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.2s;
}

.device-role-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.device-role-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.device-role-btn .role-icon {
  font-size: 24px;
  margin-bottom: 8px;
}

.device-role-btn .role-name {
  font-weight: 600;
  color: var(--text);
  font-size: 14px;
}

.device-role-btn .role-desc {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.device-role-btn.active .role-name {
  color: var(--accent-text);
}

/* Satellite pending list */
.satellite-pending-list {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 8px;
  max-height: 150px;
  overflow-y: auto;
}

.satellite-pending-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  background: var(--surface);
  border-radius: var(--radius-sm);
  margin-bottom: 4px;
}

.satellite-pending-item:last-child {
  margin-bottom: 0;
}

.satellite-pending-name {
  font-size: 13px;
  color: var(--text);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.satellite-pending-delete {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px 8px;
  font-size: 14px;
  border-radius: 4px;
}

.satellite-pending-delete:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.satellite-pending-empty {
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  padding: 12px;
}

/* Satellite mode indicator */
.satellite-mode-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: var(--warning-bg);
  color: var(--warning-text);
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
}

/* Workflow card disabled state */
.workflow-card.disabled {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
}

.workflow-card .primary-only-badge {
  display: none;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.workflow-card.disabled .primary-only-badge {
  display: block;
}

/* ===== AI PROMPT MODAL ===== */
.ai-prompt-section {
  margin-bottom: 4px;
}

.ai-prompt-box {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-family: var(--mono);
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  color: var(--text-secondary);
  max-height: 200px;
  overflow-y: auto;
  margin-bottom: 12px;
}

.ai-prompt-copy-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  border: 2px solid var(--accent);
  border-radius: var(--radius-sm);
  background: var(--accent-bg);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--accent-text);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-prompt-copy-btn:hover {
  background: var(--accent);
  color: white;
}

.ai-prompt-divider {
  height: 1px;
  background: var(--border-light);
  margin: 20px 0;
}

.ai-prompt-steps {
  margin: 0;
  padding-left: 20px;
  color: var(--text-secondary);
  font-size: 13px;
  line-height: 1.8;
}

.ai-prompt-steps li {
  margin-bottom: 4px;
}

.ai-prompt-example {
  user-select: all;
}

/* Keyboard Shortcuts Modal */
.shortcuts-section {
  margin-bottom: 20px;
}

.shortcuts-section:last-child {
  margin-bottom: 0;
}

.shortcuts-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.shortcut-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--border-light);
}

.shortcut-row:last-child {
  border-bottom: none;
}

.shortcut-key {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
}

.shortcut-desc {
  font-size: 13px;
  color: var(--text-secondary);
}

/* ===== FULL EDITOR MODAL (ported from v1.2.0) ===== */
.full-editor-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 1000;
  overflow-y: auto;
}

.full-editor-overlay.visible {
  display: block;
}

.full-editor-container {
  max-width: 700px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

.full-editor-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 24px;
}

.full-editor-back {
  width: 40px;
  height: 40px;
  border: 2px solid var(--border);
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.full-editor-back:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.full-editor-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.full-editor-subtitle {
  font-size: 13px;
  color: var(--text-muted);
}

.full-editor-panel {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 16px;
}

.full-editor-section-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

/* Line input rows */
.fe-line-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}

.fe-line-num {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  width: 16px;
  text-align: center;
  flex-shrink: 0;
  font-family: var(--mono);
}

.fe-line-input {
  flex: 1;
  padding: 10px 12px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 15px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.2s;
  min-width: 0;
}

.fe-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-line-input::placeholder {
  color: var(--text-faint);
  font-size: 13px;
}

.fe-align-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
}

.fe-align-btn:hover {
  border-color: var(--accent);
}

.fe-align-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-size-stepper {
  display: flex;
  align-items: center;
  flex-shrink: 0;
}

.fe-size-btn {
  width: 26px;
  height: 36px;
  border: 2px solid var(--border);
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-size-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.fe-size-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.fe-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-size-val {
  width: 32px;
  height: 36px;
  border-top: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.fe-style-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
  position: relative;
}

.fe-style-btn:hover {
  border-color: var(--accent);
}

.fe-style-btn.has-styles {
  color: var(--accent);
  border-color: var(--accent);
}

.fe-style-btn.popover-open {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Style popover */
.fe-style-popover {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  z-index: 100;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  margin-top: 6px;
  box-shadow: var(--shadow-lg);
  min-width: 220px;
}

.fe-style-popover.open {
  display: block;
}

.fe-popover-section {
  margin-bottom: 10px;
}

.fe-popover-section:last-child {
  margin-bottom: 0;
}

.fe-popover-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 6px;
}

.fe-style-toggles {
  display: flex;
  gap: 6px;
}

.fe-style-toggle {
  width: 36px;
  height: 34px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-style-toggle:hover {
  border-color: var(--accent);
}

.fe-style-toggle.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-style-toggle .lbl-b { font-weight: 800; }
.fe-style-toggle .lbl-i { font-style: italic; font-family: Georgia, serif; }
.fe-style-toggle .lbl-u { text-decoration: underline; }
.fe-style-toggle .lbl-s { text-decoration: line-through; }

/* Font selector in style popover */
.fe-font-select {
  width: 100%;
  padding: 6px 8px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text);
  font-size: 12px;
  cursor: pointer;
  font-family: inherit;
}

.fe-font-select:hover {
  border-color: var(--accent);
}

.fe-font-select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Style Template Dropdown */
.fe-style-template-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px 12px;
  background: var(--accent-bg);
  border-radius: 8px;
  border: 1px solid var(--border);
}

.fe-style-template-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  white-space: nowrap;
}

.fe-style-template-select {
  flex: 1;
  padding: 8px 10px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text);
  font-size: 13px;
  cursor: pointer;
  font-family: inherit;
  min-width: 0;
}

.fe-style-template-select:hover {
  border-color: var(--accent);
}

.fe-style-template-select:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-style-template-select optgroup {
  font-weight: 600;
  color: var(--text-secondary);
}

.fe-style-template-select option {
  font-weight: 400;
  color: var(--text);
  padding: 4px;
}

.fe-style-template-info {
  font-size: 11px;
  color: var(--text-muted);
  padding: 6px 0;
}

/* Style Template Editor mode indicator */
.fe-style-editor-notice {
  background: var(--accent-bg);
  border: 2px solid var(--accent);
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 12px;
  font-size: 12px;
  color: var(--accent);
}

.fe-style-editor-notice strong {
  display: block;
  margin-bottom: 4px;
}

/* Text inputs disabled in style editor mode */
.fe-line-input.style-editor-disabled {
  background: var(--surface-alt);
  color: var(--text-muted);
  cursor: not-allowed;
  font-style: italic;
}

.fe-color-palette {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.fe-color-swatch {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid var(--border);
  transition: all 0.15s;
}

.fe-color-swatch:hover {
  border-color: var(--accent);
  transform: scale(1.1);
}

.fe-color-swatch.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent);
}

.fe-color-swatch.swatch-none {
  background: var(--surface);
  position: relative;
}

.fe-color-swatch.swatch-none::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 50%;
  width: 2px;
  height: calc(100% - 6px);
  background: var(--error-text);
  transform: rotate(45deg);
}

/* Line hint */
.fe-line-hint {
  font-size: 12px;
  color: var(--text-faint);
  margin-top: 4px;
  padding-left: 22px;
}

.fe-line-hint code {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 1px 4px;
  font-size: 11px;
  font-family: var(--mono);
}

/* Token Panel */
.fe-token-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  padding-left: 22px;
}

.fe-token-toggle {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

.fe-token-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-toggle.active {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-panel {
  display: none;
  margin-top: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}

.fe-token-panel.visible {
  display: block;
}

.fe-token-category {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 10px;
  margin-bottom: 6px;
}

.fe-token-category:first-child {
  margin-top: 0;
}

.fe-token-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 4px;
}

.fe-token-chip {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  font-size: 12px;
  font-family: var(--mono);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-chip:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-token-custom-row {
  display: flex;
  gap: 6px;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}

.fe-token-custom-row input {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-family: var(--mono);
}

.fe-token-custom-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-token-custom-row button {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-custom-row button:hover {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

/* Vertical alignment */
.fe-valign-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-valign-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
}

.fe-valign-btn {
  min-width: 38px;
  height: 34px;
  padding: 0 8px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-valign-btn:hover {
  border-color: var(--accent);
}

.fe-valign-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Graphics panel */
.fe-graphics-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-graphics-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.fe-graphics-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  min-width: 45px;
}

.fe-graphic-add {
  padding: 6px 14px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-muted);
  cursor: pointer;
  font-family: inherit;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-graphic-add:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-graphic-barcode-placeholder {
  padding: 6px 14px;
  border: 2px solid var(--accent);
  border-radius: 8px;
  background: var(--accent-bg);
  color: var(--accent-text);
  font-size: 12px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
}

.fe-graphic-disabled {
  padding: 6px 14px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-muted);
  font-size: 12px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0.6;
}

.fe-graphic-thumb {
  width: 44px;
  height: 44px;
  border-radius: 6px;
  border: 2px solid var(--border);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  cursor: pointer;
}

.fe-graphic-thumb:hover {
  border-color: var(--accent);
}

.fe-graphic-thumb img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.fe-graphic-size-pills {
  display: flex;
  gap: 4px;
}

.fe-graphic-size-pill {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
}

.fe-graphic-size-pill:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-graphic-size-pill.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-graphic-remove {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-faint);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  transition: all 0.15s;
}

.fe-graphic-remove:hover {
  border-color: var(--error-border);
  color: var(--error-text);
  background: var(--error-bg);
}

/* Preview */
.fe-preview-container {
  background: repeating-conic-gradient(#d8d8d2 0% 25%, #e4e4de 0% 50%) 50% / 12px 12px;
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100px;
}

[data-theme="dark"] .fe-preview-container {
  background: repeating-conic-gradient(#2a2a32 0% 25%, #1e1e26 0% 50%) 50% / 12px 12px;
}

.fe-preview-label {
  background: white;
  border: 2px solid #888;
  border-radius: 4px;
  padding: 8px 10px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  transition: all 0.15s;
}

.fe-preview-label .preview-line {
  width: 100%;
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  line-height: 1.3;
}

.fe-preview-label .preview-line.align-left { justify-content: flex-start; }
.fe-preview-label .preview-line.align-center { justify-content: center; }
.fe-preview-label .preview-line.align-right { justify-content: flex-end; }

.fe-preview-label.empty-preview {
  align-items: center;
  justify-content: center;
  color: #bbb;
  font-size: 12px;
  font-style: italic;
}

.fe-preview-dimensions {
  text-align: center;
  font-size: 11px;
  color: var(--text-faint);
  margin-top: 8px;
  font-family: var(--mono);
}

/* Preview type selector */
.fe-preview-type-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-top: 8px;
}

.fe-preview-type-label {
  font-size: 11px;
  color: var(--text-muted);
}

.fe-preview-type-select {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 11px;
  font-family: var(--mono);
  cursor: pointer;
}

.fe-preview-type-select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Border controls */
.fe-border-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-border-row {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.fe-border-toggles {
  display: flex;
  gap: 4px;
}

.fe-border-toggle {
  width: 32px;
  height: 32px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-muted);
  cursor: pointer;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.fe-border-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-border-toggle.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-border-color {
  display: flex;
  align-items: center;
  gap: 4px;
}

.fe-border-color-swatch {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
}

.fe-border-color-swatch:hover {
  border-color: var(--accent);
}

/* Global style controls */
.fe-global-style-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px 12px;
  background: var(--surface-alt);
  border-radius: 8px;
}

.fe-global-style-label {
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  white-space: nowrap;
}

.fe-global-style-btn {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 11px;
  font-family: inherit;
  transition: all 0.15s;
}

.fe-global-style-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-global-style-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

/* Unsaved changes indicator */
.fe-dirty-indicator {
  display: none;
  color: var(--warning-text);
  font-size: 11px;
  margin-left: 8px;
}

.fe-dirty-indicator.visible {
  display: inline;
}

/* Actions */
.fe-actions {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.fe-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid transparent;
  border-radius: 10px;
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-btn-primary {
  background: var(--accent);
  color: white;
}

.fe-btn-primary:hover {
  background: var(--accent-hover);
}

.fe-btn-secondary {
  background: var(--surface);
  border-color: var(--border);
  color: var(--text);
}

.fe-btn-secondary:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Name input for save */
.fe-name-row {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.fe-name-input {
  flex: 1;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.fe-name-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Graphic picker modal */
.fe-graphic-picker {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1100;
  align-items: center;
  justify-content: center;
}

.fe-graphic-picker.visible {
  display: flex;
}

.fe-graphic-picker-modal {
  background: var(--surface);
  border-radius: var(--radius);
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.fe-gp-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-light);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.fe-gp-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
}

.fe-gp-close {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-size: 20px;
  cursor: pointer;
  border-radius: 6px;
}

.fe-gp-close:hover {
  background: var(--surface-alt);
  color: var(--text);
}

.fe-gp-tabs {
  display: flex;
  border-bottom: 1px solid var(--border-light);
}

.fe-gp-tab {
  flex: 1;
  padding: 10px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  border-bottom: 2px solid transparent;
}

.fe-gp-tab:hover {
  color: var(--text);
  background: var(--surface-alt);
}

.fe-gp-tab.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

.fe-gp-body {
  padding: 16px;
  overflow-y: auto;
  flex: 1;
}

.fe-gp-upload-area {
  text-align: center;
  padding: 30px;
}

.fe-gp-upload-btn {
  padding: 12px 24px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-gp-upload-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-gp-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.fe-gp-icon {
  width: 48px;
  height: 48px;
  border: 2px solid var(--border-light);
  border-radius: 8px;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px;
  transition: all 0.15s;
}

.fe-gp-icon:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: scale(1.05);
}

.fe-gp-icon svg {
  width: 100%;
  height: 100%;
}

/* ===== WIZARD (for workflows) ===== */
.wizard-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 900;
  overflow-y: auto;
}

.wizard-overlay.visible {
  display: block;
}

.wizard-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.wizard-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 32px;
}

.wizard-back {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  box-shadow: var(--shadow-sm);
}

.wizard-back:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.wizard-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.wizard-step {
  flex: 1;
  display: none;
  flex-direction: column;
}

.wizard-step.active {
  display: flex;
}

.wizard-question {
  font-size: 22px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 24px;
  line-height: 1.3;
}

.wizard-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.wizard-option {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 18px 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 14px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 500;
  color: var(--text);
  text-align: left;
}

.wizard-option:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option-icon {
  font-size: 24px;
}

/* ===== WIZARD TEXT EDITOR ===== */
.wizard-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.editor-lines {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.editor-line {
  display: flex;
  gap: 8px;
  align-items: stretch;
}

.editor-line-input {
  flex: 1;
  padding: 12px 14px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.15s;
}

.editor-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.editor-line-input::placeholder {
  color: var(--text-faint);
}

.editor-controls {
  display: flex;
  gap: 4px;
}

.editor-align-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-align-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-align-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.editor-size-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-size-btn.size-s { font-size: 11px; }
.editor-size-btn.size-m { font-size: 14px; }
.editor-size-btn.size-l { font-size: 17px; }

.editor-size-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Preview */
.editor-preview-section {
  margin-top: 8px;
}

.editor-preview-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.editor-preview-frame {
  background: white;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  min-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.editor-preview-label-box {
  background: #fff;
  border: 1px solid #ccc;
  width: 100%;
  max-width: 263px;
  height: 96px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 8px 12px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
}

.preview-line {
  line-height: 1.3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-line.align-left { text-align: left; }
.preview-line.align-center { text-align: center; }
.preview-line.align-right { text-align: right; }

/* Actions */
.wizard-actions {
  display: flex;
  gap: 12px;
  margin-top: auto;
  padding-top: 24px;
}

.wizard-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.wizard-btn-secondary {
  background: var(--surface);
  color: var(--text);
}

.wizard-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.wizard-btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.wizard-btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.wizard-btn-primary.danger {
  background: var(--error-text);
  border-color: var(--error-text);
}

.wizard-btn-primary.danger:hover {
  background: #b91c1c;
  border-color: #b91c1c;
}

/* ===== WF1: PRINT SOMETHING NEW ===== */

.wf1-progress {
  display: flex;
  gap: 4px;
  margin-bottom: 24px;
}

.wf1-progress-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--border);
  transition: all 0.2s;
}

.wf1-progress-dot.active {
  background: var(--accent);
  width: 24px;
  border-radius: 4px;
}

.wf1-progress-dot.done {
  background: var(--success-text);
}

/* ===== Phase 3: Smart Inference Summary Bar ===== */
.wf1-smart-summary {
  background: linear-gradient(135deg, var(--accent-bg) 0%, #f0f7ff 100%);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-bottom: 16px;
  display: none;
}

.wf1-smart-summary.visible {
  display: block;
}

.wf1-smart-summary-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.wf1-smart-summary-icon {
  font-size: 16px;
}

.wf1-smart-summary-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent-text);
}

.wf1-smart-summary-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.wf1-smart-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 4px 10px 4px 8px;
  font-size: 12px;
  color: var(--text);
}

.wf1-smart-item-label {
  color: var(--text-muted);
  font-size: 11px;
}

.wf1-smart-item-value {
  font-weight: 600;
  color: var(--text);
}

.wf1-smart-item-edit {
  color: var(--accent);
  font-size: 11px;
  cursor: pointer;
  margin-left: 2px;
  opacity: 0.7;
  transition: opacity 0.15s;
}

.wf1-smart-item-edit:hover {
  opacity: 1;
  text-decoration: underline;
}

/* Confidence indicators */
.wf1-smart-item.high {
  border-color: var(--success-border);
  background: var(--success-bg);
}

.wf1-smart-item.medium {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

/* Step skip indicator */
.wf1-skip-indicator {
  display: none;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 16px;
  background: var(--success-bg);
  border: 1px solid var(--success-border);
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
}

.wf1-skip-indicator.visible {
  display: flex;
}

.wf1-skip-indicator-icon {
  font-size: 20px;
}

.wf1-skip-indicator-text {
  font-size: 14px;
  color: var(--success-text);
}

.wf1-skip-indicator-edit {
  color: var(--accent);
  font-size: 13px;
  cursor: pointer;
  margin-left: 8px;
}

.wf1-skip-indicator-edit:hover {
  text-decoration: underline;
}

/* Confirm mode for medium confidence */
.wf1-confirm-suggestion {
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 16px;
  display: none;
}

.wf1-confirm-suggestion.visible {
  display: block;
}

.wf1-confirm-suggestion-header {
  font-size: 14px;
  font-weight: 600;
  color: var(--warning-text);
  margin-bottom: 8px;
}

.wf1-confirm-suggestion-value {
  font-size: 16px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 12px;
}

.wf1-confirm-suggestion-actions {
  display: flex;
  gap: 8px;
}

.wf1-confirm-btn {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  border: none;
  transition: all 0.15s;
}

.wf1-confirm-btn.primary {
  background: var(--accent);
  color: white;
}

.wf1-confirm-btn.primary:hover {
  background: var(--accent-hover);
}

.wf1-confirm-btn.secondary {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text);
}

.wf1-confirm-btn.secondary:hover {
  background: var(--surface-alt);
}

/* Phase 3: Inference suggestion banner */
.wf1-inference-banner {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  background: var(--success-bg);
  border: 1px solid var(--success-border);
}

.wf1-inference-banner.medium {
  background: var(--warning-bg);
  border-color: var(--warning-border);
}

.wf1-inference-banner-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.wf1-inference-banner-content {
  flex: 1;
  min-width: 0;
}

.wf1-inference-banner-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 2px;
}

.wf1-inference-banner-reason {
  font-size: 12px;
  color: var(--text-secondary);
}

.wf1-inference-use-btn {
  padding: 8px 16px;
  background: var(--success-text);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.15s;
}

.wf1-inference-use-btn:hover {
  background: #036847;
}

.wf1-inference-banner.medium .wf1-inference-use-btn {
  background: var(--warning-text);
}

.wf1-inference-banner.medium .wf1-inference-use-btn:hover {
  background: #92400e;
}

/* Inferred card style (subtle highlight when not selected) */
.wf1-type-card.inferred {
  border-color: var(--success-border);
  background: var(--success-bg);
}

.wf1-type-card.inferred::after {
  content: 'âœ¨';
  position: absolute;
  top: 4px;
  right: 8px;
  font-size: 12px;
}

/* ===== Phase 3B: Skipped Steps Banner ===== */
.wf1-skipped-banner {
  background: linear-gradient(135deg, var(--success-bg) 0%, #e8f5e9 100%);
  border: 1px solid var(--success-border);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-bottom: 16px;
  display: none;
}

.wf1-skipped-banner.visible {
  display: block;
}

.wf1-skipped-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.wf1-skipped-header-left {
  display: flex;
  align-items: center;
  gap: 8px;
}

.wf1-skipped-icon {
  font-size: 18px;
}

.wf1-skipped-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--success-text);
}

.wf1-skipped-count {
  font-size: 12px;
  color: var(--text-secondary);
  font-weight: normal;
}

.wf1-skipped-toggle {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 12px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  transition: background 0.15s;
}

.wf1-skipped-toggle:hover {
  background: rgba(0,0,0,0.05);
}

.wf1-skipped-details {
  display: none;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--success-border);
}

.wf1-skipped-details.expanded {
  display: block;
}

.wf1-skipped-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--border-light);
}

.wf1-skipped-item:last-child {
  border-bottom: none;
}

.wf1-skipped-item-info {
  display: flex;
  align-items: center;
  gap: 8px;
}

.wf1-skipped-item-label {
  font-size: 12px;
  color: var(--text-secondary);
  min-width: 80px;
}

.wf1-skipped-item-value {
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
}

.wf1-skipped-item-reason {
  font-size: 11px;
  color: var(--text-muted);
  margin-left: 8px;
}

.wf1-skipped-item-edit {
  background: none;
  border: 1px solid var(--border);
  color: var(--accent);
  font-size: 11px;
  padding: 4px 10px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}

.wf1-skipped-item-edit:hover {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Step skipped indicator within a step (when navigating back) */
.wf1-step-skipped-note {
  background: var(--accent-bg);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  margin-bottom: 12px;
  font-size: 12px;
  color: var(--accent-text);
  display: flex;
  align-items: center;
  gap: 8px;
}

.wf1-step-skipped-note-icon {
  font-size: 14px;
}

/* ===== Phase 3C: Confirm Mode ===== */
/* One-click confirmation for medium confidence suggestions */

.wf1-confirm-card {
  background: linear-gradient(135deg, #fff9e6 0%, #fffdf5 100%);
  border: 2px solid #f5c518;
  border-radius: var(--radius-md);
  padding: 16px;
  margin-bottom: 16px;
  position: relative;
  overflow: hidden;
}

.wf1-confirm-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, #f5c518, #ffd54f);
}

.wf1-confirm-header {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 12px;
}

.wf1-confirm-icon {
  font-size: 24px;
  line-height: 1;
}

.wf1-confirm-title {
  flex: 1;
}

.wf1-confirm-title-main {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}

.wf1-confirm-title-reason {
  font-size: 12px;
  color: var(--text-secondary);
}

.wf1-confirm-value {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 14px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.wf1-confirm-value-main {
  display: flex;
  align-items: center;
  gap: 10px;
}

.wf1-confirm-value-id {
  font-size: 18px;
  font-weight: 700;
  color: var(--accent);
}

.wf1-confirm-value-desc {
  font-size: 13px;
  color: var(--text);
}

.wf1-confirm-value-meta {
  font-size: 11px;
  color: var(--text-muted);
}

.wf1-confirm-actions {
  display: flex;
  gap: 10px;
  align-items: center;
}

.wf1-confirm-btn-yes {
  flex: 1;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.wf1-confirm-btn-yes:hover {
  background: var(--accent-hover);
  transform: translateY(-1px);
}

.wf1-confirm-btn-no {
  background: white;
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.wf1-confirm-btn-no:hover {
  background: var(--surface);
  color: var(--text);
  border-color: var(--text-secondary);
}

/* "Not this?" alternatives panel */
.wf1-confirm-alternatives {
  display: none;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.wf1-confirm-alternatives.visible {
  display: block;
}

.wf1-confirm-alt-header {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: 10px;
  font-weight: 500;
}

.wf1-confirm-alt-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.wf1-confirm-alt-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 12px;
  cursor: pointer;
  transition: all 0.15s;
}

.wf1-confirm-alt-item:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-confirm-alt-info {
  display: flex;
  align-items: center;
  gap: 10px;
}

.wf1-confirm-alt-id {
  font-weight: 600;
  font-size: 13px;
  color: var(--text);
}

.wf1-confirm-alt-desc {
  font-size: 12px;
  color: var(--text-secondary);
}

.wf1-confirm-alt-action {
  color: var(--accent);
  font-size: 12px;
  font-weight: 500;
}

.wf1-confirm-show-all {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 12px;
  cursor: pointer;
  padding: 8px 0;
  margin-top: 8px;
  display: block;
  width: 100%;
  text-align: center;
}

.wf1-confirm-show-all:hover {
  text-decoration: underline;
}

/* Dark mode overrides for confirm card */
body.dark-mode .wf1-confirm-card {
  background: linear-gradient(135deg, #3a3520 0%, #2a2a2a 100%);
  border-color: #b89914;
}

body.dark-mode .wf1-confirm-value {
  background: var(--surface);
  border-color: var(--border);
}

body.dark-mode .wf1-confirm-btn-no {
  background: var(--surface);
  border-color: var(--border);
  color: var(--text-muted);
}

body.dark-mode .wf1-confirm-alt-item {
  background: var(--surface);
}

/* ========== Phase 3D: Narrowed Mode ========== */
/* Narrowed card - shows filtered options for low confidence */
.wf1-narrowed-card {
  background: linear-gradient(135deg, #e8f4fc 0%, #f5faff 100%);
  border: 2px solid #4a9fd4;
  border-radius: var(--radius-md);
  padding: 16px;
  margin-bottom: 16px;
  position: relative;
  overflow: hidden;
}

.wf1-narrowed-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, #4a9fd4, #7ec8f8);
}

.wf1-narrowed-header {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 12px;
}

.wf1-narrowed-icon {
  font-size: 24px;
  line-height: 1;
}

.wf1-narrowed-title {
  flex: 1;
}

.wf1-narrowed-title-main {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}

.wf1-narrowed-title-reason {
  font-size: 12px;
  color: var(--text-secondary);
}

.wf1-narrowed-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}

.wf1-narrowed-option {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 14px;
  cursor: pointer;
  transition: all 0.15s;
}

.wf1-narrowed-option:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-narrowed-option.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 2px var(--accent-bg);
}

.wf1-narrowed-option.suggested {
  position: relative;
}

.wf1-narrowed-option.suggested::after {
  content: 'Suggested';
  position: absolute;
  top: -8px;
  right: 10px;
  background: #4a9fd4;
  color: white;
  font-size: 9px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.wf1-narrowed-option-main {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
}

.wf1-narrowed-option-id {
  font-size: 16px;
  font-weight: 700;
  color: var(--accent);
  min-width: 50px;
}

.wf1-narrowed-option-desc {
  font-size: 13px;
  color: var(--text);
}

.wf1-narrowed-option-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-left: auto;
}

.wf1-narrowed-option-stock {
  font-size: 11px;
  color: var(--success);
  background: rgba(76, 175, 80, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
  margin-left: 8px;
}

.wf1-narrowed-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border-light);
}

.wf1-narrowed-show-all {
  background: none;
  border: none;
  color: var(--accent);
  font-size: 12px;
  cursor: pointer;
  padding: 8px 0;
  display: flex;
  align-items: center;
  gap: 4px;
}

.wf1-narrowed-show-all:hover {
  text-decoration: underline;
}

.wf1-narrowed-continue {
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 10px 20px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 6px;
}

.wf1-narrowed-continue:hover {
  background: var(--accent-hover);
  transform: translateY(-1px);
}

.wf1-narrowed-continue:disabled {
  background: var(--text-muted);
  cursor: not-allowed;
  transform: none;
}

/* Dark mode overrides for narrowed card */
body.dark-mode .wf1-narrowed-card {
  background: linear-gradient(135deg, #1a3040 0%, #2a2a2a 100%);
  border-color: #3a7ca5;
}

body.dark-mode .wf1-narrowed-option {
  background: var(--surface);
  border-color: var(--border);
}

body.dark-mode .wf1-narrowed-option.suggested::after {
  background: #3a7ca5;
}

/* Type grid (reused from existing, refined for WF1) */
.wf1-type-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
  margin-bottom: 16px;
}

.wf1-type-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 12px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
  position: relative;
  user-select: none; /* Prevent text selection on double-click */
}

.wf1-type-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-type-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 1px var(--accent);
}

/* Double-click hint on hover (T1) */
.wf1-type-card::before {
  content: 'Double-click to select & continue';
  position: absolute;
  bottom: -24px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: var(--text-muted);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
}

.wf1-type-card:hover::before {
  opacity: 1;
}

.wf1-type-card.last-used::after {
  content: 'Last used';
  position: absolute;
  top: -8px;
  right: 8px;
  background: var(--accent);
  color: white;
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.wf1-type-card-id {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 2px;
}

.wf1-type-card-desc {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.wf1-type-card-meta {
  font-size: 11px;
  color: var(--text-muted);
}

.wf1-type-card-badge {
  display: inline-block;
  font-size: 10px;
  font-weight: 600;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--warning-bg);
  color: var(--warning-text);
  margin-top: 4px;
}

/* Inventory check step */
.wf1-inventory-status {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 20px;
}

.wf1-inventory-status.has-stock {
  border-color: var(--success-border);
  background: var(--success-bg);
}

.wf1-inventory-status.low-stock {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

.wf1-inventory-status.no-stock {
  border-color: var(--border);
}

.wf1-inventory-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.wf1-inventory-msg {
  font-size: 15px;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 4px;
  line-height: 1.4;
}

.wf1-inventory-detail {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.4;
}

.wf1-inventory-actions {
  display: flex;
  gap: 10px;
  margin-top: 16px;
  flex-wrap: wrap;
}

.wf1-inv-btn {
  padding: 10px 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  color: var(--text);
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.wf1-inv-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.wf1-inv-btn.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.wf1-inv-btn.primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

/* Inline inventory add */
.wf1-inv-add-inline {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-top: 16px;
}

.wf1-inv-add-inline label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.wf1-inv-add-inline input[type="number"] {
  width: 100%;
  max-width: 120px;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  font-family: inherit;
  font-size: 16px;
  text-align: center;
}

.wf1-inv-add-inline input[type="number"]:focus {
  outline: none;
  border-color: var(--accent);
}

.wf1-inv-add-actions {
  display: flex;
  gap: 10px;
  margin-top: 14px;
}

/* Content type choice step */
.wf1-content-choices {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.wf1-content-choice {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: flex-start;
  gap: 16px;
}

.wf1-content-choice:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wf1-content-choice-icon {
  font-size: 28px;
  flex-shrink: 0;
  line-height: 1;
}

.wf1-content-choice-text {
  flex: 1;
}

.wf1-content-choice-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.wf1-content-choice-desc {
  font-size: 13px;
  color: var(--text-muted);
  line-height: 1.3;
}

/* Quantity in content type step */
.wf1-qty-row {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-top: 20px;
  padding: 16px 20px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
}

.wf1-qty-label {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  flex: 1;
}

.wf1-qty-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.wf1-qty-btn {
  width: 36px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.wf1-qty-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.wf1-qty-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.wf1-qty-value {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
  min-width: 40px;
  text-align: center;
}

.wf1-qty-hint {
  font-size: 12px;
  color: var(--text-muted);
  text-align: right;
  margin-top: 6px;
}

/* ===== WF1 Step 4: Feasibility Check ===== */
.wf1-feasibility {
  padding: 16px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
}
.wf1-feasibility.ok { background: var(--success-bg, rgba(34,197,94,0.08)); border-left: 4px solid var(--success, #22c55e); }
.wf1-feasibility.warn { background: var(--warning-bg, rgba(234,179,8,0.08)); border-left: 4px solid var(--warning, #eab308); }
.wf1-feasibility.error { background: var(--danger-bg, rgba(239,68,68,0.08)); border-left: 4px solid var(--danger, #ef4444); }
.wf1-feas-icon { font-size: 24px; margin-bottom: 8px; }
.wf1-feas-msg { font-size: 15px; font-weight: 600; color: var(--heading); margin-bottom: 6px; }
.wf1-feas-detail { font-size: 13px; color: var(--text-muted); line-height: 1.5; }
.wf1-feas-actions { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
.wf1-feas-actions .wf1-inv-btn { font-size: 13px; }

/* ===== WF1 Step 5: Sheet Picker ===== */
.wf1-sheet-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.wf1-sheet-card {
  display: flex; align-items: center; gap: 14px;
  padding: 14px 16px; border-radius: var(--radius-sm);
  border: 2px solid var(--border); background: var(--surface);
  cursor: pointer; transition: border-color 0.15s, background 0.15s;
}
.wf1-sheet-card:hover { border-color: var(--accent); }
.wf1-sheet-card.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-sheet-card.create-new { border-style: dashed; }
.wf1-sheet-card.create-new:hover { border-style: solid; }
.wf1-sheet-icon { font-size: 22px; flex-shrink: 0; }
.wf1-sheet-info { flex: 1; min-width: 0; }
.wf1-sheet-name { font-size: 14px; font-weight: 600; color: var(--heading); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.wf1-sheet-meta { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
.wf1-sheet-spots { font-size: 13px; font-weight: 600; color: var(--accent); white-space: nowrap; }
.wf1-sheet-badge {
  display: inline-block; font-size: 10px; font-weight: 600; padding: 2px 7px;
  border-radius: 10px; text-transform: uppercase; margin-left: 6px;
}
.wf1-sheet-badge.dedicated { background: rgba(139,92,246,0.12); color: #8b5cf6; }
.wf1-sheet-badge.open { background: rgba(34,197,94,0.12); color: #22c55e; }
.wf1-sheet-badge.stale { background: rgba(234,179,8,0.12); color: #ca8a04; }
.wf1-sheet-warning { font-size: 12px; color: var(--warning, #ca8a04); margin-top: 6px; padding: 8px 12px; background: var(--warning-bg, rgba(234,179,8,0.06)); border-radius: var(--radius-sm); }

/* ===== WF1 Step 6: Content Editor ===== */
.wf1-editor-wrapper { margin-bottom: 16px; }
.wf1-editor-tools { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
.wf1-editor-tool-btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 6px 12px; font-size: 12px; font-weight: 600;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  background: var(--surface); color: var(--text); cursor: pointer;
  transition: border-color 0.15s;
}
.wf1-editor-tool-btn:hover { border-color: var(--accent); color: var(--accent); }
.wf1-editor-tool-btn.has-style { background: var(--accent-bg); border-color: var(--accent); color: var(--accent); }
.wf1-content-actions { display: flex; gap: 8px; margin-top: 12px; }

/* WF1 Style Dropdown */
.wf1-style-row {
  display: flex; align-items: center; gap: 10px;
  margin-bottom: 14px; padding: 10px 12px;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}
.wf1-style-row label {
  font-size: 12px; font-weight: 600; color: var(--text-secondary);
  white-space: nowrap;
}
.wf1-style-select {
  flex: 1; padding: 8px 10px;
  border: 2px solid var(--border); border-radius: 6px;
  background: var(--surface); color: var(--text);
  font-size: 13px; cursor: pointer; font-family: inherit; min-width: 0;
}
.wf1-style-select:hover { border-color: var(--accent); }
.wf1-style-select:focus { outline: none; border-color: var(--accent); }
.wf1-style-select optgroup { font-weight: 600; color: var(--text-secondary); }
.wf1-style-select option { font-weight: 400; color: var(--text); padding: 4px; }
.wf1-style-badge {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 11px; font-weight: 600; color: var(--accent);
  padding: 2px 8px; background: var(--accent-bg);
  border-radius: 10px;
}

/* Batch sub-steps */
.wf1-batch-section { margin-bottom: 16px; }
.wf1-batch-section-title { font-size: 14px; font-weight: 600; color: var(--heading); margin-bottom: 8px; }
.wf1-batch-upload {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 28px 16px; text-align: center; cursor: pointer;
  transition: border-color 0.2s; background: var(--surface);
}
.wf1-batch-upload:hover { border-color: var(--accent); }
.wf1-batch-upload-icon { font-size: 28px; margin-bottom: 8px; }
.wf1-batch-upload-text { font-size: 13px; color: var(--text-muted); }
.wf1-batch-upload-zone {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 32px 20px; text-align: center; transition: all 0.2s; background: var(--surface);
}
.wf1-batch-upload-zone:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf1-batch-upload-or { font-size: 12px; color: var(--text-muted); margin: 12px 0; }
.wf1-batch-loaded-success { text-align: center; padding: 20px; }
.wf1-batch-planning { }
.wf1-plan-summary { text-align: center; margin-bottom: 16px; padding: 16px; background: var(--accent-bg); border-radius: var(--radius-sm); }
.wf1-plan-count { font-size: 28px; font-weight: 700; color: var(--accent); }
.wf1-plan-detail { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
.wf1-plan-warning { text-align: center; padding: 20px; }
.wf1-dedicated-toggle {
  margin-bottom: 12px; padding: 10px 12px; background: var(--surface);
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  color: var(--text-muted);
}
.wf1-dedicated-toggle input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
.wf1-plan-options { display: flex; flex-direction: column; gap: 8px; }
.wf1-plan-option {
  display: flex; align-items: flex-start; gap: 12px; padding: 14px;
  border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; transition: all 0.15s; background: var(--surface);
}
.wf1-plan-option:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf1-plan-option.recommended { border-color: var(--accent); background: var(--accent-bg); }
.wf1-plan-option.recommended .wf1-plan-option-title { color: var(--accent); }
.wf1-plan-option-icon { font-size: 24px; flex-shrink: 0; }
.wf1-plan-option-content { flex: 1; }
.wf1-plan-option-title { font-weight: 600; color: var(--heading); font-size: 14px; }
.wf1-plan-option-desc { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
.wf1-mixed-mode-header {
  display: flex; align-items: flex-start; gap: 12px; padding: 14px;
  background: var(--accent-bg); border: 2px solid var(--accent); border-radius: var(--radius-sm);
  margin-bottom: 12px;
}
.wf1-mixed-mode-icon { font-size: 24px; }
.wf1-mixed-mode-text { font-size: 13px; color: var(--text); line-height: 1.5; }
.wf1-batch-status { font-size: 13px; color: var(--text-muted); margin-top: 8px; padding: 10px 14px; background: var(--surface-alt, var(--surface)); border-radius: var(--radius-sm); border: 1px solid var(--border); }
.wf1-batch-status.success { border-color: var(--success, #22c55e); }
.wf1-batch-template-list { display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto; }
.wf1-batch-template-item {
  padding: 10px 12px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; font-size: 13px; transition: border-color 0.15s;
}
.wf1-batch-template-item:hover { border-color: var(--accent); }
.wf1-batch-template-item.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-batch-template-item.create-new { border-style: dashed; opacity: 0.8; }
.wf1-batch-template-item.create-new:hover { opacity: 1; }
.wf1-batch-template-header { display: flex; justify-content: space-between; align-items: flex-start; }
.wf1-batch-template-name { font-weight: 600; color: var(--heading); flex: 1; }
.wf1-batch-template-preview { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
.wf1-template-edit-btn {
  background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px 6px;
  opacity: 0.5; transition: opacity 0.15s; border-radius: 4px;
}
.wf1-template-edit-btn:hover { opacity: 1; background: var(--surface-alt, rgba(0,0,0,0.1)); }
.wf1-batch-mapping { display: flex; flex-direction: column; gap: 6px; }
.wf1-batch-map-row { display: flex; align-items: center; gap: 10px; font-size: 13px; }
.wf1-batch-map-row label { flex: 0 0 100px; font-weight: 600; color: var(--heading); }
.wf1-batch-map-row select { flex: 1; padding: 6px 8px; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 13px; background: var(--surface); color: var(--text); }
.wf1-batch-preview-scroll { max-height: 300px; overflow-y: auto; }
.wf1-batch-preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.wf1-batch-preview-hint { font-size: 11px; color: var(--text-muted); }
.wf1-batch-preview-label { 
  display: flex; align-items: flex-start; gap: 8px;
  padding: 8px 12px; border: 1px solid var(--border); border-radius: var(--radius-sm); 
  margin-bottom: 6px; font-size: 12px; line-height: 1.5; background: var(--surface); 
}
.wf1-batch-preview-label.editing { background: var(--accent-bg); border-color: var(--accent); }
.wf1-batch-label-content { flex: 1; min-width: 0; }
.wf1-batch-edit-btn { 
  background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px 4px;
  opacity: 0.4; transition: opacity 0.15s; flex-shrink: 0;
}
.wf1-batch-preview-label:hover .wf1-batch-edit-btn { opacity: 1; }
.wf1-batch-label-edit { flex: 1; display: flex; flex-direction: column; gap: 6px; }
.wf1-batch-edit-input {
  width: 100%; padding: 6px 8px; font-size: 12px; border: 1px solid var(--border);
  border-radius: var(--radius-sm); background: var(--surface); color: var(--text);
}
.wf1-batch-edit-input:focus { border-color: var(--accent); outline: none; }
.wf1-batch-edit-actions { display: flex; gap: 6px; margin-top: 4px; }
.wf1-batch-edit-save, .wf1-batch-edit-cancel {
  padding: 4px 10px; font-size: 11px; border-radius: var(--radius-sm); cursor: pointer; border: none;
}
.wf1-batch-edit-save { background: var(--accent); color: white; }
.wf1-batch-edit-cancel { background: var(--surface-alt, #e5e5e5); color: var(--text); }
.wf1-batch-edit-delete { 
  background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px 6px;
  opacity: 0.5; margin-left: auto;
}
.wf1-batch-edit-delete:hover { opacity: 1; }
.wf1-batch-more-labels { font-size: 12px; color: var(--text-muted); text-align: center; padding: 8px; display: flex; align-items: center; justify-content: center; }
.wf1-batch-preview-count { font-size: 13px; color: var(--text-muted); }

/* ===== WF1 Step 5: Mini-Grid in Sheet Picker ===== */
.wf1-sheet-mini-grid {
  display: grid; gap: 1px; background: var(--border); border: 1px solid var(--border);
  border-radius: 3px; padding: 1px; margin-top: 8px;
}
.wf1-sheet-mini-cell {
  aspect-ratio: 1; min-width: 6px; border-radius: 1px; background: var(--surface);
}
.wf1-sheet-mini-cell.used { background: var(--text-faint); }
.wf1-sheet-mini-cell.next { background: var(--accent); opacity: 0.7; }
.wf1-sheet-grid-legend {
  display: flex; gap: 10px; margin-top: 6px; font-size: 10px; color: var(--text-muted);
}
.wf1-sheet-grid-legend span::before {
  content: ''; display: inline-block; width: 8px; height: 8px; border-radius: 2px;
  margin-right: 3px; vertical-align: middle;
}
.wf1-sheet-grid-legend .leg-avail::before { background: var(--surface); border: 1px solid var(--border); }
.wf1-sheet-grid-legend .leg-used::before { background: var(--text-faint); }
.wf1-sheet-grid-legend .leg-next::before { background: var(--accent); opacity: 0.7; }
/* WF1 Orientation Picker (T3) - in-card version */
.wf1-orientation-section {
  margin-top: 8px; padding: 8px 0 0 0; 
  border-top: 1px solid var(--border-light, var(--border));
}
.wf1-orientation-label {
  font-size: 11px; font-weight: 500; color: var(--text-muted); margin-bottom: 6px;
}
.wf1-orientation-options {
  display: flex; gap: 6px; flex-wrap: wrap;
}
.wf1-orientation-opt {
  flex: 1; min-width: 70px; padding: 6px 8px; border: 1px solid var(--border);
  border-radius: var(--radius-sm); cursor: pointer; text-align: center;
  font-size: 11px; color: var(--text); background: var(--surface);
  transition: border-color 0.15s, background 0.15s;
}
.wf1-orientation-opt:hover { border-color: var(--accent); }
.wf1-orientation-opt.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf1-orientation-opt-icon { font-size: 14px; margin-bottom: 1px; }
.wf1-orientation-opt-text { font-size: 10px; color: var(--text-muted); }
/* Rich formatting badge in WF1 editor */
.wf1-rich-badge {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 11px; color: var(--accent); padding: 4px 10px;
  background: var(--accent-bg); border-radius: var(--radius-sm);
  margin-top: 8px;
}
/* Safari print notice */
.safari-print-notice {
  font-size: 12px; color: var(--warning, #ca8a04); padding: 8px 12px;
  background: var(--warning-bg, rgba(234,179,8,0.06)); border-radius: var(--radius-sm);
  margin-top: 12px; line-height: 1.5;
}

/* ===== WF1 Multi-Sheet Plan ===== */
.wf1-multisheet-plan {
  margin-top: 16px; padding: 14px; border: 2px solid var(--accent);
  border-radius: var(--radius-sm); background: var(--accent-bg);
}
.wf1-multisheet-title {
  font-size: 13px; font-weight: 700; color: var(--accent); margin-bottom: 10px;
  display: flex; align-items: center; gap: 6px;
}
.wf1-multisheet-steps { display: flex; flex-direction: column; gap: 6px; }
.wf1-multisheet-step {
  display: flex; align-items: center; gap: 10px;
  font-size: 13px; color: var(--text); padding: 8px 10px;
  background: var(--surface); border-radius: var(--radius-sm); border: 1px solid var(--border);
}
.wf1-multisheet-step .step-num {
  flex-shrink: 0; width: 22px; height: 22px; border-radius: 50%;
  background: var(--accent); color: #fff; font-size: 11px; font-weight: 700;
  display: flex; align-items: center; justify-content: center;
}
.wf1-multisheet-step .step-detail { flex: 1; }
.wf1-multisheet-step .step-count {
  flex-shrink: 0; font-weight: 600; color: var(--accent); font-size: 12px;
}
.wf1-multisheet-note {
  font-size: 11px; color: var(--text-muted); margin-top: 8px; line-height: 1.5;
}
/* Multi-sheet post-print */
.wf1-postprint-sheets { display: flex; flex-direction: column; gap: 4px; margin: 8px 0 12px; }
.wf1-postprint-sheet-row {
  font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 6px;
}
.wf1-postprint-sheet-row .sheet-icon { opacity: 0.6; }

/* ===== OCR Line-Mapping UI ===== */
.ocr-line-mapper { margin-top: 12px; }
.ocr-lm-title { font-size: 13px; font-weight: 700; color: var(--heading); margin-bottom: 10px; }
.ocr-lm-layout { display: flex; gap: 12px; }
.ocr-lm-source, .ocr-lm-target { flex: 1; min-width: 0; }
.ocr-lm-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; }
.ocr-lm-source-list { display: flex; flex-direction: column; gap: 4px; min-height: 120px; }
.ocr-lm-source-item {
  display: flex; align-items: center; gap: 6px;
  padding: 6px 8px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  cursor: pointer; font-size: 12px; color: var(--text); background: var(--surface);
  transition: all 0.15s; user-select: none;
}
.ocr-lm-source-item:hover { border-color: var(--accent); }
.ocr-lm-source-item.selected { border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-source-item.assigned { opacity: 0.45; border-style: dashed; }
.ocr-lm-source-item .lm-grip { color: var(--text-faint); font-size: 10px; flex-shrink: 0; }
.ocr-lm-source-item .lm-text { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ocr-lm-source-item .lm-conf { font-size: 10px; color: var(--text-muted); flex-shrink: 0; }
.ocr-lm-source-item .lm-conf.low { color: var(--warning-text); font-weight: 700; }
.ocr-lm-target-slots { display: flex; flex-direction: column; gap: 6px; }
.ocr-lm-slot {
  border: 2px dashed var(--border); border-radius: var(--radius-sm);
  padding: 8px 10px; min-height: 32px; cursor: pointer;
  transition: all 0.15s; display: flex; align-items: center; gap: 6px;
}
.ocr-lm-slot:hover { border-color: var(--accent); }
.ocr-lm-slot.highlight { border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-slot.filled { border-style: solid; border-color: var(--accent); background: var(--accent-bg); }
.ocr-lm-slot .slot-label {
  font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--text-muted);
  flex-shrink: 0; min-width: 42px;
}
.ocr-lm-slot .slot-content { flex: 1; min-width: 0; font-size: 12px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ocr-lm-slot .slot-placeholder { flex: 1; font-size: 11px; color: var(--text-faint); font-style: italic; }
.ocr-lm-slot .slot-clear {
  flex-shrink: 0; background: none; border: none; cursor: pointer;
  font-size: 14px; color: var(--text-muted); padding: 0 2px; line-height: 1;
}
.ocr-lm-slot .slot-clear:hover { color: var(--error-text); }
.ocr-lm-actions { display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end; }
.ocr-lm-actions button { font-size: 12px; padding: 5px 12px; }
.ocr-lm-hint { font-size: 11px; color: var(--text-muted); margin-top: 8px; text-align: center; line-height: 1.5; }
/* Responsive: stack vertically on narrow screens */
@media (max-width: 480px) {
  .ocr-lm-layout { flex-direction: column; }
}

/* ===== WF1 Step 7: Preview ===== */
.wf1-preview-summary { font-size: 14px; color: var(--text-muted); margin-bottom: 16px; }
.wf1-preview-frame {
  border: 2px solid var(--border); border-radius: var(--radius-sm);
  padding: 16px; background: #fff; min-height: 120px;
  display: flex; flex-direction: column; justify-content: center; align-items: center;
}
.wf1-preview-label-box {
  border: 1px dashed #ccc; padding: 10px 14px; max-width: 300px; width: 100%; box-sizing: border-box;
}
.wf1-preview-label-box .preview-line { line-height: 1.4; color: #000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* ===== WF1 Step 8: Post-Print ===== */
.wf1-postprint { text-align: center; padding: 20px 0; }
.wf1-postprint-icon { font-size: 48px; margin-bottom: 12px; }
.wf1-postprint-msg { font-size: 16px; font-weight: 600; color: var(--heading); margin-bottom: 8px; }
.wf1-postprint-detail { font-size: 13px; color: var(--text-muted); margin-bottom: 20px; }
.wf1-postprint-actions { display: flex; flex-direction: column; gap: 10px; max-width: 320px; margin: 0 auto; }
.wf1-postprint-btn {
  display: flex; align-items: center; gap: 10px;
  padding: 12px 16px; border-radius: var(--radius-sm);
  border: 2px solid var(--border); background: var(--surface);
  cursor: pointer; font-size: 13px; color: var(--text);
  transition: border-color 0.15s; text-align: left;
}
.wf1-postprint-btn:hover { border-color: var(--accent); }
.wf1-postprint-btn.primary { border-color: var(--accent); background: var(--accent-bg); }

/* ===== WF2: PRINT SOMETHING AGAIN ===== */
.wf2-progress { display: flex; gap: 8px; justify-content: center; padding: 12px 0; }
.wf2-progress-dot {
  width: 10px; height: 10px; border-radius: 50%;
  background: var(--border); transition: all 0.2s;
}
.wf2-progress-dot.active { background: var(--accent); transform: scale(1.3); }
.wf2-progress-dot.done { background: var(--accent); opacity: 0.5; }

/* Content selector â€” three sections */
.wf2-section-label {
  font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
  color: var(--text-muted); margin: 16px 0 8px; padding: 0 4px;
}
.wf2-section-label:first-child { margin-top: 4px; }

.wf2-content-list {
  display: flex; flex-direction: column; gap: 6px;
  max-height: 420px; overflow-y: auto; padding: 2px;
}
.wf2-content-card {
  background: var(--surface); border: 2px solid var(--border); border-radius: var(--radius-sm);
  padding: 12px 14px; display: flex; align-items: center; gap: 12px;
  cursor: pointer; transition: all 0.15s;
}
.wf2-content-card:hover { border-color: var(--accent); background: var(--accent-bg); }
.wf2-content-card.selected { border-color: var(--accent); background: var(--accent-bg); }
.wf2-content-card-icon { font-size: 22px; opacity: 0.7; flex-shrink: 0; }
.wf2-content-card-info { flex: 1; min-width: 0; }
.wf2-content-card-title {
  font-size: 14px; font-weight: 600; color: var(--heading);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.wf2-content-card-meta { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
.wf2-content-card-badge {
  font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em;
  padding: 2px 6px; border-radius: 4px; flex-shrink: 0;
}
.wf2-content-card-badge.dedicated { background: var(--accent-bg); color: var(--accent); }
.wf2-content-card-badge.history { background: #f0f4ff; color: #5b7db1; }
[data-theme="dark"] .wf2-content-card-badge.history { background: #1a2a4a; color: #7ba3d4; }
.wf2-content-card-actions { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
.wf2-quick-btn {
  background: var(--success, #22c55e); color: white; border: none; border-radius: 4px;
  padding: 4px 10px; font-size: 11px; font-weight: 600; cursor: pointer;
  white-space: nowrap; transition: background 0.15s;
}
.wf2-quick-btn:hover { background: #16a34a; }
[data-theme="dark"] .wf2-quick-btn { background: #15803d; }
[data-theme="dark"] .wf2-quick-btn:hover { background: #22c55e; }

.wf2-search-row {
  display: flex; gap: 8px; margin-bottom: 8px;
}
.wf2-search-input {
  flex: 1; padding: 8px 12px; border: 2px solid var(--border); border-radius: var(--radius-sm);
  font-family: inherit; font-size: 14px; background: var(--surface); color: var(--text);
}
.wf2-search-input:focus { outline: none; border-color: var(--accent); }
.wf2-search-input::placeholder { color: var(--text-muted); }

.wf2-empty { text-align: center; padding: 40px 20px; color: var(--text-muted); }
.wf2-empty-icon { font-size: 40px; margin-bottom: 10px; opacity: 0.5; }
.wf2-empty-text { font-size: 14px; line-height: 1.5; }

/* Quantity step */
.wf2-qty-section { text-align: center; padding: 20px 0; }
.wf2-qty-prompt { font-size: 15px; color: var(--text); margin-bottom: 16px; }
.wf2-qty-prompt strong { color: var(--heading); }
.wf2-qty-controls {
  display: flex; align-items: center; justify-content: center; gap: 12px;
}
.wf2-qty-btn {
  width: 40px; height: 40px; border-radius: 50%; border: 2px solid var(--border);
  background: var(--surface); color: var(--text); font-size: 20px; font-weight: 700;
  cursor: pointer; transition: all 0.15s; display: flex; align-items: center; justify-content: center;
}
.wf2-qty-btn:hover { border-color: var(--accent); color: var(--accent); }
.wf2-qty-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.wf2-qty-value {
  font-size: 32px; font-weight: 700; color: var(--heading); min-width: 60px; text-align: center;
}
.wf2-qty-hint { font-size: 13px; color: var(--text-muted); margin-top: 12px; }

/* Batch reprint preview */
.wf2-batch-reprint-preview { margin: 16px 0; }
.wf2-batch-preview-scroll { 
  border: 1px solid var(--border); border-radius: var(--radius-sm); 
  overflow-y: auto; background: var(--surface); 
}
.wf2-batch-preview-item {
  padding: 8px 12px; border-bottom: 1px solid var(--border); font-size: 12px; line-height: 1.4;
}
.wf2-batch-preview-item:last-child { border-bottom: none; }

/* Sheet validation step */
.wf2-sheet-status {
  padding: 16px; border-radius: var(--radius-sm); margin-bottom: 12px;
  display: flex; align-items: flex-start; gap: 12px;
}
.wf2-sheet-status.ok { background: #e8f5e9; border: 1px solid #a5d6a7; }
.wf2-sheet-status.warn { background: #fff8e1; border: 1px solid #ffe082; }
.wf2-sheet-status.error { background: #ffebee; border: 1px solid #ef9a9a; }
[data-theme="dark"] .wf2-sheet-status.ok { background: #1b3a1b; border-color: #2e5e2e; }
[data-theme="dark"] .wf2-sheet-status.warn { background: #3a3418; border-color: #5e5428; }
[data-theme="dark"] .wf2-sheet-status.error { background: #3a1b1b; border-color: #5e2e2e; }
.wf2-sheet-status-icon { font-size: 24px; flex-shrink: 0; }
.wf2-sheet-status-text { font-size: 14px; color: var(--text); line-height: 1.5; }

/* ===== RESPONSIVE ===== */
@media (max-width: 600px) {
  .app-shell {
    padding: 16px;
  }
  
  .workflow-card {
    padding: 16px 18px;
  }
  
  .workflow-icon {
    font-size: 28px;
  }
  
  .workflow-title {
    font-size: 16px;
  }
  
  .secondary-links {
    gap: 6px;
  }
  
  .secondary-link {
    padding: 6px 12px;
    font-size: 12px;
  }
}

/* ===== BATCH IMPORT ===== */
.batch-import-modal { max-width: 560px; }

.batch-file-zone {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 100px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: all 0.15s;
}

.batch-file-zone:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.batch-file-zone.has-file {
  border-style: solid;
  border-color: var(--success-border);
  background: var(--success-bg);
  cursor: default;
}

.batch-file-zone .file-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.batch-file-zone .file-prompt {
  font-size: 13px;
  color: var(--text-muted);
}

.batch-file-zone .file-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 6px;
}

.batch-file-zone .file-info {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.batch-col-mapping {
  margin-bottom: 16px;
  max-height: 180px;
  overflow-y: auto;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px;
}

.batch-col-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  border-bottom: 1px solid var(--border-light);
}

.batch-col-row:last-child {
  border-bottom: none;
}

.batch-col-header {
  flex: 1;
  font-size: 12px;
  font-weight: 600;
  color: var(--heading);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.batch-col-arrow {
  color: var(--text-muted);
  font-size: 12px;
}

.batch-col-token {
  min-width: 120px;
  padding: 4px 8px;
  border: 1px solid var(--input-border);
  border-radius: 4px;
  font-size: 11px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.batch-col-token:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-summary {
  padding: 12px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  background: var(--accent-bg);
  border: 1px solid var(--border);
  font-size: 13px;
  color: var(--accent-text);
}

.batch-summary-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
}

.batch-summary-row .label {
  color: var(--text-secondary);
}

.batch-summary-row .value {
  font-weight: 700;
  font-family: var(--mono);
}

.batch-job-name-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 16px;
}

.batch-job-name-row label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  white-space: nowrap;
}

.batch-job-name-row input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.batch-job-name-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-preview-section {
  margin-bottom: 16px;
}

.batch-preview-title {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

.batch-preview-cards {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 4px 0;
}

.batch-preview-card {
  flex-shrink: 0;
  width: 150px;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-size: 10px;
  line-height: 1.4;
  color: var(--text);
  font-family: Arial, sans-serif;
}

.batch-preview-card .preview-line {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
}

.batch-preview-card .preview-line.align-left { justify-content: flex-start; }
.batch-preview-card .preview-line.align-center { justify-content: center; }
.batch-preview-card .preview-line.align-right { justify-content: flex-end; }

.batch-preview-more {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--text-muted);
  font-weight: 600;
  padding: 0 12px;
}

/* Job Banner */
.job-banner {
  background: var(--accent-bg);
  border: 2px solid var(--accent);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 20px;
}

.job-banner-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.job-banner-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 8px;
}

.job-banner-title .job-icon {
  font-size: 18px;
}

.job-banner-actions {
  display: flex;
  gap: 8px;
}

.job-banner-progress {
  margin-bottom: 12px;
}

.job-progress-bar {
  height: 8px;
  background: var(--border);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 6px;
}

.job-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s;
}

.job-progress-text {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-align: center;
}

.job-banner-info {
  display: flex;
  gap: 16px;
  font-size: 13px;
  color: var(--text-secondary);
}

/* Job Complete Modal */
.job-complete-modal { max-width: 400px; }

.job-complete-summary {
  text-align: center;
  padding: 20px 0;
}

.job-complete-icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.job-complete-count {
  font-size: 36px;
  font-weight: 700;
  color: var(--heading);
}

.job-complete-label {
  font-size: 14px;
  color: var(--text-secondary);
}

.job-remainder-options {
  padding: 16px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin-top: 16px;
}

.job-remainder-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 12px;
}

.job-remainder-option {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 8px 0;
  cursor: pointer;
}

.job-remainder-option input {
  margin-top: 2px;
}

.job-remainder-option-label {
  font-size: 13px;
  color: var(--text);
}

.job-remainder-option-desc {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* ===== SPLIT SHEET MODAL ===== */
.split-modal { max-width: 460px; }
.split-summary {
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 14px;
  color: var(--text);
  margin-bottom: 16px;
  text-align: center;
}
.split-form { display: flex; flex-direction: column; gap: 14px; }
.split-form-group { display: flex; flex-direction: column; gap: 6px; }
.split-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
.split-form label {
  font-size: 14px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.split-form label input[type="radio"] {
  margin: 0;
  accent-color: var(--accent);
}
.split-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.split-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}

/* ===== CLIPBOARD IMPORT MODAL ===== */
.import-modal { max-width: 560px; }
.import-summary {
  padding: 10px 14px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 13px;
  color: var(--text);
  margin-bottom: 14px;
  text-align: center;
}
.import-form { display: flex; flex-direction: column; gap: 14px; }
.import-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; }
.import-form select, .import-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  width: 100%;
}
.import-form select:focus, .import-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}
.import-stepper {
  display: inline-flex;
  align-items: center;
  gap: 0;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  overflow: hidden;
}
.import-stepper button {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.import-stepper button:hover { background: var(--accent-bg); color: var(--accent); }
.import-stepper span {
  min-width: 36px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  background: var(--input-bg);
  padding: 6px 8px;
}
.import-col-mapping { display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; }
.import-col-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 10px;
  background: var(--surface-alt);
  border-radius: 6px;
}
.import-col-row .col-sample {
  flex: 1;
  font-size: 12px;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.import-col-row select {
  width: auto;
  min-width: 100px;
  padding: 4px 8px;
  font-size: 12px;
}
.import-preview-area {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  padding: 10px;
  background: var(--surface-alt);
  border-radius: 6px;
  min-height: 60px;
}
.import-preview-label {
  padding: 6px 10px;
  background: var(--preview-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: Arial, sans-serif;
  font-size: 10px;
  color: var(--preview-text);
  line-height: 1.3;
}
.import-name-preview { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

/* ===== PRINT CSS ===== */
@media print {
  @page { size: letter; margin: 0; }
  html, body { 
    height: 11in !important; 
    width: 8.5in !important; 
    margin: 0 !important; 
    padding: 0 !important; 
    overflow: hidden !important; 
    background: #fff !important; 
    color: #000 !important; 
  }
  body > *:not(.print-sheet) { 
    display: none !important; 
    height: 0 !important; 
    width: 0 !important; 
    overflow: hidden !important; 
    position: absolute !important; 
    visibility: hidden !important; 
  }
  .print-sheet { 
    display: block !important; 
    visibility: visible !important; 
    position: relative !important; 
    width: 8.5in; 
    height: 11in; 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    box-sizing: border-box; 
  }
  .print-label {
    position: absolute; 
    overflow: hidden; 
    font-family: Arial, sans-serif;
    line-height: 1.3; 
    color: #000; 
    display: flex; 
    flex-direction: column;
    box-sizing: border-box;
  }
  .print-label .print-line { 
    width: 100%; 
    display: flex; 
    white-space: nowrap; 
    overflow: hidden; 
  }
  .print-label .print-line.align-left { justify-content: flex-start; text-align: left; }
  .print-label .print-line.align-center { justify-content: center; text-align: center; }
  .print-label .print-line.align-right { justify-content: flex-end; text-align: right; }
  .print-label .print-line.align-split { justify-content: space-between; text-align: left; }
  .print-label .print-line.align-split-fill { display: flex; justify-content: space-between; align-items: flex-end; gap: 12px; }
  .print-label .print-line.align-split-fill .split-fill-left,
  .print-label .print-line.align-split-fill .split-fill-right { display: flex; align-items: flex-end; gap: 3px; flex: 1; }
  .print-label .print-line.align-split-fill .split-fill-right { justify-content: flex-end; }
  .print-label .print-line.fill-line { display: flex; align-items: flex-end; gap: 3px; }
  .print-label .print-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .print-label .print-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid #000; min-width: 0.25in; margin-bottom: 1px; }
  .print-label.empty { color: transparent; }
  /* Tent card printing styles */
  .print-label.tent-card { position: relative; }
  .print-label .fold-line { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px dashed #bbb; z-index: 1; }
  .print-label .tent-top, .print-label .tent-bottom { position: absolute; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; padding: 0.1in; box-sizing: border-box; }
  .print-label .tent-top { top: 0; height: 50%; }
  .print-label .tent-bottom { bottom: 0; height: 50%; transform: rotate(180deg); }
}

.print-sheet { display: none; }

/* ===== BYOAI - AI Assistant Styles ===== */
.ai-key-modal {
  max-width: 420px;
}

.ai-key-modal h3 {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}

.ai-key-input-wrapper {
  margin: 16px 0;
}

.ai-key-input {
  width: 100%;
  padding: 12px;
  font-family: var(--mono);
  font-size: 13px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
}

.ai-key-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-key-hint {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 8px;
}

.ai-key-providers {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 12px;
  font-size: 12px;
  color: var(--text-secondary);
}

.ai-key-providers a {
  color: var(--accent);
  text-decoration: none;
}

.ai-key-providers a:hover {
  text-decoration: underline;
}

.ai-key-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px;
  border-radius: var(--radius-sm);
  background: var(--success-bg);
  color: var(--success-text);
  margin-bottom: 16px;
}

.ai-key-status.no-key {
  background: var(--surface-alt);
  color: var(--text-secondary);
}

.ai-ask-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
}

.ai-ask-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

.ai-ask-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.ai-prompt-input-wrapper {
  margin: 16px 0;
}

.ai-prompt-input {
  width: 100%;
  padding: 12px;
  font-size: 14px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 80px;
}

.ai-prompt-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-prompt-input::placeholder {
  color: var(--text-muted);
}

.ai-generating {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  font-size: 13px;
}

.ai-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: ai-spin 0.8s linear infinite;
}

@keyframes ai-spin {
  to { transform: rotate(360deg); }
}

.ai-error {
  padding: 12px;
  background: var(--error-bg);
  color: var(--error-text);
  border-radius: var(--radius-sm);
  font-size: 13px;
  margin-top: 12px;
}

.ai-settings-section {
  border-top: 1px solid var(--border);
  padding-top: 16px;
  margin-top: 16px;
}

.ai-settings-section h4 {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* ===== AI Preview Modal ===== */
.ai-preview-modal {
  max-width: 540px;
}

.ai-preview-section {
  margin-bottom: 16px;
}

.ai-preview-section-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-understanding {
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-size: 14px;
  color: var(--text);
  border-left: 3px solid var(--accent);
}

.ai-preview-labels {
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  overflow: hidden;
  max-height: 280px;
  overflow-y: auto;
}

.ai-preview-label-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
}

.ai-preview-label-item:last-child {
  border-bottom: none;
}

.ai-preview-label-item:hover {
  background: var(--surface-alt);
}

.ai-preview-label-num {
  min-width: 24px;
  height: 24px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 600;
  flex-shrink: 0;
}

.ai-preview-label-content {
  flex: 1;
  min-width: 0;
}

.ai-preview-label-text {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  word-break: break-word;
}

.ai-preview-label-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-preview-label-edit {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 14px;
  transition: all 0.15s;
  flex-shrink: 0;
}

.ai-preview-label-edit:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.ai-preview-settings {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  font-size: 13px;
  color: var(--text-secondary);
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.ai-preview-setting {
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-setting strong {
  color: var(--text);
}

.ai-preview-skip-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 8px 0;
}

.ai-preview-skip-label input {
  cursor: pointer;
}

.ai-preview-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview inline edit mode */
.ai-preview-label-item.editing {
  background: var(--accent-bg);
}

.ai-preview-label-item.editing .ai-preview-label-text {
  display: none;
}

.ai-preview-edit-input {
  width: 100%;
  padding: 8px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--accent);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
}

.ai-preview-edit-input:focus {
  outline: none;
}

.ai-preview-edit-actions {
  display: flex;
  gap: 6px;
  margin-top: 6px;
}

.ai-preview-edit-actions button {
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  border: none;
}

.ai-preview-edit-save {
  background: var(--accent);
  color: white;
}

.ai-preview-edit-cancel {
  background: var(--surface-alt);
  color: var(--text-secondary);
  border: 1px solid var(--border) !important;
}

/* Refine panel */
.ai-refine-panel {
  display: none;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview error state */
.ai-preview-error {
  padding: 24px;
  text-align: center;
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  border-radius: var(--radius-sm);
}

.ai-preview-error-icon {
  font-size: 32px;
  margin-bottom: 12px;
}

.ai-preview-error-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--warning-text);
  margin-bottom: 8px;
}

.ai-preview-error-message {
  font-size: 14px;
  color: var(--text);
  line-height: 1.5;
  margin-bottom: 12px;
}

.ai-preview-error-hint {
  font-size: 13px;
  color: var(--text-muted);
  font-style: italic;
}

.ai-refine-panel.visible {
  display: block;
}

.ai-refine-original {
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.ai-refine-original strong {
  color: var(--text-secondary);
}

.ai-refine-input {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 60px;
}

.ai-refine-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-refine-input::placeholder {
  color: var(--text-muted);
}

.ai-refine-actions {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

/* ===== EMOJI PICKER (Full Editor) ===== */
.fe-emoji-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.fe-emoji-toggle {
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.fe-emoji-toggle:hover { border-color: var(--accent); }
.fe-emoji-toggle.active { border-color: var(--accent); background: var(--accent-bg); }
.fe-emoji-panel {
  display: none;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-lg);
  padding: 10px;
  margin-bottom: 12px;
}
.fe-emoji-panel.visible { display: block; }
.fe-emoji-search {
  width: 100%;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 13px;
  font-family: inherit;
  margin-bottom: 8px;
}
.fe-emoji-search:focus { outline: none; border-color: var(--accent); }
.fe-emoji-search::placeholder { color: var(--text-faint); }
.fe-emoji-scroll { max-height: 220px; overflow-y: auto; }
.fe-emoji-category { margin-bottom: 8px; }
.fe-emoji-category-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 4px;
}
.fe-emoji-grid { display: flex; flex-wrap: wrap; gap: 2px; }
.fe-emoji-btn {
  width: 34px;
  height: 34px;
  border: none;
  border-radius: 6px;
  background: transparent;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.1s;
}
.fe-emoji-btn:hover { background: var(--accent-bg); }

/* ===== OCR SCAN MODAL ===== */
.ocr-image-area {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 8px;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 140px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: border-color 0.15s;
}
.ocr-image-area:hover { border-color: var(--accent); }
.ocr-image-area.has-image { cursor: default; border-style: solid; padding: 12px; }
.ocr-image-area img {
  max-width: 100%;
  max-height: 220px;
  border-radius: 4px;
  object-fit: contain;
}
.ocr-placeholder {
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  line-height: 1.5;
}
.ocr-rotation-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 12px;
}
.ocr-rotate-btn {
  padding: 6px 14px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  transition: all 0.15s;
}
.ocr-rotate-btn:hover { border-color: var(--accent); background: var(--accent-bg); }
.ocr-rotation-label {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
  text-align: center;
}
.ocr-progress {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 0;
}
.ocr-progress-bar {
  flex: 1;
  height: 8px;
  background: var(--surface-alt);
  border-radius: 4px;
  overflow: hidden;
}
.ocr-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s ease;
}
.ocr-progress-text {
  font-size: 12px;
  color: var(--text-secondary);
  min-width: 90px;
  text-align: right;
  font-family: var(--mono);
}
.ocr-results-area {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}
.ocr-results-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.ocr-result-line {
  display: flex;
  align-items: center;
  gap: 8px;
}
.ocr-result-line input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 13px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.ocr-result-line input:focus { outline: none; border-color: var(--accent); }
.ocr-result-line input.low-confidence { border-color: var(--warning-text); background: var(--warning-bg); }
.ocr-result-line .ocr-conf {
  font-size: 10px;
  font-family: var(--mono);
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
}
.ocr-result-line .ocr-conf.low { color: var(--warning-text); font-weight: 700; }
.ocr-result-line .ocr-line-remove {
  width: 28px;
  height: 28px;
  border: none;
  background: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  flex-shrink: 0;
}
.ocr-result-line .ocr-line-remove:hover { background: var(--error-bg); color: var(--error-text); }
.ocr-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
  font-style: italic;
}

/* ===== INVENTORY BREAKDOWN BAR ===== */
.inventory-breakdown {
  margin-bottom: 16px;
}
.inventory-breakdown-bar {
  display: flex;
  height: 12px;
  border-radius: 6px;
  overflow: hidden;
  background: var(--surface-alt);
  margin-bottom: 8px;
}
.inventory-breakdown-segment {
  height: 100%;
  min-width: 2px;
  transition: width 0.3s ease;
}
.inventory-breakdown-segment.shelf { background: var(--success-text); }
.inventory-breakdown-segment.assigned { background: var(--accent); }
.inventory-breakdown-segment.partial { background: var(--warning-text); }
.inventory-breakdown-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 12px;
}
.inventory-breakdown-item {
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--text-secondary);
}
.inventory-breakdown-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}
.inventory-breakdown-dot.shelf { background: var(--success-text); }
.inventory-breakdown-dot.assigned { background: var(--accent); }
.inventory-breakdown-dot.partial { background: var(--warning-text); }
.inventory-burn-rate {
  margin-top: 8px;
  padding: 8px 12px;
  background: var(--surface-hover, #f8f9fa);
  border-radius: 6px;
  font-size: 12px;
  color: var(--text-muted);
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}
.inventory-burn-stat { display: flex; align-items: center; gap: 4px; }
.inventory-burn-stat strong { color: var(--text); font-weight: 600; }
.inventory-burn-stat.warn strong { color: var(--warning-text); }
.inventory-burn-stat.danger strong { color: var(--danger, #dc2626); }
.inventory-breakdown-value {
  font-weight: 600;
  font-family: var(--mono);
}

/* ===== HISTORY TAB IMPROVEMENTS ===== */
.history-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}
.history-search {
  flex: 1;
  min-width: 200px;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.history-search:focus { outline: none; border-color: var(--accent); }
.history-search::placeholder { color: var(--text-faint); }
.history-filter-select {
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  min-width: 140px;
}
.history-filter-select:focus { outline: none; border-color: var(--accent); }
.history-date-group {
  margin-bottom: 20px;
}
.history-date-header {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border-light);
}
.history-group-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.history-card-checkbox {
  width: 20px;
  height: 20px;
  margin-right: 4px;
  cursor: pointer;
}
.history-bulk-actions {
  display: flex;
  gap: 10px;
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  align-items: center;
}
.history-bulk-count {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent-text);
  margin-right: auto;
}
.history-bulk-btn {
  padding: 8px 14px;
  background: var(--accent);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: #fff;
  cursor: pointer;
  transition: all 0.15s;
}
.history-bulk-btn:hover { background: var(--accent-hover); }
.history-bulk-btn.secondary {
  background: transparent;
  border: 2px solid var(--accent);
  color: var(--accent);
}
.history-bulk-btn.secondary:hover {
  background: var(--accent-bg);
}
.history-no-results {
  text-align: center;
  padding: 32px;
  color: var(--text-muted);
  font-size: 14px;
}
</style>
</head>
<body>

<div class="app-shell" id="appShell">
  <!-- Header -->
  <header class="app-header">
    <div class="app-title">
      ðŸ·ï¸ LabelKeeper
      <span class="version">v3.27.7</span>
    </div>
    <div class="header-actions">
      <button class="icon-btn" onclick="openSettings()" title="Settings">âš™ï¸</button>
    </div>
  </header>

  <!-- Tab Bar -->
  <nav class="tab-bar" id="tabBar">
    <button class="tab-btn active" data-tab="workflows" onclick="switchTab('workflows')">Workflows</button>
    <button class="tab-btn" data-tab="sheets" onclick="switchTab('sheets')">Sheets</button>
    <button class="tab-btn" data-tab="saved" onclick="switchTab('saved')">Content</button>
    <button class="tab-btn" data-tab="templates" onclick="switchTab('templates')">Templates</button>
    <button class="tab-btn" data-tab="inventory" onclick="switchTab('inventory')">Inventory</button>
    <button class="tab-btn" data-tab="history" onclick="switchTab('history')">History</button>
  </nav>

  <!-- Workflow Hub (Workflows Tab) -->
  <main class="workflow-hub active" id="workflowHub">
    <div>
      <h2 class="workflow-heading">What would you like to do?</h2>
    </div>
    
    <div class="workflow-cards-row">
      <div class="workflow-card-primary" onclick="wf1Start()">
        <div class="workflow-icon">ðŸ–¨ï¸</div>
        <div class="workflow-title">Print Something New</div>
        <div class="workflow-desc">Create new labels â€” single design or a mailing list</div>
      </div>
      
      <div class="workflow-card-primary" onclick="wf2Start()">
        <div class="workflow-icon">ðŸ”„</div>
        <div class="workflow-title">Print Something Again</div>
        <div class="workflow-desc">Reprint from your saved content or history</div>
      </div>
    </div>
    
    <!-- AI conversational prompt â€” only visible when AI key is set -->
    <div class="workflow-ai-prompt" id="workflowAiPrompt" style="display:none;">
      <div class="ai-conv-input-row">
        <span class="ai-conv-sparkle">âœ¨</span>
        <input type="text" class="ai-conv-input" id="aiConvInput" 
          placeholder="...or tell me what you need" 
          onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();aiConvSend()}"
          autocomplete="off">
        <button class="ai-conv-send" id="aiConvSendBtn" onclick="aiConvSend()" title="Send">
          <span class="ai-conv-send-icon">â†’</span>
        </button>
      </div>
      <div class="ai-conv-suggestions" id="aiConvSuggestions">
        <span class="ai-conv-chip" onclick="aiConvFill('I need address labels')">ðŸ“¬ Address labels</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Print name badges for a meeting')">ðŸ‘‹ Name badges</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Make pantry labels')">ðŸ·ï¸ Organize</span>
        <span class="ai-conv-chip" onclick="aiConvFill('Reprint my last labels')">ðŸ”„ Reprint</span>
      </div>
      <div class="ai-conv-status" id="aiConvStatus" style="display:none;">
        <div class="ai-conv-thinking">
          <div class="ai-spinner"></div>
          <span id="aiConvStatusText">Thinking...</span>
        </div>
      </div>
      <div class="ai-conv-response" id="aiConvResponse" style="display:none;"></div>
    </div>
    
    <!-- Quick Actions section (T10-T11) - populated dynamically -->
    <div class="quick-actions-section" id="quickActionsSection">
      <!-- Populated by renderQuickActions() -->
    </div>
  </main>

  <!-- Tab Panels (Power Mode) -->
  <div id="tabPanels">
    <div class="tab-panel" id="panel-sheets">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“„</div>
        <div class="panel-placeholder-text">Your label sheets will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-saved">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ’¾</div>
        <div class="panel-placeholder-text">Saved content will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-templates">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“</div>
        <div class="panel-placeholder-text">Templates will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-inventory">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“¦</div>
        <div class="panel-placeholder-text">Inventory tracking will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-history">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“œ</div>
        <div class="panel-placeholder-text">Print history will appear here</div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" style="max-width: 440px;">
    <div class="modal-header">
      <div class="modal-title">Settings</div>
      <button class="modal-close" onclick="closeSettings()">Ã—</button>
    </div>
    <div class="modal-body">
      
      <!-- ===== GENERAL (Most Used) ===== -->
      <div class="settings-section-title">General</div>
      
      <div class="setting-row">
        <div>
          <div class="setting-label">Dark Mode</div>
          <div class="setting-desc">Use dark color theme</div>
        </div>
        <div class="toggle" id="darkModeToggle" onclick="toggleDarkMode()">
          <div class="toggle-thumb"></div>
        </div>
      </div>
      
      <div class="setting-row" style="margin-top: 16px;">
        <div style="flex: 1;">
          <div class="setting-label">Quick Actions</div>
          <div class="setting-desc">Recent prints on home screen (0 = hide)</div>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="quickActionsCount" min="0" max="10" step="1" style="width: 60px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updateQuickActionsCount()">
        </div>
      </div>
      
      <!-- ===== DATA MANAGEMENT ===== -->
      <div class="settings-divider"></div>
      <div class="settings-section-title">Data &amp; Sync</div>
      
      <div class="settings-data-stats" id="settingsDataStats">
        <!-- Populated by JS -->
      </div>
      
      <!-- Backup Status -->
      <div id="backupStatusBox" class="backup-status-box">
        <!-- Populated by JS -->
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="exportAllData()">
          <span>ðŸ“¤</span> Export Backup
        </button>
        <label class="settings-action-btn">
          <span>ðŸ“¥</span> Import Backup
          <input type="file" accept=".json" style="display:none;" onchange="importData(this.files[0])">
        </label>
      </div>
      
      <!-- Device Sync (Collapsible) -->
      <div class="settings-section-collapsible" style="margin-top: 16px;" onclick="toggleSettingsDeviceSync()">
        <div class="setting-label" style="cursor: pointer; display: flex; align-items: center; gap: 8px;">
          <span id="settingsDeviceSyncArrow" style="font-size: 12px; transition: transform 0.2s;">â–¶</span>
          ðŸ“± Device Sync
        </div>
        <div class="setting-desc" style="margin-left: 20px; margin-top: 2px;">Sync between primary &amp; satellite devices</div>
      </div>
      
      <div id="settingsDeviceSyncPanel" style="display: none; margin-top: 12px;">
        <!-- Device Role Selector -->
        <div class="setting-row" style="margin-bottom: 16px;">
          <div class="setting-label">This device is:</div>
          <div class="device-role-selector" id="deviceRoleSelector">
            <button class="device-role-btn" data-role="primary" onclick="setDeviceRole('primary')">
              <span class="role-icon">ðŸ’»</span>
              <span class="role-name">Primary</span>
              <span class="role-desc">Full access, can print</span>
            </button>
            <button class="device-role-btn" data-role="satellite" onclick="setDeviceRole('satellite')">
              <span class="role-icon">ðŸ“±</span>
              <span class="role-name">Satellite</span>
              <span class="role-desc">Capture content only</span>
            </button>
          </div>
        </div>
        
        <!-- Primary mode buttons -->
        <div id="syncPrimaryUI">
          <div class="setting-desc" style="margin-bottom: 12px;">
            Sync content between your primary and satellite devices.
          </div>
          <div class="settings-btn-row">
            <button class="settings-action-btn" onclick="primaryReceiveFromSatellite()">
              <span>ðŸ“¥</span> Receive from Satellite
            </button>
            <button class="settings-action-btn" onclick="primaryShareToSatellite()">
              <span>ðŸ“¤</span> Share to Satellite
            </button>
          </div>
          <div class="settings-btn-row" style="margin-top: 8px;">
            <button class="settings-action-btn secondary" onclick="primaryTransferRole()">
              <span>ðŸ”„</span> Transfer Primary to Another Device
            </button>
          </div>
        </div>
        
        <!-- Satellite mode buttons -->
        <div id="syncSatelliteUI" style="display: none;">
          <div class="setting-desc" style="margin-bottom: 12px;">
            Content you create here will sync to your primary device.
          </div>
          
          <!-- Pending queue display -->
          <div id="satellitePendingSection" style="margin-bottom: 16px;">
            <div class="setting-label" style="margin-bottom: 8px;">Pending sync (<span id="satellitePendingCount">0</span> items):</div>
            <div id="satellitePendingList" class="satellite-pending-list">
              <!-- Populated by JS -->
            </div>
          </div>
          
          <div class="settings-btn-row">
            <button class="settings-action-btn" onclick="satelliteShareToPrimary()">
              <span>ðŸ“¤</span> Share to Primary
            </button>
            <button class="settings-action-btn" onclick="satelliteReceiveFromPrimary()">
              <span>ðŸ“¥</span> Receive from Primary
            </button>
          </div>
        </div>
      </div>
      
      <div class="settings-btn-row" style="margin-top: 16px;">
        <button class="settings-action-btn secondary" onclick="showWelcome()">
          <span>ðŸ‘‹</span> Show Welcome
        </button>
        <button class="settings-action-btn danger" onclick="clearAllData()">
          <span>ðŸ—‘ï¸</span> Clear All Data
        </button>
      </div>
      
      <!-- ===== ADVANCED (Collapsible) ===== -->
      <div class="settings-divider"></div>
      <div class="settings-section-collapsible" onclick="toggleSettingsAdvanced()">
        <div class="settings-section-title" style="margin-bottom: 0; cursor: pointer; display: flex; align-items: center; gap: 8px;">
          <span id="settingsAdvancedArrow" style="font-size: 12px; transition: transform 0.2s;">â–¶</span>
          Advanced
        </div>
        <div class="setting-desc" style="margin-left: 20px; margin-top: 4px;">Print calibration settings</div>
      </div>
      
      <div id="settingsAdvancedPanel" style="display: none; margin-top: 12px;">
        <div class="settings-warning-box">
          <div class="settings-warning-icon">âš ï¸</div>
          <div class="settings-warning-text">
            <strong>Caution:</strong> These settings affect print alignment. Only adjust if labels are printing incorrectly on paper. Safari's print preview may look wrong but usually prints correctly at default values.
          </div>
        </div>
        
        <div class="setting-row" style="margin-top: 16px; margin-bottom: 12px;">
          <div style="flex: 1;">
            <div class="setting-label">Safari Vertical Scale</div>
            <div class="setting-desc" style="font-size: 11px;">Compresses labels vertically (0.90-1.0)</div>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <input type="number" id="safariVScale" min="0.90" max="1.0" step="0.01" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
          </div>
        </div>
        
        <div class="setting-row" style="gap: 16px;">
          <div style="flex: 1;">
            <div class="setting-label">Vertical Offset</div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
              <input type="number" id="printOffsetTop" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
              <span style="color: var(--text-muted); font-size: 13px;">in</span>
            </div>
          </div>
          <div style="flex: 1;">
            <div class="setting-label">Horizontal Offset</div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
              <input type="number" id="printOffsetLeft" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
              <span style="color: var(--text-muted); font-size: 13px;">in</span>
            </div>
          </div>
        </div>
        
        <div class="setting-row" style="margin-top: 16px;">
          <div>
            <div class="setting-label">Show Label Boundaries</div>
            <div class="setting-desc">Print gray rectangles for alignment testing</div>
          </div>
          <div class="toggle" id="labelBoundariesToggle" onclick="toggleLabelBoundaries()">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        
        <button class="settings-action-btn secondary" style="margin-top: 16px; width: 100%;" onclick="resetAdvancedSettings()">
          <span>â†©ï¸</span> Reset to Defaults
        </button>
      </div>
      
      <!-- ===== AI INTEGRATION ===== -->
      <div class="settings-divider"></div>
      <div class="settings-section-title">AI Integration</div>
      
      <!-- BYOAI Status -->
      <div id="aiKeyStatus" class="ai-key-status no-key">
        <span>ðŸ”‘</span>
        <span id="aiKeyStatusText">No API key configured</span>
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" id="aiKeyConfigBtn" onclick="showAIKeyModal()">
          <span>ðŸ”‘</span> <span id="aiKeyConfigBtnText">Add API Key</span>
        </button>
        <button class="settings-action-btn secondary" id="aiKeyClearBtn" onclick="clearAIKey()" style="display: none;">
          <span>ðŸ—‘ï¸</span> Remove Key
        </button>
      </div>
      
      <div class="setting-desc" style="margin: 12px 0;">
        Add your own API key to enable "âœ¨ Ask AI" in the editor. Your key stays on this device only.
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">External AI (Copy/Paste)</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Use any AI (Claude, ChatGPT, etc.) to generate labels. Copy the prompt below and paste AI-generated labels directly into the editor.
      </div>
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showAIPromptModal()">
          <span>ðŸ¤–</span> View AI Prompt
        </button>
        <button class="settings-action-btn secondary" onclick="copyDeepLinkExample()">
          <span>ðŸ”—</span> Copy Link Format
        </button>
      </div>
      
      <!-- ===== HELP ===== -->
      <div class="settings-divider"></div>
      <div class="settings-section-title">Help</div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showShortcutsModal()">
          <span>âŒ¨ï¸</span> Keyboard Shortcuts
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Modal -->
<div class="modal-overlay" id="shortcutsModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <div class="modal-title">Keyboard Shortcuts</div>
      <button class="modal-close" onclick="closeShortcutsModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="shortcuts-section">
        <div class="shortcuts-title">Global</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Esc</span>
          <span class="shortcut-desc">Close modal or wizard</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">?</span>
          <span class="shortcut-desc">Show this help (when not typing)</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Text Editor / OCR</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Ctrl+V</span>
          <span class="shortcut-desc">Paste text or image</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Enter</span>
          <span class="shortcut-desc">Confirm dialog / Submit form</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Navigation</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Tab</span>
          <span class="shortcut-desc">Move between fields</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Prompt Modal -->
<div class="modal-overlay" id="aiPromptModal">
  <div class="modal" style="max-width: 560px;">
    <div class="modal-header">
      <div class="modal-title">AI Integration</div>
      <button class="modal-close" onclick="closeAIPromptModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ“‹ Copy this prompt to your AI assistant:</h3>
        <div class="ai-prompt-box" id="aiPromptBox">
          <!-- Populated by JS -->
        </div>
        <button class="ai-prompt-copy-btn" onclick="copyAIPrompt()">
          <span>ðŸ“‹</span> Copy Prompt
        </button>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ¤– How it works:</h3>
        <ol class="ai-prompt-steps">
          <li>Copy the prompt above and paste it into Claude, ChatGPT, or any AI</li>
          <li>Ask the AI to generate labels (e.g., "Create address labels for John Smith at 123 Main St")</li>
          <li>Copy the AI's output</li>
          <li>Paste into LabelKeeper's text editor â€” it auto-detects the format!</li>
        </ol>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ”— Deep Link Format:</h3>
        <div class="ai-prompt-example" style="font-family: var(--mono); font-size: 12px; background: var(--surface-alt); padding: 12px; border-radius: 8px; word-break: break-all;">
          labelkeeper.html?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1
        </div>
        <div class="setting-desc" style="margin-top: 8px;">
          Use pipe (|) to separate lines. URL-encode special characters.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Key Setup Modal (BYOAI) -->
<div class="modal-overlay" id="aiKeyModal">
  <div class="modal ai-key-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Enable AI Assistant</div>
      <button class="modal-close" onclick="closeAIKeyModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <p style="color: var(--text-secondary); margin-bottom: 16px;">
        Paste your API key to use AI features. Your key stays on this device only â€” it's never sent anywhere except directly to your chosen AI provider.
      </p>
      
      <div class="ai-key-input-wrapper">
        <input type="password" class="ai-key-input" id="aiKeyInput" placeholder="sk-ant-... or sk-..." autocomplete="off">
        <div class="ai-key-hint">
          Works with: <strong>Claude</strong> â€¢ <strong>OpenAI</strong> â€¢ <strong>Gemini</strong>
        </div>
      </div>
      
      <div class="ai-key-providers">
        <span>Get a key:</span>
        <a href="https://console.anthropic.com/settings/keys" target="_blank">Claude â†’</a>
        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI â†’</a>
        <a href="https://aistudio.google.com/app/apikey" target="_blank">Gemini â†’</a>
      </div>
      
      <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIKeyModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveAIKey()">Save & Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Modal -->
<div class="modal-overlay" id="aiCategoryModal">
  <div class="modal" style="max-width: 500px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ What kind of labels?</div>
      <button class="modal-close" onclick="closeAICategoryModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-category-grid">
        <div class="ai-category-card" onclick="selectAICategory('address')">
          <div class="ai-category-icon">ðŸ“¬</div>
          <div class="ai-category-title">Address</div>
          <div class="ai-category-desc">Return address or shipping labels</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('gift')">
          <div class="ai-category-icon">ðŸŽ</div>
          <div class="ai-category-title">Gift</div>
          <div class="ai-category-desc">Gift tags for any occasion</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('organize')">
          <div class="ai-category-icon">ðŸ·ï¸</div>
          <div class="ai-category-title">Organize</div>
          <div class="ai-category-desc">Pantry, files, bins, storage</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('moving')">
          <div class="ai-category-icon">ðŸ“¦</div>
          <div class="ai-category-title">Moving</div>
          <div class="ai-category-desc">Box labels with room & contents</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('nametag')">
          <div class="ai-category-icon">ðŸ‘‹</div>
          <div class="ai-category-title">Name Tag</div>
          <div class="ai-category-desc">Name badges for events</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('custom')">
          <div class="ai-category-icon">âœï¸</div>
          <div class="ai-category-title">Custom</div>
          <div class="ai-category-desc">Describe anything you need</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Form Modal -->
<div class="modal-overlay" id="aiFormModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <button class="modal-back" onclick="backToAICategories()" style="background:none;border:none;font-size:20px;cursor:pointer;color:var(--text-secondary);margin-right:8px;">â†</button>
      <div class="modal-title" id="aiFormTitle">âœ¨ Address Labels</div>
      <button class="modal-close" onclick="closeAIFormModal()">Ã—</button>
    </div>
    <div class="modal-body" id="aiFormBody">
      <!-- Form content injected by JS -->
    </div>
  </div>
</div>

<!-- AI Generate Modal (BYOAI) -->
<div class="modal-overlay" id="aiGenerateModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Ask AI</div>
      <button class="modal-close" onclick="closeAIGenerateModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-input-wrapper">
        <textarea class="ai-prompt-input" id="aiPromptTextarea" placeholder="Describe the label you want to create...

Examples:
â€¢ Return address label for John Smith at 123 Main St, Boston MA 02101
â€¢ Shipping label for Acme Corp, 456 Business Ave, Suite 100, Chicago IL 60601
â€¢ Make a label that says &quot;Happy Birthday&quot; with confetti vibes"></textarea>
      </div>
      
      <div id="aiGenerateStatus" style="display: none;">
        <div class="ai-generating">
          <div class="ai-spinner"></div>
          <span>Generating...</span>
        </div>
      </div>
      
      <div id="aiGenerateError" class="ai-error" style="display: none;"></div>
      
      <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIGenerateModal()">Cancel</button>
        <button class="btn btn-primary" id="aiGenerateBtn" onclick="generateWithAI()">
          âœ¨ Generate
        </button>
      </div>
    </div>
  </div>
</div>

<!-- AI Preview Modal -->
<div class="modal-overlay" id="aiPreviewModal">
  <div class="modal ai-preview-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ AI Preview</div>
      <button class="modal-close" onclick="closeAIPreviewModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Understanding section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“ What I understood</div>
        <div class="ai-preview-understanding" id="aiPreviewUnderstanding">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Labels section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ·ï¸ Labels I'll create (<span id="aiPreviewLabelCount">0</span>)</div>
        <div class="ai-preview-labels" id="aiPreviewLabels">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Settings section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“‹ Settings</div>
        <div class="ai-preview-settings">
          <div class="ai-preview-setting">
            <span>Type:</span>
            <strong id="aiPreviewType">5160 Address Labels</strong>
          </div>
          <div class="ai-preview-setting">
            <span>Quantity:</span>
            <strong id="aiPreviewQty">1</strong>
          </div>
        </div>
      </div>
      
      <!-- Skip preview checkbox -->
      <label class="ai-preview-skip-label">
        <input type="checkbox" id="aiPreviewSkip" onchange="toggleAIPreviewSkip()">
        <span>Don't show preview (trust AI output)</span>
      </label>
      
      <!-- Refine panel (hidden by default) -->
      <div class="ai-refine-panel" id="aiRefinePanel">
        <div class="ai-refine-original">
          <strong>Original request:</strong> <span id="aiRefineOriginal"></span>
        </div>
        <textarea class="ai-refine-input" id="aiRefineInput" placeholder="Add more detail or corrections..."></textarea>
        <div class="ai-refine-actions">
          <button class="btn btn-secondary" onclick="hideRefinePanel()">Cancel</button>
          <button class="btn btn-primary" onclick="regenerateWithRefinement()">âœ¨ Regenerate</button>
        </div>
      </div>
      
      <!-- Action buttons -->
      <div class="ai-preview-actions" id="aiPreviewActions">
        <button class="btn btn-secondary" onclick="closeAIPreviewModal()">Cancel</button>
        <button class="btn btn-secondary" onclick="showRefinePanel()">ðŸ”„ Refine</button>
        <button class="btn btn-primary" onclick="acceptAIPreview()">âœ“ Accept</button>
      </div>
    </div>
  </div>
</div>

<!-- Barcode Modal -->
<div class="modal-overlay" id="barcodeModal" style="z-index: 1100;">
  <div class="modal" style="max-width: 420px;">
    <div class="modal-header">
      <div class="modal-title">â–£ Add Barcode</div>
      <button class="modal-close" onclick="closeBarcodeModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Analysis Results -->
      <div class="barcode-analysis-box" id="barcodeAnalysisBox">
        <!-- Populated by JS -->
      </div>
      
      <!-- QR Options (shown when QR selected) -->
      <div id="barcodeQrOptions" style="display: none; margin-top: 16px;">
        <div class="form-group">
          <label class="form-label">Position</label>
          <div class="barcode-position-selector">
            <button type="button" class="barcode-pos-btn" data-pos="only" onclick="setBarcodePosition('only')">
              <span class="pos-icon">â–£</span> Replace Text
            </button>
            <button type="button" class="barcode-pos-btn" data-pos="left" onclick="setBarcodePosition('left')">
              <span class="pos-icon">â—¨</span> Left + Text
            </button>
            <button type="button" class="barcode-pos-btn active" data-pos="right" onclick="setBarcodePosition('right')">
              <span class="pos-icon">â—§</span> Right + Text
            </button>
          </div>
        </div>
        
        <div class="form-group" style="margin-top: 12px;">
          <label class="form-label">Encode As</label>
          <select class="form-input" id="barcodeEncodeType" style="padding: 8px 12px;">
            <option value="text">Plain Text</option>
            <option value="vcard">vCard (Contact)</option>
            <option value="url">URL</option>
          </select>
        </div>
      </div>
      
      <!-- 1D Barcode Options (shown when 1D barcode selected - future) -->
      <div id="barcode1dOptions" style="display: none; margin-top: 16px;">
        <label class="form-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="barcode1dShowText" checked>
          Show text below barcode
        </label>
      </div>
      
      <div class="modal-btns" style="margin-top: 20px;">
        <button class="btn btn-secondary" onclick="closeBarcodeModal()">Cancel</button>
        <button class="btn btn-danger" id="barcodeRemoveBtn" style="display: none;" onclick="removeBarcode()">Remove</button>
        <button class="btn btn-primary" id="barcodeApplyBtn" onclick="applyBarcode()">Apply</button>
      </div>
    </div>
  </div>
</div>

<!-- OCR Scan Modal -->
<div class="modal-overlay" id="ocrModal" style="z-index: 1100;">
  <div class="modal" style="max-width: 520px;">
    <div class="modal-header">
      <div class="modal-title">ðŸ“· Scan Image</div>
      <button class="modal-close" onclick="closeOcrModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Image area: shows preview, click to pick file -->
      <div class="ocr-image-area" id="ocrImageArea" onclick="ocrImageAreaClick()">
        <div class="ocr-placeholder" id="ocrPlaceholder">
          <div style="font-size: 32px; margin-bottom: 6px;">ðŸ“·</div>
          <div>Click to select an image, or drag & drop</div>
          <div style="font-size: 11px; margin-top: 6px; color: var(--text-faint);">or paste a screenshot (Ctrl+V / âŒ˜V)</div>
        </div>
        <img id="ocrPreviewImg" style="display: none;" alt="Scanned image">
      </div>
      <input type="file" id="ocrFileInput" accept="image/*" style="display: none;" onchange="handleOcrFile(event)">
      
      <!-- Rotation controls -->
      <div class="ocr-rotation-bar" id="ocrRotationBar" style="display: none;">
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(-90)" title="Rotate left">â†¶</button>
        <span class="ocr-rotation-label" id="ocrRotationLabel"></span>
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(90)" title="Rotate right">â†·</button>
      </div>
      
      <!-- Progress bar -->
      <div id="ocrProgressArea" style="display: none;">
        <div class="ocr-progress">
          <div class="ocr-progress-bar"><div class="ocr-progress-fill" id="ocrProgressFill"></div></div>
          <div class="ocr-progress-text" id="ocrProgressText">Loadingâ€¦</div>
        </div>
      </div>
      
      <!-- Editable results -->
      <div id="ocrResultsArea" style="display: none;">
        <div class="ocr-results-label">Extracted text â€” edit as needed:</div>
        <div class="ocr-results-area" id="ocrResultLines"></div>
        <div class="ocr-hint" id="ocrHint"></div>
      </div>
      
      <div class="modal-btns" style="margin-top: 16px;">
        <button class="btn btn-secondary" onclick="closeOcrModal()">Cancel</button>
        <button class="btn btn-secondary" id="ocrNewImageBtn" style="display: none;" onclick="ocrNewImage()">ðŸ“· New</button>
        <button class="btn btn-secondary" id="ocrRescanBtn" style="display: none;" onclick="ocrRescan()">ðŸ”„ Rescan</button>
        <button class="btn btn-primary" id="ocrConfirmBtn" style="display: none;" onclick="confirmOcr()">Use Text</button>
      </div>
    </div>
  </div>
</div>

<!-- Full Editor (ported from v1.2.0) -->
<div class="full-editor-overlay" id="fullEditorOverlay">
  <div class="full-editor-container">
    <div class="full-editor-header">
      <button class="full-editor-back" onclick="closeFullEditor()">â†</button>
      <div>
        <div class="full-editor-title" id="fullEditorTitle">Edit Label</div>
        <div class="full-editor-subtitle" id="fullEditorSubtitle">Full formatting options</div>
      </div>
    </div>
    
    <!-- Name input (for new/rename) -->
    <div class="fe-name-row" id="feNameRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feName" placeholder="Name this label (e.g., Return Address, Aria's Labels)">
    </div>
    
    <!-- Name display for existing (editable) -->
    <div class="fe-name-row" id="feNameEditRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feNameEdit" placeholder="Label name">
      <span class="fe-dirty-indicator" id="feDirtyIndicator">â— unsaved</span>
    </div>
    
    <!-- Style Template Selector -->
    <div class="fe-style-template-row" id="feStyleTemplateRow">
      <span class="fe-style-template-label">ðŸŽ¨ Style:</span>
      <select class="fe-style-template-select" id="feStyleTemplateSelect" onchange="applyStyleTemplate(this.value)">
        <option value="">â€” None (manual styling) â€”</option>
      </select>
    </div>
    
    <!-- Style Editor Mode Notice (hidden by default) -->
    <div class="fe-style-editor-notice" id="feStyleEditorNotice" style="display:none;">
      <strong>âœï¸ Editing Style Template</strong>
      Text is disabled â€” adjust only visual styling (fonts, colors, graphics, borders).
      <div class="fe-style-meta-row" style="display:flex; gap:12px; margin-top:8px; flex-wrap:wrap;">
        <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
          Category:
          <select id="feStyleCategory" style="padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--input-bg);color:var(--text);font-size:12px;">
            <option value="holiday">ðŸŽ„ Holiday</option>
            <option value="wedding">ðŸ’’ Wedding</option>
            <option value="birthday">ðŸŽ‚ Birthday</option>
            <option value="baby">ðŸ‘¶ Baby</option>
            <option value="professional">ðŸ’¼ Professional</option>
            <option value="school">ðŸ“š School</option>
            <option value="seasonal">ðŸ‚ Seasonal</option>
            <option value="simple">âœ¨ Simple & Clean</option>
          </select>
        </label>
        <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
          Label Type:
          <select id="feStyleLabelType" style="padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--input-bg);color:var(--text);font-size:12px;">
            <option value="5160">5160 (Address)</option>
            <option value="5163">5163 (Shipping)</option>
            <option value="5164">5164 (Large)</option>
            <option value="5167">5167 (Return)</option>
            <option value="5195">5195 (Small)</option>
            <option value="8293">8293 (Round)</option>
            <option value="5395">5395 (Badge)</option>
            <option value="5302">5302 (Tent)</option>
          </select>
        </label>
      </div>
    </div>
    
    <!-- Text Input Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Label Text</div>
      
      <!-- Global Style Controls -->
      <div class="fe-global-style-row">
        <span class="fe-global-style-label">All lines:</span>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('bold')" id="feGlobalBold" title="Bold all"><b>B</b></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('italic')" id="feGlobalItalic" title="Italic all"><i>I</i></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('underline')" id="feGlobalUnderline" title="Underline all"><u>U</u></button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('left')" title="Align all left">â†</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('center')" title="Align all center">â€¢</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('right')" title="Align all right">â†’</button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(11)" title="Size 11 all">11</button>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(14)" title="Size 14 all">14</button>
      </div>
      
      <div id="feLineInputs">
        <!-- Line 1 -->
        <div class="fe-line-row">
          <span class="fe-line-num">1</span>
          <input type="text" class="fe-line-input" id="feLine1" placeholder="Line 1 â€” use || to split, __ for fill line" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=1">
          <button class="fe-align-btn active" data-line="1" data-align="left" onclick="setFeAlign(1,'left')">â†</button>
          <button class="fe-align-btn" data-line="1" data-align="center" onclick="setFeAlign(1,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="1" data-align="right" onclick="setFeAlign(1,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(1,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize1">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(1,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn1" onclick="toggleFeStylePopover(1)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover1"></div>
          </div>
        </div>
        
        <!-- Line 2 -->
        <div class="fe-line-row">
          <span class="fe-line-num">2</span>
          <input type="text" class="fe-line-input" id="feLine2" placeholder="Line 2" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=2">
          <button class="fe-align-btn active" data-line="2" data-align="left" onclick="setFeAlign(2,'left')">â†</button>
          <button class="fe-align-btn" data-line="2" data-align="center" onclick="setFeAlign(2,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="2" data-align="right" onclick="setFeAlign(2,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(2,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize2">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(2,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn2" onclick="toggleFeStylePopover(2)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover2"></div>
          </div>
        </div>
        
        <!-- Line 3 -->
        <div class="fe-line-row">
          <span class="fe-line-num">3</span>
          <input type="text" class="fe-line-input" id="feLine3" placeholder="Line 3" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=3">
          <button class="fe-align-btn active" data-line="3" data-align="left" onclick="setFeAlign(3,'left')">â†</button>
          <button class="fe-align-btn" data-line="3" data-align="center" onclick="setFeAlign(3,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="3" data-align="right" onclick="setFeAlign(3,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(3,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize3">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(3,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn3" onclick="toggleFeStylePopover(3)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover3"></div>
          </div>
        </div>
        
        <!-- Line 4 -->
        <div class="fe-line-row">
          <span class="fe-line-num">4</span>
          <input type="text" class="fe-line-input" id="feLine4" placeholder="Line 4" maxlength="80" oninput="updateFullEditorPreview()" onpaste="setTimeout(updateFullEditorPreview,0)" onfocus="feLastFocusedLine=4">
          <button class="fe-align-btn active" data-line="4" data-align="left" onclick="setFeAlign(4,'left')">â†</button>
          <button class="fe-align-btn" data-line="4" data-align="center" onclick="setFeAlign(4,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="4" data-align="right" onclick="setFeAlign(4,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(4,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize4">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(4,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn4" onclick="toggleFeStylePopover(4)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover4"></div>
          </div>
        </div>
      </div>
      
      <div class="fe-line-hint">Use <code>||</code> to split a line Â· Use <code>__</code> for a fill line, e.g. <code>Name__</code></div>
      
      <!-- Token Panel (for templates) -->
      <div class="fe-token-toggle-row" id="feTokenToggleRow" style="display:none;">
        <button class="fe-token-toggle" id="feTokenToggle" onclick="toggleFeTokenPanel()">{T} Insert Token</button>
      </div>
      <div class="fe-token-panel" id="feTokenPanel"></div>
      
      <!-- Emoji Panel -->
      <div class="fe-emoji-toggle-row">
        <button class="fe-emoji-toggle" id="feClearToggle" onclick="clearEditorLines()" title="Clear text lines">ðŸ§¹ Clear</button>
        <button class="fe-emoji-toggle" id="fePasteToggle" onclick="pasteToEditor()" title="Paste from clipboard">ðŸ“‹ Paste</button>
        <button class="fe-emoji-toggle" id="feEmojiToggle" onclick="toggleFeEmojiPanel()">ðŸ˜€ Emoji</button>
        <button class="fe-emoji-toggle" id="feOcrToggle" onclick="openOcrModal()">ðŸ“· Scan</button>
        <button class="fe-emoji-toggle" id="feBarcodeToggle" onclick="openBarcodeModal()">â–£ Barcode</button>
      </div>
      <div class="fe-emoji-panel" id="feEmojiPanel">
        <input type="text" class="fe-emoji-search" id="feEmojiSearch" placeholder="Search emojiâ€¦" oninput="filterFeEmojis()">
        <div class="fe-emoji-scroll" id="feEmojiScroll"></div>
      </div>
      
      <!-- Vertical Alignment -->
      <div class="fe-valign-row">
        <span class="fe-valign-label">Vertical:</span>
        <button class="fe-valign-btn" data-valign="top" onclick="setFeValign('top')">â†‘</button>
        <button class="fe-valign-btn active" data-valign="center" onclick="setFeValign('center')">â€”</button>
        <button class="fe-valign-btn" data-valign="bottom" onclick="setFeValign('bottom')">â†“</button>
        <button class="fe-valign-btn" data-valign="spread" onclick="setFeValign('spread')">â†•</button>
      </div>
      
      <!-- Graphics -->
      <div class="fe-graphics-section">
        <div class="full-editor-section-title">Graphics</div>
        <div class="fe-graphics-row" id="feGraphicsLeft">
          <span class="fe-graphics-label">Left:</span>
          <span id="feGraphicLeftContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('left')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
        <div class="fe-graphics-row" id="feGraphicsRight">
          <span class="fe-graphics-label">Right:</span>
          <span id="feGraphicRightContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('right')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
      </div>
      
      <!-- Border Controls -->
      <div class="fe-border-section">
        <div class="full-editor-section-title">Label Border</div>
        <div class="fe-border-row">
          <div class="fe-border-toggles">
            <button class="fe-border-toggle" id="feBorderTop" onclick="toggleFeBorder('top')" title="Top border">T</button>
            <button class="fe-border-toggle" id="feBorderBottom" onclick="toggleFeBorder('bottom')" title="Bottom border">B</button>
            <button class="fe-border-toggle" id="feBorderLeft" onclick="toggleFeBorder('left')" title="Left border">L</button>
            <button class="fe-border-toggle" id="feBorderRight" onclick="toggleFeBorder('right')" title="Right border">R</button>
          </div>
          <button class="fe-global-style-btn" onclick="toggleAllBorders()" id="feBorderAll" title="Toggle all borders">All</button>
          <div class="fe-border-color">
            <input type="color" class="fe-border-color-swatch" id="feBorderColor" value="#000000" onchange="updateFeBorderColor(this.value)" title="Border color">
          </div>
        </div>
      </div>
    </div>
    
    <!-- Preview Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Preview</div>
      <div class="fe-preview-container">
        <div class="fe-preview-label empty-preview" id="fePreviewLabel">
          <span>Type above to preview</span>
        </div>
      </div>
      <div class="fe-preview-dimensions" id="fePreviewDimensions"></div>
      <div class="fe-preview-type-row">
        <span class="fe-preview-type-label">Preview as:</span>
        <select class="fe-preview-type-select" id="fePreviewType" onchange="changeFePreviewType(this.value)">
          <option value="5160">5160 (1Ã—2â…)</option>
          <option value="5163">5163 (2Ã—4)</option>
          <option value="5164">5164 (3â…“Ã—4)</option>
          <option value="8163">8163 (2Ã—4)</option>
        </select>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="fe-actions">
      <button class="fe-btn fe-btn-secondary" onclick="closeFullEditor()">Cancel</button>
      <button class="fe-btn fe-btn-secondary" id="feBackToWizardBtn" onclick="closeFullEditorToWizard()" style="display:none;">â† Back to Wizard</button>
      <button class="fe-btn fe-btn-primary" id="feSaveBtn" onclick="saveFromFullEditor()">Save</button>
    </div>
  </div>
</div>

<!-- Graphic Picker Modal -->
<div class="fe-graphic-picker" id="feGraphicPicker">
  <div class="fe-graphic-picker-modal">
    <div class="fe-gp-header">
      <span class="fe-gp-title">Add Graphic</span>
      <button class="fe-gp-close" onclick="closeFeGraphicPicker()">Ã—</button>
    </div>
    <div class="fe-gp-tabs">
      <button class="fe-gp-tab active" data-tab="library" onclick="switchFeGpTab('library')">Library</button>
      <button class="fe-gp-tab" data-tab="upload" onclick="switchFeGpTab('upload')">Upload</button>
    </div>
    <div class="fe-gp-body" id="feGpBody">
      <!-- Populated by JS -->
    </div>
  </div>
  <input type="file" id="feGraphicFileInput" accept="image/*" style="display:none" onchange="handleFeGraphicUpload(event)">
</div>

<!-- Print Wizard -->
<!-- ============================================ -->
<!-- WF1: Print Something New Wizard              -->
<!-- ============================================ -->
<div class="wizard-overlay" id="wf1Wizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="wf1Back()">â†</button>
      <div class="wizard-title">Print Something New</div>
    </div>
    
    <!-- Progress indicator -->
    <div class="wf1-progress" id="wf1Progress"></div>
    
    <!-- Phase 3B: Skipped Steps Banner (shown after auto-skipping) -->
    <div class="wf1-skipped-banner" id="wf1SkippedBanner">
      <div class="wf1-skipped-header">
        <div class="wf1-skipped-header-left">
          <span class="wf1-skipped-icon">âš¡</span>
          <span class="wf1-skipped-title">Fast-tracked</span>
          <span class="wf1-skipped-count" id="wf1SkippedCount"></span>
        </div>
        <button class="wf1-skipped-toggle" id="wf1SkippedToggle" onclick="wf1ToggleSkippedDetails()">Show details</button>
      </div>
      <div class="wf1-skipped-details" id="wf1SkippedDetails">
        <!-- Populated dynamically -->
      </div>
    </div>
    
    <!-- Phase 3: Smart Inference Summary Bar -->
    <div class="wf1-smart-summary" id="wf1SmartSummary">
      <div class="wf1-smart-summary-header">
        <span class="wf1-smart-summary-icon">âœ¨</span>
        <span class="wf1-smart-summary-title">Smart selections based on your patterns</span>
      </div>
      <div class="wf1-smart-summary-items" id="wf1SmartSummaryItems">
        <!-- Populated dynamically -->
      </div>
    </div>
    
    <!-- WF1 Step 1: What label type? -->
    <div class="wizard-step active" id="wf1Step1">
      <div class="wizard-question">What label type are you printing?</div>
      <!-- Phase 3C: Confirm card for medium confidence (shown/hidden by JS) -->
      <div id="wf1ConfirmCard" class="wf1-confirm-card" style="display: none;">
        <!-- Populated by wf1RenderConfirmCard() -->
      </div>
      <!-- Phase 3D: Narrowed card for low confidence (shown/hidden by JS) -->
      <div id="wf1NarrowedCard" class="wf1-narrowed-card" style="display: none;">
        <!-- Populated by wf1RenderNarrowedCard() -->
      </div>
      <div class="wf1-type-grid" id="wf1TypeGrid">
        <!-- Populated by wf1RenderTypeGrid() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1TypeNextBtn" onclick="wf1ToStep2()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 2: Inventory check -->
    <div class="wizard-step" id="wf1Step2">
      <div class="wizard-question">Inventory Check</div>
      <div id="wf1InventoryContent">
        <!-- Populated by wf1RenderInventoryCheck() -->
      </div>
      <div class="wizard-actions" id="wf1Step2Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1InvNextBtn" onclick="wf1ToStep3()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 3: Content type + quantity -->
    <div class="wizard-step" id="wf1Step3">
      <div class="wizard-question" id="wf1Step3Question">What kind of print job?</div>
      <div id="wf1Step3Content">
        <div class="wf1-content-choices">
          <div class="wf1-content-choice" onclick="wf1SetJobType('individual')" ondblclick="wf1SetJobTypeAndAdvance('individual')">
            <div class="wf1-content-choice-icon">ðŸ·ï¸</div>
            <div class="wf1-content-choice-text">
              <div class="wf1-content-choice-title">Same content on every label</div>
              <div class="wf1-content-choice-desc">One design, printed multiple times</div>
            </div>
          </div>
          <div class="wf1-content-choice" onclick="wf1SetJobType('batch')" ondblclick="wf1SetJobTypeAndAdvance('batch')">
            <div class="wf1-content-choice-icon">ðŸ“‹</div>
            <div class="wf1-content-choice-text">
              <div class="wf1-content-choice-title">Different content on each label</div>
              <div class="wf1-content-choice-desc">A mailing list, name tags, or unique labels</div>
            </div>
          </div>
        </div>
        
        <div class="wf1-qty-row" id="wf1QtyRow" style="display:none;">
          <div class="wf1-qty-label">How many labels?</div>
          <div class="wf1-qty-controls">
            <button class="wf1-qty-btn" id="wf1QtyMinus" onclick="wf1AdjustQty(-1)">âˆ’</button>
            <div class="wf1-qty-value" id="wf1QtyValue">1</div>
            <button class="wf1-qty-btn" onclick="wf1AdjustQty(1)">+</button>
          </div>
        </div>
        <div class="wf1-qty-hint" id="wf1QtyHint" style="display:none;"></div>
      </div>
      
      <div class="wizard-actions" id="wf1Step3Actions" style="display:none;">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf1ToStep4()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 4: Feasibility check -->
    <div class="wizard-step" id="wf1Step4">
      <div class="wizard-question">Can we handle this job?</div>
      <div id="wf1FeasibilityContent">
        <!-- Populated by wf1RenderFeasibility() -->
      </div>
      <div class="wizard-actions" id="wf1Step4Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1FeasNextBtn" onclick="wf1ToStep5()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 5: Sheet selection -->
    <div class="wizard-step" id="wf1Step5">
      <div class="wizard-question">Which sheet do you want to print on?</div>
      <div id="wf1SheetPickerContent">
        <!-- Populated by wf1RenderSheetPicker() -->
      </div>
      <div class="wizard-actions" id="wf1Step5Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1SheetNextBtn" onclick="wf1ToStep6()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 6: Create content -->
    <div class="wizard-step" id="wf1Step6">
      <div class="wizard-question" id="wf1ContentQuestion">What should the labels say?</div>
      <div id="wf1ContentArea">
        <!-- Populated by wf1RenderContentStep() -->
      </div>
      <div class="wizard-actions" id="wf1Step6Actions" style="display:none;">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf1ContentNextBtn" onclick="wf1ToStep7()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF1 Step 7: Preview & print -->
    <div class="wizard-step" id="wf1Step7">
      <div class="wizard-question">Ready to print?</div>
      <div id="wf1PreviewContent">
        <!-- Populated by wf1RenderPreview() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf1Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf1ExecutePrint()">ðŸ–¨ï¸ Print</button>
      </div>
    </div>
    
    <!-- WF1 Step 8: Post-print -->
    <div class="wizard-step" id="wf1Step8">
      <div id="wf1PostPrintContent">
        <!-- Populated by wf1RenderPostPrint() -->
      </div>
      <div class="wizard-actions" id="wf1Step8Actions">
        <button class="wizard-btn wizard-btn-primary" onclick="wf1Close()">Done</button>
      </div>
    </div>
  </div>
  <input type="file" id="wf1BatchFileInput" accept=".csv,.tsv,.txt" style="display:none;" onchange="wf1HandleBatchFile(this)">
</div>

<!-- WF2: Print Something Again Wizard -->
<div class="wizard-overlay" id="wf2Wizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="wf2Back()">â†</button>
      <div class="wizard-title">Print Something Again</div>
    </div>
    
    <!-- Progress indicator -->
    <div class="wf2-progress" id="wf2Progress"></div>
    
    <!-- WF2 Step 1: Select content to reprint -->
    <div class="wizard-step active" id="wf2Step1">
      <div class="wizard-question">What are you reprinting?</div>
      <div id="wf2ContentSelector">
        <!-- Populated by wf2RenderContentSelector() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" id="wf2Step1NextBtn" onclick="wf2ToStep2()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 2: Quantity check -->
    <div class="wizard-step" id="wf2Step2">
      <div class="wizard-question">How many copies?</div>
      <div id="wf2QuantityContent">
        <!-- Populated by wf2RenderQuantityCheck() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf2ToStep3()">Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 3: Sheet validation -->
    <div class="wizard-step" id="wf2Step3">
      <div class="wizard-question">Which sheet to print on?</div>
      <div id="wf2SheetContent">
        <!-- Populated by wf2RenderSheetCheck() -->
      </div>
      <div class="wizard-actions" id="wf2Step3Actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="wf2SheetNextBtn" onclick="wf2ToStep4()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- WF2 Step 4: Preview & Print -->
    <div class="wizard-step" id="wf2Step4">
      <div class="wizard-question">Ready to print?</div>
      <div id="wf2PreviewContent">
        <!-- Populated by wf2RenderPreview() -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wf2Back()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wf2ExecutePrint()">ðŸ–¨ï¸ Print</button>
      </div>
    </div>
    
    <!-- WF2 Step 5: Post-print -->
    <div class="wizard-step" id="wf2Step5">
      <div id="wf2PostPrintContent">
        <!-- Populated by wf2RenderPostPrint() -->
      </div>
      <div class="wizard-actions" id="wf2Step5Actions">
        <button class="wizard-btn wizard-btn-primary" onclick="wf2Close()">Done</button>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Sheet Modal -->
<div class="simple-modal-overlay" id="sheetModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="sheetModalTitle">New Sheet</div>
      <button class="modal-close" onclick="closeSheetModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheet Name</label>
        <input type="text" class="form-input" id="sheetNameInput" placeholder="e.g., Holiday Cards" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="sheetTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group" id="sheetCountGroup">
        <label class="form-label">Number of Physical Sheets</label>
        <input type="number" class="form-input" id="sheetCountInput" value="1" min="1" max="20">
        <div class="form-hint">Pool multiple sheets together for large jobs</div>
      </div>
      <div class="form-group">
        <label class="form-label">Note <span style="color:var(--text-faint);font-weight:normal">(optional)</span></label>
        <input type="text" class="form-input" id="sheetNoteInput" placeholder="e.g., For client mailings" maxlength="80">
        <div class="form-hint">Brief description of what this sheet is for</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSheetModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSheetModal()">Save</button>
    </div>
  </div>
</div>

<!-- Create/Edit Saved Text Modal -->
<div class="simple-modal-overlay" id="savedTextModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="savedTextModalTitle">New Saved Text</div>
      <button class="modal-close" onclick="closeSavedTextModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Name</label>
        <input type="text" class="form-input" id="savedTextNameInput" placeholder="e.g., Return Address" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Line 1</label>
        <input type="text" class="form-input" id="savedTextLine1" placeholder="First line" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 2</label>
        <input type="text" class="form-input" id="savedTextLine2" placeholder="Second line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 3</label>
        <input type="text" class="form-input" id="savedTextLine3" placeholder="Third line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 4</label>
        <input type="text" class="form-input" id="savedTextLine4" placeholder="Fourth line (optional)" maxlength="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSavedTextModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSavedTextModal()">Save</button>
    </div>
  </div>
</div>

<!-- Confirm Dialog -->
<div class="simple-modal-overlay" id="confirmModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="confirmModalTitle">Confirm</div>
      <button class="modal-close" onclick="closeConfirmModal(false)">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p id="confirmModalMessage">Are you sure?</p>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" id="confirmModalCancelBtn" onclick="closeConfirmModal(false)">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" id="confirmModalOkBtn" onclick="closeConfirmModal(true)">OK</button>
    </div>
  </div>
</div>

<!-- Add Text to Sheet Picker Modal -->
<div class="simple-modal-overlay" id="addTextPickerModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="addTextPickerTitle">Add Content</div>
      <button class="modal-close" onclick="closeAddTextPickerModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p style="margin-bottom: 12px; color: var(--text-secondary); font-size: 13px;">Select content to add:</p>
      <div class="tab-content-list" style="max-height: 280px; overflow-y: auto;" id="addTextPickerContent">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<!-- Add Inventory Modal -->
<div class="simple-modal-overlay" id="addInventoryModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title">Add Label Type to Inventory</div>
      <button class="modal-close" onclick="closeAddInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="addInventoryTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="addInventoryStock" value="10" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="addInventoryThreshold" value="5" min="0" max="100">
        <div class="form-hint">You'll see a warning when stock drops to this level</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAddInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAddInventory()">Add</button>
    </div>
  </div>
</div>

<!-- Adjust Inventory Modal -->
<div class="simple-modal-overlay" id="adjustInventoryModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="adjustInventoryTitle">Adjust Stock</div>
      <button class="modal-close" onclick="closeAdjustInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="adjustInventoryStock" value="0" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="adjustInventoryThreshold" value="5" min="0" max="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAdjustInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAdjustInventory()">Save</button>
    </div>
  </div>
</div>

<!-- Batch Import Modal -->
<div class="modal-overlay" id="batchImportModal">
  <div class="modal batch-import-modal">
    <h3>ðŸ“¦ Create Batch Print Job</h3>
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
      Import a CSV file and print labels using template: <strong id="batchTemplateName"></strong>
    </div>

    <!-- File drop zone -->
    <div class="batch-file-zone" id="batchFileZone" onclick="document.getElementById('batchFileInput').click()">
      <span class="file-icon">ðŸ“„</span>
      <span class="file-prompt">Click to select a CSV file or drag & drop here</span>
    </div>
    <input type="file" id="batchFileInput" accept=".csv,.txt" style="display:none" onchange="handleBatchFile(event)">

    <!-- Column mapping (shown after file loaded) -->
    <div id="batchMappingSection" style="display:none">
      <div style="font-size:12px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px">
        Map CSV columns to template tokens:
      </div>
      <div class="batch-col-mapping" id="batchColMapping"></div>

      <!-- Summary -->
      <div class="batch-summary" id="batchSummary"></div>

      <!-- Job name -->
      <div class="batch-job-name-row">
        <label for="batchJobName">Job name:</label>
        <input type="text" id="batchJobName" placeholder="e.g., Holiday Mailing 2024">
      </div>

      <!-- Preview cards -->
      <div class="batch-preview-section">
        <div class="batch-preview-title">Preview (first 3 labels)</div>
        <div class="batch-preview-cards" id="batchPreviewCards"></div>
      </div>
    </div>

    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeBatchImportModal()">Cancel</button>
      <button class="btn btn-primary" id="batchCreateBtn" style="display:none" onclick="createBatchJob()">ðŸ“¦ Create Print Job</button>
    </div>
  </div>
</div>

<!-- Job Complete Modal -->
<div class="modal-overlay" id="jobCompleteModal">
  <div class="modal job-complete-modal">
    <div class="job-complete-summary">
      <div class="job-complete-icon">âœ…</div>
      <div class="job-complete-count" id="jobCompleteCount">0</div>
      <div class="job-complete-label">labels printed successfully</div>
    </div>
    
    <div class="job-remainder-options" id="jobRemainderOptions" style="display:none">
      <div class="job-remainder-title">What would you like to do with the remaining positions on the last sheet?</div>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="keep" checked>
        <div>
          <div class="job-remainder-option-label">Keep as partial sheet</div>
          <div class="job-remainder-option-desc">Save the sheet for future printing</div>
        </div>
      </label>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="discard">
        <div>
          <div class="job-remainder-option-label">Discard remaining positions</div>
          <div class="job-remainder-option-desc">Delete all job sheets (saves space)</div>
        </div>
      </label>
    </div>
    
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-primary" onclick="completeJob()">Done</button>
    </div>
  </div>
</div>

<!-- Split Remaining Modal (ported from v1.2) -->
<div class="simple-modal-overlay" id="splitModal">
  <div class="simple-modal split-modal">
    <h3>âœ‚ï¸ Split Remaining Labels</h3>
    <div class="split-summary" id="splitSummary"></div>
    <div class="split-form">
      <div class="split-form-group">
        <label for="splitName" class="split-form-title">New sheet name:</label>
        <input type="text" id="splitName" placeholder="Leftover 5160 - Feb" maxlength="40">
      </div>
      <div class="split-form-group" id="splitModeGroup">
        <div class="split-form-title">Physical sheets:</div>
        <label><input type="radio" name="splitMode" value="separate" checked> Split into separate sheets</label>
        <label><input type="radio" name="splitMode" value="together"> Keep together as one pool</label>
      </div>
      <div class="split-form-group">
        <div class="split-form-title">Text associations:</div>
        <label><input type="radio" name="splitTexts" value="remove" checked> Remove texts (clean slate)</label>
        <label><input type="radio" name="splitTexts" value="keep"> Keep texts (qty set to 0)</label>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeSimpleModal('splitModal')">Cancel</button>
      <button class="btn btn-primary" onclick="executeSplit()">âœ‚ï¸ Split</button>
    </div>
  </div>
</div>

<!-- Clipboard Import Modal (ported from v1.2) -->
<div class="modal-overlay" id="importTextModal">
  <div class="modal import-modal">
    <h3>ðŸ“‹ Import from Clipboard</h3>
    <div class="import-summary" id="importSummary"></div>
    <div class="import-form">
      <!-- Template selection -->
      <div id="importTemplateRow">
        <label for="importTemplateSelect" class="import-form-title">Apply template:</label>
        <select id="importTemplateSelect" onchange="onImportTemplateChange()">
          <option value="">No Template (manual)</option>
        </select>
      </div>
      <!-- Plain list mode: lines per label -->
      <div id="importPlainControls" style="display:none">
        <div class="import-form-title">Lines per label:</div>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="import-stepper">
            <button onclick="stepLinesPerLabel(-1)">âˆ’</button>
            <span id="linesPerLabelVal">1</span>
            <button onclick="stepLinesPerLabel(1)">+</button>
          </div>
          <span style="font-size:13px;color:var(--text-secondary)" id="importRecordCount"></span>
        </div>
      </div>
      <!-- Tabular mode: column mapping -->
      <div id="importTabularControls" style="display:none">
        <div class="import-form-title" id="importColMappingTitle">Map columns to label lines:</div>
        <div class="import-col-mapping" id="importColMapping"></div>
      </div>
      <!-- Preview -->
      <div>
        <div class="import-form-title">Preview:</div>
        <div class="import-preview-area" id="importPreviewArea"></div>
      </div>
      <!-- Base name -->
      <div>
        <label for="importBaseName" class="import-form-title">Base name:</label>
        <input type="text" id="importBaseName" placeholder="e.g. Student" maxlength="40">
        <div class="import-name-preview" id="importNamePreview"></div>
      </div>
      <!-- Sheet assignment -->
      <div>
        <label for="importSheetAssign" class="import-form-title">Assign to sheet (optional):</label>
        <select id="importSheetAssign">
          <option value="">â€” Don't assign â€”</option>
        </select>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeModal('importTextModal')">Cancel</button>
      <button class="btn btn-primary" id="importExecuteBtn" onclick="executeImport()">Import</button>
    </div>
  </div>
</div>

<!-- Welcome / First Run Modal -->
<div class="welcome-overlay" id="welcomeModal">
  <div class="welcome-modal">
    <div class="welcome-header">
      <div class="welcome-icon">ðŸ·ï¸</div>
      <div class="welcome-title">Welcome to LabelKeeper</div>
      <div class="welcome-version">v3.27.7</div>
    </div>
    <div class="welcome-body">
      <div class="welcome-tagline">
        Print labels without wasting a single position. LabelKeeper tracks which spots on your label sheets have been used, so you can print one label at a time or hundredsâ€”and never lose track.
      </div>
      
      <div class="welcome-features">
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“‹</div>
          <div class="welcome-feature-text">
            <strong>Track Sheet Usage</strong><br>
            Never wonder which positions are already printedâ€”the app remembers for you.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¦</div>
          <div class="welcome-feature-text">
            <strong>Manage Inventory</strong><br>
            Know when you're running low on label sheets before you need them.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¬</div>
          <div class="welcome-feature-text">
            <strong>Batch Printing</strong><br>
            Import a mailing list and print dozens of labels in one go.
          </div>
        </div>
      </div>
      
      <div class="welcome-data-status" id="welcomeDataStatus" style="display:none;">
        <div class="welcome-data-title">ðŸ“ Found Existing Data</div>
        <div class="welcome-data-items" id="welcomeDataItems">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>
    <div class="welcome-footer">
      <div class="welcome-btn-group">
        <button class="welcome-btn welcome-btn-primary" onclick="closeWelcome(true)">Get Started</button>
        <button class="welcome-btn welcome-btn-secondary" onclick="showSetupWizardFromWelcome()" id="welcomeSetupBtn" style="display:none;">Set Up Label Sheets First</button>
      </div>
      <button class="welcome-skip" onclick="closeWelcome(false)">Don't show again</button>
    </div>
  </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Device Sync Modal -->
<div class="simple-modal-overlay" id="syncModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="syncModalTitle">Device Sync</div>
      <button class="modal-close" onclick="closeSyncModal()">Ã—</button>
    </div>
    <div class="simple-modal-body" id="syncModalBody">
      <!-- Content populated by JS -->
    </div>
  </div>
</div>

<div class="print-sheet" id="printSheet"></div>

<script>
// ============================================================================
// QR CODE GENERATOR (Compact implementation)
// Based on qrcode-generator by Kazuhiko Arase - MIT License
// ============================================================================
const QRCode = (function() {
  const PAD0 = 0xEC, PAD1 = 0x11;
  const _QRMath = {
    glog: function(n) { if (n < 1) throw new Error('glog(' + n + ')'); return _QRMath.LOG_TABLE[n]; },
    gexp: function(n) { while (n < 0) n += 255; while (n >= 256) n -= 255; return _QRMath.EXP_TABLE[n]; },
    EXP_TABLE: new Array(256), LOG_TABLE: new Array(256)
  };
  for (let i = 0; i < 8; i++) _QRMath.EXP_TABLE[i] = 1 << i;
  for (let i = 8; i < 256; i++) _QRMath.EXP_TABLE[i] = _QRMath.EXP_TABLE[i - 4] ^ _QRMath.EXP_TABLE[i - 5] ^ _QRMath.EXP_TABLE[i - 6] ^ _QRMath.EXP_TABLE[i - 8];
  for (let i = 0; i < 255; i++) _QRMath.LOG_TABLE[_QRMath.EXP_TABLE[i]] = i;

  function QRPolynomial(num, shift) {
    let offset = 0;
    while (offset < num.length && num[offset] === 0) offset++;
    this.num = new Array(num.length - offset + shift);
    for (let i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
  }
  QRPolynomial.prototype = {
    get: function(index) { return this.num[index]; },
    getLength: function() { return this.num.length; },
    multiply: function(e) {
      const num = new Array(this.getLength() + e.getLength() - 1);
      for (let i = 0; i < this.getLength(); i++)
        for (let j = 0; j < e.getLength(); j++)
          num[i + j] ^= _QRMath.gexp(_QRMath.glog(this.get(i)) + _QRMath.glog(e.get(j)));
      return new QRPolynomial(num, 0);
    },
    mod: function(e) {
      if (this.getLength() - e.getLength() < 0) return this;
      const ratio = _QRMath.glog(this.get(0)) - _QRMath.glog(e.get(0));
      const num = new Array(this.getLength());
      for (let i = 0; i < this.getLength(); i++) num[i] = this.get(i);
      for (let i = 0; i < e.getLength(); i++) num[i] ^= _QRMath.gexp(_QRMath.glog(e.get(i)) + ratio);
      return new QRPolynomial(num, 0).mod(e);
    }
  };

  function QRRSBlock(totalCount, dataCount) { this.totalCount = totalCount; this.dataCount = dataCount; }
  QRRSBlock.RS_BLOCK_TABLE = [
    [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
    [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
    [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
    [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
    [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
    [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
    [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
    [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
    [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],
    [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16]
  ];
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    const rsBlock = QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + errorCorrectLevel];
    const list = [];
    for (let i = 0; i < rsBlock.length; i += 3) {
      const count = rsBlock[i], totalCount = rsBlock[i + 1], dataCount = rsBlock[i + 2];
      for (let j = 0; j < count; j++) list.push(new QRRSBlock(totalCount, dataCount));
    }
    return list;
  };

  function QRBitBuffer() { this.buffer = []; this.length = 0; }
  QRBitBuffer.prototype = {
    get: function(index) { return ((this.buffer[Math.floor(index / 8)] >>> (7 - index % 8)) & 1) === 1; },
    put: function(num, length) { for (let i = 0; i < length; i++) this.putBit(((num >>> (length - i - 1)) & 1) === 1); },
    getLengthInBits: function() { return this.length; },
    putBit: function(bit) { if (this.length === this.buffer.length * 8) this.buffer.push(0); if (bit) this.buffer[Math.floor(this.length / 8)] |= (0x80 >>> (this.length % 8)); this.length++; }
  };

  const QRUtil = {
    PATTERN_POSITION_TABLE: [[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],
    G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
    getBCHTypeInfo: function(data) { let d = data << 10; while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15))); return ((data << 10) | d) ^ QRUtil.G15_MASK; },
    getBCHTypeNumber: function(data) { let d = data << 12; while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18))); return (data << 12) | d; },
    getBCHDigit: function(data) { let digit = 0; while (data !== 0) { digit++; data >>>= 1; } return digit; },
    getPatternPosition: function(typeNumber) { return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1]; },
    getMask: function(maskPattern, i, j) {
      switch (maskPattern) {
        case 0: return (i + j) % 2 === 0;
        case 1: return i % 2 === 0;
        case 2: return j % 3 === 0;
        case 3: return (i + j) % 3 === 0;
        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case 5: return (i * j) % 2 + (i * j) % 3 === 0;
        case 6: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;
        case 7: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;
        default: throw new Error('bad maskPattern:' + maskPattern);
      }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
      let a = new QRPolynomial([1], 0);
      for (let i = 0; i < errorCorrectLength; i++) a = a.multiply(new QRPolynomial([1, _QRMath.gexp(i)], 0));
      return a;
    },
    getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) return mode === 4 ? 8 : mode === 2 ? 9 : mode === 1 ? 10 : 8;
      else if (type < 27) return mode === 4 ? 16 : mode === 2 ? 11 : mode === 1 ? 13 : 10;
      else return mode === 4 ? 16 : mode === 2 ? 13 : mode === 1 ? 15 : 12;
    },
    getLostPoint: function(qrCode) {
      const moduleCount = qrCode.getModuleCount();
      let lostPoint = 0;
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          let sameCount = 0;
          const dark = qrCode.isDark(row, col);
          for (let r = -1; r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) continue;
            for (let c = -1; c <= 1; c++) {
              if (col + c < 0 || moduleCount <= col + c) continue;
              if (r === 0 && c === 0) continue;
              if (dark === qrCode.isDark(row + r, col + c)) sameCount++;
            }
          }
          if (sameCount > 5) lostPoint += (3 + sameCount - 5);
        }
      }
      for (let row = 0; row < moduleCount - 1; row++) {
        for (let col = 0; col < moduleCount - 1; col++) {
          let count = 0;
          if (qrCode.isDark(row, col)) count++;
          if (qrCode.isDark(row + 1, col)) count++;
          if (qrCode.isDark(row, col + 1)) count++;
          if (qrCode.isDark(row + 1, col + 1)) count++;
          if (count === 0 || count === 4) lostPoint += 3;
        }
      }
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) lostPoint += 40;
        }
      }
      for (let col = 0; col < moduleCount; col++) {
        for (let row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) lostPoint += 40;
        }
      }
      let darkCount = 0;
      for (let col = 0; col < moduleCount; col++) for (let row = 0; row < moduleCount; row++) if (qrCode.isDark(row, col)) darkCount++;
      const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    }
  };

  function QR8bitByte(data) { this.mode = 4; this.data = data; }
  QR8bitByte.prototype = {
    getLength: function() { return this.data.length; },
    write: function(buffer) { for (let i = 0; i < this.data.length; i++) buffer.put(this.data.charCodeAt(i), 8); }
  };

  function QRCodeModel(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  QRCodeModel.prototype = {
    addData: function(data) { this.dataList.push(new QR8bitByte(data)); this.dataCache = null; },
    isDark: function(row, col) { return this.modules[row][col]; },
    getModuleCount: function() { return this.moduleCount; },
    make: function() { this.makeImpl(false, this.getBestMaskPattern()); },
    makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (let row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (let col = 0; col < this.moduleCount; col++) this.modules[row][col] = null;
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) this.setupTypeNumber(test);
      if (this.dataCache === null) this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      this.mapData(this.dataCache, maskPattern);
    },
    setupPositionProbePattern: function(row, col) {
      for (let r = -1; r <= 7; r++) {
        if (row + r <= -1 || this.moduleCount <= row + r) continue;
        for (let c = -1; c <= 7; c++) {
          if (col + c <= -1 || this.moduleCount <= col + c) continue;
          if ((0 <= r && r <= 6 && (c === 0 || c === 6)) || (0 <= c && c <= 6 && (r === 0 || r === 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) this.modules[row + r][col + c] = true;
          else this.modules[row + r][col + c] = false;
        }
      }
    },
    getBestMaskPattern: function() {
      let minLostPoint = 0, pattern = 0;
      for (let i = 0; i < 8; i++) {
        this.makeImpl(true, i);
        const lostPoint = QRUtil.getLostPoint(this);
        if (i === 0 || minLostPoint > lostPoint) { minLostPoint = lostPoint; pattern = i; }
      }
      return pattern;
    },
    setupTimingPattern: function() {
      for (let r = 8; r < this.moduleCount - 8; r++) {
        if (this.modules[r][6] !== null) continue;
        this.modules[r][6] = (r % 2 === 0);
      }
      for (let c = 8; c < this.moduleCount - 8; c++) {
        if (this.modules[6][c] !== null) continue;
        this.modules[6][c] = (c % 2 === 0);
      }
    },
    setupPositionAdjustPattern: function() {
      const pos = QRUtil.getPatternPosition(this.typeNumber);
      for (let i = 0; i < pos.length; i++) {
        for (let j = 0; j < pos.length; j++) {
          const row = pos[i], col = pos[j];
          if (this.modules[row][col] !== null) continue;
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) this.modules[row + r][col + c] = true;
              else this.modules[row + r][col + c] = false;
            }
          }
        }
      }
    },
    setupTypeNumber: function(test) {
      const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (let i = 0; i < 18; i++) {
        const mod = (!test && ((bits >> i) & 1) === 1);
        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (let i = 0; i < 18; i++) {
        const mod = (!test && ((bits >> i) & 1) === 1);
        this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    },
    setupTypeInfo: function(test, maskPattern) {
      const data = (this.errorCorrectLevel << 3) | maskPattern;
      const bits = QRUtil.getBCHTypeInfo(data);
      for (let i = 0; i < 15; i++) {
        const mod = (!test && ((bits >> i) & 1) === 1);
        if (i < 6) this.modules[i][8] = mod;
        else if (i < 8) this.modules[i + 1][8] = mod;
        else this.modules[this.moduleCount - 15 + i][8] = mod;
      }
      for (let i = 0; i < 15; i++) {
        const mod = (!test && ((bits >> i) & 1) === 1);
        if (i < 8) this.modules[8][this.moduleCount - i - 1] = mod;
        else if (i < 9) this.modules[8][15 - i - 1 + 1] = mod;
        else this.modules[8][15 - i - 1] = mod;
      }
      this.modules[this.moduleCount - 8][8] = (!test);
    },
    mapData: function(data, maskPattern) {
      let inc = -1, row = this.moduleCount - 1, bitIndex = 7, byteIndex = 0;
      for (let col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (this.modules[row][col - c] === null) {
              let dark = false;
              if (byteIndex < data.length) dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
              const mask = QRUtil.getMask(maskPattern, row, col - c);
              if (mask) dark = !dark;
              this.modules[row][col - c] = dark;
              bitIndex--;
              if (bitIndex === -1) { byteIndex++; bitIndex = 7; }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) { row -= inc; inc = -inc; break; }
        }
      }
    }
  };
  QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
    const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    const buffer = new QRBitBuffer();
    for (let i = 0; i < dataList.length; i++) {
      const data = dataList[i];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    let totalDataCount = 0;
    for (let i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;
    if (buffer.getLengthInBits() > totalDataCount * 8) throw new Error('code length overflow');
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) buffer.put(0, 4);
    while (buffer.getLengthInBits() % 8 !== 0) buffer.putBit(false);
    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) break;
      buffer.put(PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) break;
      buffer.put(PAD1, 8);
    }
    return QRCodeModel.createBytes(buffer, rsBlocks);
  };
  QRCodeModel.createBytes = function(buffer, rsBlocks) {
    let offset = 0, maxDcCount = 0, maxEcCount = 0;
    const dcdata = new Array(rsBlocks.length), ecdata = new Array(rsBlocks.length);
    for (let r = 0; r < rsBlocks.length; r++) {
      const dcCount = rsBlocks[r].dataCount, ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (let i = 0; i < dcdata[r].length; i++) dcdata[r][i] = 0xff & buffer.buffer[i + offset];
      offset += dcCount;
      const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      const modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (let i = 0; i < ecdata[r].length; i++) {
        const modIndex = i + modPoly.getLength() - ecdata[r].length;
        ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
      }
    }
    let totalCodeCount = 0;
    for (let i = 0; i < rsBlocks.length; i++) totalCodeCount += rsBlocks[i].totalCount;
    const data = new Array(totalCodeCount);
    let index = 0;
    for (let i = 0; i < maxDcCount; i++) for (let r = 0; r < rsBlocks.length; r++) if (i < dcdata[r].length) data[index++] = dcdata[r][i];
    for (let i = 0; i < maxEcCount; i++) for (let r = 0; r < rsBlocks.length; r++) if (i < ecdata[r].length) data[index++] = ecdata[r][i];
    return data;
  };

  // Public API
  return {
    create: function(text, errorLevel) {
      errorLevel = errorLevel || 0; // 0=L, 1=M, 2=Q, 3=H
      // Auto-detect type number (size)
      for (let typeNumber = 1; typeNumber <= 10; typeNumber++) {
        try {
          const qr = new QRCodeModel(typeNumber, errorLevel);
          qr.addData(text);
          qr.make();
          return qr;
        } catch (e) { continue; }
      }
      throw new Error('Text too long for QR code');
    },
    toDataURL: function(text, options) {
      options = options || {};
      const size = options.size || 100;
      const margin = options.margin !== undefined ? options.margin : 2;
      const dark = options.dark || '#000000';
      const light = options.light || '#ffffff';
      const errorLevel = options.errorLevel || 0;
      
      const qr = this.create(text, errorLevel);
      const moduleCount = qr.getModuleCount();
      const cellSize = Math.floor(size / (moduleCount + margin * 2));
      const actualSize = cellSize * (moduleCount + margin * 2);
      
      const canvas = document.createElement('canvas');
      canvas.width = actualSize;
      canvas.height = actualSize;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = light;
      ctx.fillRect(0, 0, actualSize, actualSize);
      
      ctx.fillStyle = dark;
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          if (qr.isDark(row, col)) {
            ctx.fillRect((col + margin) * cellSize, (row + margin) * cellSize, cellSize, cellSize);
          }
        }
      }
      return canvas.toDataURL('image/png');
    }
  };
})();

// ============================================================================
// BARCODE ANALYSIS - Smart detection of available encoding types
// ============================================================================
function analyzeBarcodeOptions(text) {
  if (!text || text.length === 0) {
    return { available: [], suggestion: null };
  }
  
  const len = text.length;
  const isDigitsOnly = /^\d+$/.test(text);
  const isAlphanumUpper = /^[A-Z0-9\-. $/+%]+$/.test(text);
  const looksLikeContact = /\d{3}[-.)]?\s*\d{3}[-.]\d{4}/.test(text) || /@/.test(text);
  const looksLikeURL = /^https?:\/\//i.test(text);
  const looksLikeEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(text);
  
  const available = [];
  
  // QR Code - always available for any text
  available.push({
    type: 'qr',
    name: 'QR Code',
    note: len + ' chars',
    available: true
  });
  
  // Code 128 - up to ~30 chars, full ASCII
  available.push({
    type: 'code128',
    name: 'Code 128',
    note: len > 30 ? 'too long (max ~30)' : len + ' chars',
    available: len <= 30
  });
  
  // Code 39 - alphanumeric uppercase only
  available.push({
    type: 'code39',
    name: 'Code 39',
    note: !isAlphanumUpper ? 'invalid chars (A-Z, 0-9, - . $ / + % only)' : len > 30 ? 'too long' : len + ' chars',
    available: isAlphanumUpper && len <= 30
  });
  
  // UPC-A - exactly 12 digits (or 11 + check digit)
  available.push({
    type: 'upca',
    name: 'UPC-A',
    note: !isDigitsOnly ? 'digits only' : (len !== 11 && len !== 12) ? 'needs 11-12 digits' : 'âœ“',
    available: isDigitsOnly && (len === 11 || len === 12)
  });
  
  // EAN-13 - exactly 13 digits (or 12 + check digit)
  available.push({
    type: 'ean13',
    name: 'EAN-13',
    note: !isDigitsOnly ? 'digits only' : (len !== 12 && len !== 13) ? 'needs 12-13 digits' : 'âœ“',
    available: isDigitsOnly && (len === 12 || len === 13)
  });
  
  // EAN-8 - exactly 8 digits (or 7 + check digit)
  available.push({
    type: 'ean8',
    name: 'EAN-8',
    note: !isDigitsOnly ? 'digits only' : (len !== 7 && len !== 8) ? 'needs 7-8 digits' : 'âœ“',
    available: isDigitsOnly && (len === 7 || len === 8)
  });
  
  // Smart suggestion
  let suggestion = null;
  if (looksLikeURL) {
    suggestion = { type: 'url', label: 'URL detected - QR code recommended for easy scanning' };
  } else if (looksLikeEmail) {
    suggestion = { type: 'email', label: 'Email detected - can encode as mailto: QR' };
  } else if (looksLikeContact) {
    suggestion = { type: 'contact', label: 'Looks like contact info - could encode as vCard QR' };
  } else if (isDigitsOnly && (len === 11 || len === 12)) {
    suggestion = { type: 'upc', label: 'Looks like a UPC code' };
  }
  
  return { available, suggestion };
}

// Generate vCard format from text lines
function generateVCard(lines) {
  // Try to parse: Name, Address, City State ZIP, Phone/Email
  const vcard = ['BEGIN:VCARD', 'VERSION:3.0'];
  
  if (lines[0]) vcard.push('FN:' + lines[0]);
  if (lines[1] && lines[2]) {
    // Parse city, state, zip from line 3
    const csz = lines[2].match(/^(.+),\s*([A-Z]{2})\s+(\d{5}(-\d{4})?)/i);
    if (csz) {
      vcard.push('ADR:;;' + lines[1] + ';' + csz[1] + ';' + csz[2] + ';' + csz[3] + ';');
    } else {
      vcard.push('ADR:;;' + lines[1] + ';;;' + lines[2] + ';');
    }
  }
  if (lines[3]) {
    if (/@/.test(lines[3])) {
      vcard.push('EMAIL:' + lines[3]);
    } else {
      vcard.push('TEL:' + lines[3].replace(/[^\d+]/g, ''));
    }
  }
  
  vcard.push('END:VCARD');
  return vcard.join('\n');
}

// ============================================================================
// LABELKEEPER v2.5.0 â€” DATA LAYER
// ============================================================================

// ========== LABEL TYPES (from v1.x) ==========
const LABEL_TYPES = {
  '5160': { name: '5160 / 8160', desc: 'Standard Address', labelW: 2.625, labelH: 1, cols: 3, rows: 10, topMargin: 0.5, leftMargin: 0.1875, hGutter: 0.125, vGutter: 0, sizeDisplay: '1â€³ Ã— 2â…â€³', layoutDisplay: '3 Ã— 10' },
  '5161': { name: '5161 / 8161', desc: 'Address + Logo', labelW: 4, labelH: 1, cols: 2, rows: 10, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 10' },
  '5162': { name: '5162 / 8162', desc: 'Large Address', labelW: 4, labelH: 1.333, cols: 2, rows: 7, topMargin: 0.8335, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 7' },
  '5163': { name: '5163 / 8163', desc: 'Shipping', labelW: 4, labelH: 2, cols: 2, rows: 5, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '2â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 5' },
  '5164': { name: '5164 / 8164', desc: 'Large Shipping', labelW: 4, labelH: 3.333, cols: 2, rows: 3, topMargin: 0.5005, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '3â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 3' },
  '5167': { name: '5167 / 8167', desc: 'Return Address (tiny)', labelW: 1.75, labelH: 0.5, cols: 4, rows: 20, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'Â½â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 20' },
  '5168': { name: '5168 / 8168', desc: 'Extra Large Shipping', labelW: 3.5, labelH: 5, cols: 2, rows: 2, topMargin: 0.5, leftMargin: 0.5, hGutter: 0.5, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 5â€³', layoutDisplay: '2 Ã— 2' },
  '5195': { name: '5195 / 8195', desc: 'Small Return Address', labelW: 1.75, labelH: 0.667, cols: 4, rows: 15, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'â…”â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 15' },
  '5165': { name: '5165', desc: 'Full Sheet', labelW: 8.5, labelH: 11, cols: 1, rows: 1, topMargin: 0, leftMargin: 0, hGutter: 0, vGutter: 0, sizeDisplay: '8Â½â€³ Ã— 11â€³', layoutDisplay: '1 Ã— 1' },
  // Round Labels
  '8293': { name: '8293', desc: 'Round Label', labelW: 1.5, labelH: 1.5, cols: 4, rows: 5, topMargin: 0.75, leftMargin: 0.4375, hGutter: 0.5, vGutter: 0.5, sizeDisplay: '1Â½â€³ âŒ€', layoutDisplay: '4 Ã— 5', category: 'round' },
  // Name Badges & Tent Cards (Session 21)
  '5395': { name: '5395', desc: 'Name Badge', labelW: 3.375, labelH: 2.333, cols: 2, rows: 4, topMargin: 0.55, leftMargin: 0.6875, hGutter: 0.375, vGutter: 0.19, sizeDisplay: '2â…“â€³ Ã— 3â…œâ€³', layoutDisplay: '2 Ã— 4', category: 'badge' },
  '5302': { name: '5302', desc: 'Tent Card (Small)', labelW: 3.5, labelH: 4, cols: 2, rows: 2, topMargin: 0.75, leftMargin: 0.75, hGutter: 0, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 2â€³ (folded)', layoutDisplay: '2 Ã— 2', category: 'tent', foldLine: 2 }
};
const TYPE_ORDER = ['5160', '5163', '5164', '5161', '5162', '5167', '5195', '5168', '5165', '8293', '5395', '5302'];

// ========== LOCALSTORAGE KEYS ==========
// v1.x compatible keys (preserved for data migration)
const SHEETS_KEY = 'avery_sheets_v6';
const ACTIVE_KEY = 'avery_active_v6';
const TEXTS_KEY = 'avery5160_saved_texts';
const THEME_KEY = 'avery5160_theme';
const INVENTORY_KEY = 'avery_inventory';
const ACTIVE_JOB_KEY = 'avery_active_job';
const JOB_HISTORY_KEY = 'avery_job_history';
const CUSTOM_TOKENS_KEY = 'avery5160_custom_tokens';

// v2.0 keys
const SETTINGS_KEY = 'lk_settings';
const PRINT_HISTORY_KEY = 'lk_print_history';
const FIRST_RUN_KEY = 'lk_first_run';
const SATELLITE_PENDING_KEY = 'lk_satellite_pending';
const INVENTORY_HISTORY_KEY = 'lk_inventory_history';

// ========== APP STATE ==========
let settings = {
  darkMode: false,
  lastLabelType: '5160',
  printOffsetTop: 0,       // Manual offset - inches to shift print vertically
  printOffsetLeft: 0,      // Manual offset - inches to shift print horizontally  
  safariPrintOffset: 0.5,  // Safari auto-compensation (adjustable) - DEPRECATED
  safariVScale: 1.0,      // Safari vertical compression ratio (0.90-1.0) â€” default 1.0; only reduce if actual prints are misaligned
  showLabelBoundaries: false, // Debug: show label boundary rectangles on print
  deviceRole: 'primary',   // 'primary' or 'satellite' - controls sync behavior
  storeId: null,           // Unique ID for this device/browser combo
  quickActionsCount: 5     // Number of quick actions to show on home (0-10) â€” T11
};

let sheets = {};
let activeSheetId = null;
let savedTexts = [];
let inventory = {};
let activeJob = null;
let jobHistory = [];
let customTokens = [];
let inventoryHistory = [];  // G8: tracks inventory changes over time
let printHistory = [];
let lastPrintJob = null; // For undo last print (from v1.2)

// Safari detection for print offset compensation
// Safari doesn't properly respect @page { margin: 0 } in iframes
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// Helper to get Safari offset (uses settings value, defaults to 0.5)
function getSafariPrintOffset() {
  return isSafari ? (settings.safariPrintOffset ?? 0.5) : 0;
}

// Batch job state (for CSV import)
let batchTemplateId = null;
let batchCsvData = null;
let batchCsvFileName = null;
let batchColTokenMap = [];

// UI state
let currentTab = 'workflows';
// ============================================================================
// LABELKEEPER - INTELLIGENT WORKFLOW STATE MODEL
// Phase 1: Foundation
// ============================================================================
//
// This module establishes the PrintJobSpec data structure and utilities
// that power the confidence-driven workflow system.
//
// INSERT LOCATION: After line ~8710 in labelkeeper HTML file
//                  (after "// UI state" section, before WF1 code)
//
// ============================================================================

// ============================================================================
// 1.1 CONSTANTS & CONFIGURATION
// ============================================================================

/**
 * Confidence levels determine how workflow steps are presented
 * - high: Skip step entirely, show in final summary
 * - medium: One-click confirm with alternatives visible
 * - low: Present narrowed options, no default selected
 * - none: Full selection UI
 */
const CONFIDENCE_LEVELS = {
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low',
  NONE: 'none'
};

/**
 * Sources indicate where a confidence value came from
 * Higher priority sources can override lower ones
 */
const CONFIDENCE_SOURCES = {
  // Highest priority - explicit user input
  EXPLICIT: 'explicit',           // User directly stated this value
  SHEET_LOCKED: 'sheet-locked',   // Sheet determines label type
  
  // High priority - strong inference
  CONTENT_MATCH: 'content-match', // Saved content specifies type
  INVENTORY_ONLY: 'inventory-only', // Only one option in stock
  BATCH_COUNT: 'batch-count',     // CSV row count determines quantity
  DEDICATED: 'dedicated',         // Dedicated sheet for this content
  
  // Medium priority - pattern-based
  HISTORY: 'history',             // Based on past job patterns
  TEMPLATE_TYPE: 'template-type', // Template implies mode
  
  // Lower priority - contextual
  CONTEXT: 'context',             // Inferred from content/situation
  ONLY_OPTION: 'only-option',     // Single valid choice available
  AUTO_BEST: 'auto-best',         // System picked best option
  
  // Lowest priority
  DEFAULT: 'default',             // System/user default setting
  SUGGESTION: 'suggestion'        // Weak suggestion
};

/**
 * History analysis thresholds
 * Based on last 10 jobs, how many matches for each confidence level
 */
const HISTORY_THRESHOLDS = {
  HIGH: 9,    // 9-10 of last 10 â†’ high confidence
  MEDIUM: 5,  // 5-8 of last 10 â†’ medium confidence
  LOW: 2      // 2-4 of last 10 â†’ low confidence
              // 0-1 â†’ none
};

/**
 * Elements required for a complete print job
 * Used by isSpecComplete() to validate before printing
 */
const REQUIRED_ELEMENTS = ['labelType', 'content', 'quantity', 'sheetSelection'];

/**
 * Element dependency order for inference
 * Earlier elements should be resolved before later ones
 */
const INFERENCE_ORDER = [
  'labelType',      // Independent, or locked by sheet/content
  'contentMode',    // May depend on content source
  'content',        // May affect labelType inference
  'quantity',       // Depends on contentMode for batch
  'sheetSelection', // Depends on labelType, quantity
  'positions',      // Depends on sheetSelection
  'postPrint'       // Depends on sheetSelection, content
];

// ============================================================================
// 1.2 SPEC ELEMENT FACTORY
// ============================================================================

/**
 * Creates a single spec element with all required fields
 * @param {*} value - The element's value (null if unknown)
 * @param {string} confidence - Confidence level
 * @param {string} source - Where confidence came from
 * @param {Array} alternatives - Other valid options
 * @returns {Object} Spec element
 */
function createSpecElement(value = null, confidence = CONFIDENCE_LEVELS.NONE, source = null, alternatives = []) {
  return {
    value: value,
    confidence: confidence,
    source: source,
    alternatives: alternatives,
    rejected: false,
    rejectedValues: []
  };
}

/**
 * Creates an extended spec element with additional fields
 * Used for elements that need extra properties (content, sheetSelection, etc.)
 * @param {Object} base - Base element from createSpecElement
 * @param {Object} extensions - Additional properties
 * @returns {Object} Extended spec element
 */
function createExtendedSpecElement(base, extensions = {}) {
  return { ...base, ...extensions };
}

// ============================================================================
// 1.3 PRINTJOBSPEC FACTORY
// ============================================================================

/**
 * Creates a new PrintJobSpec with all elements initialized
 * @param {string} source - Origin of this spec ('wf1-direct', 'wf2-reprint', 'ai', 'quick-action')
 * @returns {Object} Complete PrintJobSpec
 */
function createPrintJobSpec(source = 'wf1-direct') {
  return {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHAT FORMAT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    labelType: createSpecElement(),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHAT CONTENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    content: createExtendedSpecElement(
      createSpecElement(),
      {
        displayName: null,        // Human-readable name for UI
        richFormatting: null,     // { lines, graphics, alignV, border, barcode }
        styleTemplate: null,      // Style template ID if applied
        csvData: null,            // Raw CSV rows (when source='csv')
        csvColumns: null,         // Column headers
        columnMap: null           // Token â†’ column mapping
      }
    ),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HOW MANY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    quantity: createSpecElement(),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SAME OR DIFFERENT PER LABEL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    contentMode: createSpecElement(),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHICH SHEET(S)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sheetSelection: createExtendedSpecElement(
      createSpecElement(),
      {
        sheetId: null,            // Specific sheet ID when value='specific'
        plan: null                // Multi-sheet plan when value='multi'
      }
    ),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHERE ON SHEET
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    positions: createExtendedSpecElement(
      createSpecElement(),
      {
        orientation: 'next'       // 'next' | 'col1' | 'col2' | etc.
      }
    ),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AFTER PRINTING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    postPrint: createExtendedSpecElement(
      createSpecElement(),
      {
        dedicatedName: null       // Name if dedicating sheet to this content
      }
    ),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // METADATA (not user-facing)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    _meta: {
      createdAt: Date.now(),
      source: source,
      aiQuestionsAsked: 0,
      workflowPath: [],           // Steps visited: ['labelType', 'quantity', ...]
      edits: [],                  // Log of user corrections
      skippedSteps: [],           // Steps skipped due to high confidence
      completedAt: null
    }
  };
}

// ============================================================================
// 1.4 HISTORY ANALYSIS
// ============================================================================

/**
 * Analyzes print history to find patterns for a specific element
 * @param {string} elementName - Which element to analyze ('labelType', 'quantity', etc.)
 * @param {Array} history - Print history array
 * @param {number} count - How many recent jobs to consider (default 10)
 * @returns {Object} { value, confidence, count, total, alternatives }
 */
function analyzeHistory(elementName, history, count = 10) {
  // Map element names to history field names
  const ELEMENT_TO_HISTORY_FIELD = {
    'labelType': 'labelType',
    'quantity': 'quantity',
    'contentMode': 'jobType',      // History stores 'individual'/'batch'
    'orientation': 'orientation',
    'postPrint': 'postAction'
  };
  
  const fieldName = ELEMENT_TO_HISTORY_FIELD[elementName] || elementName;
  const recent = (history || []).slice(0, count);
  
  if (recent.length === 0) {
    return {
      value: null,
      confidence: CONFIDENCE_LEVELS.NONE,
      count: 0,
      total: 0,
      alternatives: []
    };
  }
  
  // Count occurrences of each value
  const counts = {};
  recent.forEach(job => {
    const val = job[fieldName];
    if (val !== undefined && val !== null) {
      counts[val] = (counts[val] || 0) + 1;
    }
  });
  
  // Handle empty counts (field not present in history)
  if (Object.keys(counts).length === 0) {
    return {
      value: null,
      confidence: CONFIDENCE_LEVELS.NONE,
      count: 0,
      total: recent.length,
      alternatives: []
    };
  }
  
  // Sort by frequency (descending)
  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const [topValue, topCount] = sorted[0];
  const total = recent.length;
  
  // Determine confidence based on thresholds
  let confidence;
  if (topCount >= HISTORY_THRESHOLDS.HIGH) {
    confidence = CONFIDENCE_LEVELS.HIGH;
  } else if (topCount >= HISTORY_THRESHOLDS.MEDIUM) {
    confidence = CONFIDENCE_LEVELS.MEDIUM;
  } else if (topCount >= HISTORY_THRESHOLDS.LOW) {
    confidence = CONFIDENCE_LEVELS.LOW;
  } else {
    confidence = CONFIDENCE_LEVELS.NONE;
  }
  
  // Build alternatives list (other values seen, in frequency order)
  const alternatives = sorted.slice(1).map(([value]) => value);
  
  return {
    value: topValue,
    confidence: confidence,
    count: topCount,
    total: total,
    alternatives: alternatives
  };
}

/**
 * Combines multiple confidence signals into a final confidence level
 * Uses highest confidence source, with tie-breaking by source priority
 * @param {Array} signals - Array of { confidence, source, value } objects
 * @returns {Object} { value, confidence, source }
 */
function combineConfidence(signals) {
  if (!signals || signals.length === 0) {
    return { value: null, confidence: CONFIDENCE_LEVELS.NONE, source: null };
  }
  
  // Filter out null/none signals
  const validSignals = signals.filter(s => 
    s && s.confidence && s.confidence !== CONFIDENCE_LEVELS.NONE
  );
  
  if (validSignals.length === 0) {
    return { value: null, confidence: CONFIDENCE_LEVELS.NONE, source: null };
  }
  
  // Sort by confidence level (high > medium > low)
  const confidenceOrder = {
    [CONFIDENCE_LEVELS.HIGH]: 3,
    [CONFIDENCE_LEVELS.MEDIUM]: 2,
    [CONFIDENCE_LEVELS.LOW]: 1,
    [CONFIDENCE_LEVELS.NONE]: 0
  };
  
  // Source priority for tie-breaking
  const sourcePriority = {
    [CONFIDENCE_SOURCES.EXPLICIT]: 100,
    [CONFIDENCE_SOURCES.SHEET_LOCKED]: 95,
    [CONFIDENCE_SOURCES.CONTENT_MATCH]: 90,
    [CONFIDENCE_SOURCES.INVENTORY_ONLY]: 85,
    [CONFIDENCE_SOURCES.BATCH_COUNT]: 85,
    [CONFIDENCE_SOURCES.DEDICATED]: 80,
    [CONFIDENCE_SOURCES.HISTORY]: 70,
    [CONFIDENCE_SOURCES.TEMPLATE_TYPE]: 65,
    [CONFIDENCE_SOURCES.CONTEXT]: 50,
    [CONFIDENCE_SOURCES.ONLY_OPTION]: 45,
    [CONFIDENCE_SOURCES.AUTO_BEST]: 40,
    [CONFIDENCE_SOURCES.DEFAULT]: 20,
    [CONFIDENCE_SOURCES.SUGGESTION]: 10
  };
  
  validSignals.sort((a, b) => {
    // First by confidence level
    const confDiff = confidenceOrder[b.confidence] - confidenceOrder[a.confidence];
    if (confDiff !== 0) return confDiff;
    
    // Then by source priority
    const aPriority = sourcePriority[a.source] || 0;
    const bPriority = sourcePriority[b.source] || 0;
    return bPriority - aPriority;
  });
  
  return {
    value: validSignals[0].value,
    confidence: validSignals[0].confidence,
    source: validSignals[0].source
  };
}

// ============================================================================
// 1.5 SPEC MANIPULATION
// ============================================================================

/**
 * Updates a spec element with new values
 * Preserves existing fields not included in updates
 * @param {Object} spec - The PrintJobSpec
 * @param {string} elementName - Which element to update
 * @param {Object} updates - Fields to update
 * @returns {Object} The updated spec (mutates original)
 */
function updateSpecElement(spec, elementName, updates) {
  if (!spec || !spec[elementName]) {
    console.warn('updateSpecElement: Invalid spec or element', elementName);
    return spec;
  }
  
  Object.assign(spec[elementName], updates);
  
  // Record in metadata
  if (spec._meta && updates.value !== undefined) {
    spec._meta.edits.push({
      element: elementName,
      value: updates.value,
      source: updates.source || 'unknown',
      timestamp: Date.now()
    });
  }
  
  return spec;
}

/**
 * Marks an element as rejected by the user
 * - Adds current value to rejectedValues
 * - Sets rejected flag to true
 * - Degrades confidence to 'none'
 * - Clears current value
 * @param {Object} spec - The PrintJobSpec
 * @param {string} elementName - Which element was rejected
 * @returns {Object} The updated spec
 */
function markRejected(spec, elementName) {
  if (!spec || !spec[elementName]) {
    console.warn('markRejected: Invalid spec or element', elementName);
    return spec;
  }
  
  const element = spec[elementName];
  
  // Add current value to rejected list (if not null and not already rejected)
  if (element.value !== null && !element.rejectedValues.includes(element.value)) {
    element.rejectedValues.push(element.value);
  }
  
  // Mark as rejected
  element.rejected = true;
  
  // Degrade confidence
  element.confidence = CONFIDENCE_LEVELS.NONE;
  
  // Clear value (user must choose again)
  element.value = null;
  
  // Remove rejected values from alternatives
  element.alternatives = element.alternatives.filter(
    v => !element.rejectedValues.includes(v)
  );
  
  // Record in metadata
  if (spec._meta) {
    spec._meta.edits.push({
      element: elementName,
      action: 'rejected',
      rejectedValue: element.rejectedValues[element.rejectedValues.length - 1],
      timestamp: Date.now()
    });
  }
  
  return spec;
}

/**
 * Clears rejection state for an element
 * Used when user re-selects a previously rejected value
 * @param {Object} spec - The PrintJobSpec
 * @param {string} elementName - Which element to clear
 * @returns {Object} The updated spec
 */
function clearRejection(spec, elementName) {
  if (!spec || !spec[elementName]) {
    return spec;
  }
  
  spec[elementName].rejected = false;
  // Note: rejectedValues is NOT cleared - we remember what was rejected
  // This is intentional so we don't suggest it again at high confidence
  
  return spec;
}

/**
 * Degrades confidence by one level
 * high â†’ medium â†’ low â†’ none
 * @param {Object} element - The spec element to degrade
 * @returns {string} The new confidence level
 */
function degradeConfidence(element) {
  const degradeMap = {
    [CONFIDENCE_LEVELS.HIGH]: CONFIDENCE_LEVELS.MEDIUM,
    [CONFIDENCE_LEVELS.MEDIUM]: CONFIDENCE_LEVELS.LOW,
    [CONFIDENCE_LEVELS.LOW]: CONFIDENCE_LEVELS.NONE,
    [CONFIDENCE_LEVELS.NONE]: CONFIDENCE_LEVELS.NONE
  };
  
  element.confidence = degradeMap[element.confidence] || CONFIDENCE_LEVELS.NONE;
  return element.confidence;
}

/**
 * Checks if a spec has all required elements resolved
 * @param {Object} spec - The PrintJobSpec
 * @returns {boolean} True if all required elements have values
 */
function isSpecComplete(spec) {
  if (!spec) return false;
  
  for (const elementName of REQUIRED_ELEMENTS) {
    if (!spec[elementName] || spec[elementName].value === null) {
      return false;
    }
  }
  
  return true;
}

/**
 * Gets list of elements that still need resolution
 * @param {Object} spec - The PrintJobSpec
 * @returns {Array} Element names that have null values or low/none confidence
 */
function getUnresolvedElements(spec) {
  if (!spec) return REQUIRED_ELEMENTS;
  
  const unresolved = [];
  
  for (const elementName of INFERENCE_ORDER) {
    const element = spec[elementName];
    if (!element) continue;
    
    // Unresolved if: no value, rejected, or low/none confidence
    if (element.value === null || 
        element.rejected || 
        element.confidence === CONFIDENCE_LEVELS.NONE ||
        element.confidence === CONFIDENCE_LEVELS.LOW) {
      unresolved.push(elementName);
    }
  }
  
  return unresolved;
}

/**
 * Gets list of elements with high confidence (can be skipped)
 * @param {Object} spec - The PrintJobSpec
 * @returns {Array} Element names with high confidence and not rejected
 */
function getHighConfidenceElements(spec) {
  if (!spec) return [];
  
  const highConf = [];
  
  for (const elementName of INFERENCE_ORDER) {
    const element = spec[elementName];
    if (!element) continue;
    
    if (element.value !== null && 
        element.confidence === CONFIDENCE_LEVELS.HIGH && 
        !element.rejected) {
      highConf.push(elementName);
    }
  }
  
  return highConf;
}

// ============================================================================
// 1.6 SERIALIZATION & DEBUG
// ============================================================================

/**
 * Creates a human-readable summary of the spec
 * Used for confirmation screen and logging
 * @param {Object} spec - The PrintJobSpec
 * @returns {Object} Summary with display-friendly values
 */
function specToSummary(spec) {
  if (!spec) return null;
  
  // Helper to format content preview
  const formatContent = (content) => {
    if (!content.value) return '(not set)';
    if (Array.isArray(content.value) && content.value.length > 0) {
      // Check if it's batch (array of arrays)
      if (Array.isArray(content.value[0])) {
        return `${content.value.length} labels (batch)`;
      }
      // Single label - show first line preview
      const firstLine = content.value[0];
      const text = typeof firstLine === 'string' ? firstLine : (firstLine.text || '');
      return text.substring(0, 40) + (text.length > 40 ? '...' : '');
    }
    return content.displayName || '(content set)';
  };
  
  // Helper to format sheet selection
  const formatSheet = (sheet) => {
    if (!sheet.value) return '(not set)';
    switch (sheet.value) {
      case 'new': return 'New sheet';
      case 'auto': return 'Auto-select best';
      case 'specific': return sheet.sheetId ? `Sheet ${sheet.sheetId.substring(0, 8)}...` : 'Specific sheet';
      case 'multi': return `Multi-sheet plan (${sheet.plan?.length || 0} sheets)`;
      default: return sheet.value;
    }
  };
  
  return {
    labelType: {
      display: spec.labelType.value || '(not set)',
      confidence: spec.labelType.confidence,
      editable: true
    },
    content: {
      display: formatContent(spec.content),
      confidence: spec.content.confidence,
      editable: true
    },
    quantity: {
      display: spec.quantity.value !== null ? spec.quantity.value.toString() : '(not set)',
      confidence: spec.quantity.confidence,
      editable: true
    },
    contentMode: {
      display: spec.contentMode.value === 'variable' ? 'Different per label' : 'Same on all',
      confidence: spec.contentMode.confidence,
      editable: true
    },
    sheetSelection: {
      display: formatSheet(spec.sheetSelection),
      confidence: spec.sheetSelection.confidence,
      editable: true
    },
    positions: {
      display: spec.positions.orientation === 'next' ? 'Next available' : `Start at ${spec.positions.orientation}`,
      confidence: spec.positions.confidence,
      editable: true
    },
    postPrint: {
      display: spec.postPrint.value || 'Track usage',
      confidence: spec.postPrint.confidence,
      editable: true
    }
  };
}

/**
 * Creates a debug log of the spec
 * Shows all fields including internal state
 * @param {Object} spec - The PrintJobSpec
 * @returns {string} Formatted debug string
 */
function specToLog(spec) {
  if (!spec) return 'PrintJobSpec: null';
  
  const lines = ['â•â•â• PrintJobSpec Debug â•â•â•'];
  lines.push(`Source: ${spec._meta?.source || 'unknown'}`);
  lines.push(`Created: ${spec._meta?.createdAt ? new Date(spec._meta.createdAt).toISOString() : 'unknown'}`);
  lines.push('');
  
  for (const elementName of INFERENCE_ORDER) {
    const element = spec[elementName];
    if (!element) continue;
    
    const status = element.rejected ? 'â›” REJECTED' : 
                   element.confidence === 'high' ? 'âœ“ HIGH' :
                   element.confidence === 'medium' ? 'â— MEDIUM' :
                   element.confidence === 'low' ? 'â—‹ LOW' : '? NONE';
    
    lines.push(`${elementName}: ${status}`);
    lines.push(`  value: ${JSON.stringify(element.value)}`);
    lines.push(`  source: ${element.source || 'none'}`);
    if (element.alternatives?.length > 0) {
      lines.push(`  alternatives: ${element.alternatives.join(', ')}`);
    }
    if (element.rejectedValues?.length > 0) {
      lines.push(`  rejected: ${element.rejectedValues.join(', ')}`);
    }
    lines.push('');
  }
  
  lines.push(`Complete: ${isSpecComplete(spec) ? 'YES' : 'NO'}`);
  lines.push(`Unresolved: ${getUnresolvedElements(spec).join(', ') || 'none'}`);
  lines.push(`High confidence: ${getHighConfidenceElements(spec).join(', ') || 'none'}`);
  
  return lines.join('\n');
}

/**
 * Logs spec to console in a formatted way
 * @param {Object} spec - The PrintJobSpec
 * @param {string} label - Optional label for the log
 */
function logSpec(spec, label = '') {
  const header = label ? `PrintJobSpec [${label}]` : 'PrintJobSpec';
  console.group(header);
  console.log(specToLog(spec));
  console.groupEnd();
}

// ============================================================================
// 1.7 VALIDATION
// ============================================================================

/**
 * Validates a spec element has required fields
 * @param {Object} element - The spec element
 * @returns {boolean} True if valid
 */
function isValidElement(element) {
  return element &&
         typeof element === 'object' &&
         'value' in element &&
         'confidence' in element &&
         'source' in element &&
         'rejected' in element &&
         Array.isArray(element.rejectedValues);
}

/**
 * Validates entire spec structure
 * @param {Object} spec - The PrintJobSpec
 * @returns {Object} { valid: boolean, errors: string[] }
 */
function validateSpec(spec) {
  const errors = [];
  
  if (!spec) {
    return { valid: false, errors: ['Spec is null or undefined'] };
  }
  
  // Check all required elements exist
  for (const elementName of INFERENCE_ORDER) {
    if (!spec[elementName]) {
      errors.push(`Missing element: ${elementName}`);
    } else if (!isValidElement(spec[elementName])) {
      errors.push(`Invalid element structure: ${elementName}`);
    }
  }
  
  // Check metadata
  if (!spec._meta) {
    errors.push('Missing _meta object');
  }
  
  return {
    valid: errors.length === 0,
    errors: errors
  };
}

// ============================================================================
// 1.8 CLONING & RESET
// ============================================================================

/**
 * Creates a deep clone of a spec
 * @param {Object} spec - The PrintJobSpec to clone
 * @returns {Object} New spec with same values
 */
function cloneSpec(spec) {
  if (!spec) return null;
  return JSON.parse(JSON.stringify(spec));
}

/**
 * Resets a spec to initial state while preserving metadata
 * @param {Object} spec - The PrintJobSpec to reset
 * @returns {Object} The reset spec
 */
function resetSpec(spec) {
  if (!spec) return createPrintJobSpec();
  
  const meta = spec._meta;
  const newSpec = createPrintJobSpec(meta?.source || 'reset');
  
  // Preserve some metadata
  newSpec._meta.createdAt = meta?.createdAt || Date.now();
  newSpec._meta.aiQuestionsAsked = 0;
  newSpec._meta.workflowPath = [];
  newSpec._meta.edits = [];
  newSpec._meta.skippedSteps = [];
  
  return newSpec;
}

/**
 * Resets a single element to initial state
 * Preserves rejectedValues so we don't suggest them again
 * @param {Object} spec - The PrintJobSpec
 * @param {string} elementName - Which element to reset
 * @returns {Object} The updated spec
 */
function resetElement(spec, elementName) {
  if (!spec || !spec[elementName]) return spec;
  
  const rejectedValues = spec[elementName].rejectedValues || [];
  
  // Create fresh element
  spec[elementName] = createSpecElement();
  
  // Restore rejected values
  spec[elementName].rejectedValues = rejectedValues;
  
  return spec;
}

// ============================================================================
// 1.9 CONVENIENCE HELPERS
// ============================================================================

/**
 * Quick check if an element needs user input
 * @param {Object} element - The spec element
 * @returns {boolean} True if user needs to provide input
 */
function needsUserInput(element) {
  if (!element) return true;
  if (element.rejected) return true;
  if (element.value === null) return true;
  if (element.confidence === CONFIDENCE_LEVELS.NONE) return true;
  return false;
}

/**
 * Quick check if an element can be auto-accepted
 * @param {Object} element - The spec element
 * @returns {boolean} True if can skip user input
 */
function canAutoAccept(element) {
  if (!element) return false;
  if (element.rejected) return false;
  if (element.value === null) return false;
  return element.confidence === CONFIDENCE_LEVELS.HIGH;
}

/**
 * Quick check if an element should show confirmation UI
 * @param {Object} element - The spec element
 * @returns {boolean} True if should show one-click confirm
 */
function shouldConfirm(element) {
  if (!element) return false;
  if (element.rejected) return false;
  if (element.value === null) return false;
  return element.confidence === CONFIDENCE_LEVELS.MEDIUM;
}

/**
 * Gets the appropriate UI mode for an element
 * @param {Object} element - The spec element
 * @returns {string} 'skip' | 'confirm' | 'narrowed' | 'full' | 'rejected'
 */
function getElementUIMode(element) {
  if (!element) return 'full';
  if (element.rejected) return 'rejected';
  if (canAutoAccept(element)) return 'skip';
  if (shouldConfirm(element)) return 'confirm';
  if (element.confidence === CONFIDENCE_LEVELS.LOW) return 'narrowed';
  return 'full';
}

// ============================================================================
// 1.10 EXPORT FOR TESTING (attach to window in dev mode)
// ============================================================================

/**
 * Expose internals for console testing
 * Usage: window._pjs.createPrintJobSpec('test')
 */
if (typeof window !== 'undefined') {
  window._pjs = {
    // Constants
    CONFIDENCE_LEVELS,
    CONFIDENCE_SOURCES,
    HISTORY_THRESHOLDS,
    REQUIRED_ELEMENTS,
    INFERENCE_ORDER,
    
    // Factories
    createSpecElement,
    createExtendedSpecElement,
    createPrintJobSpec,
    
    // History analysis
    analyzeHistory,
    combineConfidence,
    
    // Spec manipulation
    updateSpecElement,
    markRejected,
    clearRejection,
    degradeConfidence,
    isSpecComplete,
    getUnresolvedElements,
    getHighConfidenceElements,
    
    // Serialization
    specToSummary,
    specToLog,
    logSpec,
    
    // Validation
    isValidElement,
    validateSpec,
    
    // Cloning & reset
    cloneSpec,
    resetSpec,
    resetElement,
    
    // Convenience
    needsUserInput,
    canAutoAccept,
    shouldConfirm,
    getElementUIMode,
    
    // Quick test
    test: function() {
      console.log('Creating test spec...');
      const spec = createPrintJobSpec('test');
      
      console.log('Initial state:');
      logSpec(spec, 'initial');
      
      console.log('\nUpdating labelType to 5160 with high confidence...');
      updateSpecElement(spec, 'labelType', {
        value: '5160',
        confidence: CONFIDENCE_LEVELS.HIGH,
        source: CONFIDENCE_SOURCES.INVENTORY_ONLY
      });
      
      console.log('\nUpdating quantity to 5 with medium confidence...');
      updateSpecElement(spec, 'quantity', {
        value: 5,
        confidence: CONFIDENCE_LEVELS.MEDIUM,
        source: CONFIDENCE_SOURCES.HISTORY,
        alternatives: [1, 10, 30]
      });
      
      console.log('\nAfter updates:');
      logSpec(spec, 'updated');
      
      console.log('\nUI modes:');
      INFERENCE_ORDER.forEach(name => {
        console.log(`  ${name}: ${getElementUIMode(spec[name])}`);
      });
      
      console.log('\nMarking quantity as rejected...');
      markRejected(spec, 'quantity');
      logSpec(spec, 'after rejection');
      
      console.log('\nTest complete!');
      return spec;
    }
  };
  
  console.log('PrintJobSpec utilities loaded. Run window._pjs.test() to verify.');
}

// ============================================================================
// Phase 2: Inference Engine
// ============================================================================
//
// This module provides inference functions that populate PrintJobSpec elements
// based on available context (inventory, history, content, etc.)
//
// Each inference function returns an object with:
//   { value, confidence, source, alternatives, reasoning }
//
// The reasoning field is for debug display only and explains the decision.
//
// ============================================================================

// ============================================================================
// 2.1 CONTEXT BUILDER
// ============================================================================

/**
 * Builds a context object for inference from current app state
 * @returns {Object} Context with inventory, sheets, history, etc.
 */
function buildInferenceContext() {
  // Get sheets with available labels (spots > 0)
  const availableSheets = Object.values(sheets || {})
    .filter(sh => {
      const spec = LABEL_TYPES[sh.labelType];
      if (!spec) return false;
      const total = spec.cols * spec.rows;
      const used = (sh.usedPositions || []).length;
      return used < total;
    })
    .map(sh => {
      const spec = LABEL_TYPES[sh.labelType];
      const total = spec.cols * spec.rows;
      const used = (sh.usedPositions || []).length;
      return {
        id: sh.id,
        labelType: sh.labelType,
        name: sh.name,
        dedication: sh.dedication || null,
        available: total - used,
        total: total,
        usedCount: used
      };
    });
  
  // Group sheets by label type
  const sheetsByType = {};
  availableSheets.forEach(sh => {
    if (!sheetsByType[sh.labelType]) {
      sheetsByType[sh.labelType] = [];
    }
    sheetsByType[sh.labelType].push(sh);
  });
  
  // Get label types with available sheets
  const typesWithSheets = Object.keys(sheetsByType);
  
  // Get inventory counts (unopened packs)
  const inventoryCounts = {};
  for (const [typeId, count] of Object.entries(inventory || {})) {
    if (count > 0 && LABEL_TYPES[typeId]) {
      inventoryCounts[typeId] = count;
    }
  }
  
  // All types with either sheets or inventory
  const typesAvailable = [...new Set([
    ...typesWithSheets,
    ...Object.keys(inventoryCounts)
  ])];
  
  // Recent print history (last 10 jobs)
  const recentHistory = (printHistory || []).slice(0, 10);
  
  // Saved content (non-template saved texts)
  const savedContent = (savedTexts || [])
    .filter(t => !t.type || t.type === 'saved')
    .map(t => ({
      id: t.id,
      name: t.name,
      labelType: t.labelType,
      text: typeof t.text === 'string' ? t.text.substring(0, 100) : null
    }));
  
  return {
    availableSheets,
    sheetsByType,
    typesWithSheets,
    inventoryCounts,
    typesAvailable,
    recentHistory,
    savedContent,
    totalSheetCount: availableSheets.length,
    hasInventory: Object.keys(inventoryCounts).length > 0
  };
}

// ============================================================================
// 2.2 LABEL TYPE INFERENCE
// ============================================================================

/**
 * Infers the best label type based on context
 * Priority: sheet-locked > content-match > inventory-only > history > default
 * 
 * @param {Object} spec - The PrintJobSpec
 * @param {Object} context - From buildInferenceContext()
 * @param {Object} hints - Optional hints { lockedBySheet, contentLabelType }
 * @returns {Object} { value, confidence, source, alternatives, reasoning }
 */
function inferLabelType(spec, context, hints = {}) {
  const result = {
    value: null,
    confidence: CONFIDENCE_LEVELS.NONE,
    source: null,
    alternatives: [],
    reasoning: []
  };
  
  // Check for rejected values to exclude
  const rejected = spec?.labelType?.rejectedValues || [];
  
  // Helper to filter rejected
  const notRejected = (typeId) => !rejected.includes(typeId);
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Sheet-locked: If a specific sheet is pre-selected, use its type
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.lockedBySheet) {
    const lockedType = hints.lockedBySheet;
    if (notRejected(lockedType)) {
      result.value = lockedType;
      result.confidence = CONFIDENCE_LEVELS.HIGH;
      result.source = CONFIDENCE_SOURCES.SHEET_LOCKED;
      result.reasoning.push(`Sheet pre-selected â†’ locked to ${lockedType}`);
      return result;
    } else {
      result.reasoning.push(`Sheet locked to ${lockedType} but user rejected it`);
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Content-match: If content specifies a label type
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.contentLabelType) {
    const contentType = hints.contentLabelType;
    if (notRejected(contentType)) {
      result.value = contentType;
      result.confidence = CONFIDENCE_LEVELS.HIGH;
      result.source = CONFIDENCE_SOURCES.CONTENT_MATCH;
      result.reasoning.push(`Content specifies ${contentType}`);
      return result;
    } else {
      result.reasoning.push(`Content specifies ${contentType} but user rejected it`);
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. Inventory-only: If only one type is available
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const availableTypes = context.typesAvailable.filter(notRejected);
  
  if (availableTypes.length === 0) {
    result.reasoning.push('No label types available (all rejected or no stock)');
    result.alternatives = TYPE_ORDER.filter(notRejected);
    return result;
  }
  
  if (availableTypes.length === 1) {
    result.value = availableTypes[0];
    result.confidence = CONFIDENCE_LEVELS.HIGH;
    result.source = CONFIDENCE_SOURCES.INVENTORY_ONLY;
    result.reasoning.push(`Only ${availableTypes[0]} in stock`);
    return result;
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. History pattern: Check recent jobs
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const historyResult = analyzeHistory('labelType', context.recentHistory);
  
  if (historyResult.value && notRejected(historyResult.value)) {
    // Only use history if the type is actually available
    if (availableTypes.includes(historyResult.value)) {
      result.value = historyResult.value;
      result.confidence = historyResult.confidence;
      result.source = CONFIDENCE_SOURCES.HISTORY;
      result.alternatives = historyResult.alternatives.filter(
        t => notRejected(t) && availableTypes.includes(t)
      );
      result.reasoning.push(
        `History: ${historyResult.count}/${historyResult.total} jobs used ${historyResult.value}`
      );
      return result;
    } else {
      result.reasoning.push(
        `History suggests ${historyResult.value} but not in current stock`
      );
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5. Default: Use most common type with sheets, or first available
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Prefer types that have open sheets
  const typesWithOpenSheets = context.typesWithSheets.filter(notRejected);
  
  if (typesWithOpenSheets.length > 0) {
    // Pick the type with the most available spots
    let bestType = typesWithOpenSheets[0];
    let bestSpots = 0;
    
    for (const typeId of typesWithOpenSheets) {
      const sheetsOfType = context.sheetsByType[typeId] || [];
      const totalSpots = sheetsOfType.reduce((sum, sh) => sum + sh.available, 0);
      if (totalSpots > bestSpots) {
        bestSpots = totalSpots;
        bestType = typeId;
      }
    }
    
    result.value = bestType;
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.AUTO_BEST;
    result.alternatives = typesWithOpenSheets.filter(t => t !== bestType);
    result.reasoning.push(`Default: ${bestType} has ${bestSpots} available spots`);
    return result;
  }
  
  // Fall back to first available in inventory
  const firstAvailable = availableTypes[0];
  result.value = firstAvailable;
  result.confidence = CONFIDENCE_LEVELS.LOW;
  result.source = CONFIDENCE_SOURCES.AUTO_BEST;
  result.alternatives = availableTypes.slice(1);
  result.reasoning.push(`Fallback: using ${firstAvailable} from inventory`);
  
  return result;
}

// ============================================================================
// 2.3 QUANTITY INFERENCE
// ============================================================================

/**
 * Infers quantity based on context
 * Priority: batch-count > history > default
 * 
 * @param {Object} spec - The PrintJobSpec
 * @param {Object} context - From buildInferenceContext()
 * @param {Object} hints - Optional { batchSize, isReprint, repreatQuantity }
 * @returns {Object} { value, confidence, source, alternatives, reasoning }
 */
function inferQuantity(spec, context, hints = {}) {
  const result = {
    value: null,
    confidence: CONFIDENCE_LEVELS.NONE,
    source: null,
    alternatives: [],
    reasoning: []
  };
  
  // Check for rejected values
  const rejected = spec?.quantity?.rejectedValues || [];
  const notRejected = (val) => !rejected.includes(val);
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Batch count: CSV rows determine quantity
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.batchSize && hints.batchSize > 0) {
    const batch = hints.batchSize;
    if (notRejected(batch)) {
      result.value = batch;
      result.confidence = CONFIDENCE_LEVELS.HIGH;
      result.source = CONFIDENCE_SOURCES.BATCH_COUNT;
      result.reasoning.push(`Batch import: ${batch} rows`);
      return result;
    } else {
      result.reasoning.push(`Batch size ${batch} rejected by user`);
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Reprint: Use original quantity
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.isReprint && hints.reprintQuantity) {
    const reprQty = hints.reprintQuantity;
    if (notRejected(reprQty)) {
      result.value = reprQty;
      result.confidence = CONFIDENCE_LEVELS.MEDIUM;
      result.source = CONFIDENCE_SOURCES.HISTORY;
      result.alternatives = [1, 5, 10, 30].filter(q => q !== reprQty && notRejected(q));
      result.reasoning.push(`Reprint: original quantity was ${reprQty}`);
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. History pattern
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const historyResult = analyzeHistory('quantity', context.recentHistory);
  
  if (historyResult.value !== null && notRejected(Number(historyResult.value))) {
    result.value = Number(historyResult.value);
    result.confidence = historyResult.confidence;
    result.source = CONFIDENCE_SOURCES.HISTORY;
    result.alternatives = historyResult.alternatives
      .map(Number)
      .filter(q => !isNaN(q) && notRejected(q));
    result.reasoning.push(
      `History: ${historyResult.count}/${historyResult.total} jobs used ${historyResult.value}`
    );
    return result;
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Default: 1 label
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (notRejected(1)) {
    result.value = 1;
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.alternatives = [5, 10, 30].filter(notRejected);
    result.reasoning.push('Default: 1 label');
  } else {
    // If 1 is rejected, try common quantities
    const fallbacks = [5, 10, 30, 2, 3];
    for (const qty of fallbacks) {
      if (notRejected(qty)) {
        result.value = qty;
        result.confidence = CONFIDENCE_LEVELS.NONE;
        result.source = CONFIDENCE_SOURCES.DEFAULT;
        result.alternatives = fallbacks.filter(q => q !== qty && notRejected(q));
        result.reasoning.push(`Default (1 rejected): using ${qty}`);
        break;
      }
    }
  }
  
  return result;
}

// ============================================================================
// 2.4 CONTENT MODE INFERENCE
// ============================================================================

/**
 * Infers whether content is same on all labels or different per label
 * 
 * @param {Object} spec - The PrintJobSpec
 * @param {Object} context - From buildInferenceContext()
 * @param {Object} hints - Optional { hasCSV, hasTokens, templateType }
 * @returns {Object} { value, confidence, source, alternatives, reasoning }
 */
function inferContentMode(spec, context, hints = {}) {
  const result = {
    value: null,
    confidence: CONFIDENCE_LEVELS.NONE,
    source: null,
    alternatives: [],
    reasoning: []
  };
  
  const rejected = spec?.contentMode?.rejectedValues || [];
  const notRejected = (val) => !rejected.includes(val);
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. CSV data â†’ variable (different per label)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.hasCSV) {
    if (notRejected('variable')) {
      result.value = 'variable';
      result.confidence = CONFIDENCE_LEVELS.HIGH;
      result.source = CONFIDENCE_SOURCES.BATCH_COUNT;
      result.alternatives = notRejected('same') ? ['same'] : [];
      result.reasoning.push('CSV import â†’ variable content');
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Template with tokens â†’ variable
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (hints.hasTokens && hints.templateType === 'template') {
    if (notRejected('variable')) {
      result.value = 'variable';
      result.confidence = CONFIDENCE_LEVELS.MEDIUM;
      result.source = CONFIDENCE_SOURCES.TEMPLATE_TYPE;
      result.alternatives = notRejected('same') ? ['same'] : [];
      result.reasoning.push('Template with tokens â†’ likely variable');
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. History pattern
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const historyResult = analyzeHistory('contentMode', context.recentHistory);
  
  if (historyResult.value && notRejected(historyResult.value)) {
    result.value = historyResult.value;
    result.confidence = historyResult.confidence;
    result.source = CONFIDENCE_SOURCES.HISTORY;
    result.alternatives = historyResult.alternatives.filter(notRejected);
    result.reasoning.push(
      `History: ${historyResult.count}/${historyResult.total} jobs were ${historyResult.value}`
    );
    return result;
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Default: same on all (simpler workflow)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (notRejected('same')) {
    result.value = 'same';
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.alternatives = notRejected('variable') ? ['variable'] : [];
    result.reasoning.push('Default: same content on all labels');
  } else if (notRejected('variable')) {
    result.value = 'variable';
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.reasoning.push('Default (same rejected): variable');
  }
  
  return result;
}

// ============================================================================
// 2.5 SHEET SELECTION INFERENCE
// ============================================================================

/**
 * Infers which sheet(s) to use for printing
 * Priority: dedicated > specific-fit > auto-best
 * 
 * @param {Object} spec - The PrintJobSpec
 * @param {Object} context - From buildInferenceContext()
 * @param {Object} hints - Optional { labelType, quantity, contentId }
 * @returns {Object} { value, confidence, source, alternatives, sheetId, plan, reasoning }
 */
function inferSheetSelection(spec, context, hints = {}) {
  const result = {
    value: null,
    confidence: CONFIDENCE_LEVELS.NONE,
    source: null,
    alternatives: [],
    sheetId: null,
    plan: null,
    reasoning: []
  };
  
  const rejected = spec?.sheetSelection?.rejectedValues || [];
  const notRejected = (val) => !rejected.includes(val);
  
  const labelType = hints.labelType || spec?.labelType?.value;
  const quantity = hints.quantity || spec?.quantity?.value || 1;
  const contentId = hints.contentId;
  
  if (!labelType) {
    result.reasoning.push('Cannot infer sheet: no label type specified');
    return result;
  }
  
  // Get sheets of the right type
  const sheetsOfType = (context.sheetsByType[labelType] || [])
    .filter(sh => sh.available > 0);
  
  if (sheetsOfType.length === 0) {
    // No open sheets - need new sheet
    if (notRejected('new')) {
      result.value = 'new';
      result.confidence = CONFIDENCE_LEVELS.HIGH;
      result.source = CONFIDENCE_SOURCES.INVENTORY_ONLY;
      result.reasoning.push(`No open ${labelType} sheets â†’ new sheet`);
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Dedicated sheet for this content
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (contentId) {
    const dedicatedSheet = sheetsOfType.find(sh => sh.dedication === contentId);
    if (dedicatedSheet && dedicatedSheet.available >= quantity) {
      if (notRejected('specific') && notRejected(dedicatedSheet.id)) {
        result.value = 'specific';
        result.sheetId = dedicatedSheet.id;
        result.confidence = CONFIDENCE_LEVELS.HIGH;
        result.source = CONFIDENCE_SOURCES.DEDICATED;
        result.reasoning.push(`Dedicated sheet "${dedicatedSheet.name}" for this content`);
        return result;
      }
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Single sheet with exact or sufficient capacity
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Sort by available (ascending) to use nearly-full sheets first
  const sortedSheets = [...sheetsOfType].sort((a, b) => a.available - b.available);
  
  // Find first sheet that can fit all labels
  const fitSheet = sortedSheets.find(sh => sh.available >= quantity);
  
  if (fitSheet) {
    if (notRejected('specific') && notRejected(fitSheet.id)) {
      result.value = 'specific';
      result.sheetId = fitSheet.id;
      result.confidence = CONFIDENCE_LEVELS.MEDIUM;
      result.source = CONFIDENCE_SOURCES.AUTO_BEST;
      
      // Build alternatives from other sheets that fit
      result.alternatives = sortedSheets
        .filter(sh => sh.id !== fitSheet.id && sh.available >= quantity)
        .map(sh => sh.id);
      
      result.reasoning.push(
        `Sheet "${fitSheet.name}" has ${fitSheet.available} spots (need ${quantity})`
      );
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. Multi-sheet plan needed
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const totalAvailable = sheetsOfType.reduce((sum, sh) => sum + sh.available, 0);
  
  if (totalAvailable >= quantity) {
    // Can fulfill with multiple existing sheets
    if (notRejected('multi')) {
      // Build a simple plan: fill sheets in order until quantity met
      const plan = [];
      let remaining = quantity;
      
      for (const sh of sortedSheets) {
        if (remaining <= 0) break;
        const useFromSheet = Math.min(sh.available, remaining);
        plan.push({
          sheetId: sh.id,
          sheetName: sh.name,
          count: useFromSheet
        });
        remaining -= useFromSheet;
      }
      
      result.value = 'multi';
      result.plan = plan;
      result.confidence = CONFIDENCE_LEVELS.MEDIUM;
      result.source = CONFIDENCE_SOURCES.AUTO_BEST;
      result.reasoning.push(`Multi-sheet plan: ${plan.length} sheets needed`);
      return result;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Need new sheet(s) from inventory
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (notRejected('new')) {
    const spec = LABEL_TYPES[labelType];
    const perSheet = spec ? spec.cols * spec.rows : 30;
    const sheetsNeeded = Math.ceil(quantity / perSheet);
    
    result.value = 'new';
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.AUTO_BEST;
    result.reasoning.push(`Need ${sheetsNeeded} new sheet(s) from inventory`);
    
    // Add 'auto' as alternative if available
    if (notRejected('auto')) {
      result.alternatives = ['auto'];
    }
    return result;
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5. Fallback: auto selection
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (notRejected('auto')) {
    result.value = 'auto';
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.reasoning.push('Fallback: auto-select sheets');
    return result;
  }
  
  result.reasoning.push('Unable to determine sheet selection');
  return result;
}

// ============================================================================
// 2.6 POST-PRINT ACTION INFERENCE
// ============================================================================

/**
 * Infers what to do after printing (track, dedicate, etc.)
 * 
 * @param {Object} spec - The PrintJobSpec
 * @param {Object} context - From buildInferenceContext()
 * @param {Object} hints - Optional { isReprint, sheetWillBeEmpty, contentName }
 * @returns {Object} { value, confidence, source, alternatives, dedicatedName, reasoning }
 */
function inferPostPrint(spec, context, hints = {}) {
  const result = {
    value: null,
    confidence: CONFIDENCE_LEVELS.NONE,
    source: null,
    alternatives: [],
    dedicatedName: null,
    reasoning: []
  };
  
  const rejected = spec?.postPrint?.rejectedValues || [];
  const notRejected = (val) => !rejected.includes(val);
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. History pattern for post-print action
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const historyResult = analyzeHistory('postPrint', context.recentHistory);
  
  if (historyResult.value && notRejected(historyResult.value)) {
    result.value = historyResult.value;
    result.confidence = historyResult.confidence;
    result.source = CONFIDENCE_SOURCES.HISTORY;
    result.alternatives = historyResult.alternatives.filter(notRejected);
    result.reasoning.push(
      `History: ${historyResult.count}/${historyResult.total} jobs used ${historyResult.value}`
    );
    return result;
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Default: track usage
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (notRejected('track')) {
    result.value = 'track';
    result.confidence = CONFIDENCE_LEVELS.LOW;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.alternatives = ['dedicate', 'discard'].filter(notRejected);
    result.reasoning.push('Default: track sheet usage');
    return result;
  }
  
  // Fallbacks
  if (notRejected('dedicate')) {
    result.value = 'dedicate';
    result.confidence = CONFIDENCE_LEVELS.NONE;
    result.source = CONFIDENCE_SOURCES.DEFAULT;
    result.reasoning.push('Fallback: dedicate sheet');
    return result;
  }
  
  return result;
}

// ============================================================================
// 2.7 ORCHESTRATION: RUN ALL INFERENCES
// ============================================================================

/**
 * Runs all inference functions in dependency order
 * Updates the spec in place with inferred values
 * 
 * @param {Object} spec - The PrintJobSpec to populate
 * @param {Object} hints - Optional hints for each element
 * @returns {Object} { spec, inferences, summary }
 */
function runAllInferences(spec, hints = {}) {
  const context = buildInferenceContext();
  const inferences = {};
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Label Type (independent)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inferences.labelType = inferLabelType(spec, context, {
    lockedBySheet: hints.lockedBySheet,
    contentLabelType: hints.contentLabelType
  });
  
  if (inferences.labelType.value !== null) {
    updateSpecElement(spec, 'labelType', {
      value: inferences.labelType.value,
      confidence: inferences.labelType.confidence,
      source: inferences.labelType.source,
      alternatives: inferences.labelType.alternatives
    });
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Content Mode (may depend on content source)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inferences.contentMode = inferContentMode(spec, context, {
    hasCSV: hints.hasCSV,
    hasTokens: hints.hasTokens,
    templateType: hints.templateType
  });
  
  if (inferences.contentMode.value !== null) {
    updateSpecElement(spec, 'contentMode', {
      value: inferences.contentMode.value,
      confidence: inferences.contentMode.confidence,
      source: inferences.contentMode.source,
      alternatives: inferences.contentMode.alternatives
    });
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. Quantity (depends on content mode for batch)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inferences.quantity = inferQuantity(spec, context, {
    batchSize: hints.batchSize,
    isReprint: hints.isReprint,
    reprintQuantity: hints.reprintQuantity
  });
  
  if (inferences.quantity.value !== null) {
    updateSpecElement(spec, 'quantity', {
      value: inferences.quantity.value,
      confidence: inferences.quantity.confidence,
      source: inferences.quantity.source,
      alternatives: inferences.quantity.alternatives
    });
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Sheet Selection (depends on labelType, quantity)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inferences.sheetSelection = inferSheetSelection(spec, context, {
    labelType: spec.labelType.value,
    quantity: spec.quantity.value,
    contentId: hints.contentId
  });
  
  if (inferences.sheetSelection.value !== null) {
    updateSpecElement(spec, 'sheetSelection', {
      value: inferences.sheetSelection.value,
      confidence: inferences.sheetSelection.confidence,
      source: inferences.sheetSelection.source,
      alternatives: inferences.sheetSelection.alternatives,
      sheetId: inferences.sheetSelection.sheetId,
      plan: inferences.sheetSelection.plan
    });
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5. Post-Print Action
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  inferences.postPrint = inferPostPrint(spec, context, {
    isReprint: hints.isReprint,
    contentName: hints.contentName
  });
  
  if (inferences.postPrint.value !== null) {
    updateSpecElement(spec, 'postPrint', {
      value: inferences.postPrint.value,
      confidence: inferences.postPrint.confidence,
      source: inferences.postPrint.source,
      alternatives: inferences.postPrint.alternatives,
      dedicatedName: inferences.postPrint.dedicatedName
    });
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Build summary
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const highConf = getHighConfidenceElements(spec);
  const unresolved = getUnresolvedElements(spec);
  
  const summary = {
    complete: isSpecComplete(spec),
    highConfidenceCount: highConf.length,
    unresolvedCount: unresolved.length,
    canSkipSteps: highConf,
    needsInput: unresolved,
    contextStats: {
      sheetsAvailable: context.totalSheetCount,
      typesAvailable: context.typesAvailable.length,
      historyJobs: context.recentHistory.length
    }
  };
  
  return { spec, inferences, summary };
}

/**
 * Recalculate inference summary from current spec state
 * Used after learning adjustments modify inference confidence levels
 * @param {Object} inferences - Current inference results
 * @returns {Object} Updated summary object
 */
function summarizeInferences(inferences) {
  // Use the global wf1Spec if available
  const spec = typeof wf1Spec !== 'undefined' ? wf1Spec : {};
  const context = buildInferenceContext();
  
  const highConf = getHighConfidenceElements(spec);
  const unresolved = getUnresolvedElements(spec);
  
  return {
    complete: isSpecComplete(spec),
    highConfidenceCount: highConf.length,
    unresolvedCount: unresolved.length,
    canSkipSteps: highConf,
    needsInput: unresolved,
    contextStats: {
      sheetsAvailable: context.totalSheetCount,
      typesAvailable: context.typesAvailable.length,
      historyJobs: context.recentHistory.length
    }
  };
}

// ============================================================================
// 2.8 DEBUG: INFERENCE LOG
// ============================================================================

/**
 * Creates a human-readable log of inference results
 * @param {Object} inferences - From runAllInferences
 * @returns {string} Formatted debug log
 */
function inferenceToLog(inferences) {
  const lines = ['â•â•â• Inference Results â•â•â•'];
  
  for (const [element, result] of Object.entries(inferences)) {
    const status = 
      result.confidence === 'high' ? 'âœ“ HIGH' :
      result.confidence === 'medium' ? 'â— MED' :
      result.confidence === 'low' ? 'â—‹ LOW' : '? NONE';
    
    lines.push(`\n${element}: ${status}`);
    lines.push(`  value: ${JSON.stringify(result.value)}`);
    lines.push(`  source: ${result.source || 'none'}`);
    
    if (result.alternatives?.length > 0) {
      lines.push(`  alternatives: ${result.alternatives.join(', ')}`);
    }
    
    if (result.reasoning?.length > 0) {
      lines.push(`  reasoning:`);
      result.reasoning.forEach(r => lines.push(`    - ${r}`));
    }
  }
  
  return lines.join('\n');
}

/**
 * Logs inference results to console
 * @param {Object} inferences - From runAllInferences
 * @param {string} label - Optional label
 */
function logInferences(inferences, label = '') {
  const header = label ? `Inferences [${label}]` : 'Inferences';
  console.group(header);
  console.log(inferenceToLog(inferences));
  console.groupEnd();
}

// ============================================================================
// 2.9 EXPORT FOR TESTING
// ============================================================================

if (typeof window !== 'undefined' && window._pjs) {
  // Extend existing _pjs with Phase 2 functions
  Object.assign(window._pjs, {
    // Context
    buildInferenceContext,
    
    // Individual inferences
    inferLabelType,
    inferQuantity,
    inferContentMode,
    inferSheetSelection,
    inferPostPrint,
    
    // Orchestration
    runAllInferences,
    
    // Debug
    inferenceToLog,
    logInferences,
    
    // Quick test for Phase 2
    testInference: function() {
      console.log('Testing Phase 2 Inference Engine...\n');
      
      // Build context
      console.log('1. Building context...');
      const ctx = buildInferenceContext();
      console.log(`   Sheets: ${ctx.totalSheetCount}`);
      console.log(`   Types available: ${ctx.typesAvailable.join(', ') || 'none'}`);
      console.log(`   History jobs: ${ctx.recentHistory.length}`);
      
      // Create spec and run inferences
      console.log('\n2. Running all inferences...');
      const spec = createPrintJobSpec('test-inference');
      const result = runAllInferences(spec, {});
      
      // Show results
      console.log('\n3. Results:');
      logInferences(result.inferences, 'test');
      
      console.log('\n4. Summary:');
      console.log(`   Complete: ${result.summary.complete}`);
      console.log(`   High confidence: ${result.summary.highConfidenceCount}`);
      console.log(`   Can skip: ${result.summary.canSkipSteps.join(', ') || 'none'}`);
      console.log(`   Needs input: ${result.summary.needsInput.join(', ') || 'none'}`);
      
      console.log('\n5. Final spec:');
      logSpec(spec, 'after-inference');
      
      console.log('\nPhase 2 test complete!');
      return { spec, inferences: result.inferences, summary: result.summary };
    },
    
    // Phase 3: Test WF1 integration
    testWF1Integration: function() {
      console.log('Testing Phase 3/3B WF1 Integration...\n');
      
      // Check if WF1 functions exist
      const funcs = [
        'wf1InitInferences',
        'wf1GetUIMode', 
        'wf1ShouldSkipStep',
        'wf1AcceptInference',
        'wf1RejectInference',
        'wf1UpdateSmartSummary',
        'wf1FormatInferenceValue',
        'wf1EditInference',
        'wf1ApplyInferenceToState',
        // Phase 3B functions
        'wf1CheckAutoSkip',
        'wf1ExecuteAutoSkip',
        'wf1UpdateSkippedBanner',
        'wf1ToggleSkippedDetails',
        'wf1EditSkippedElement',
        'wf1ResetSkippedSteps',
        // Phase 3C functions
        'wf1CheckConfirmMode',
        'wf1RenderConfirmCard',
        'getTopAlternativeTypes',
        'wf1ConfirmAccept',
        'wf1ConfirmShowAlternatives',
        'wf1ConfirmSelectAlternative',
        'wf1ConfirmSelectContentMode',
        'wf1ConfirmShowAll',
        // Phase 3D functions
        'wf1CheckNarrowedMode',
        'wf1RenderNarrowedCard',
        'getNarrowedLabelTypes',
        'wf1NarrowedSelect',
        'wf1NarrowedSelectAndContinue',
        'wf1NarrowedContinue',
        'wf1NarrowedShowAll'
      ];
      
      console.log('1. Checking Phase 3/3B/3C/3D functions exist...');
      let allExist = true;
      funcs.forEach(f => {
        const exists = typeof window[f] === 'function';
        console.log(`   ${f}: ${exists ? 'âœ“' : 'âœ—'}`);
        if (!exists) allExist = false;
      });
      
      if (!allExist) {
        console.log('\nâœ— Some Phase 3/3B/3C/3D functions missing!');
        return false;
      }
      
      // Test initialization
      console.log('\n2. Testing wf1InitInferences()...');
      const result = wf1InitInferences();
      console.log(`   Spec created: ${!!wf1Spec}`);
      console.log(`   Inferences: ${!!wf1Inferences}`);
      console.log(`   Summary: ${!!wf1InferenceSummary}`);
      
      // Test UI mode determination
      console.log('\n3. Testing wf1GetUIMode()...');
      INFERENCE_ORDER.forEach(element => {
        const mode = wf1GetUIMode(element);
        console.log(`   ${element}: ${mode}`);
      });
      
      // Test step skip logic
      console.log('\n4. Testing wf1ShouldSkipStep()...');
      [1, 2, 3, 4, 5, 6, 7, 8].forEach(step => {
        const skip = wf1ShouldSkipStep(step);
        console.log(`   Step ${step}: ${skip ? 'SKIP' : 'show'}`);
      });
      
      // Test formatting
      console.log('\n5. Testing wf1FormatInferenceValue()...');
      console.log(`   labelType '5160': ${wf1FormatInferenceValue('labelType', '5160')}`);
      console.log(`   quantity 5: ${wf1FormatInferenceValue('quantity', 5)}`);
      console.log(`   contentMode 'same': ${wf1FormatInferenceValue('contentMode', 'same')}`);
      console.log(`   sheetSelection 'new': ${wf1FormatInferenceValue('sheetSelection', 'new')}`);
      
      // Phase 3B: Test auto-skip detection
      console.log('\n6. Testing Phase 3B wf1CheckAutoSkip()...');
      [1, 2, 3, 4, 5, 6, 7, 8].forEach(step => {
        const skipInfo = wf1CheckAutoSkip(step);
        if (skipInfo) {
          console.log(`   Step ${step}: can skip â†’ step ${skipInfo.targetStep} (${skipInfo.element})`);
        } else {
          console.log(`   Step ${step}: no auto-skip`);
        }
      });
      
      // Test skipped steps tracking
      console.log('\n7. Testing skipped steps tracking...');
      wf1ResetSkippedSteps();
      console.log(`   After reset: ${wf1SkippedSteps.length} skipped`);
      wf1SkippedSteps.push('labelType');
      console.log(`   After adding labelType: ${wf1SkippedSteps.length} skipped`);
      wf1ResetSkippedSteps();
      console.log(`   After reset again: ${wf1SkippedSteps.length} skipped`);
      
      // Phase 3C: Test confirm mode detection
      console.log('\n8. Testing Phase 3C wf1CheckConfirmMode()...');
      [1, 2, 3, 4, 5].forEach(step => {
        const confirmInfo = wf1CheckConfirmMode(step);
        if (confirmInfo) {
          console.log(`   Step ${step}: CONFIRM mode for ${confirmInfo.element} = ${confirmInfo.value}`);
        } else {
          console.log(`   Step ${step}: no confirm mode`);
        }
      });
      
      // Phase 3C: Test alternatives
      console.log('\n9. Testing Phase 3C getTopAlternativeTypes()...');
      const alts = getTopAlternativeTypes('5160', 3);
      console.log(`   Alternatives to 5160: ${alts.map(a => a.typeId).join(', ') || 'none in stock'}`);
      
      // Phase 3D: Test narrowed mode detection
      console.log('\n10. Testing Phase 3D wf1CheckNarrowedMode()...');
      [1, 2, 3, 4, 5].forEach(step => {
        const narrowedInfo = wf1CheckNarrowedMode(step);
        if (narrowedInfo) {
          console.log(`   Step ${step}: NARROWED mode for ${narrowedInfo.element} = ${narrowedInfo.value} (${narrowedInfo.options.length} options)`);
        } else {
          console.log(`   Step ${step}: no narrowed mode`);
        }
      });
      
      // Phase 3D: Test narrowed types
      console.log('\n11. Testing Phase 3D getNarrowedLabelTypes()...');
      const narrowed = getNarrowedLabelTypes('5160', 5);
      console.log(`   Narrowed options for 5160:`);
      narrowed.forEach(opt => {
        console.log(`     - ${opt.typeId}: stock=${opt.stock}, suggested=${opt.suggested}`);
      });
      
      // Phase 4: Test learning functions
      console.log('\n12. Testing Phase 4 Learning Loop functions...');
      const phase4Funcs = ['recordCorrection', 'recordAcceptance', 'getCorrectionRate', 'getConfidencePenalty', 'getLearnedPreference', 'applyLearningToInference', 'getLearningStats'];
      phase4Funcs.forEach(fn => {
        const exists = typeof window[fn] === 'function';
        console.log(`   ${fn}: ${exists ? 'âœ“' : 'âœ—'}`);
      });
      
      // Test learning stats
      if (typeof getLearningStats === 'function') {
        const stats = getLearningStats();
        console.log(`   Learning stats: ${stats.totalAcceptances} acceptances, ${stats.totalCorrections} corrections`);
      }
      
      console.log('\nâœ“ Phase 3/3B/3C/3D/4 test complete!');
      return { spec: wf1Spec, inferences: wf1Inferences, summary: wf1InferenceSummary, skipped: wf1SkippedSteps };
    }
  });
  
  console.log('Phase 2+3B+3C+3D+4 loaded. Run window._pjs.testInference() or window._pjs.testWF1Integration() to verify.');
}

// ============================================================================
// Phase 4: Learning Loop
// ============================================================================
//
// This module tracks user corrections to inferences and adjusts confidence
// over time based on correction patterns. It enables per-user preference learning.
//
// Key concepts:
// - Correction: When user selects something different from what was inferred
// - Acceptance: When user accepts (confirms, double-clicks) the inference
// - Correction Rate: corrections / (corrections + acceptances)
// - Confidence Penalty: High correction rate â†’ lower confidence for that pattern
//
// Data stored in localStorage as 'lkLearning':
// {
//   corrections: { elementName: { inferred: X, chosen: Y, count: N } },
//   acceptances: { elementName: { value: X, count: N } },
//   preferences: { elementName: topChoice },
//   stats: { totalCorrections, totalAcceptances, lastUpdated }
// }
// ============================================================================

// Storage key for learning data
const LEARNING_KEY = 'lkLearning';

// Learning data (loaded at startup)
let learningData = null;

/**
 * Initialize learning data structure
 */
function createLearningData() {
  return {
    corrections: {},    // Track corrections by element
    acceptances: {},    // Track acceptances by element
    preferences: {},    // Derived top preferences
    stats: {
      totalCorrections: 0,
      totalAcceptances: 0,
      lastUpdated: Date.now()
    },
    version: 1
  };
}

/**
 * Load learning data from localStorage
 */
function loadLearningData() {
  try {
    const stored = localStorage.getItem(LEARNING_KEY);
    if (stored) {
      learningData = JSON.parse(stored);
      // Ensure structure is valid
      if (!learningData.corrections) learningData.corrections = {};
      if (!learningData.acceptances) learningData.acceptances = {};
      if (!learningData.preferences) learningData.preferences = {};
      if (!learningData.stats) learningData.stats = { totalCorrections: 0, totalAcceptances: 0, lastUpdated: Date.now() };
    } else {
      learningData = createLearningData();
    }
  } catch (e) {
    console.warn('[Phase 4] Failed to load learning data:', e);
    learningData = createLearningData();
  }
}

/**
 * Save learning data to localStorage
 */
function saveLearningData() {
  try {
    if (!learningData) learningData = createLearningData();
    learningData.stats.lastUpdated = Date.now();
    localStorage.setItem(LEARNING_KEY, JSON.stringify(learningData));
  } catch (e) {
    console.warn('[Phase 4] Failed to save learning data:', e);
  }
}

/**
 * Record a correction - user chose differently than inferred
 * @param {string} element - Element name ('labelType', 'contentMode', etc.)
 * @param {string} inferredValue - What the system suggested
 * @param {string} chosenValue - What the user selected
 * @param {string} source - Source of inference (for pattern tracking)
 */
function recordCorrection(element, inferredValue, chosenValue, source = 'unknown') {
  if (!learningData) loadLearningData();
  if (!element || inferredValue === null || inferredValue === chosenValue) return;
  
  // Initialize element tracking if needed
  if (!learningData.corrections[element]) {
    learningData.corrections[element] = {};
  }
  
  // Create a key for this specific correction pattern
  const key = `${inferredValue}â†’${chosenValue}`;
  
  if (!learningData.corrections[element][key]) {
    learningData.corrections[element][key] = {
      inferred: inferredValue,
      chosen: chosenValue,
      source: source,
      count: 0,
      firstSeen: Date.now(),
      lastSeen: null
    };
  }
  
  learningData.corrections[element][key].count++;
  learningData.corrections[element][key].lastSeen = Date.now();
  learningData.stats.totalCorrections++;
  
  console.log(`[Phase 4] Correction recorded: ${element} ${inferredValue} â†’ ${chosenValue} (count: ${learningData.corrections[element][key].count})`);
  
  // Update preferences
  updatePreferences(element);
  saveLearningData();
}

/**
 * Record an acceptance - user accepted the inference
 * @param {string} element - Element name
 * @param {string} value - The accepted value
 * @param {string} source - Source of inference
 */
function recordAcceptance(element, value, source = 'unknown') {
  if (!learningData) loadLearningData();
  if (!element || value === null) return;
  
  // Initialize element tracking if needed
  if (!learningData.acceptances[element]) {
    learningData.acceptances[element] = {};
  }
  
  if (!learningData.acceptances[element][value]) {
    learningData.acceptances[element][value] = {
      value: value,
      source: source,
      count: 0,
      firstSeen: Date.now(),
      lastSeen: null
    };
  }
  
  learningData.acceptances[element][value].count++;
  learningData.acceptances[element][value].lastSeen = Date.now();
  learningData.stats.totalAcceptances++;
  
  console.log(`[Phase 4] Acceptance recorded: ${element} = ${value} (count: ${learningData.acceptances[element][value].count})`);
  
  // Update preferences
  updatePreferences(element);
  saveLearningData();
}

/**
 * Update derived preferences for an element based on corrections and acceptances
 * @param {string} element - Element name
 */
function updatePreferences(element) {
  if (!learningData) return;
  
  // Count total choices for each value
  const valueCounts = {};
  
  // Add acceptance counts
  if (learningData.acceptances[element]) {
    for (const [value, data] of Object.entries(learningData.acceptances[element])) {
      valueCounts[value] = (valueCounts[value] || 0) + data.count;
    }
  }
  
  // Add correction target counts (what user chose instead)
  if (learningData.corrections[element]) {
    for (const [key, data] of Object.entries(learningData.corrections[element])) {
      valueCounts[data.chosen] = (valueCounts[data.chosen] || 0) + data.count;
    }
  }
  
  // Find the top preference
  let topValue = null;
  let topCount = 0;
  for (const [value, count] of Object.entries(valueCounts)) {
    if (count > topCount) {
      topCount = count;
      topValue = value;
    }
  }
  
  if (topValue) {
    learningData.preferences[element] = {
      value: topValue,
      count: topCount,
      total: Object.values(valueCounts).reduce((a, b) => a + b, 0)
    };
  }
}

/**
 * Get the correction rate for a specific inference pattern
 * @param {string} element - Element name
 * @param {string} value - The inferred value
 * @returns {number} Correction rate (0-1), or null if no data
 */
function getCorrectionRate(element, value) {
  if (!learningData) loadLearningData();
  
  let corrections = 0;
  let acceptances = 0;
  
  // Count corrections where this value was inferred
  if (learningData.corrections[element]) {
    for (const [key, data] of Object.entries(learningData.corrections[element])) {
      if (data.inferred === value) {
        corrections += data.count;
      }
    }
  }
  
  // Count acceptances of this value
  if (learningData.acceptances[element]?.[value]) {
    acceptances = learningData.acceptances[element][value].count;
  }
  
  const total = corrections + acceptances;
  if (total === 0) return null;
  
  return corrections / total;
}

/**
 * Get confidence penalty based on correction history
 * Returns a multiplier (0.5-1.0) to apply to base confidence
 * @param {string} element - Element name
 * @param {string} value - The inferred value
 * @returns {number} Multiplier for confidence (1.0 = no penalty)
 */
function getConfidencePenalty(element, value) {
  const correctionRate = getCorrectionRate(element, value);
  
  if (correctionRate === null) return 1.0; // No data, no penalty
  
  // Penalty scale:
  // 0% corrections â†’ 1.0 (no penalty)
  // 25% corrections â†’ 0.9 (minor penalty)
  // 50% corrections â†’ 0.75 (moderate penalty)
  // 75% corrections â†’ 0.6 (significant penalty)
  // 100% corrections â†’ 0.5 (maximum penalty)
  
  return Math.max(0.5, 1 - (correctionRate * 0.5));
}

/**
 * Get user's preferred value for an element (if learned)
 * @param {string} element - Element name
 * @returns {Object|null} { value, count, total } or null
 */
function getLearnedPreference(element) {
  if (!learningData) loadLearningData();
  return learningData.preferences[element] || null;
}

/**
 * Adjust inference result based on learning data
 * Call this after runAllInferences to apply learning adjustments
 * @param {Object} inference - The inference result { value, confidence, source, ... }
 * @param {string} element - Element name
 * @returns {Object} Adjusted inference
 */
function applyLearningToInference(inference, element) {
  if (!inference || !inference.value) return inference;
  if (!learningData) loadLearningData();
  
  const adjusted = { ...inference };
  
  // 1. Apply confidence penalty based on correction history
  const penalty = getConfidencePenalty(element, inference.value);
  if (penalty < 1.0) {
    // Downgrade confidence if heavily corrected
    if (penalty < 0.7 && adjusted.confidence === CONFIDENCE_LEVELS.HIGH) {
      adjusted.confidence = CONFIDENCE_LEVELS.MEDIUM;
      adjusted.reasoning = adjusted.reasoning || [];
      adjusted.reasoning.push(`Confidence reduced: ${Math.round((1-penalty)*100)}% correction rate`);
    } else if (penalty < 0.6 && adjusted.confidence === CONFIDENCE_LEVELS.MEDIUM) {
      adjusted.confidence = CONFIDENCE_LEVELS.LOW;
      adjusted.reasoning = adjusted.reasoning || [];
      adjusted.reasoning.push(`Confidence reduced: high correction rate`);
    }
  }
  
  // 2. Check if there's a strongly preferred alternative
  const preference = getLearnedPreference(element);
  if (preference && preference.value !== inference.value && preference.count >= 5) {
    // User has a strong preference for something else
    const prefRate = preference.count / preference.total;
    if (prefRate >= 0.7) {
      // 70%+ of choices are the preferred value
      adjusted.learningNote = `User typically chooses ${preference.value}`;
      
      // If the preferred value is in alternatives, flag it
      if (adjusted.alternatives && adjusted.alternatives.includes(preference.value)) {
        adjusted.preferredAlternative = preference.value;
      }
    }
  }
  
  return adjusted;
}

/**
 * Get learning stats summary
 */
function getLearningStats() {
  if (!learningData) loadLearningData();
  
  const elementStats = {};
  const elements = new Set([
    ...Object.keys(learningData.corrections || {}),
    ...Object.keys(learningData.acceptances || {})
  ]);
  
  for (const element of elements) {
    const corrections = Object.values(learningData.corrections[element] || {})
      .reduce((sum, d) => sum + d.count, 0);
    const acceptances = Object.values(learningData.acceptances[element] || {})
      .reduce((sum, d) => sum + d.count, 0);
    
    elementStats[element] = {
      corrections,
      acceptances,
      total: corrections + acceptances,
      correctionRate: corrections + acceptances > 0 
        ? Math.round((corrections / (corrections + acceptances)) * 100) + '%'
        : 'N/A',
      preference: learningData.preferences[element]?.value || null
    };
  }
  
  return {
    totalCorrections: learningData.stats.totalCorrections,
    totalAcceptances: learningData.stats.totalAcceptances,
    lastUpdated: learningData.stats.lastUpdated,
    elements: elementStats
  };
}

/**
 * Clear all learning data (reset)
 */
function clearLearningData() {
  learningData = createLearningData();
  saveLearningData();
  console.log('[Phase 4] Learning data cleared');
}

// Initialize on load
if (typeof window !== 'undefined') {
  // Load learning data at startup
  loadLearningData();
  
  // Expose Phase 4 APIs
  if (window._pjs) {
    Object.assign(window._pjs, {
      recordCorrection,
      recordAcceptance,
      getCorrectionRate,
      getConfidencePenalty,
      getLearnedPreference,
      applyLearningToInference,
      getLearningStats,
      clearLearningData,
      
      // Test function for Phase 4
      testLearning: function() {
        console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('Phase 4: Learning Loop Test');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        
        // Test 1: Record some corrections
        console.log('1. Recording test corrections...');
        recordCorrection('labelType', '5160', '5163', 'test');
        recordCorrection('labelType', '5160', '5163', 'test');
        recordCorrection('labelType', '5160', '5167', 'test');
        console.log('   Recorded: 5160â†’5163 (x2), 5160â†’5167 (x1)');
        
        // Test 2: Record some acceptances
        console.log('\n2. Recording test acceptances...');
        recordAcceptance('labelType', '5163', 'test');
        recordAcceptance('labelType', '5163', 'test');
        recordAcceptance('labelType', '5163', 'test');
        recordAcceptance('labelType', '5163', 'test');
        recordAcceptance('labelType', '5163', 'test');
        console.log('   Recorded: 5163 accepted (x5)');
        
        // Test 3: Check correction rate
        console.log('\n3. Checking correction rates...');
        const rate5160 = getCorrectionRate('labelType', '5160');
        const rate5163 = getCorrectionRate('labelType', '5163');
        console.log(`   5160 correction rate: ${rate5160 !== null ? Math.round(rate5160*100)+'%' : 'N/A'}`);
        console.log(`   5163 correction rate: ${rate5163 !== null ? Math.round(rate5163*100)+'%' : 'N/A'}`);
        
        // Test 4: Check confidence penalty
        console.log('\n4. Checking confidence penalties...');
        const penalty5160 = getConfidencePenalty('labelType', '5160');
        const penalty5163 = getConfidencePenalty('labelType', '5163');
        console.log(`   5160 confidence multiplier: ${penalty5160}`);
        console.log(`   5163 confidence multiplier: ${penalty5163}`);
        
        // Test 5: Check learned preference
        console.log('\n5. Checking learned preferences...');
        const pref = getLearnedPreference('labelType');
        console.log(`   Preferred labelType: ${pref ? pref.value + ' (' + pref.count + '/' + pref.total + ')' : 'none'}`);
        
        // Test 6: Get full stats
        console.log('\n6. Full learning stats:');
        const stats = getLearningStats();
        console.log('   ', stats);
        
        console.log('\nâœ“ Phase 4 Learning Loop test complete!');
        return stats;
      }
    });
  }
  
  console.log('Phase 4 Learning Loop loaded. Run window._pjs.testLearning() to verify.');
}

// Wizard state managed by WF1/WF2
let sheetGridPages = {}; // Tracks current page for multi-sheet grids

// ========== BUILT-IN TEMPLATES ==========
const BUILTIN_TEMPLATES = [
  // ===== IMPORT TEMPLATES (type: 'template') =====
  { id: '__builtin_mailing', name: 'Mailing Address', text: 'left,11:{first_name} {last_name}\nleft,11:{street}\nleft,11:{city}, {state} {zip}\nleft,10:{country}', alignV: 'center', type: 'template', tokens: ['first_name','last_name','street','city','state','zip','country'], builtin: true, labelType: '5160' },
  { id: '__builtin_return', name: 'Return Address', text: 'left,9:{name}\nleft,9:{street}\nleft,9:{city}, {state} {zip}', alignV: 'center', type: 'template', tokens: ['name','street','city','state','zip'], builtin: true, labelType: '5167' },
  { id: '__builtin_classroom', name: 'Classroom Label', text: 'left,14:{student_name}\ncenter,11:Room {room} || {teacher}\ncenter,10:Level: {level}', alignV: 'center', type: 'template', tokens: ['student_name','room','teacher','level'], builtin: true, labelType: '5160' },
  { id: '__builtin_namebadge', name: 'Name Badge', text: 'center,16:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5163' },
  { id: '__builtin_badge_simple', name: 'Name Badge (Simple)', text: 'center,24:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_company', name: 'Name Badge (Company)', text: 'center,10:HELLO my name is\ncenter,20:{name}\ncenter,12:{company}', alignV: 'center', type: 'template', tokens: ['name','company'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_event', name: 'Name Badge (Event)', text: 'center,18:{name}\ncenter,12:{title}\ncenter,10:{company}', alignV: 'center', type: 'template', tokens: ['name','title','company'], builtin: true, labelType: '5395' },
  { id: '__builtin_tent_name', name: 'Tent Card (Name)', text: 'center,28:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_table', name: 'Tent Card (Table)', text: 'center,14:Table\ncenter,36:{table_number}', alignV: 'center', type: 'template', tokens: ['table_number'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_food', name: 'Tent Card (Food Label)', text: 'center,18:{dish_name}\ncenter,11:{description}', alignV: 'center', type: 'template', tokens: ['dish_name','description'], builtin: true, labelType: '5302' },
  
  // ===== STYLE TEMPLATES (type: 'style') =====
  // Style templates use lineStyles array which gets converted to text format at runtime
  // The text field contains formatting only (empty text), actual content comes from user
  
  // ----- HOLIDAY (5160) -----
  { id: '__style_holiday_festive_5160', name: 'Holiday Festive', type: 'style', category: 'holiday', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'holly' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#c41e3a' },
    lineStyles: [
      { fontFamily: 'elegant', fontSize: 12, bold: true, color: '#c41e3a', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#2d5a27', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#2d5a27', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#666666', align: 'center' }
    ]
  },
  { id: '__style_holiday_gold_5160', name: 'Elegant Gold', type: 'style', category: 'holiday', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#b8860b' },
    lineStyles: [
      { fontFamily: 'formal', fontSize: 12, italic: true, color: '#b8860b', align: 'center' },
      { fontFamily: 'formal', fontSize: 10, color: '#333333', align: 'center' },
      { fontFamily: 'formal', fontSize: 9, color: '#333333', align: 'center' },
      { fontFamily: 'formal', fontSize: 8, color: '#666666', align: 'center' }
    ]
  },
  { id: '__style_holiday_snowy_5160', name: 'Snowy Blue', type: 'style', category: 'holiday', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'snowflake' }, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'elegant', fontSize: 11, bold: true, color: '#1e40af', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#3b82f6', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#3b82f6', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- WEDDING (5160) -----
  { id: '__style_wedding_elegant_5160', name: 'Elegant Script', type: 'style', category: 'wedding', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'script', fontSize: 14, color: '#4a4a4a', align: 'center' },
      { fontFamily: 'formal', fontSize: 10, color: '#6b7280', align: 'center' },
      { fontFamily: 'formal', fontSize: 9, color: '#6b7280', align: 'center' },
      { fontFamily: 'formal', fontSize: 8, color: '#9ca3af', align: 'center' }
    ]
  },
  { id: '__style_wedding_modern_5160', name: 'Modern Minimal', type: 'style', category: 'wedding', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: false, right: false, color: '#d4af37' },
    lineStyles: [
      { fontFamily: 'display', fontSize: 11, color: '#1f2937', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  { id: '__style_wedding_floral_5160', name: 'Floral Romance', type: 'style', category: 'wedding', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'rose' }, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'script', fontSize: 12, color: '#be185d', align: 'center' },
      { fontFamily: 'serif', fontSize: 10, italic: true, color: '#6b7280', align: 'center' },
      { fontFamily: 'serif', fontSize: 9, color: '#6b7280', align: 'center' },
      { fontFamily: 'serif', fontSize: 8, color: '#9ca3af', align: 'center' }
    ]
  },
  
  // ----- BIRTHDAY (5160) -----
  { id: '__style_birthday_fun_5160', name: 'Fun Celebration', type: 'style', category: 'birthday', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'balloon' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#ec4899' },
    lineStyles: [
      { fontFamily: 'fun', fontSize: 14, color: '#7c3aed', align: 'center' },
      { fontFamily: 'default', fontSize: 10, bold: true, color: '#ec4899', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#6b7280', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  { id: '__style_birthday_elegant_5160', name: 'Elegant Adult', type: 'style', category: 'birthday', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#1f2937' },
    lineStyles: [
      { fontFamily: 'elegant', fontSize: 12, bold: true, color: '#1f2937', align: 'center' },
      { fontFamily: 'serif', fontSize: 10, italic: true, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- BABY (5160) -----
  { id: '__style_baby_pink_5160', name: 'Soft Pink', type: 'style', category: 'baby', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'rattle' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#f9a8d4' },
    lineStyles: [
      { fontFamily: 'handwritten', fontSize: 14, color: '#be185d', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#ec4899', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#f472b6', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#9ca3af', align: 'center' }
    ]
  },
  { id: '__style_baby_blue_5160', name: 'Soft Blue', type: 'style', category: 'baby', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'rattle' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#93c5fd' },
    lineStyles: [
      { fontFamily: 'handwritten', fontSize: 14, color: '#1d4ed8', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#3b82f6', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#60a5fa', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#9ca3af', align: 'center' }
    ]
  },
  
  // ----- PROFESSIONAL (5160) -----
  { id: '__style_pro_corporate_5160', name: 'Corporate Blue', type: 'style', category: 'professional', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: true, left: false, right: false, color: '#1e40af' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 11, bold: true, color: '#1e3a8a', align: 'left' },
      { fontFamily: 'default', fontSize: 10, color: '#1f2937', align: 'left' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'left' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'left' }
    ]
  },
  { id: '__style_pro_minimal_5160', name: 'Modern Minimal', type: 'style', category: 'professional', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'display', fontSize: 11, color: '#1f2937', align: 'left' },
      { fontFamily: 'default', fontSize: 10, color: '#4b5563', align: 'left' },
      { fontFamily: 'default', fontSize: 9, color: '#6b7280', align: 'left' },
      { fontFamily: 'default', fontSize: 8, color: '#9ca3af', align: 'left' }
    ]
  },
  { id: '__style_pro_executive_5160', name: 'Executive', type: 'style', category: 'professional', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#1f2937' },
    lineStyles: [
      { fontFamily: 'serif', fontSize: 11, bold: true, color: '#1f2937', align: 'center' },
      { fontFamily: 'serif', fontSize: 10, color: '#374151', align: 'center' },
      { fontFamily: 'serif', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'serif', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- SCHOOL (5160) -----
  { id: '__style_school_fun_5160', name: 'Classroom Fun', type: 'style', category: 'school', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'apple' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#ef4444' },
    lineStyles: [
      { fontFamily: 'handwritten', fontSize: 14, color: '#1f2937', align: 'center' },
      { fontFamily: 'default', fontSize: 10, bold: true, color: '#ef4444', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  { id: '__style_school_neat_5160', name: 'Teacher Neat', type: 'style', category: 'school', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'pencil' }, right: null },
    border: { top: false, bottom: true, left: false, right: false, color: '#fbbf24' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 11, bold: true, color: '#1f2937', align: 'left' },
      { fontFamily: 'default', fontSize: 10, color: '#4b5563', align: 'left' },
      { fontFamily: 'default', fontSize: 9, color: '#6b7280', align: 'left' },
      { fontFamily: 'default', fontSize: 8, color: '#9ca3af', align: 'left' }
    ]
  },
  
  // ----- SEASONAL (5160) -----
  { id: '__style_spring_floral_5160', name: 'Spring Floral', type: 'style', category: 'seasonal', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'tulip' }, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'script', fontSize: 12, color: '#db2777', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#16a34a', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  { id: '__style_summer_bright_5160', name: 'Summer Bright', type: 'style', category: 'seasonal', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'sun' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#f59e0b' },
    lineStyles: [
      { fontFamily: 'fun', fontSize: 14, color: '#ea580c', align: 'center' },
      { fontFamily: 'default', fontSize: 10, bold: true, color: '#0891b2', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  { id: '__style_fall_harvest_5160', name: 'Fall Harvest', type: 'style', category: 'seasonal', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'leaf' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#b45309' },
    lineStyles: [
      { fontFamily: 'serif', fontSize: 12, bold: true, color: '#92400e', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#b45309', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#78350f', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- SIMPLE (5160) -----
  { id: '__style_simple_clean_5160', name: 'Clean Black', type: 'style', category: 'simple', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 11, bold: true, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 10, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 9, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 8, color: '#4b5563', align: 'left' }
    ]
  },
  { id: '__style_simple_gray_5160', name: 'Minimal Gray', type: 'style', category: 'simple', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 11, color: '#374151', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#6b7280', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#9ca3af', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#9ca3af', align: 'center' }
    ]
  },
  { id: '__style_simple_boxed_5160', name: 'Boxed', type: 'style', category: 'simple', labelType: '5160', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#374151' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 11, bold: true, color: '#1f2937', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 9, color: '#6b7280', align: 'center' },
      { fontFamily: 'default', fontSize: 8, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- 5163 (Shipping/Name Badges) -----
  { id: '__style_pro_shipping_5163', name: 'Shipping Professional', type: 'style', category: 'professional', labelType: '5163', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#1f2937' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 14, bold: true, color: '#1f2937', align: 'left' },
      { fontFamily: 'default', fontSize: 12, color: '#374151', align: 'left' },
      { fontFamily: 'default', fontSize: 11, color: '#4b5563', align: 'left' },
      { fontFamily: 'default', fontSize: 10, color: '#6b7280', align: 'left' }
    ]
  },
  { id: '__style_wedding_elegant_5163', name: 'Elegant Script', type: 'style', category: 'wedding', labelType: '5163', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'script', fontSize: 20, color: '#4a4a4a', align: 'center' },
      { fontFamily: 'formal', fontSize: 12, color: '#6b7280', align: 'center' },
      { fontFamily: 'formal', fontSize: 11, color: '#6b7280', align: 'center' },
      { fontFamily: 'formal', fontSize: 10, color: '#9ca3af', align: 'center' }
    ]
  },
  { id: '__style_birthday_fun_5163', name: 'Fun Celebration', type: 'style', category: 'birthday', labelType: '5163', builtin: true,
    alignV: 'center', graphics: { left: { type: 'builtin', id: 'balloon' }, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#ec4899' },
    lineStyles: [
      { fontFamily: 'fun', fontSize: 20, color: '#7c3aed', align: 'center' },
      { fontFamily: 'default', fontSize: 12, bold: true, color: '#ec4899', align: 'center' },
      { fontFamily: 'default', fontSize: 11, color: '#6b7280', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#6b7280', align: 'center' }
    ]
  },
  
  // ----- 5167 (Small Return Address) -----
  { id: '__style_simple_clean_5167', name: 'Clean Black', type: 'style', category: 'simple', labelType: '5167', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 8, bold: true, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 7, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 7, color: '#000000', align: 'left' },
      { fontFamily: 'default', fontSize: 6, color: '#4b5563', align: 'left' }
    ]
  },
  { id: '__style_holiday_festive_5167', name: 'Holiday Festive', type: 'style', category: 'holiday', labelType: '5167', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: true, bottom: true, left: true, right: true, color: '#c41e3a' },
    lineStyles: [
      { fontFamily: 'elegant', fontSize: 8, bold: true, color: '#c41e3a', align: 'center' },
      { fontFamily: 'default', fontSize: 7, color: '#2d5a27', align: 'center' },
      { fontFamily: 'default', fontSize: 7, color: '#2d5a27', align: 'center' },
      { fontFamily: 'default', fontSize: 6, color: '#666666', align: 'center' }
    ]
  },
  
  // ----- 5395 (Name Badges) -----
  { id: '__style_pro_badge_5395', name: 'Professional Badge', type: 'style', category: 'professional', labelType: '5395', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: true, left: false, right: false, color: '#1e40af' },
    lineStyles: [
      { fontFamily: 'default', fontSize: 24, bold: true, color: '#1f2937', align: 'center' },
      { fontFamily: 'default', fontSize: 14, color: '#4b5563', align: 'center' },
      { fontFamily: 'default', fontSize: 12, color: '#6b7280', align: 'center' },
      { fontFamily: 'default', fontSize: 10, color: '#9ca3af', align: 'center' }
    ]
  },
  { id: '__style_wedding_badge_5395', name: 'Wedding Guest', type: 'style', category: 'wedding', labelType: '5395', builtin: true,
    alignV: 'center', graphics: { left: null, right: null },
    border: { top: false, bottom: false, left: false, right: false, color: '#000000' },
    lineStyles: [
      { fontFamily: 'script', fontSize: 28, color: '#4a4a4a', align: 'center' },
      { fontFamily: 'formal', fontSize: 12, italic: true, color: '#6b7280', align: 'center' },
      { fontFamily: 'formal', fontSize: 10, color: '#9ca3af', align: 'center' },
      { fontFamily: 'formal', fontSize: 10, color: '#9ca3af', align: 'center' }
    ]
  }
];

// Built-in tokens for template editing (categorized)
const BUILTIN_TOKENS = {
  'Name': ['name', 'first_name', 'last_name', 'prefix', 'suffix'],
  'Address': ['street', 'street2', 'city', 'state', 'zip', 'country'],
  'School': ['student_name', 'room', 'teacher', 'grade', 'level', 'student_id'],
  'General': ['title', 'company', 'department', 'phone', 'email'],
  'Events': ['table_number', 'dish_name', 'description', 'event_name', 'date']
};

// Token alias map for auto-mapping columns during CSV import
const TOKEN_ALIASES = {
  'first_name': ['first name', 'first', 'fname', 'given name', 'given_name'],
  'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name'],
  'name': ['full name', 'fullname', 'full_name', 'student name', 'student_name', 'guest', 'guest name'],
  'student_name': ['student name', 'student', 'pupil', 'child name'],
  'street': ['street address', 'address', 'address1', 'address_1', 'street_address', 'addr'],
  'street2': ['address 2', 'address2', 'address_2', 'apt', 'suite', 'unit'],
  'city': ['town', 'municipality'],
  'state': ['province', 'region', 'st'],
  'zip': ['zip code', 'zipcode', 'postal', 'postal code', 'postal_code', 'postcode'],
  'country': ['nation'],
  'room': ['room number', 'classroom'],
  'teacher': ['teacher name', 'instructor'],
  'grade': ['year', 'class year'],
  'title': ['job title', 'position'],
  'company': ['organization', 'org', 'employer'],
  'phone': ['telephone', 'tel', 'mobile', 'cell'],
  'email': ['email address', 'e-mail'],
  'table_number': ['table', 'table no', 'table #', 'seating'],
  'dish_name': ['dish', 'food', 'item', 'menu item'],
  'description': ['desc', 'details', 'notes', 'info', 'ingredients', 'allergens']
};

// ========== EMOJI DATA ==========
const EMOJI_DATA = [
  { cat: 'Common', emojis: [
    { e: 'â­', n: 'star' }, { e: 'â¤ï¸', n: 'heart love' }, { e: 'âœ…', n: 'check done' }, { e: 'âŒ', n: 'x cross no' },
    { e: 'âš ï¸', n: 'warning caution' }, { e: 'ðŸ“Œ', n: 'pin pushpin' }, { e: 'ðŸ”´', n: 'red circle' }, { e: 'ðŸŸ¢', n: 'green circle' },
    { e: 'ðŸ”µ', n: 'blue circle' }, { e: 'ðŸŸ¡', n: 'yellow circle' }, { e: 'â¬›', n: 'black square' }, { e: 'â¬œ', n: 'white square' },
    { e: 'â–¶ï¸', n: 'play arrow right' }, { e: 'â—€ï¸', n: 'left arrow' }, { e: 'ðŸ”¹', n: 'diamond blue' }, { e: 'ðŸ”¸', n: 'diamond orange' },
  ]},
  { cat: 'School', emojis: [
    { e: 'ðŸ“š', n: 'books reading' }, { e: 'ðŸ“–', n: 'open book reading' }, { e: 'ðŸŽ’', n: 'backpack school bag' }, { e: 'âœ‚ï¸', n: 'scissors craft' },
    { e: 'ðŸ“', n: 'triangle ruler math' }, { e: 'ðŸ“', n: 'ruler measure' }, { e: 'ðŸ–ï¸', n: 'crayon color draw' }, { e: 'ðŸ–Œï¸', n: 'paintbrush art' },
    { e: 'ðŸŽ¨', n: 'art palette paint color' }, { e: 'ðŸ”¬', n: 'microscope science' }, { e: 'ðŸ§ª', n: 'test tube science lab' }, { e: 'ðŸ§®', n: 'abacus math count' },
    { e: 'ðŸŽµ', n: 'music note' }, { e: 'ðŸŽ¶', n: 'music notes' }, { e: 'ðŸ…', n: 'medal award' }, { e: 'ðŸ†', n: 'trophy winner award' },
    { e: 'ðŸ““', n: 'notebook journal' }, { e: 'ðŸ–Šï¸', n: 'pen write' }, { e: 'âœï¸', n: 'pencil write' }, { e: 'ðŸ“', n: 'memo note write' },
    { e: 'ðŸ§©', n: 'puzzle piece' }, { e: 'ðŸŽ²', n: 'dice game' }, { e: 'ðŸ§¸', n: 'teddy bear toy' }, { e: 'ðŸª', n: 'kite play' },
    { e: 'ðŸŽ', n: 'apple teacher' }, { e: 'ðŸ›', n: 'caterpillar bug insect' }, { e: 'ðŸ¸', n: 'frog animal' }, { e: 'ðŸ¢', n: 'turtle animal slow' },
    { e: 'ðŸ¦•', n: 'dinosaur dino' }, { e: 'ðŸ', n: 'bee honeybee insect' }, { e: 'ðŸž', n: 'ladybug insect' }, { e: 'ðŸ¦', n: 'lion animal' },
  ]},
  { cat: 'People', emojis: [
    { e: 'ðŸ˜€', n: 'smile happy' }, { e: 'ðŸ˜Š', n: 'blush smile' }, { e: 'ðŸ‘‹', n: 'wave hello' }, { e: 'ðŸ‘', n: 'thumbs up' },
    { e: 'ðŸ‘Ž', n: 'thumbs down' }, { e: 'ðŸ‘', n: 'clap hands' }, { e: 'ðŸ™', n: 'pray thanks' }, { e: 'ðŸ’ª', n: 'strong muscle' },
    { e: 'ðŸŽ‰', n: 'party celebrate' }, { e: 'ðŸŽ‚', n: 'birthday cake' }, { e: 'ðŸ‘¤', n: 'person silhouette' }, { e: 'ðŸ‘¥', n: 'people group' },
  ]},
  { cat: 'Office', emojis: [
    { e: 'ðŸ“', n: 'folder file' }, { e: 'ðŸ“‚', n: 'open folder' }, { e: 'ðŸ“‹', n: 'clipboard' }, { e: 'ðŸ“Ž', n: 'paperclip' },
    { e: 'âœï¸', n: 'pencil edit' }, { e: 'ðŸ–Šï¸', n: 'pen' }, { e: 'ðŸ“', n: 'memo note' }, { e: 'ðŸ“Š', n: 'chart graph' },
    { e: 'ðŸ“…', n: 'calendar date' }, { e: 'ðŸ—“ï¸', n: 'calendar spiral' }, { e: 'ðŸ“‡', n: 'card index' }, { e: 'ðŸ·ï¸', n: 'label tag' },
    { e: 'ðŸ“¦', n: 'box package' }, { e: 'ðŸ—‚ï¸', n: 'dividers tabs' }, { e: 'ðŸ”‘', n: 'key' }, { e: 'ðŸ”’', n: 'lock' },
  ]},
  { cat: 'Places', emojis: [
    { e: 'ðŸ ', n: 'home house' }, { e: 'ðŸ¢', n: 'office building' }, { e: 'ðŸ«', n: 'school' }, { e: 'ðŸ¥', n: 'hospital' },
    { e: 'â›ª', n: 'church' }, { e: 'ðŸ›ï¸', n: 'classical building' }, { e: 'ðŸ“', n: 'location pin' }, { e: 'ðŸš—', n: 'car' },
    { e: 'âœˆï¸', n: 'airplane travel' }, { e: 'ðŸŒŽ', n: 'earth globe' }, { e: 'ðŸª', n: 'store shop' }, { e: 'ðŸ…¿ï¸', n: 'parking' },
  ]},
  { cat: 'Nature', emojis: [
    { e: 'ðŸŒŸ', n: 'glowing star' }, { e: 'â˜€ï¸', n: 'sun' }, { e: 'ðŸŒ™', n: 'moon' }, { e: 'ðŸŒˆ', n: 'rainbow' },
    { e: 'ðŸ”¥', n: 'fire hot' }, { e: 'ðŸ’§', n: 'water drop' }, { e: 'â„ï¸', n: 'snowflake cold' }, { e: 'ðŸŒº', n: 'flower' },
    { e: 'ðŸŒ²', n: 'tree pine' }, { e: 'ðŸ€', n: 'clover luck' }, { e: 'ðŸ¾', n: 'paw prints animal' }, { e: 'ðŸ¦‹', n: 'butterfly' },
  ]},
  { cat: 'Arrows & Numbers', emojis: [
    { e: 'âž¡ï¸', n: 'right arrow' }, { e: 'â¬…ï¸', n: 'left arrow' }, { e: 'â¬†ï¸', n: 'up arrow' }, { e: 'â¬‡ï¸', n: 'down arrow' },
    { e: 'â†©ï¸', n: 'return back' }, { e: 'ðŸ”„', n: 'refresh cycle' }, { e: 'â‘ ', n: 'one 1' }, { e: 'â‘¡', n: 'two 2' },
    { e: 'â‘¢', n: 'three 3' }, { e: 'â‘£', n: 'four 4' }, { e: 'â‘¤', n: 'five 5' }, { e: 'â’¶', n: 'letter a' },
    { e: 'â’·', n: 'letter b' }, { e: 'â’¸', n: 'letter c' }, { e: 'â„¢', n: 'trademark' }, { e: 'Â©', n: 'copyright' },
  ]},
];

// ========== OCR STATE ==========
let ocrImageBlob = null;
let ocrResults = [];
let ocrRotation = 0;

// ========== HISTORY FILTER STATE ==========
let historySearchQuery = '';
let historyTypeFilter = 'all';
let historySelectedIds = new Set();

const DEFAULT_LOW_THRESHOLD = 5;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function escapeHtml(t) {
  const d = document.createElement('div');
  d.textContent = t;
  return d.innerHTML;
}

function escapeAttr(t) {
  return t.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' ');
}

function generateId(prefix) {
  // If satellite mode, add sat_ prefix so we can track what was created here
  if (settings.deviceRole === 'satellite') {
    const storeId = getOrCreateStoreId();
    return 'sat_' + (prefix || 'id') + '_' + storeId + '_' + Date.now();
  }
  return (prefix || 'id') + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
}

// Get or create a unique store ID for this device/browser
function getOrCreateStoreId() {
  if (settings.storeId) return settings.storeId;
  
  // Generate: platform-browser-random
  const ua = navigator.userAgent;
  const platform = /iPhone|iPad/.test(ua) ? 'ios' : 
                   /Mac/.test(ua) ? 'mac' : 
                   /Win/.test(ua) ? 'win' : 
                   /Android/.test(ua) ? 'android' : 'other';
  const browser = /Chrome/.test(ua) && !/Edg/.test(ua) ? 'chrome' :
                  /Safari/.test(ua) && !/Chrome/.test(ua) ? 'safari' :
                  /Firefox/.test(ua) ? 'firefox' : 
                  /Edg/.test(ua) ? 'edge' : 'other';
  const random = Math.random().toString(36).substring(2, 8);
  
  settings.storeId = `${platform}-${browser}-${random}`;
  saveSettings();
  return settings.storeId;
}

// Check if an ID was created on this satellite device
function isLocalSatelliteItem(id) {
  if (settings.deviceRole !== 'satellite') return false;
  const storeId = getOrCreateStoreId();
  return id && id.startsWith('sat_') && id.includes('_' + storeId + '_');
}

// Get satellite pending queue
function getSatellitePending() {
  try {
    return JSON.parse(localStorage.getItem(SATELLITE_PENDING_KEY) || '[]');
  } catch (e) {
    return [];
  }
}

// Save satellite pending queue
function saveSatellitePending(pending) {
  try {
    localStorage.setItem(SATELLITE_PENDING_KEY, JSON.stringify(pending));
  } catch (e) {}
}

// Add item to satellite pending queue
function addToSatellitePending(id) {
  if (settings.deviceRole !== 'satellite') return;
  const pending = getSatellitePending();
  if (!pending.includes(id)) {
    pending.push(id);
    saveSatellitePending(pending);
  }
}

// Remove item from satellite pending queue
function removeFromSatellitePending(id) {
  const pending = getSatellitePending();
  const filtered = pending.filter(p => p !== id);
  saveSatellitePending(filtered);
}

// ========== LABEL TYPE HELPERS ==========
function getSpec(typeId) {
  return LABEL_TYPES[typeId || '5160'];
}

function getLabelsPerSheet(typeId) {
  const spec = getSpec(typeId);
  return spec.cols * spec.rows;
}

// ========== SHEET HELPERS ==========
function getSheet(id) {
  return sheets[id] || null;
}

function getActiveSheet() {
  return sheets[activeSheetId] || null;
}

function getPoolSize(sh) {
  const spec = getSpec(sh.labelType);
  return spec.cols * spec.rows * (sh.sheetCount || 1);
}

function getPrintedCount(sh) {
  return (sh.printed || []).length;
}

function getRemainingCount(sh) {
  return getPoolSize(sh) - getPrintedCount(sh);
}

function getAssignedCount(sh) {
  if (!sh.texts) return 0;
  return Object.values(sh.texts).reduce((sum, t) => sum + (t.qty || 0), 0);
}

function getAvailableSpots(sh) {
  return Math.max(0, getRemainingCount(sh) - getAssignedCount(sh));
}

// Get physical sheet info for a position index
function getPhysicalSheet(index, sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const physicalSheet = Math.floor(index / lps);
  const localIndex = index % lps;
  const localRow = Math.floor(localIndex / spec.cols);
  const localCol = localIndex % spec.cols;
  return { physicalSheet, localIndex, row: localRow, col: localCol };
}

// Build position assignments for a sheet
function buildAssignments(sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const total = lps * (sh.sheetCount || 1);
  const printed = new Set(sh.printed || []);
  const assignments = {};
  const errors = [];
  const used = new Set();

  if (!sh.texts) return { assignments, errors };

  const textIds = Object.keys(sh.texts);

  // First pass: place column-specific texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0 || placement === 'next') continue;

    const colNum = parseInt(placement.split(':')[1]) - 1;
    if (colNum < 0 || colNum >= spec.cols) {
      assignments[textId] = [];
      errors.push({ textId, message: 'Column ' + (colNum+1) + ' does not exist' });
      continue;
    }
    const indices = [];
    for (let p = 0; p < (sh.sheetCount || 1) && indices.length < qty; p++) {
      for (let r = 0; r < spec.rows && indices.length < qty; r++) {
        const idx = p * lps + r * spec.cols + colNum;
        if (!printed.has(idx) && !used.has(idx)) {
          indices.push(idx);
          used.add(idx);
        }
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' in Column ' + (colNum+1) + ' but only ' + indices.length + ' available' });
    }
  }

  // Second pass: place "next available" texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0) { assignments[textId] = assignments[textId] || []; continue; }
    if (placement !== 'next') continue;

    const indices = [];
    for (let i = 0; i < total && indices.length < qty; i++) {
      if (!printed.has(i) && !used.has(i)) {
        indices.push(i);
        used.add(i);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' spots but only ' + indices.length + ' available' });
    }
  }

  // Ensure all textIds have an entry
  for (const textId of textIds) {
    if (!assignments[textId]) assignments[textId] = [];
  }

  return { assignments, errors };
}

// ========== SAVED TEXT HELPERS ==========
function getSavedText(id) {
  // Check user texts first
  const found = savedTexts.find(t => t.id === id);
  if (found) return found;
  // Check built-in templates
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getBuiltinTemplate(id) {
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getTexts() {
  // Return saved texts that are not templates or style templates
  return savedTexts.filter(t => t.type !== 'template' && t.type !== 'style');
}

function getTemplates() {
  // Return only import templates (type: 'template'), not style templates
  const builtinImport = BUILTIN_TEMPLATES.filter(t => t.type === 'template');
  return [...builtinImport, ...savedTexts.filter(t => t.type === 'template')];
}

// ========== LINE SERIALIZATION ==========
function serializeLines(lines) {
  return lines.map(l => {
    // Format: align,fontSize,fontFamily,flags,color,fillColor,borders:text
    // fontFamily defaults to 'default' if not specified
    const fontFamily = l.fontFamily || 'default';
    let meta = l.align + ',' + (l.fontSize || 11) + ',' + fontFamily;
    const flags = (l.bold ? 'b' : '') + (l.italic ? 'i' : '') + (l.underline ? 'u' : '') + (l.strikethrough ? 's' : '');
    const color = l.color || '';
    const fill = l.fillColor || '';
    const borders = l.borders || '';
    if (flags || color || fill || borders) {
      meta += ',' + flags + ',' + color + ',' + fill + ',' + borders;
    }
    return meta + ':' + l.text;
  }).join('\n');
}

function deserializeLines(str) {
  if (!str) return [];
  return str.split('\n').filter(s => s.trim()).map(s => {
    // New format: align,fontSize,fontFamily,flags,color,fillColor,borders:text
    const colonIdx = s.indexOf(':');
    if (colonIdx === -1) {
      return { text: s, align: 'left', fontSize: 11, fontFamily: 'default' };
    }
    
    const meta = s.substring(0, colonIdx);
    const text = s.substring(colonIdx + 1);
    const parts = meta.split(',');
    
    // Parse alignment
    const align = ['left', 'center', 'right'].includes(parts[0]) ? parts[0] : 'left';
    
    // Parse font size
    const fontSize = parseInt(parts[1]) || 11;
    
    // Check if this is new format (fontFamily is 3rd field) or legacy format
    const line = { text, align, fontSize, fontFamily: 'default' };
    
    if (parts.length >= 3) {
      // Check if 3rd field is a fontFamily ID or legacy flags
      const third = parts[2];
      const isLegacyFlags = /^[bius]*$/.test(third) && !FE_FONTS.find(f => f.id === third);
      
      if (isLegacyFlags) {
        // Legacy extended format: align,fontSize,flags,color,fillColor,borders
        const flags = third;
        if (flags.includes('b')) line.bold = true;
        if (flags.includes('i')) line.italic = true;
        if (flags.includes('u')) line.underline = true;
        if (flags.includes('s')) line.strikethrough = true;
        if (parts[3]) line.color = parts[3];
        if (parts[4]) line.fillColor = parts[4];
        if (parts[5]) line.borders = parts[5];
      } else {
        // New format: align,fontSize,fontFamily,flags,color,fillColor,borders
        line.fontFamily = third || 'default';
        if (parts.length >= 4) {
          const flags = parts[3] || '';
          if (flags.includes('b')) line.bold = true;
          if (flags.includes('i')) line.italic = true;
          if (flags.includes('u')) line.underline = true;
          if (flags.includes('s')) line.strikethrough = true;
        }
        if (parts[4]) line.color = parts[4];
        if (parts[5]) line.fillColor = parts[5];
        if (parts[6]) line.borders = parts[6];
      }
    }
    
    return line;
  });
}

function getFlatText(lines) {
  return lines.map(l => l.text).join(' / ');
}

// Generate a clean, descriptive name for content created via wizard
function generateContentName(lines, labelType) {
  // Try to extract meaningful text from the first non-empty line
  let firstLine = '';
  for (const line of lines) {
    const text = (line.text || '').trim();
    if (text) {
      // Clean up fill-in blanks and split syntax
      let clean = text
        .replace(/__+/g, '___')  // Normalize underscores
        .replace(/\|\|/g, ' / ') // Replace split marker
        .trim();
      if (clean && clean !== '___') {
        firstLine = clean;
        break;
      }
    }
  }
  
  // If we found meaningful text, use first 20 chars
  if (firstLine && firstLine.length > 3) {
    const preview = firstLine.substring(0, 20);
    return preview + (firstLine.length > 20 ? '...' : '');
  }
  
  // Fallback: generate a date-based name
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
  const typeLabel = labelType ? LABEL_TYPES[labelType]?.name || labelType : 'Label';
  
  return typeLabel + ' - ' + dateStr + ' ' + timeStr;
}

// Parse line for split (||) and fill (__) syntax
function parseLine(text) {
  if (text.includes('||')) {
    const parts = text.split('||').map(s => s.trim());
    const left = parts[0];
    const right = parts.slice(1).join(' ').trim();
    
    // Check if either side has fill-line syntax
    const leftHasFill = left.includes('__');
    const rightHasFill = right.includes('__');
    
    if (leftHasFill || rightHasFill) {
      // Parse each side for fill-line
      let leftParsed = { type: 'normal', text: left };
      let rightParsed = { type: 'normal', text: right };
      
      if (leftHasFill) {
        const idx = left.indexOf('__');
        leftParsed = { type: 'fill', label: left.substring(0, idx), trailing: left.substring(idx + 2).trim() };
      }
      if (rightHasFill) {
        const idx = right.indexOf('__');
        rightParsed = { type: 'fill', label: right.substring(0, idx), trailing: right.substring(idx + 2).trim() };
      }
      
      return { type: 'split-fill', left: leftParsed, right: rightParsed };
    }
    
    return { type: 'split', left, right };
  }
  if (text.includes('__')) {
    const idx = text.indexOf('__');
    return { type: 'fill', label: text.substring(0, idx), trailing: text.substring(idx + 2).trim() };
  }
  return { type: 'normal', text };
}

/**
 * UNIFIED LABEL PREVIEW RENDERER
 * Creates a complete label preview matching Full Editor quality.
 * Use this EVERYWHERE you need to preview a label.
 * 
 * @param {Object} config - Label configuration
 * @param {Array} config.lines - Array of line objects [{text, align, fontSize, bold, italic, color, fillColor, fontFamily, underline, strikethrough}]
 * @param {Object} config.graphics - {left: {data, size}, right: {data, size}} or null
 * @param {Object} config.border - {top, bottom, left, right, color} or null
 * @param {Object} config.barcode - {enabled, type, position, data} or null
 * @param {string} config.alignV - 'top' | 'center' | 'bottom' | 'spread'
 * @param {string} config.labelType - Label type for sizing (e.g., '5160')
 * @param {Object} options - Rendering options
 * @param {boolean} options.showPlaceholder - Show placeholder text if empty
 * @param {boolean} options.compact - Use compact sizing for cards/lists
 * @param {number} options.maxWidth - Maximum width in pixels
 * @returns {string} Complete HTML for the label preview
 */
function renderUnifiedLabelPreview(config, options = {}) {
  const lines = config.lines || [];
  const graphics = config.graphics || {};
  const border = config.border || {};
  const barcode = config.barcode || {};
  const alignV = config.alignV || 'center';
  const labelType = config.labelType || settings.lastLabelType || '5160';
  
  const showPlaceholder = options.showPlaceholder || false;
  const compact = options.compact || false;
  const maxWidth = options.maxWidth || (compact ? 200 : 300);
  
  // Filter to non-empty lines
  const nonEmptyLines = lines.filter(l => l && l.text && l.text.trim());
  
  // Check for content
  const hasQR = barcode.enabled && barcode.type === 'qr';
  const qrPosition = hasQR ? barcode.position : null;
  const qrOnly = qrPosition === 'only';
  const hasLeftGfx = graphics.left && graphics.left.data;
  const hasRightGfx = graphics.right && graphics.right.data;
  const hasContent = nonEmptyLines.length > 0 || hasLeftGfx || hasRightGfx || hasQR;
  
  // Empty state
  if (!hasContent) {
    if (showPlaceholder) {
      return '<div class="wf1-preview-label-box" style="padding:12px;color:#999;font-size:11px;">Your text will appear here</div>';
    }
    return '';
  }
  
  // Calculate dimensions
  const spec = LABEL_TYPES[labelType];
  const aspectRatio = spec ? (spec.labelW / spec.labelH) : 2.5;
  const width = Math.min(maxWidth, spec ? spec.labelW * 72 : 200);
  const height = width / aspectRatio;
  
  // Build container styles
  let containerStyle = 'width:' + width + 'px;min-height:' + height + 'px;';
  containerStyle += 'display:flex;flex-direction:column;padding:8px;box-sizing:border-box;';
  containerStyle += 'background:#fff;color:#000;font-family:Arial,sans-serif;';
  
  // Vertical alignment
  if (alignV === 'top') {
    containerStyle += 'justify-content:flex-start;';
  } else if (alignV === 'bottom') {
    containerStyle += 'justify-content:flex-end;';
  } else if (alignV === 'spread') {
    containerStyle += 'justify-content:space-between;';
  } else {
    containerStyle += 'justify-content:center;';
  }
  
  // Border styles
  const borderColor = border.color || '#000';
  const defaultBorder = '2px solid #ddd';
  containerStyle += 'border-top:' + (border.top ? '2px solid ' + borderColor : defaultBorder) + ';';
  containerStyle += 'border-bottom:' + (border.bottom ? '2px solid ' + borderColor : defaultBorder) + ';';
  containerStyle += 'border-left:' + (border.left ? '2px solid ' + borderColor : defaultBorder) + ';';
  containerStyle += 'border-right:' + (border.right ? '2px solid ' + borderColor : defaultBorder) + ';';
  containerStyle += 'border-radius:4px;';
  
  // Start HTML
  let html = '<div class="wf1-preview-label-box" style="' + containerStyle + '">';
  
  // QR Only mode
  if (qrOnly && barcode.data) {
    const qrDataURL = generateQRDataURL(barcode.data, Math.min(height - 16, 80));
    if (qrDataURL) {
      html += '<div style="display:flex;justify-content:center;align-items:center;width:100%;height:100%;">';
      html += '<img src="' + qrDataURL + '" style="max-width:80px;max-height:80px;">';
      html += '</div>';
    }
    html += '</div>';
    return html;
  }
  
  // Check for side content
  const hasLeftContent = hasLeftGfx || qrPosition === 'left';
  const hasRightContent = hasRightGfx || qrPosition === 'right';
  const hasSideContent = hasLeftContent || hasRightContent;
  
  if (hasSideContent) {
    html += '<div style="display:flex;align-items:center;width:100%;height:100%;gap:6px;">';
    
    // Left side
    if (qrPosition === 'left' && barcode.data) {
      const qrDataURL = generateQRDataURL(barcode.data, 48);
      if (qrDataURL) {
        html += '<div style="flex-shrink:0;"><img src="' + qrDataURL + '" style="width:40px;height:40px;"></div>';
      }
    } else if (hasLeftGfx) {
      const gfx = graphics.left;
      const size = gfx.size === 'S' ? 24 : gfx.size === 'L' ? 48 : 36;
      html += '<div style="flex-shrink:0;"><img src="' + gfx.data + '" style="width:' + size + 'px;height:' + size + 'px;object-fit:contain;"></div>';
    }
    
    html += '<div style="flex:1;min-width:0;">';
  }
  
  // Render lines
  for (const line of nonEmptyLines) {
    html += renderPreviewLineHtml(line);
  }
  
  if (hasSideContent) {
    html += '</div>';
    
    // Right side
    if (qrPosition === 'right' && barcode.data) {
      const qrDataURL = generateQRDataURL(barcode.data, 48);
      if (qrDataURL) {
        html += '<div style="flex-shrink:0;"><img src="' + qrDataURL + '" style="width:40px;height:40px;"></div>';
      }
    } else if (hasRightGfx) {
      const gfx = graphics.right;
      const size = gfx.size === 'S' ? 24 : gfx.size === 'L' ? 48 : 36;
      html += '<div style="flex-shrink:0;"><img src="' + gfx.data + '" style="width:' + size + 'px;height:' + size + 'px;object-fit:contain;"></div>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  return html;
}

/**
 * Generate QR code data URL for preview (wrapper for qrcode.js)
 * Returns null if QR generation not available or fails
 */
function generateQRDataURL(data, size) {
  if (!data || typeof QRCode === 'undefined') return null;
  try {
    const canvas = document.createElement('canvas');
    QRCode.toCanvas(canvas, data, { width: size || 64, margin: 1 }, function() {});
    return canvas.toDataURL();
  } catch (e) {
    return null;
  }
}

/**
 * CANONICAL PREVIEW LINE RENDERER
 * Renders a single line with all special formats.
 * Handles: split (||), fill (__), rich formatting, alignment, font family
 * 
 * @param {Object} line - Line object with text, align, fontSize, bold, italic, etc.
 * @param {Object} options - Optional: { darkMode: false }
 * @returns {string} HTML string for the preview line
 */
function renderPreviewLineHtml(line, options = {}) {
  if (!line || (!line.text && line.text !== '')) {
    return '';
  }
  
  const text = line.text || '';
  if (!text.trim()) return '';
  
  const align = line.align || 'left';
  const fontSize = line.fontSize || 11;
  
  // Build style string using buildLineStyleStr if available, otherwise inline
  let style = '';
  if (typeof buildLineStyleStr === 'function') {
    style = buildLineStyleStr(line);
  } else {
    style = 'font-size:' + fontSize + 'px;';
    if (line.fontFamily && line.fontFamily !== 'default') {
      const fontDef = typeof FE_FONTS !== 'undefined' ? FE_FONTS.find(f => f.id === line.fontFamily) : null;
      if (fontDef) style += 'font-family:' + fontDef.family + ';';
    }
    if (line.bold) style += 'font-weight:bold;';
    if (line.italic) style += 'font-style:italic;';
    if (line.underline && line.strikethrough) style += 'text-decoration:underline line-through;';
    else if (line.underline) style += 'text-decoration:underline;';
    else if (line.strikethrough) style += 'text-decoration:line-through;';
    if (line.color) style += 'color:' + line.color + ';';
    if (line.fillColor) style += 'background-color:' + line.fillColor + ';padding:1px 3px;';
  }
  
  // Parse for special formats
  const parsed = parseLine(text);
  
  if (parsed.type === 'split-fill') {
    // Complex: split with fill lines
    let leftHtml, rightHtml;
    if (parsed.left.type === 'fill') {
      leftHtml = '<span>' + escapeHtml(parsed.left.label) + '</span><span style="flex:1;border-bottom:1px solid currentColor;margin:0 2px 2px;min-width:20px;"></span>' + (parsed.left.trailing ? '<span>' + escapeHtml(parsed.left.trailing) + '</span>' : '');
    } else {
      leftHtml = '<span>' + escapeHtml(parsed.left.text) + '</span>';
    }
    if (parsed.right.type === 'fill') {
      rightHtml = '<span>' + escapeHtml(parsed.right.label) + '</span><span style="flex:1;border-bottom:1px solid currentColor;margin:0 2px 2px;min-width:20px;"></span>' + (parsed.right.trailing ? '<span>' + escapeHtml(parsed.right.trailing) + '</span>' : '');
    } else {
      rightHtml = '<span>' + escapeHtml(parsed.right.text) + '</span>';
    }
    return '<div class="preview-line" style="display:flex;justify-content:space-between;align-items:flex-end;gap:12px;' + style + '">' +
      '<div style="display:flex;align-items:flex-end;gap:3px;flex:1;">' + leftHtml + '</div>' +
      '<div style="display:flex;align-items:flex-end;gap:3px;flex:1;justify-content:flex-end;">' + rightHtml + '</div>' +
    '</div>';
  }
  
  if (parsed.type === 'split') {
    return '<div class="preview-line" style="display:flex;justify-content:space-between;' + style + '">' +
      '<span>' + escapeHtml(parsed.left) + '</span>' +
      '<span>' + escapeHtml(parsed.right) + '</span>' +
    '</div>';
  }
  
  if (parsed.type === 'fill') {
    return '<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;' + style + '">' +
      '<span>' + escapeHtml(parsed.label) + '</span>' +
      '<span style="flex:1;border-bottom:1px solid currentColor;margin-bottom:2px;min-width:30px;"></span>' +
      (parsed.trailing ? '<span>' + escapeHtml(parsed.trailing) + '</span>' : '') +
    '</div>';
  }
  
  // Normal text
  return '<div class="preview-line" style="text-align:' + align + ';' + style + '">' + escapeHtml(text) + '</div>';
}

/**
 * Render multiple lines as a simple label preview (for cases that don't need full label chrome)
 * @param {Array} lines - Array of line objects
 * @param {Object} options - Optional settings
 * @returns {string} HTML string for the lines
 */
function renderLabelPreviewHtml(lines, options = {}) {
  if (!lines || lines.length === 0) {
    if (options.showPlaceholder) {
      return '<div class="preview-line" style="font-size:11px; color:#999;">Your text will appear here</div>';
    }
    return '';
  }
  
  let html = '';
  for (const line of lines) {
    if (line && (line.text || line.text === '')) {
      html += renderPreviewLineHtml(line, options);
    }
  }
  return html || (options.showPlaceholder ? '<div class="preview-line" style="font-size:11px; color:#999;">Your text will appear here</div>' : '');
}

// ========== TOKEN SYSTEM ==========
function extractTokens(text) {
  const re = /\{([a-z][a-z0-9_]*)\}/gi;
  const tokens = [];
  let m;
  while ((m = re.exec(text)) !== null) {
    const token = m[1].toLowerCase();
    if (!tokens.includes(token)) tokens.push(token);
  }
  return tokens;
}

function replaceTokens(text, record) {
  return text.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, token) => {
    const key = token.toLowerCase();
    return record[key] !== undefined ? record[key] : match;
  });
}

// ========== AI INTEGRATION (v2.0 - Session 9) ==========

/**
 * Parse #LABELKEEPER format from clipboard/text
 * Format:
 *   #LABELKEEPER
 *   type: 5160
 *   qty: 3
 *   ---
 *   Line 1 content
 *   Line 2 content
 *   Line 3 content
 *   Line 4 content
 * 
 * Returns: { valid: true, type, qty, lines[] } or { valid: false }
 */
function parseLabelKeeperFormat(text) {
  if (!text || typeof text !== 'string') {
    return { valid: false };
  }
  
  const trimmed = text.trim();
  
  // Must start with #LABELKEEPER (case insensitive)
  if (!trimmed.toUpperCase().startsWith('#LABELKEEPER')) {
    return { valid: false };
  }
  
  // Split into header and content
  const separatorIndex = trimmed.indexOf('---');
  if (separatorIndex === -1) {
    return { valid: false };
  }
  
  const headerSection = trimmed.substring(0, separatorIndex);
  const contentSection = trimmed.substring(separatorIndex + 3).trim();
  
  // Parse header fields
  const headerLines = headerSection.split('\n').map(l => l.trim()).filter(l => l && l !== '#LABELKEEPER');
  
  let type = null;
  let qty = 1;
  
  for (const line of headerLines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) continue;
    
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    
    if (key === 'type') {
      // Accept formats: "5160", "avery5160", "avery 5160"
      const typeMatch = value.match(/\d{4}/);
      if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
        type = typeMatch[0];
      }
    } else if (key === 'qty' || key === 'quantity' || key === 'count') {
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
        qty = parsed;
      }
    }
  }
  
  // Parse content lines (up to 4)
  const contentLines = contentSection.split('\n').map(l => l.trim());
  const lines = contentLines.slice(0, 4);
  
  // Pad to 4 lines if needed
  while (lines.length < 4) {
    lines.push('');
  }
  
  // Must have at least one non-empty line
  if (lines.every(l => !l)) {
    return { valid: false };
  }
  
  return {
    valid: true,
    type: type,  // null means use default/last-used
    qty: qty,
    lines: lines
  };
}

/**
 * Parse URL query parameters for deep linking
 * Supported params:
 *   ?text=Line1|Line2|Line3|Line4  (pipe-separated)
 *   ?type=5160
 *   ?qty=3
 *   ?action=print  (goes directly to print wizard)
 * 
 * Returns: { hasParams: true, text, type, qty, action } or { hasParams: false }
 */
function parseUrlParams() {
  const params = new URLSearchParams(window.location.search);
  
  // Check for sheet deep link (QR code scan)
  if (params.has('sheet')) {
    return { 
      hasParams: true,
      action: 'openSheet',
      sheetId: params.get('sheet')
    };
  }
  
  if (!params.has('text') && !params.has('action')) {
    return { hasParams: false };
  }
  
  const result = {
    hasParams: true,
    text: null,
    lines: ['', '', '', ''],
    type: null,
    qty: 1,
    action: params.get('action') || 'print'
  };
  
  // Parse text (pipe-separated lines)
  if (params.has('text')) {
    const textParam = params.get('text');
    const lines = textParam.split('|').map(l => l.trim());
    result.lines = lines.slice(0, 4);
    while (result.lines.length < 4) {
      result.lines.push('');
    }
    result.text = textParam;
  }
  
  // Parse type
  if (params.has('type')) {
    const typeMatch = params.get('type').match(/\d{4}/);
    if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
      result.type = typeMatch[0];
    }
  }
  
  // Parse quantity
  if (params.has('qty')) {
    const parsed = parseInt(params.get('qty'), 10);
    if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
      result.qty = parsed;
    }
  }
  
  return result;
}

/**
 * Generate shareable prompt for AI assistants
 */
function getAIPromptTemplate() {
  return `When generating labels for LabelKeeper, format your output like this:

#LABELKEEPER
type: 5160
qty: 1
---
Line 1 (name or main text)
Line 2 (address line 1 or subtitle)
Line 3 (address line 2 or additional info)
Line 4 (city, state zip or footer)

Supported label types:
- 5160: Address labels (1" x 2.625", 30/sheet)
- 5163: Shipping labels (2" x 4", 10/sheet)
- 5167: Return address (0.5" x 1.75", 80/sheet)
- 5161: Address (1" x 4", 20/sheet)
- 5162: Address (1.33" x 4", 14/sheet)
- 5164: Shipping (3.33" x 4", 6/sheet)
- 8463: Shipping (2" x 4", 10/sheet)
- 18163: Shipping (2" x 4", 10/sheet)
- 5267: Return address (0.5" x 1.75", 80/sheet)

The user can paste this format directly into LabelKeeper for instant preview and printing.`;
}

// ============================================================================
// DATA PERSISTENCE
// ============================================================================

// ========== SETTINGS ==========
function loadSettings() {
  try {
    const saved = localStorage.getItem(SETTINGS_KEY);
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
    } else {
      // No saved settings - check system preference for dark mode
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        settings.darkMode = true;
      }
    }
    // Check legacy theme key
    const legacyTheme = localStorage.getItem(THEME_KEY);
    if (legacyTheme === 'dark') {
      settings.darkMode = true;
    }
  } catch(e) {}
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    localStorage.setItem(THEME_KEY, settings.darkMode ? 'dark' : 'light');
  } catch(e) {}
}

// ========== SHEETS ==========
function loadSheets() {
  try {
    const s = localStorage.getItem(SHEETS_KEY);
    if (s) sheets = JSON.parse(s);
    activeSheetId = localStorage.getItem(ACTIVE_KEY);
  } catch(e) {}
  
  // Try legacy migration
  if (!Object.keys(sheets).length) {
    try {
      const old = localStorage.getItem('avery5160_sheets');
      if (old) {
        const oldSheets = JSON.parse(old);
        for (const [id, sh] of Object.entries(oldSheets)) {
          sheets[id] = { ...sh, id, labelType: '5160' };
        }
        activeSheetId = localStorage.getItem('avery5160_active');
      }
    } catch(e) {}
  }
  
  // Ensure data consistency
  for (const [id, sh] of Object.entries(sheets)) {
    if (!sh.id) sh.id = id;  // Ensure id property exists
    if (!sh.labelType) sh.labelType = '5160';
    if (!sh.texts) sh.texts = {};
    if (!sh.sheetCount) sh.sheetCount = 1;
    if (!sh.printed) sh.printed = [];
    for (const entry of Object.values(sh.texts)) {
      if (!entry.placement) entry.placement = 'next';
    }
  }
  
  // Set active sheet if none
  if (!activeSheetId || !sheets[activeSheetId]) {
    if (Object.keys(sheets).length) {
      activeSheetId = Object.keys(sheets)[0];
    }
  }
}

function saveSheets() {
  try {
    localStorage.setItem(SHEETS_KEY, JSON.stringify(sheets));
    localStorage.setItem(ACTIVE_KEY, activeSheetId || '');
  } catch(e) {}
}

// ========== SAVED TEXTS ==========
function loadSavedTexts() {
  try {
    const s = localStorage.getItem(TEXTS_KEY);
    if (s) savedTexts = JSON.parse(s);
  } catch(e) {}
}

function saveSavedTexts() {
  try {
    localStorage.setItem(TEXTS_KEY, JSON.stringify(savedTexts));
  } catch(e) {}
}

// ========== INVENTORY ==========
function loadInventory() {
  try {
    const s = localStorage.getItem(INVENTORY_KEY);
    if (s) inventory = JSON.parse(s);
  } catch(e) {}
}

function saveInventory() {
  try {
    localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory));
  } catch(e) {}
}

// G8: Inventory history tracking
function loadInventoryHistory() {
  try {
    const s = localStorage.getItem(INVENTORY_HISTORY_KEY);
    if (s) inventoryHistory = JSON.parse(s);
  } catch(e) {}
}

function saveInventoryHistory() {
  try {
    localStorage.setItem(INVENTORY_HISTORY_KEY, JSON.stringify(inventoryHistory));
  } catch(e) {}
}

function addInventoryEvent(typeId, action, delta, newStock) {
  inventoryHistory.push({
    ts: Date.now(),
    type: typeId,
    action: action,  // 'add', 'set', 'print', 'adjust', 'remove'
    delta: delta,
    stock: newStock
  });
  // Keep last 500 events across all types
  if (inventoryHistory.length > 500) {
    inventoryHistory = inventoryHistory.slice(-500);
  }
  saveInventoryHistory();
}

function getInventoryBurnRate(typeId) {
  const events = inventoryHistory.filter(e => e.type === typeId);
  if (events.length < 2) return null;

  // Find the first stock event (when tracking began)
  const firstEvent = events[0];
  const lastEvent = events[events.length - 1];
  const daysSinceStart = (lastEvent.ts - firstEvent.ts) / 86400000;
  if (daysSinceStart < 1) return null;

  // Count total consumption: sum of negative deltas from 'print' and negative 'adjust'
  let totalConsumed = 0;
  for (const e of events) {
    if (e.delta < 0) totalConsumed += Math.abs(e.delta);
  }

  if (totalConsumed === 0) return null;

  const monthsElapsed = daysSinceStart / 30;
  const ratePerMonth = monthsElapsed > 0 ? totalConsumed / monthsElapsed : 0;
  const currentStock = inventory[typeId] ? inventory[typeId].stock : 0;
  const weeksLeft = ratePerMonth > 0 ? (currentStock / (ratePerMonth / 4.33)) : null;

  return {
    totalConsumed,
    daysSinceStart: Math.floor(daysSinceStart),
    ratePerMonth: Math.round(ratePerMonth * 10) / 10,
    weeksLeft: weeksLeft !== null ? Math.round(weeksLeft) : null,
    firstTracked: firstEvent.ts
  };
}

function getInventoryForType(labelType) {
  return inventory[labelType] || null;
}

function getInventorySummary(labelType) {
  const inv = inventory[labelType];
  const spec = LABEL_TYPES[labelType];
  if (!spec) return null;
  const lps = spec.cols * spec.rows;
  const stock = inv ? inv.stock : 0;

  let activeSheets = 0, partialSheets = 0, partialLabels = 0, fullyConsumed = 0;
  let assignedUnusedSheets = 0; // Sheets assigned to content but fully available
  let assignedPartialSheets = 0; // Sheets assigned with some printed
  
  for (const sh of Object.values(sheets)) {
    if (sh.labelType !== labelType) continue;
    const count = sh.sheetCount || 1;
    const printed = new Set(sh.printed || []);
    for (let p = 0; p < count; p++) {
      activeSheets++;
      let open = 0;
      for (let i = p * lps; i < (p + 1) * lps; i++) {
        if (!printed.has(i)) open++;
      }
      if (open === lps) {
        // All positions available
        assignedUnusedSheets++;
        partialSheets++; // Still count toward partial for legacy
        partialLabels += open;
      } else if (open > 0) {
        assignedPartialSheets++;
        partialSheets++;
        partialLabels += open;
      } else {
        fullyConsumed++;
      }
    }
  }

  return {
    stock, lps,
    stockLabels: stock * lps,
    activeSheets, partialSheets, partialLabels, fullyConsumed,
    assignedUnusedSheets,
    assignedPartialSheets,
    totalSheets: stock + partialSheets,
    totalLabels: (stock * lps) + partialLabels,
    isLow: inv ? stock <= inv.lowThreshold : false,
    lowThreshold: inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
}

// ========== BATCH JOBS ==========
function loadActiveJob() {
  try {
    const stored = localStorage.getItem(ACTIVE_JOB_KEY);
    activeJob = stored ? JSON.parse(stored) : null;
  } catch(e) { activeJob = null; }
}

function saveActiveJob() {
  try {
    if (activeJob) {
      localStorage.setItem(ACTIVE_JOB_KEY, JSON.stringify(activeJob));
    } else {
      localStorage.removeItem(ACTIVE_JOB_KEY);
    }
  } catch(e) {}
}

function hasActiveJob() {
  return activeJob !== null;
}

function getActiveJob() {
  return activeJob;
}

function loadJobHistory() {
  try {
    const stored = localStorage.getItem(JOB_HISTORY_KEY);
    jobHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { jobHistory = []; }
}

function saveJobHistory() {
  try {
    localStorage.setItem(JOB_HISTORY_KEY, JSON.stringify(jobHistory));
  } catch(e) {}
}

// ========== PRINT HISTORY (v2 new) ==========
function loadPrintHistory() {
  try {
    const stored = localStorage.getItem(PRINT_HISTORY_KEY);
    printHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { printHistory = []; }
}

function savePrintHistory() {
  try {
    localStorage.setItem(PRINT_HISTORY_KEY, JSON.stringify(printHistory));
  } catch(e) {}
}

function addPrintHistoryEntry(entry) {
  printHistory.unshift({
    id: generateId('ph'),
    timestamp: Date.now(),
    ...entry
  });
  // Keep last 100 entries
  if (printHistory.length > 100) {
    printHistory = printHistory.slice(0, 100);
  }
  savePrintHistory();
}

// ========== CUSTOM TOKENS ==========
function loadCustomTokens() {
  try {
    const s = localStorage.getItem(CUSTOM_TOKENS_KEY);
    if (s) customTokens = JSON.parse(s);
  } catch(e) {}
}

function saveCustomTokens() {
  try {
    localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(customTokens));
  } catch(e) {}
}

// ============================================================================
// SHEET OPERATIONS
// ============================================================================

function createSheet(name, labelType, sheetCount = 1, note = '') {
  const id = generateId('sh');
  sheets[id] = {
    id,
    name,
    labelType,
    sheetCount,
    note: note || '',
    printed: [],
    texts: {},
    createdAt: Date.now()
  };
  activeSheetId = id;
  saveSheets();
  return id;
}

function deleteSheet(id) {
  if (!sheets[id]) return false;
  delete sheets[id];
  if (activeSheetId === id) {
    activeSheetId = Object.keys(sheets)[0] || null;
  }
  saveSheets();
  return true;
}

async function confirmDeleteSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  const ok = await showConfirmDialog(
    'Delete "' + sh.name + '"? This removes the sheet and all position data. This cannot be undone.',
    'Delete Sheet',
    'Delete',
    'Cancel'
  );
  if (ok) {
    deleteSheet(id);
    showToast('Sheet deleted', 'success');
    renderCurrentTab();
  }
}

function retireSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  sh.retired = true;
  sh.retiredAt = Date.now();
  saveSheets();
  showToast('"' + sh.name + '" retired â€” it won\'t appear in print workflows', 'success');
  renderCurrentTab();
}

function unretireSheet(id) {
  const sh = sheets[id];
  if (!sh) return;
  sh.retired = false;
  sh.retiredAt = null;
  saveSheets();
  showToast('"' + sh.name + '" restored to active sheets', 'success');
  renderCurrentTab();
}

function renameSheet(id, newName) {
  if (!sheets[id]) return false;
  sheets[id].name = newName;
  saveSheets();
  return true;
}

function cloneSheet(id) {
  const original = sheets[id];
  if (!original) return null;
  
  const cloneId = generateId('sheet');
  const clone = {
    id: cloneId,
    name: original.name + ' (Copy)',
    labelType: original.labelType,
    printed: [],  // Start fresh - no positions used
    texts: {},    // No linked content
    hasBackLabel: original.hasBackLabel || false,
    createdAt: Date.now(),
    lastUsedAt: Date.now()
  };
  
  sheets[cloneId] = clone;
  saveSheets();
  
  // Refresh the current view to show the new sheet
  renderCurrentTab();
  
  showToast('Sheet cloned: ' + clone.name, 'success');
  
  // Scroll to and highlight the new sheet card after a brief delay
  setTimeout(() => {
    const card = document.querySelector('[data-sheet-id="' + cloneId + '"]');
    if (card) {
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
      card.classList.add('highlight-flash');
      setTimeout(() => card.classList.remove('highlight-flash'), 1500);
    }
  }, 100);
  
  return cloneId;
}

function setActiveSheet(id) {
  if (sheets[id]) {
    activeSheetId = id;
    saveSheets();
  }
}

function markPositionsPrinted(sheetId, positions) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const printed = new Set(sh.printed || []);
  for (const pos of positions) {
    printed.add(pos);
  }
  sh.printed = Array.from(printed).sort((a, b) => a - b);
  saveSheets();
}

// ============================================================================
// SAVED TEXT OPERATIONS
// ============================================================================

function createSavedText(name, lines, opts = {}) {
  const id = generateId('st');
  const entry = {
    id,
    name,
    text: serializeLines(lines),
    alignV: opts.alignV || 'center',
    createdAt: Date.now()
  };
  if (opts.graphics) entry.graphics = opts.graphics;
  if (opts.border) entry.border = opts.border;
  if (opts.barcode) entry.barcode = opts.barcode;
  if (opts.isTemplate) {
    entry.type = 'template';
    entry.tokens = extractTokens(entry.text);
    entry.labelType = opts.labelType || '5160';
  }
  if (opts.isStyleTemplate) {
    entry.type = 'style';
    entry.category = opts.category || 'simple';
    entry.labelType = opts.labelType || '5160';
    entry.lineStyles = opts.lineStyles; // Store line styles for style templates
  }
  savedTexts.push(entry);
  saveSavedTexts();
  
  // Track in satellite pending queue if in satellite mode
  addToSatellitePending(id);
  
  return id;
}

function updateSavedText(id, updates) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  savedTexts[idx] = { ...savedTexts[idx], ...updates };
  if (updates.text && savedTexts[idx].type === 'template') {
    savedTexts[idx].tokens = extractTokens(updates.text);
  }
  saveSavedTexts();
  return true;
}

function deleteSavedText(id) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  
  // In satellite mode, can only delete items that are still in pending queue
  if (settings.deviceRole === 'satellite') {
    const pending = getSatellitePending();
    if (!pending.includes(id)) {
      showToast("Can't delete - synced from primary device", 'error');
      return false;
    }
    // Remove from pending queue
    removeFromSatellitePending(id);
  }
  
  savedTexts.splice(idx, 1);
  // Remove from all sheets
  for (const sh of Object.values(sheets)) {
    if (sh.texts && sh.texts[id]) {
      delete sh.texts[id];
    }
  }
  saveSavedTexts();
  saveSheets();
  return true;
}

async function confirmDeleteSavedText(id) {
  const st = getSavedText(id);
  if (!st) return;
  const ok = await showConfirmDialog(
    'Delete "' + st.name + '"? This cannot be undone.',
    'Delete Saved Text',
    'Delete',
    'Cancel'
  );
  if (ok) {
    deleteSavedText(id);
    showToast('Deleted', 'success');
    renderCurrentTab();
  }
}

function cloneSavedText(id, newName) {
  const original = getSavedText(id);
  if (!original) return null;
  const clone = {
    id: generateId('st'),
    name: newName || (original.name + ' (Copy)'),
    text: original.text,
    alignV: original.alignV || 'center',
    createdAt: Date.now()
  };
  if (original.graphics) clone.graphics = JSON.parse(JSON.stringify(original.graphics));
  if (original.border) clone.border = JSON.parse(JSON.stringify(original.border));
  if (original.barcode) clone.barcode = JSON.parse(JSON.stringify(original.barcode));
  if (original.type === 'template') {
    clone.type = 'template';
    clone.tokens = [...(original.tokens || [])];
    clone.labelType = original.labelType || '5160';
  }
  savedTexts.push(clone);
  saveSavedTexts();
  
  // Track in satellite pending queue if in satellite mode
  addToSatellitePending(clone.id);
  
  showToast('Cloned: ' + clone.name, 'success');
  renderAll();
  
  // Open the Full Editor with the new clone for immediate editing
  openFullEditor(clone.id, clone.type === 'template');
  
  return clone.id;
}

// ============================================================================
// DATA EXPORT/IMPORT
// ============================================================================

function exportAllDataJSON() {
  const data = {
    version: '3.27.7',
    exportedAt: new Date().toISOString(),
    sheets,
    savedTexts,
    inventory,
    inventoryHistory,
    activeJob,
    jobHistory,
    customTokens,
    printHistory,
    settings,
    theme: settings.darkMode ? 'dark' : 'light'
  };
  return JSON.stringify(data, null, 2);
}

function importAllData(json) {
  try {
    const data = JSON.parse(json);
    
    // Validate
    if (!data.sheets && !data.savedTexts) {
      throw new Error('Invalid backup file');
    }
    
    // Import sheets
    if (data.sheets) {
      sheets = data.sheets;
      // Ensure consistency
      for (const sh of Object.values(sheets)) {
        if (!sh.labelType) sh.labelType = '5160';
        if (!sh.texts) sh.texts = {};
        if (!sh.sheetCount) sh.sheetCount = 1;
        if (!sh.printed) sh.printed = [];
      }
      activeSheetId = Object.keys(sheets)[0] || null;
      saveSheets();
    }
    
    // Import texts
    if (data.savedTexts) {
      savedTexts = data.savedTexts;
      saveSavedTexts();
    }
    
    // Import inventory
    if (data.inventory) {
      inventory = data.inventory;
      saveInventory();
    }
    
    // Import inventory history (G8)
    if (data.inventoryHistory) {
      inventoryHistory = data.inventoryHistory;
      saveInventoryHistory();
    }
    
    // Import jobs
    if (data.activeJob !== undefined) {
      activeJob = data.activeJob;
      saveActiveJob();
    }
    if (data.jobHistory) {
      jobHistory = data.jobHistory;
      saveJobHistory();
    }
    
    // Import custom tokens
    if (data.customTokens) {
      customTokens = data.customTokens;
      saveCustomTokens();
    }
    
    // Import print history
    if (data.printHistory) {
      printHistory = data.printHistory;
      savePrintHistory();
    }
    
    // Import learning data (Phase 4)
    if (data.learningData) {
      learningData = data.learningData;
      saveLearningData();
    }
    
    // Import theme
    if (data.theme) {
      settings.darkMode = data.theme === 'dark';
      saveSettings();
    }
    
    return { success: true };
  } catch(e) {
    return { success: false, error: e.message };
  }
}

// ============================================================================
// DATA STATS (for UI)
// ============================================================================

function getDataStats() {
  const sheetCount = Object.keys(sheets).length;
  // Count saved texts that are not templates or style templates
  const textCount = savedTexts.filter(t => t.type !== 'template' && t.type !== 'style').length;
  // Count import templates (type: 'template')
  const importTemplateCount = getImportTemplates().length;
  // Count style templates (type: 'style')
  const styleTemplateCount = getStyleTemplates().length;
  const templateCount = importTemplateCount + styleTemplateCount;
  const inventoryTypes = Object.keys(inventory).length;
  
  let totalAvailable = 0;
  let totalPrinted = 0;
  for (const sh of Object.values(sheets)) {
    totalAvailable += getRemainingCount(sh);
    totalPrinted += getPrintedCount(sh);
  }
  
  return {
    sheetCount,
    textCount,
    templateCount,
    importTemplateCount,
    styleTemplateCount,
    inventoryTypes,
    totalAvailable,
    totalPrinted,
    printHistoryCount: printHistory.length,
    hasData: sheetCount > 0 || textCount > 0
  };
}

// ============================================================================
// UI STATE & NAVIGATION
// ============================================================================

function applyTheme() {
  document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light');
  updateToggle('darkModeToggle', settings.darkMode);
}

function toggleDarkMode() {
  settings.darkMode = !settings.darkMode;
  saveSettings();
  applyTheme();
}

function updateToggle(id, active) {
  const toggle = document.getElementById(id);
  if (toggle) {
    toggle.classList.toggle('active', active);
  }
}

function openSettings() {
  // Populate data stats
  const stats = getDataStats();
  const statsEl = document.getElementById('settingsDataStats');
  
  // Get learning stats (Phase 4)
  let learningHtml = '';
  if (typeof getLearningStats === 'function') {
    const learningStats = getLearningStats();
    const total = learningStats.totalAcceptances + learningStats.totalCorrections;
    if (total > 0) {
      const acceptRate = Math.round((learningStats.totalAcceptances / total) * 100);
      learningHtml = '<div class="settings-data-stat">ðŸ§  <strong>' + acceptRate + '%</strong> suggestion accuracy (' + total + ' total)</div>';
    }
  }
  
  statsEl.innerHTML = 
    '<div class="settings-data-stat">ðŸ“„ <strong>' + stats.sheetCount + '</strong> sheet' + (stats.sheetCount !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ’¾ <strong>' + stats.textCount + '</strong> saved text' + (stats.textCount !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“¦ <strong>' + stats.inventoryTypes + '</strong> inventory type' + (stats.inventoryTypes !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“œ <strong>' + stats.printHistoryCount + '</strong> history item' + (stats.printHistoryCount !== 1 ? 's' : '') + '</div>' +
    learningHtml;
  
  // Populate print offset fields
  document.getElementById('safariVScale').value = settings.safariVScale ?? 1.0;
  document.getElementById('printOffsetTop').value = settings.printOffsetTop || 0;
  document.getElementById('printOffsetLeft').value = settings.printOffsetLeft || 0;
  
  // Populate Quick Actions count (T11)
  document.getElementById('quickActionsCount').value = settings.quickActionsCount ?? 5;
  
  // Update label boundaries toggle
  const boundariesToggle = document.getElementById('labelBoundariesToggle');
  if (boundariesToggle) {
    boundariesToggle.classList.toggle('active', settings.showLabelBoundaries);
  }
  
  // Update device role UI
  updateDeviceRoleUI();
  
  // Update AI key status
  updateAIKeyStatusUI();
  
  // Update backup status
  updateBackupStatus();
  
  document.getElementById('settingsModal').classList.add('visible');
}

function toggleLabelBoundaries() {
  settings.showLabelBoundaries = !settings.showLabelBoundaries;
  const toggle = document.getElementById('labelBoundariesToggle');
  if (toggle) {
    toggle.classList.toggle('active', settings.showLabelBoundaries);
  }
  saveSettings();
  showToast(settings.showLabelBoundaries ? 'Label boundaries enabled' : 'Label boundaries disabled', 'success');
}

function updatePrintOffset() {
  settings.safariVScale = parseFloat(document.getElementById('safariVScale').value) || 1.0;
  // Clamp to valid range
  if (settings.safariVScale < 0.90) settings.safariVScale = 0.90;
  if (settings.safariVScale > 1.0) settings.safariVScale = 1.0;
  document.getElementById('safariVScale').value = settings.safariVScale;
  
  settings.printOffsetTop = parseFloat(document.getElementById('printOffsetTop').value) || 0;
  settings.printOffsetLeft = parseFloat(document.getElementById('printOffsetLeft').value) || 0;
  saveSettings();
  showToast('Print settings saved', 'success');
}

// T11: Update Quick Actions count setting
function updateQuickActionsCount() {
  let count = parseInt(document.getElementById('quickActionsCount').value) || 5;
  // Clamp to valid range
  if (count < 0) count = 0;
  if (count > 10) count = 10;
  document.getElementById('quickActionsCount').value = count;
  
  settings.quickActionsCount = count;
  saveSettings();
  
  // Immediately refresh the Quick Actions display
  renderQuickActions();
  
  showToast('Quick actions updated', 'success');
}

function closeSettings() {
  document.getElementById('settingsModal').classList.remove('visible');
}

// Toggle advanced settings panel
function toggleSettingsAdvanced() {
  const panel = document.getElementById('settingsAdvancedPanel');
  const arrow = document.getElementById('settingsAdvancedArrow');
  
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    arrow.style.transform = 'rotate(90deg)';
  } else {
    panel.style.display = 'none';
    arrow.style.transform = 'rotate(0deg)';
  }
}

// Reset advanced print settings to defaults
function resetAdvancedSettings() {
  document.getElementById('safariVScale').value = '1.0';
  document.getElementById('printOffsetTop').value = '0';
  document.getElementById('printOffsetLeft').value = '0';
  
  settings.safariVScale = 1.0;
  settings.printOffsetTop = 0;
  settings.printOffsetLeft = 0;
  settings.showLabelBoundaries = false;
  
  // Update the toggle
  document.getElementById('labelBoundariesToggle').classList.remove('active');
  
  saveSettings();
  showToast('Print settings reset to defaults', 'success');
}

// Toggle device sync panel
function toggleSettingsDeviceSync() {
  const panel = document.getElementById('settingsDeviceSyncPanel');
  const arrow = document.getElementById('settingsDeviceSyncArrow');
  
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    arrow.style.transform = 'rotate(90deg)';
  } else {
    panel.style.display = 'none';
    arrow.style.transform = 'rotate(0deg)';
  }
}

// Update backup status display
function updateBackupStatus() {
  const box = document.getElementById('backupStatusBox');
  if (!box) return;
  
  const lastBackup = settings.lastBackupAt;
  const now = Date.now();
  const oneWeek = 7 * 24 * 60 * 60 * 1000;
  const oneDay = 24 * 60 * 60 * 1000;
  
  if (!lastBackup) {
    // Never backed up
    box.className = 'backup-status-box status-warning';
    box.innerHTML = '<span class="backup-status-icon">âš ï¸</span>' +
      '<span class="backup-status-text"><strong>No backup yet</strong> â€” Export a backup to protect your data</span>';
  } else {
    const elapsed = now - lastBackup;
    const daysAgo = Math.floor(elapsed / oneDay);
    
    // Format the date
    const backupDate = new Date(lastBackup);
    const dateStr = backupDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    
    if (elapsed > oneWeek) {
      // More than a week - warning
      box.className = 'backup-status-box status-warning';
      box.innerHTML = '<span class="backup-status-icon">âš ï¸</span>' +
        '<span class="backup-status-text"><strong>Backup recommended</strong> â€” Last backup was ' + 
        (daysAgo === 1 ? 'yesterday' : daysAgo + ' days ago') + ' (' + dateStr + ')</span>';
    } else {
      // Recent backup - OK
      box.className = 'backup-status-box status-ok';
      let timeAgo;
      if (daysAgo === 0) {
        timeAgo = 'today';
      } else if (daysAgo === 1) {
        timeAgo = 'yesterday';
      } else {
        timeAgo = daysAgo + ' days ago';
      }
      box.innerHTML = '<span class="backup-status-icon">âœ“</span>' +
        '<span class="backup-status-text">Last backup: ' + timeAgo + ' (' + dateStr + ')</span>';
    }
  }
}

// ========== AI PROMPT MODAL ==========
function showAIPromptModal() {
  const promptBox = document.getElementById('aiPromptBox');
  if (promptBox) {
    promptBox.textContent = getAIPromptTemplate();
  }
  document.getElementById('aiPromptModal').classList.add('visible');
}

function closeAIPromptModal() {
  document.getElementById('aiPromptModal').classList.remove('visible');
}

function copyAIPrompt() {
  const prompt = getAIPromptTemplate();
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(prompt).then(() => {
      showToast('Prompt copied to clipboard!', 'success');
    }).catch(() => {
      fallbackCopyToClipboard(prompt);
    });
  } else {
    fallbackCopyToClipboard(prompt);
  }
}

function fallbackCopyToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    document.execCommand('copy');
    showToast('Prompt copied!', 'success');
  } catch (e) {
    showToast('Failed to copy. Please select and copy manually.', 'warning');
  }
  document.body.removeChild(textarea);
}

function copyDeepLinkExample() {
  const baseUrl = window.location.href.split('?')[0];
  const example = baseUrl + '?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1';
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(example).then(() => {
      showToast('Link format copied!', 'success');
    }).catch(() => {
      showToast('Copy failed', 'error');
    });
  }
}

// ========== BYOAI - Bring Your Own AI ==========
const AI_KEY_STORAGE = 'lk_ai_key';
const AI_PROVIDER_STORAGE = 'lk_ai_provider';

// Detect provider from API key format
function detectAIProvider(key) {
  if (!key) return null;
  key = key.trim();
  if (key.startsWith('sk-ant-')) return 'claude';
  if (key.startsWith('sk-')) return 'openai';
  // Gemini keys are typically 39 chars and alphanumeric
  if (/^[A-Za-z0-9_-]{39}$/.test(key)) return 'gemini';
  return null;
}

// Get stored AI key
function getAIKey() {
  try {
    return localStorage.getItem(AI_KEY_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Get stored provider
function getAIProvider() {
  try {
    return localStorage.getItem(AI_PROVIDER_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Save AI key
function saveAIKeyToStorage(key, provider) {
  try {
    localStorage.setItem(AI_KEY_STORAGE, key);
    localStorage.setItem(AI_PROVIDER_STORAGE, provider);
    return true;
  } catch (e) {
    return false;
  }
}

// Clear AI key
function clearAIKeyFromStorage() {
  try {
    localStorage.removeItem(AI_KEY_STORAGE);
    localStorage.removeItem(AI_PROVIDER_STORAGE);
    return true;
  } catch (e) {
    return false;
  }
}

// Update Settings UI to reflect AI key status
function updateAIKeyStatusUI() {
  const hasKey = !!getAIKey();
  const provider = getAIProvider();
  
  const statusEl = document.getElementById('aiKeyStatus');
  const statusTextEl = document.getElementById('aiKeyStatusText');
  const configBtn = document.getElementById('aiKeyConfigBtn');
  const configBtnText = document.getElementById('aiKeyConfigBtnText');
  const clearBtn = document.getElementById('aiKeyClearBtn');
  
  // Show/hide AI prompt on workflow hub
  const aiPrompt = document.getElementById('workflowAiPrompt');
  if (aiPrompt) aiPrompt.style.display = hasKey ? 'block' : 'none';
  
  if (!statusEl) return;
  
  if (hasKey && provider) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    statusEl.classList.remove('no-key');
    statusTextEl.textContent = `Connected to ${providerNames[provider] || provider}`;
    configBtnText.textContent = 'Change Key';
    clearBtn.style.display = 'inline-flex';
  } else {
    statusEl.classList.add('no-key');
    statusTextEl.textContent = 'No API key configured';
    configBtnText.textContent = 'Add API Key';
    clearBtn.style.display = 'none';
  }
}

// Show AI Key modal
function showAIKeyModal() {
  const input = document.getElementById('aiKeyInput');
  if (input) {
    input.value = getAIKey();
  }
  document.getElementById('aiKeyModal').classList.add('visible');
}

// Close AI Key modal
function closeAIKeyModal() {
  document.getElementById('aiKeyModal').classList.remove('visible');
}

// Save AI key from modal
function saveAIKey() {
  const input = document.getElementById('aiKeyInput');
  const key = input ? input.value.trim() : '';
  
  if (!key) {
    showToast('Please enter an API key', 'warning');
    return;
  }
  
  const provider = detectAIProvider(key);
  if (!provider) {
    showToast('Unrecognized key format. Please use a Claude, OpenAI, or Gemini key.', 'error');
    return;
  }
  
  if (saveAIKeyToStorage(key, provider)) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    showToast(`${providerNames[provider]} API key saved!`, 'success');
    closeAIKeyModal();
    updateAIKeyStatusUI();
  } else {
    showToast('Failed to save key', 'error');
  }
}

// Clear AI key
async function clearAIKey() {
  const ok = await showConfirmDialog(
    'Remove your API key? You can add it again anytime.',
    'Remove API Key',
    'Remove',
    'Cancel'
  );
  if (ok) {
    clearAIKeyFromStorage();
    showToast('API key removed', 'info');
    updateAIKeyStatusUI();
  }
}

// ===== AI CATEGORY FLOW =====
let currentAICategory = null;

function openAICategoryModal() {
  // Check if AI key is configured first
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  document.getElementById('aiCategoryModal').classList.add('visible');
}

function closeAICategoryModal() {
  document.getElementById('aiCategoryModal').classList.remove('visible');
}

function selectAICategory(category) {
  currentAICategory = category;
  closeAICategoryModal();
  showAICategoryForm(category);
}

function showAICategoryForm(category) {
  const titleEl = document.getElementById('aiFormTitle');
  const bodyEl = document.getElementById('aiFormBody');
  
  const forms = {
    address: {
      title: 'ðŸ“¬ Address Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Full Address</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiAddressInput" placeholder="Paste or type the full address...

Example:
John Smith
123 Main Street
Boston, MA 02101"></textarea>
          <div class="ai-form-hint">Include name, street, city, state, and zip</div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    gift: {
      title: 'ðŸŽ Gift Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Who is it for?</label>
          <input type="text" class="ai-form-input" id="aiGiftTo" placeholder="Sarah, Mom, The Johnsons...">
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">What's the occasion?</label>
          <input type="text" class="ai-form-input" id="aiGiftOccasion" placeholder="Birthday, Christmas, Thank you...">
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Birthday')">Birthday</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Christmas')">Christmas</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Thank You')">Thank You</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Wedding')">Wedding</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Baby Shower')">Baby Shower</span>
          </div>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">From (optional)</label>
          <input type="text" class="ai-form-input" id="aiGiftFrom" placeholder="With love from...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    organize: {
      title: 'ðŸ·ï¸ Organization Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What are you labeling?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiOrganizeItems" placeholder="List items (one per line or comma separated)...

Examples:
â€¢ Flour, Sugar, Rice, Pasta
â€¢ Q1 Reports, Tax Documents, Receipts
â€¢ Kids Toys, Winter Clothes, Holiday Decor"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('pantry')">ðŸ¥« Pantry</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('files')">ðŸ“ Files</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('bins')">ðŸ“¦ Storage Bins</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('kids')">ðŸ§¸ Kids Stuff</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    moving: {
      title: 'ðŸ“¦ Moving Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What rooms/boxes do you need?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiMovingRooms" placeholder="List rooms or box contents...

Example:
Kitchen - Pots & Pans
Kitchen - Fragile Dishes
Bedroom - Clothes
Garage - Tools"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Kitchen')">Kitchen</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bedroom')">Bedroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bathroom')">Bathroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Living Room')">Living Room</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Garage')">Garage</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('FRAGILE')">âš ï¸ Fragile</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    nametag: {
      title: 'ðŸ‘‹ Name Tags',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Names</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiNametagNames" placeholder="Enter names (one per line or comma separated)...

Example:
John Smith
Sarah Johnson
Mike Williams"></textarea>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">Event or company (optional)</label>
          <input type="text" class="ai-form-input" id="aiNametagEvent" placeholder="Team Meeting, Book Club, Acme Corp...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Name Tags</button>
        </div>
      `
    },
    custom: {
      title: 'âœï¸ Custom Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Describe what you need</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiCustomPrompt" placeholder="Tell the AI what kind of labels you want...

Examples:
â€¢ Warning labels for homemade hot sauce bottles
â€¢ Return address with a fun gardening theme
â€¢ Labels for my handmade candle business"></textarea>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Generate</button>
        </div>
      `
    }
  };
  
  const form = forms[category];
  titleEl.textContent = form.title;
  bodyEl.innerHTML = form.html;
  
  document.getElementById('aiFormModal').classList.add('visible');
}

function closeAIFormModal() {
  document.getElementById('aiFormModal').classList.remove('visible');
  currentAICategory = null;
}

function backToAICategories() {
  closeAIFormModal();
  openAICategoryModal();
}

// Helper functions for suggestion chips
function fillGiftOccasion(value) {
  document.getElementById('aiGiftOccasion').value = value;
}

function fillOrganizeType(type) {
  const examples = {
    pantry: 'Flour, Sugar, Rice, Pasta, Cereal, Oats',
    files: 'Tax Documents, Medical Records, Insurance, Receipts',
    bins: 'Holiday Decor, Winter Clothes, Sports Equipment',
    kids: 'Toys, Art Supplies, Books, Games'
  };
  document.getElementById('aiOrganizeItems').value = examples[type] || '';
}

function fillMovingRoom(room) {
  const input = document.getElementById('aiMovingRooms');
  const current = input.value.trim();
  if (current) {
    input.value = current + '\n' + room;
  } else {
    input.value = room;
  }
}

// Build prompt from category form and generate
async function generateFromCategory() {
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  const statusEl = document.getElementById('aiFormStatus');
  const errorEl = document.getElementById('aiFormError');
  const btn = document.getElementById('aiFormSubmit');
  
  // Build the prompt based on category
  let prompt = '';
  
  switch (currentAICategory) {
    case 'address':
      const address = document.getElementById('aiAddressInput').value.trim();
      if (!address) {
        showToast('Please enter an address', 'warning');
        return;
      }
      prompt = `Format this as a clean address label:\n${address}`;
      break;
      
    case 'gift':
      const to = document.getElementById('aiGiftTo').value.trim();
      const occasion = document.getElementById('aiGiftOccasion').value.trim();
      const from = document.getElementById('aiGiftFrom').value.trim();
      if (!to) {
        showToast('Please enter who the gift is for', 'warning');
        return;
      }
      prompt = `Create a gift tag label for ${to}`;
      if (occasion) prompt += ` for ${occasion}`;
      if (from) prompt += `, from ${from}`;
      break;
      
    case 'organize':
      const items = document.getElementById('aiOrganizeItems').value.trim();
      if (!items) {
        showToast('Please enter items to label', 'warning');
        return;
      }
      prompt = `Create organization labels for these items (one label per item, keep text short and clear):\n${items}`;
      break;
      
    case 'moving':
      const rooms = document.getElementById('aiMovingRooms').value.trim();
      if (!rooms) {
        showToast('Please enter rooms or contents', 'warning');
        return;
      }
      prompt = `Create moving box labels for these (include room name prominently, add relevant icon if possible with text):\n${rooms}`;
      break;
      
    case 'nametag':
      const names = document.getElementById('aiNametagNames').value.trim();
      const event = document.getElementById('aiNametagEvent').value.trim();
      if (!names) {
        showToast('Please enter names', 'warning');
        return;
      }
      prompt = `Create name tag labels for these people`;
      if (event) prompt += ` (for: ${event})`;
      prompt += `:\n${names}`;
      break;
      
    case 'custom':
      const customPrompt = document.getElementById('aiCustomPrompt').value.trim();
      if (!customPrompt) {
        showToast('Please describe what you need', 'warning');
        return;
      }
      prompt = customPrompt;
      break;
      
    default:
      showToast('Unknown category', 'error');
      return;
  }
  
  // Show loading
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, prompt);
    
    closeAIFormModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: prompt,
        category: currentAICategory,
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, prompt, currentAICategory);
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Open AI Generate modal (or key modal if no key)
function openAIGenerate() {
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  
  // Clear previous state
  const textarea = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  if (textarea) textarea.value = '';
  if (statusEl) statusEl.style.display = 'none';
  if (errorEl) errorEl.style.display = 'none';
  if (btn) btn.disabled = false;
  
  document.getElementById('aiGenerateModal').classList.add('visible');
}

// Close AI Generate modal
function closeAIGenerateModal() {
  document.getElementById('aiGenerateModal').classList.remove('visible');
}

// Generate label content with AI
async function generateWithAI() {
  const key = getAIKey();
  const provider = getAIProvider();
  const promptInput = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  const userPrompt = promptInput ? promptInput.value.trim() : '';
  
  if (!userPrompt) {
    showToast('Please describe the label you want', 'warning');
    return;
  }
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Show loading state
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, userPrompt);
    
    closeAIGenerateModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: userPrompt,
        category: 'custom',
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, userPrompt, 'custom');
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Call the appropriate AI provider API
async function callAIProvider(provider, key, userPrompt) {
  const systemPrompt = `You are a label content generator for LabelKeeper. Output label content in LabelKeeper format.

OUTPUT FORMAT:
Return up to 4 lines of label text, optionally with formatting and graphics instructions.

LINE FORMAT:
alignment,size:text

ALIGNMENT: left | center | right (default: left)
SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left-aligned and right-aligned parts
  Example: "left,11:Teacher: Smith || Room: 101" 
  This renders "Teacher: Smith" on the left and "Room: 101" on the right of the same line

â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) to create a blank line for writing
  Example: "left,11:Name: __" renders as "Name: _______________" (a long line for writing)
  
â€¢ DECORATIVE LINES: For visual separators, use Unicode characters:
  - Solid line: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (use â”€ character, NOT dashes)
  - Dotted: Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· (use Â· middle dot)
  - Stars: â˜… â˜… â˜… â˜… â˜… or â˜† â˜† â˜† â˜† â˜†
  - Hearts: â™¥ â™¥ â™¥ â™¥ â™¥
  - Arrows: â†’ â† â†‘ â†“
  
DO NOT use ASCII dashes (---) for decorative lines. Use proper Unicode box-drawing characters.

EXAMPLES:
"center,14:FRAGILE" - Large centered text
"left,11:From: || To:" - Split line with labels on each side
"center,11:â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" - Decorative separator line
"left,11:Signature: __" - Fill-in line for signature

GRAPHICS:
You CAN generate custom SVG graphics! If the user wants an icon, logo, or image:
1. Output the label text lines first
2. Then add a line starting with SVG_LEFT: or SVG_RIGHT: followed by valid SVG code
3. SVG should use viewBox="0 0 64 64" and be self-contained with solid fills (not just strokes)

Example with graphic:
left,14:Warning
center,11:Hot Surface
SVG_LEFT:<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><text x="32" y="42" text-anchor="middle" fill="white" font-size="32" font-weight="bold">!</text></svg>

COMMON ICON SVGs YOU CAN USE:
- Warning triangle: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4L4 56h56L32 4z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>
- Checkmark: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32L28 40L44 24" stroke="#fff" stroke-width="4" fill="none"/></svg>
- X/Stop: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><path d="M20 20L44 44M44 20L20 44" stroke="#fff" stroke-width="4"/></svg>
- Heart: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56C16 44 4 32 4 20c0-10 8-16 18-16 6 0 10 4 10 4s4-4 10-4c10 0 18 6 18 16 0 12-12 24-28 36z" fill="#ef4444"/></svg>
- Star: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#fbbf24"/></svg>
- Arrow right: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32h32M36 20l12 12-12 12" stroke="#333" stroke-width="4" fill="none" stroke-linecap="round"/></svg>
- Box/Package: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/></svg>
- Fragile glass: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8L44 8L44 28Q44 48 32 56Q20 48 20 28Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20L32 32L28 32L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>

Feel free to create custom SVGs for specific requests (logos, symbols, simple illustrations). Keep SVGs simple with solid fills for good print quality.

QR CODES / BARCODES:
You cannot generate functional QR codes or barcodes. If requested, explain they need to use Full Editor and upload a QR code image.

OUTPUT ONLY THE FORMATTED LINES AND OPTIONAL SVG. NO EXPLANATIONS OR MARKDOWN.`;

  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 200,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 200,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 200
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
}

// ============================================================================
// AI PREVIEW SYSTEM - Shows what AI understood before applying
// ============================================================================

const AI_SKIP_PREVIEW_KEY = 'lk_ai_skip_preview';

// State for current AI preview
let aiPreviewState = {
  originalPrompt: '',
  category: null,
  understanding: '',
  labels: [],
  suggestedType: '5160',
  quantity: 1,
  svgLeft: null,
  svgRight: null
};

// Check if user wants to skip preview
function shouldSkipAIPreview() {
  try {
    return localStorage.getItem(AI_SKIP_PREVIEW_KEY) === 'true';
  } catch (e) {
    return false;
  }
}

// Toggle skip preview preference
function toggleAIPreviewSkip() {
  const checkbox = document.getElementById('aiPreviewSkip');
  try {
    if (checkbox && checkbox.checked) {
      localStorage.setItem(AI_SKIP_PREVIEW_KEY, 'true');
    } else {
      localStorage.removeItem(AI_SKIP_PREVIEW_KEY);
    }
  } catch (e) {}
}

// New system prompt that returns JSON with understanding
function getAISystemPromptWithPreview() {
  return `You are a label content generator for LabelKeeper. You MUST respond with valid JSON only.

RESPONSE FORMAT (strict JSON, no markdown):
{
  "understanding": "Brief summary of what the user wants (1-2 sentences)",
  "labels": [
    {
      "preview": "Human-readable preview text for this label",
      "lines": ["alignment,size:text", ...],
      "svg": null or "SVG_LEFT:..." or "SVG_RIGHT:..."
    }
  ],
  "suggestedType": "5160",
  "quantity": 1,
  "error": null
}

HANDLING IMPOSSIBLE REQUESTS:
If you cannot fulfill the request (e.g., user asks you to access files, browse the web, read emails, or do something outside label generation), respond with:
{
  "understanding": "What the user asked for",
  "labels": [],
  "suggestedType": "5160",
  "quantity": 0,
  "error": "Brief explanation of why this can't be done and what the user could do instead"
}
Example error: "I cannot access local files or Excel documents. To create labels from your contacts, please copy the contact information from Excel and paste it here, or use the CSV Import feature in the main menu."

IMPORTANT: Always respond with JSON. Never write conversational text or instructions as label content.

LABEL LINE FORMAT:
alignment,size:text
- ALIGNMENT: left | center | right (default: left)
- SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left and right parts
  Example: "left,11:Teacher: Smith || Room: 101"
â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) for a blank line
  Example: "left,11:Name: __"
â€¢ DECORATIVE LINES: Use Unicode: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (not dashes)

LABEL TYPES:
- "5160": Address labels (30/sheet) - most common
- "5163": Shipping labels (10/sheet) - larger
- "5167": Return address (80/sheet) - small
- "5395": Name badges (8/sheet)

GRAPHICS (optional):
For icons/images, add svg field with "SVG_LEFT:<svg...>" or "SVG_RIGHT:<svg...>"
SVG should use viewBox="0 0 64 64" with solid fills.

MULTIPLE LABELS:
If user wants multiple different labels (e.g., "labels for Flour, Sugar, Rice"), create separate label objects in the array.
If user wants multiple copies of the SAME label, use quantity field instead.

EXAMPLES:

Request: "Address label for John Smith, 123 Main St, Boston MA"
{
  "understanding": "Creating an address label for John Smith in Boston",
  "labels": [{"preview": "John Smith\\n123 Main St\\nBoston, MA", "lines": ["left,11:John Smith", "left,11:123 Main St", "left,11:Boston, MA"], "svg": null}],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Pantry labels for Flour, Sugar, and Rice"
{
  "understanding": "Creating 3 pantry organization labels",
  "labels": [
    {"preview": "FLOUR", "lines": ["center,14:FLOUR"], "svg": null},
    {"preview": "SUGAR", "lines": ["center,14:SUGAR"], "svg": null},
    {"preview": "RICE", "lines": ["center,14:RICE"], "svg": null}
  ],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Warning label with exclamation icon"
{
  "understanding": "Creating a warning label with an icon",
  "labels": [{"preview": "âš ï¸ WARNING\\nHot Surface", "lines": ["center,14:WARNING", "center,11:Hot Surface"], "svg": "SVG_LEFT:<svg viewBox=\\"0 0 64 64\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M32 4L4 56h56L32 4z\\" fill=\\"#fbbf24\\"/><rect x=\\"29\\" y=\\"20\\" width=\\"6\\" height=\\"20\\" fill=\\"#1f2937\\"/><circle cx=\\"32\\" cy=\\"48\\" r=\\"4\\" fill=\\"#1f2937\\"/></svg>"}],
  "suggestedType": "5163",
  "quantity": 1
}

RESPOND WITH VALID JSON ONLY. NO MARKDOWN, NO EXPLANATION, NO CODE BLOCKS.`;
}

// Call AI provider and get structured preview data
async function callAIProviderForPreview(provider, key, userPrompt) {
  const systemPrompt = getAISystemPromptWithPreview();
  
  let responseText = '';
  
  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 1000,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 1000
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
  
  // Parse JSON response
  try {
    // Clean up response - remove markdown code blocks if present
    let cleanJson = responseText.trim();
    if (cleanJson.startsWith('```json')) {
      cleanJson = cleanJson.slice(7);
    } else if (cleanJson.startsWith('```')) {
      cleanJson = cleanJson.slice(3);
    }
    if (cleanJson.endsWith('```')) {
      cleanJson = cleanJson.slice(0, -3);
    }
    cleanJson = cleanJson.trim();
    
    const parsed = JSON.parse(cleanJson);
    return parsed;
  } catch (e) {
    console.error('Failed to parse AI response as JSON:', responseText);
    
    // Detect if this looks like a conversational refusal/explanation rather than label content
    const lowerResponse = responseText.toLowerCase();
    const refusalPatterns = [
      'i cannot', 'i can\'t', 'i\'m unable', 'i am unable',
      'i don\'t have access', 'i do not have access',
      'unfortunately', 'i\'m sorry', 'i apologize',
      'not able to', 'unable to access', 'cannot access',
      'please provide', 'you\'ll need to', 'you will need to',
      'copy and paste', 'copy the', 'paste the',
      'however,', 'instead,', 'alternatively,'
    ];
    
    const looksLikeRefusal = refusalPatterns.some(pattern => lowerResponse.includes(pattern));
    
    if (looksLikeRefusal) {
      // This is an explanation/refusal - return as error, not label content
      return {
        understanding: 'Unable to complete this request',
        labels: [],
        suggestedType: '5160',
        quantity: 0,
        error: responseText.split('\n').slice(0, 4).join(' ').substring(0, 300) + (responseText.length > 300 ? '...' : '')
      };
    }
    
    // Fallback: try to create a basic response from raw text (only if it looks like actual content)
    return {
      understanding: 'Generated label content',
      labels: [{
        preview: responseText.split('\n')[0] || 'Label',
        lines: responseText.split('\n').filter(l => l.trim()).slice(0, 4),
        svg: null
      }],
      suggestedType: '5160',
      quantity: 1,
      error: null
    };
  }
}

// Show AI Preview modal with results
function showAIPreviewModal(previewData, originalPrompt, category) {
  // Store state
  aiPreviewState = {
    originalPrompt: originalPrompt,
    category: category,
    understanding: previewData.understanding || 'Generated labels',
    labels: previewData.labels || [],
    suggestedType: previewData.suggestedType || '5160',
    quantity: previewData.quantity || 1,
    error: previewData.error || null,
    svgLeft: null,
    svgRight: null
  };
  
  // Extract SVG from first label if present
  if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
    const svg = aiPreviewState.labels[0].svg;
    if (svg.startsWith('SVG_LEFT:')) {
      aiPreviewState.svgLeft = svg.substring(9).trim();
    } else if (svg.startsWith('SVG_RIGHT:')) {
      aiPreviewState.svgRight = svg.substring(10).trim();
    }
  }
  
  // Populate understanding
  document.getElementById('aiPreviewUnderstanding').textContent = aiPreviewState.understanding;
  
  // Handle error state
  const labelsContainer = document.getElementById('aiPreviewLabels');
  const labelCountEl = document.getElementById('aiPreviewLabelCount');
  const acceptBtn = document.getElementById('aiPreviewAcceptBtn');
  
  if (aiPreviewState.error) {
    // Show error message instead of labels
    labelCountEl.textContent = '0';
    labelsContainer.innerHTML = `
      <div class="ai-preview-error">
        <div class="ai-preview-error-icon">âš ï¸</div>
        <div class="ai-preview-error-title">Unable to generate labels</div>
        <div class="ai-preview-error-message">${escapeHtml(aiPreviewState.error)}</div>
        <div class="ai-preview-error-hint">Use the "Refine" button below to provide different information or rephrase your request.</div>
      </div>
    `;
    // Disable accept button when there's an error
    if (acceptBtn) {
      acceptBtn.disabled = true;
      acceptBtn.style.opacity = '0.5';
    }
  } else {
    // Normal flow - populate labels list
    labelCountEl.textContent = aiPreviewState.labels.length;
    labelsContainer.innerHTML = '';
    
    if (acceptBtn) {
      acceptBtn.disabled = false;
      acceptBtn.style.opacity = '1';
    }
  
    aiPreviewState.labels.forEach((label, index) => {
      const item = document.createElement('div');
      item.className = 'ai-preview-label-item';
      item.dataset.index = index;
      
      // Format preview text for display
      const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
      const displayText = previewText.replace(/\\n/g, '\n');
      
      // Build meta info
      let metaInfo = [];
      if (label.lines && label.lines.length > 0) {
        const firstLine = label.lines[0];
        if (firstLine.includes(',')) {
          const parts = firstLine.split(':')[0].split(',');
          if (parts[0]) metaInfo.push(parts[0]);
          if (parts[1]) metaInfo.push('size ' + parts[1]);
        }
      }
      if (label.svg) metaInfo.push('has graphic');
      
      item.innerHTML = `
        <div class="ai-preview-label-num">${index + 1}</div>
        <div class="ai-preview-label-content">
          <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
          ${metaInfo.length ? `<div class="ai-preview-label-meta">${metaInfo.join(' â€¢ ')}</div>` : ''}
        </div>
        <button class="ai-preview-label-edit" onclick="editPreviewLabel(${index})" title="Edit this label">âœï¸</button>
      `;
      
      labelsContainer.appendChild(item);
    });
  }
  
  // Populate settings
  const typeSpec = LABEL_TYPES[aiPreviewState.suggestedType];
  const typeDisplay = typeSpec ? `${aiPreviewState.suggestedType} ${typeSpec.desc}` : aiPreviewState.suggestedType;
  document.getElementById('aiPreviewType').textContent = typeDisplay;
  document.getElementById('aiPreviewQty').textContent = aiPreviewState.labels.length > 1 
    ? aiPreviewState.labels.length + ' labels' 
    : aiPreviewState.quantity;
  
  // Set skip checkbox state
  const skipCheckbox = document.getElementById('aiPreviewSkip');
  if (skipCheckbox) {
    skipCheckbox.checked = shouldSkipAIPreview();
  }
  
  // Hide refine panel
  hideRefinePanel();
  
  // Show modal
  document.getElementById('aiPreviewModal').classList.add('visible');
}

// Close AI Preview modal
function closeAIPreviewModal() {
  document.getElementById('aiPreviewModal').classList.remove('visible');
  hideRefinePanel();
}

// Edit a specific label in preview
function editPreviewLabel(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item || item.classList.contains('editing')) return;
  
  const label = aiPreviewState.labels[index];
  const textEl = item.querySelector('.ai-preview-label-text');
  const currentText = label.preview || label.lines?.join('\n') || '';
  
  // Switch to edit mode
  item.classList.add('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  const originalHTML = contentDiv.innerHTML;
  
  contentDiv.innerHTML = `
    <textarea class="ai-preview-edit-input" rows="3">${escapeHtml(currentText.replace(/\\n/g, '\n'))}</textarea>
    <div class="ai-preview-edit-actions">
      <button class="ai-preview-edit-save" onclick="savePreviewLabelEdit(${index})">Save</button>
      <button class="ai-preview-edit-cancel" onclick="cancelPreviewLabelEdit(${index})">Cancel</button>
    </div>
  `;
  
  // Store original HTML for cancel
  item.dataset.originalHtml = originalHTML;
  
  // Focus input
  const input = contentDiv.querySelector('.ai-preview-edit-input');
  if (input) input.focus();
}

// Save edited label
function savePreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const input = item.querySelector('.ai-preview-edit-input');
  const newText = input ? input.value.trim() : '';
  
  if (newText) {
    // Update state
    const lines = newText.split('\n').filter(l => l.trim()).slice(0, 4);
    aiPreviewState.labels[index].preview = newText.replace(/\n/g, '\\n');
    aiPreviewState.labels[index].lines = lines.map(l => 'left,11:' + l);
    
    // Rebuild item
    rebuildPreviewLabelItem(index);
  } else {
    cancelPreviewLabelEdit(index);
  }
}

// Cancel label edit
function cancelPreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  item.classList.remove('editing');
  const contentDiv = item.querySelector('.ai-preview-label-content');
  if (contentDiv && item.dataset.originalHtml) {
    contentDiv.innerHTML = item.dataset.originalHtml;
  }
}

// Rebuild label item after edit
function rebuildPreviewLabelItem(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const label = aiPreviewState.labels[index];
  const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
  const displayText = previewText.replace(/\\n/g, '\n');
  
  item.classList.remove('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  contentDiv.innerHTML = `
    <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
  `;
}

// Show refine panel
function showRefinePanel() {
  document.getElementById('aiRefineOriginal').textContent = aiPreviewState.originalPrompt;
  document.getElementById('aiRefineInput').value = '';
  document.getElementById('aiRefinePanel').classList.add('visible');
  document.getElementById('aiPreviewActions').style.display = 'none';
  document.getElementById('aiRefineInput').focus();
}

// Hide refine panel
function hideRefinePanel() {
  document.getElementById('aiRefinePanel').classList.remove('visible');
  document.getElementById('aiPreviewActions').style.display = 'flex';
}

// Regenerate with refinement
async function regenerateWithRefinement() {
  const refinement = document.getElementById('aiRefineInput').value.trim();
  if (!refinement) {
    showToast('Please add some refinement details', 'warning');
    return;
  }
  
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Build combined prompt
  const combinedPrompt = `Original request: ${aiPreviewState.originalPrompt}\n\nRefinement: ${refinement}`;
  
  // Close preview and show loading
  closeAIPreviewModal();
  
  // Re-trigger the appropriate flow
  try {
    showToast('Regenerating with your refinements...', 'info');
    
    const previewData = await callAIProviderForPreview(provider, key, combinedPrompt);
    
    if (shouldSkipAIPreview()) {
      applyAIPreviewToWizard();
    } else {
      showAIPreviewModal(previewData, combinedPrompt, aiPreviewState.category);
    }
  } catch (error) {
    console.error('AI regeneration error:', error);
    showToast(error.message || 'Failed to regenerate. Try again.', 'error');
  }
}

// Accept and apply the AI preview
function acceptAIPreview() {
  applyAIPreviewToWizard();
  closeAIPreviewModal();
  showToast('Labels created! Review and print.', 'success');
}

// Apply AI preview state to the wizard
function applyAIPreviewToWizard() {
  if (aiPreviewState.labels.length === 0) return;
  
  // If called from WF1, populate WF1 editor instead
  if (wf1_aiActive) {
    const label = aiPreviewState.labels[0];
    const lines = label.lines || [];
    
    // Build content lines from AI output
    wf1ContentLines = [];
    for (let i = 0; i < Math.min(lines.length, 4); i++) {
      const parsed = parseLabelLine(lines[i] || '');
      wf1ContentLines.push(parsed);
    }
    
    // Re-open WF1 wizard at step 6
    wf1_aiActive = false;
    showWizard('wf1Wizard');
    wf1ShowStep('wf1Step6');
    wf1PopulateEditorFromLines(wf1ContentLines);
    showToast('AI content applied!', 'success');
    return;
  }
  
  // If multiple labels, create each as separate content
  if (aiPreviewState.labels.length > 1) {
    // Save each label as content
    aiPreviewState.labels.forEach((label, i) => {
      const lines = label.lines || [];
      const parsedLines = lines.map(parseLabelLine);
      
      // Create content item
      const id = 'text_' + Date.now() + '_' + i;
      const textContent = parsedLines.map(l => l.text).join('\n');
      
      // Save to storage (simplified - just text for now)
      const savedTexts = loadSavedTexts();
      savedTexts[id] = {
        text: textContent,
        lines: parsedLines,
        isTemplate: false,
        createdAt: Date.now()
      };
      saveSavedTexts(savedTexts);
    });
    
    showToast(`${aiPreviewState.labels.length} labels saved to Content!`, 'success');
    showTab('content');
    renderContentTab();
    return;
  }
  
  // Single label - route to WF1
  const label = aiPreviewState.labels[0];
  const lines = label.lines || [];
  
  // Build content lines from AI output
  const parsedLines = [];
  for (let i = 0; i < Math.min(lines.length, 4); i++) {
    parsedLines.push(parseLabelLine(lines[i] || ''));
  }
  
  // Start WF1 and populate content at step 6
  wf1Start();
  setTimeout(function() {
    wf1PopulateEditorFromLines(parsedLines);
    
    // Handle SVG graphics
    if (aiPreviewState.svgLeft || aiPreviewState.svgRight) {
      showToast('Opening Full Editor to apply graphics...', 'info');
      window._aiGeneratedSvgLeft = aiPreviewState.svgLeft;
      window._aiGeneratedSvgRight = aiPreviewState.svgRight;
      
      wf1_fullEditorActive = true;
      setTimeout(function() {
        openFullEditorFromWizard();
        setTimeout(function() {
          if (window._aiGeneratedSvgLeft) {
            const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgLeft);
            feGraphics.left = { data: svgDataUrl, size: 'M' };
          }
          if (window._aiGeneratedSvgRight) {
            const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgRight);
            feGraphics.right = { data: svgDataUrl, size: 'M' };
          }
          updateFullEditorPreview();
          renderFeGraphics();
          window._aiGeneratedSvgLeft = null;
          window._aiGeneratedSvgRight = null;
        }, 100);
      }, 300);
    }
  }, 100);
}

// ============================================================================
// AI CONVERSATIONAL LAYER (Phase 4) â€” Natural language â†’ WF1/WF2
// ============================================================================

// Fill the AI prompt input with suggestion text
function aiConvFill(text) {
  const input = document.getElementById('aiConvInput');
  if (input) {
    input.value = text;
    input.focus();
  }
}

// Conversation history for multi-turn AI chat
let aiConvHistory = [];

// Reset conversational UI to idle state
function aiConvReset() {
  aiConvHistory = []; // Clear conversation history
  document.getElementById('aiConvInput').value = '';
  document.getElementById('aiConvStatus').style.display = 'none';
  document.getElementById('aiConvResponse').style.display = 'none';
  document.getElementById('aiConvResponse').innerHTML = '';
  document.getElementById('aiConvSuggestions').style.display = 'flex';
  document.getElementById('aiConvSendBtn').disabled = false;
  
  // Clear any pending AI state
  window._aiConvWF1Params = null;
  window._aiConvWF2Params = null;
  window._aiConvEditorParams = null;
  window._aiConvPendingContent = null;
  window._aiConvStylePreference = null;
}

// Gather current app state context for the AI system prompt
function aiConvGetAppContext() {
  const ctx = { inventory: {}, sheets: [], savedContent: [], recentHistory: [] };
  
  // Inventory summary per type
  for (const typeId of TYPE_ORDER) {
    const summary = getInventorySummary(typeId);
    if (summary && (summary.stock > 0 || summary.partialLabels > 0)) {
      ctx.inventory[typeId] = {
        type: LABEL_TYPES[typeId].desc,
        stock: summary.stock,
        stockLabels: summary.stockLabels,
        partialLabels: summary.partialLabels,
        totalLabels: summary.totalLabels
      };
    }
  }
  
  // Active sheets with room
  for (const sh of Object.values(sheets)) {
    const remaining = getRemainingCount(sh);
    if (remaining > 0) {
      const spec = LABEL_TYPES[sh.labelType];
      ctx.sheets.push({
        name: sh.name,
        type: sh.labelType,
        typeDesc: spec ? spec.desc : sh.labelType,
        remaining: remaining,
        hasDedicatedContent: sh.texts && Object.keys(sh.texts).length > 0
      });
    }
  }
  
  // Saved content (names only, not full text)
  const stArr = savedTexts || [];
  for (const t of stArr) {
    if (t.name || t.text) {
      ctx.savedContent.push(t.name || (typeof t.text === 'string' ? t.text.substring(0, 40) : 'Saved'));
    }
  }
  
  // Recent print history (last 5)
  const hist = printHistory || [];
  for (let i = 0; i < Math.min(5, hist.length); i++) {
    const h = hist[i];
    ctx.recentHistory.push({
      name: h.textName || h.name || 'Unknown',
      labelType: h.labelType,
      count: h.count || h.totalLabels || 0,
      date: h.date || h.printedAt || ''
    });
  }
  
  return ctx;
}

// Build the conversational AI system prompt
function aiConvBuildSystemPrompt(appContext) {
  const typeList = TYPE_ORDER.map(t => {
    const spec = LABEL_TYPES[t];
    const lps = spec.cols * spec.rows;
    return t + ': ' + spec.desc + ' (' + spec.sizeDisplay + ', ' + lps + '/sheet)';
  }).join('\n  ');
  
  let invSummary = 'None tracked';
  const invKeys = Object.keys(appContext.inventory);
  if (invKeys.length > 0) {
    invSummary = invKeys.map(k => {
      const i = appContext.inventory[k];
      return k + ' (' + i.type + '): ' + i.totalLabels + ' labels available';
    }).join('; ');
  }
  
  let sheetSummary = 'No active sheets with room';
  if (appContext.sheets.length > 0) {
    sheetSummary = appContext.sheets.map(s =>
      '"' + s.name + '" (' + s.type + ' ' + s.typeDesc + '): ' + s.remaining + ' spots'
    ).join('; ');
  }
  
  let histSummary = 'No recent prints';
  if (appContext.recentHistory.length > 0) {
    histSummary = appContext.recentHistory.map(h =>
      '"' + h.name + '" (' + h.labelType + ', ' + h.count + ' labels, ' + h.date + ')'
    ).join('; ');
  }
  
  return `You are the AI assistant for LabelKeeper, a label printing app. Your job is to gather information and hand off to the print workflow engine with as much context as possible.

RESPOND WITH VALID JSON ONLY. No markdown, no explanation, no code blocks.

YOUR ROLE:
- You are an INFORMATION GATHERER, not the workflow controller
- You collect details and hand off to the workflow engine (WF1)
- The workflow engine handles all navigation, UI, and printing
- ALWAYS use action "wf1" for new print jobs - never bypass the workflow

RESPONSE FORMAT:
{
  "message": "Your response to the user (see MESSAGE GUIDELINES below)",
  "action": "wf1" | "wf2" | "clarify" | "settings",
  "params": {
    "labelType": "5160" | "5163" | ... | null,
    "jobType": "individual" | "batch" | null,
    "quantity": number | null,
    "contentLines": ["alignment,size:text", ...] | null,
    "batchItems": [["line1","line2",...], ...] | null,
    "savedContentName": "name of saved content to reprint" | null,
    "printOrientation": "row" | "col1" | "col2" | null,
    "stylePreference": "professional" | "elegant" | "formal" | "simple" | "fun" | null,
    "userWillPaste": true | false | null,
    "skipToPreview": true | false | null
  }
}

INFORMATION NEEDED FOR A PRINT JOB:
1. Label type/size - IMPORTANT: Use inventory to suggest, ask by SIZE not product number
2. Content - text to print (user provides, or will paste/type in workflow)
3. Quantity - how many labels
4. Style preference (optional) - professional, elegant, formal, simple, fun
5. Review preference - when user provides complete text, ASK if they want to review/edit or go straight to print

IMPORTANT - WHEN USER PROVIDES COMPLETE TEXT:
If the user gives you the actual text content for their labels AND you have all other required info (label type, quantity), you MUST ask whether they want to:
- Review and edit the text in the editor (styling, alignment, etc.)
- Go straight to print preview

Use action "clarify" with a message like:
"I have everything ready:
â€¢ [quantity] labels on [label size]
â€¢ Text: [show their text]

Would you like to:
1. Review and adjust styling in the editor first
2. Go straight to print preview"

When user responds:
- "review", "edit", "editor", "adjust", "styling" â†’ set skipToPreview: false (or null)
- "print", "straight to print", "skip", "go ahead", "ready" â†’ set skipToPreview: true

ACTIONS:
- "clarify": Ask for missing critical information. PREFERRED when info is incomplete OR when asking about review vs print.
- "wf1": Hand off to Print Something New workflow. Use for ALL new print jobs.
- "wf2": Hand off to Print Something Again workflow. For reprinting saved content.
- "settings": User wants to manage inventory, sheets, or settings.

LABEL TYPES & SIZES:
  ${typeList}

INVENTORY-AWARE SUGGESTIONS (IMPORTANT):
When user has inventory, ALWAYS suggest based on what they have available:
- Inventory: ${invSummary}
- Active sheets: ${sheetSummary}

LABEL SIZE SELECTION STRATEGY:
1. If user has inventory: "I see you have [sizes available]. Which size works better - the [dimension] or the [dimension]?"
2. If user mentions specific use case, suggest appropriate size from their inventory
3. Do NOT ask for Avery product numbers - users don't know them
4. Frame questions by SIZE and USE CASE:
   - Small labels (1" x 2-5/8") = 5160 - good for: return address, file folders, small items
   - Medium labels (2" x 4") = 5163 - good for: shipping, name tags, general purpose
   - Large labels (3-1/3" x 4") = 5164 - good for: shipping boxes, large items
   - Name badges (2-1/3" x 3-3/8") = 5395 - good for: events, meetings

TYPE INFERENCE RULES:
- "address labels", "mailing labels", "return address" â†’ 5160 (or suggest from inventory)
- "shipping labels" â†’ 5163 or 5164 (suggest based on inventory)
- "name badges", "name tags" â†’ 5395
- "tent cards", "table cards" â†’ 5302
- "school project", "organizing", "general" â†’ SUGGEST from inventory by size, don't ask for type

Recent print history: ${histSummary}
Saved content: ${appContext.savedContent.length > 0 ? appContext.savedContent.slice(0, 8).join(', ') : 'None'}

DECISION PROCESS:
1. Parse what user ALREADY PROVIDED in their message
2. If user has inventory and needs label type: SUGGEST sizes from their stock
3. If missing critical info (type, quantity, or content approach): action "clarify"
4. Once you have enough info: action "wf1" with ALL known params
5. The workflow engine will handle everything from there

CLARIFY STRATEGY:
- Brief, conversational
- Acknowledge what you understood first
- When asking about label size, reference their inventory: "I see you have 2x4 inch and 1x2Â½ inch labels. Which size works better for your project?"
- Ask about SIZE preference, not Avery numbers

MESSAGE GUIDELINES:

For action "clarify":
- Acknowledge what you understood
- Ask specific questions about what's missing
- Reference inventory when asking about label size
- Example: "Got it - 10 labels for a school project. I see you have two sizes available: 2Ã—4 inch (good for larger text) and 1Ã—2Â½ inch (compact). Which would work better?"

For action "wf1":
- Confirm what you understood
- Explain you're handing off to the print workflow
- If they'll enter content in the workflow, mention it
- Example: "Perfect! I'll hand you off to the print workflow with: 10 labels on your 2Ã—4 inch sheets. The workflow will guide you through entering your text and previewing the labels."
- If you have their content: "I have your text ready. The workflow will show you a preview and let you adjust styling before printing."

STYLE PREFERENCES:
When user mentions style (elegant, professional, clean, fun, etc.), set stylePreference param:
- "elegant", "fancy", "script" â†’ "elegant"
- "professional", "corporate", "business" â†’ "professional"
- "formal", "sophisticated" â†’ "formal"
- "simple", "clean", "minimal" â†’ "simple"
- "fun", "playful", "colorful" â†’ "fun"

PRINT ORIENTATION:
- "first column", "column 1", "left column" â†’ printOrientation "col1"
- "second column", "column 2", "right column" â†’ printOrientation "col2"
- "row by row", "across", "normal" â†’ printOrientation "row"

CONTENT LINE FORMAT (when user provides actual text):
Format: alignment,size,color:text
- alignment: left, center, right
- size: 9 (small), 11 (normal), 14 (large)
- color: optional hex color (e.g., #2563eb for blue)
- Examples:
  - "center,14:FRAGILE" (centered, large, default black)
  - "left,11,#2563eb:John Smith" (left, normal, blue)
  - "center,14,#dc2626:URGENT" (centered, large, red)
- Default to "left,11:" if not specified

AVAILABLE COLORS (use hex codes):
- Black: #000000 (default)
- Red: #dc2626
- Blue: #2563eb
- Green: #16a34a
- Orange: #ea580c
- Purple: #9333ea
- Brown: #78350f
- Gray: #6b7280

When user requests colors, map their words to hex codes:
- "red", "urgent", "warning" â†’ #dc2626
- "blue", "corporate", "professional" â†’ #2563eb
- "green", "success", "approved" â†’ #16a34a
- "orange", "attention" â†’ #ea580c
- "purple", "special" â†’ #9333ea

RESPOND WITH JSON ONLY.`;
}

// Send the user's message to the AI
async function aiConvSend() {
  const input = document.getElementById('aiConvInput');
  const userText = (input.value || '').trim();
  if (!userText) return;
  
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Clear input immediately
  input.value = '';
  
  // Show loading
  document.getElementById('aiConvSendBtn').disabled = true;
  document.getElementById('aiConvSuggestions').style.display = 'none';
  document.getElementById('aiConvStatus').style.display = 'block';
  document.getElementById('aiConvStatusText').textContent = 'Thinking...';
  document.getElementById('aiConvResponse').style.display = 'none';
  
  // Add user message to history
  aiConvHistory.push({ role: 'user', content: userText });
  
  try {
    const appContext = aiConvGetAppContext();
    const systemPrompt = aiConvBuildSystemPrompt(appContext);
    
    // Call AI provider with full conversation history
    let responseText = await aiConvCallProvider(provider, key, systemPrompt, aiConvHistory);
    
    // Parse JSON
    let result;
    try {
      let clean = responseText.trim();
      if (clean.startsWith('```json')) clean = clean.slice(7);
      else if (clean.startsWith('```')) clean = clean.slice(3);
      if (clean.endsWith('```')) clean = clean.slice(0, -3);
      clean = clean.trim();
      result = JSON.parse(clean);
    } catch (e) {
      console.error('Failed to parse AI conv response:', responseText);
      result = { message: 'I had trouble understanding that. Could you try describing what labels you need?', action: 'clarify', params: {} };
    }
    
    // Add assistant response to history (store the message for context)
    aiConvHistory.push({ role: 'assistant', content: result.message || responseText });
    
    // Hide loading
    document.getElementById('aiConvStatus').style.display = 'none';
    
    // Handle the result
    aiConvHandleResult(result, userText);
    
  } catch (error) {
    console.error('AI conv error:', error);
    // Remove the failed user message from history
    aiConvHistory.pop();
    document.getElementById('aiConvStatus').style.display = 'none';
    document.getElementById('aiConvResponse').style.display = 'block';
    document.getElementById('aiConvResponse').innerHTML =
      '<div class="ai-conv-error">âš ï¸ ' + escapeHtml(error.message || 'Failed to connect to AI. Check your API key.') + '</div>' +
      '<div style="margin-top:8px;"><button class="ai-conv-action-btn" onclick="aiConvReset()">Try Again</button></div>';
  } finally {
    document.getElementById('aiConvSendBtn').disabled = false;
  }
}

// Call the AI provider for conversational intent parsing
async function aiConvCallProvider(provider, key, systemPrompt, conversationHistory) {
  // Build messages array from conversation history
  // For multi-turn, we need proper role alternation
  
  if (provider === 'claude') {
    // Claude uses system prompt separately, messages array for conversation
    // First message includes system context, then alternating user/assistant
    const messages = [];
    
    // For the first turn, include system prompt with the user message
    // For subsequent turns, just use the conversation history
    if (conversationHistory.length === 1) {
      messages.push({ 
        role: 'user', 
        content: systemPrompt + '\n\nUser: ' + conversationHistory[0].content 
      });
    } else {
      // Multi-turn: include system prompt context with first message
      for (let i = 0; i < conversationHistory.length; i++) {
        const msg = conversationHistory[i];
        if (i === 0) {
          messages.push({ 
            role: 'user', 
            content: systemPrompt + '\n\nUser: ' + msg.content 
          });
        } else {
          messages.push({ 
            role: msg.role, 
            content: msg.role === 'user' ? 'User: ' + msg.content : msg.content 
          });
        }
      }
    }
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 800,
        messages: messages
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'Claude API error: ' + response.status);
    }
    const data = await response.json();
    return data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    // OpenAI uses system message + conversation history
    const messages = [{ role: 'system', content: systemPrompt }];
    for (const msg of conversationHistory) {
      messages.push({ role: msg.role, content: msg.content });
    }
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + key
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 800,
        messages: messages
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'OpenAI API error: ' + response.status);
    }
    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    // Gemini uses contents array with role-based parts
    const contents = [];
    for (const msg of conversationHistory) {
      contents.push({
        role: msg.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: msg.role === 'user' && contents.length === 0 
          ? systemPrompt + '\n\nUser: ' + msg.content 
          : msg.content }]
      });
    }
    
    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=' + key, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: contents,
        generationConfig: { maxOutputTokens: 800 }
      })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || 'Gemini API error: ' + response.status);
    }
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
}

// Format AI message for display - converts newlines to <br> and escapes HTML
function formatAiMessage(msg) {
  if (!msg) return '';
  return escapeHtml(msg).replace(/\\n/g, '<br>').replace(/\n/g, '<br>');
}

// Handle the structured AI response
function aiConvHandleResult(result, userText) {
  const responseEl = document.getElementById('aiConvResponse');
  const params = result.params || {};
  
  if (result.action === 'clarify') {
    // AI needs more info â€” show message and keep input active for follow-up
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Start Over</button>' +
      '</div>';
    // Focus input for follow-up response (input already cleared in aiConvSend)
    document.getElementById('aiConvInput').focus();
    return;
  }
  
  if (result.action === 'settings') {
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn" onclick="switchTab(\'inventory\');aiConvReset()">Open Inventory</button>' +
        '<button class="ai-conv-action-btn" onclick="switchTab(\'sheets\');aiConvReset()">Open Sheets</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Dismiss</button>' +
      '</div>';
    return;
  }
  
  if (result.action === 'editor') {
    // DEPRECATED: Editor action now routes through WF1 for proper workflow integration
    // Convert editor params to WF1 params and use WF1 instead
    console.log('[AI] Redirecting deprecated "editor" action to WF1');
    
    // Map editor params to WF1 params
    params.userWillPaste = (params.editorMode === 'paste');
    params.jobType = params.jobType || 'individual';
    
    // Fall through to WF1 handling
    result.action = 'wf1';
    // Don't return - continue to WF1 block below
  }
  
  if (result.action === 'wf2') {
    // Show confirmation then launch WF2
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(result.message) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn primary" onclick="aiConvLaunchWF2();aiConvReset()">Print Again â†’</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Cancel</button>' +
      '</div>';
    // Store params for WF2 launch
    window._aiConvWF2Params = params;
    return;
  }
  
  if (result.action === 'wf1') {
    // Determine what we can pre-fill and describe it
    const labelType = params.labelType || null;
    const spec = labelType ? LABEL_TYPES[labelType] : null;
    const typeDesc = spec ? spec.desc + ' (' + labelType + ')' : null;
    const jobType = params.jobType || null;
    const qty = params.quantity || null;
    const hasContent = (params.contentLines && params.contentLines.length > 0) || (params.batchItems && params.batchItems.length > 0);
    
    // Build summary of what will be pre-filled
    let summary = result.message;
    
    responseEl.style.display = 'block';
    responseEl.innerHTML =
      '<div class="ai-conv-msg">' + formatAiMessage(summary) + '</div>' +
      '<div class="ai-conv-actions">' +
        '<button class="ai-conv-action-btn primary" onclick="aiConvLaunchWF1();aiConvReset()">Let\'s Go â†’</button>' +
        '<button class="ai-conv-action-btn" onclick="aiConvReset()">Cancel</button>' +
      '</div>';
    // Store params for WF1 launch
    window._aiConvWF1Params = params;
    return;
  }
  
  // Fallback
  responseEl.style.display = 'block';
  responseEl.innerHTML =
    '<div class="ai-conv-msg">' + formatAiMessage(result.message || 'I\'m not sure what to do with that.') + '</div>' +
    '<div class="ai-conv-actions">' +
      '<button class="ai-conv-action-btn" onclick="aiConvReset()">Try Again</button>' +
    '</div>';
}

// Launch WF1 with AI-determined parameters
function aiConvLaunchWF1() {
  const params = window._aiConvWF1Params || {};
  window._aiConvWF1Params = null;
  
  // Clear any stale AI state
  window._aiConvPendingContent = null;
  window._aiConvStylePreference = null;
  
  // Store style preference for later application (only if provided)
  if (params.stylePreference) {
    window._aiConvStylePreference = params.stylePreference;
  }
  
  // Start WF1 - this resets all workflow state
  wf1Start();
  
  // Pre-set print orientation if specified
  if (params.printOrientation) {
    const orientMap = { 'row': 'next', 'col1': 'col1', 'col2': 'col2' };
    wf1Orientation = orientMap[params.printOrientation] || 'next';
  }
  
  // Determine what we actually have from AI
  const hasLabelType = params.labelType && LABEL_TYPES[params.labelType];
  const hasJobType = params.jobType === 'individual' || params.jobType === 'batch';
  const hasQuantity = params.quantity && params.quantity > 0;
  const hasContent = params.contentLines && params.contentLines.length > 0;
  const wantsSkipToPreview = params.skipToPreview === true;
  
  console.log('[AIâ†’WF1] Params received:', {
    labelType: params.labelType || '(none)',
    jobType: params.jobType || '(none)',
    quantity: params.quantity || '(none)',
    contentLines: hasContent ? params.contentLines.length + ' lines' : '(none)',
    skipToPreview: wantsSkipToPreview
  });
  
  // If we don't even have label type, just show step 1
  if (!hasLabelType) {
    console.log('[AIâ†’WF1] No label type - stopping at step 1');
    return;
  }
  
  // We have label type - select it and advance
  wf1LabelType = params.labelType;
  wf1RenderTypeGrid();
  
  setTimeout(function() {
    wf1SelectType(params.labelType);
    wf1ToStep2(); // Go to inventory check
    
    // If we don't have job type or quantity, stop here and let user continue
    if (!hasJobType) {
      console.log('[AIâ†’WF1] No job type - stopping at step 2');
      return;
    }
    
    // We have job type - continue to step 3
    setTimeout(function() {
      wf1ToStep3();
      
      // Set job type
      wf1SetJobType(params.jobType);
      
      // Set quantity if provided
      if (hasQuantity && params.jobType === 'individual') {
        wf1Quantity = params.quantity;
        const qtyEl = document.getElementById('wf1QtyValue');
        if (qtyEl) qtyEl.textContent = wf1Quantity;
      }
      
      // If no quantity for individual job, stop here
      if (params.jobType === 'individual' && !hasQuantity) {
        console.log('[AIâ†’WF1] Individual job but no quantity - stopping at step 3');
        return;
      }
      
      // Continue to feasibility check
      setTimeout(function() {
        wf1ToStep4();
        
        // Continue to sheet selection
        setTimeout(function() {
          wf1ToStep5();
          
          // Auto-select sheet if possible
          setTimeout(function() {
            if (!wf1SelectedSheet) {
              const matchingSheets = Object.values(sheets).filter(s => 
                s.labelType === wf1LabelType && !s.retired && getRemainingCount(s) >= wf1Quantity
              );
              if (matchingSheets.length > 0) {
                wf1SelectSheet(matchingSheets[0].id);
              } else {
                // Check for any sheet with room, or use new sheet
                const anyWithRoom = Object.values(sheets).filter(s => 
                  s.labelType === wf1LabelType && !s.retired && getRemainingCount(s) > 0
                );
                if (anyWithRoom.length > 0) {
                  wf1SelectSheet(anyWithRoom[0].id);
                } else {
                  wf1SelectSheet('__new__');
                }
              }
            }
            
            // If no content, stop at sheet selection
            if (!hasContent) {
              console.log('[AIâ†’WF1] No content - stopping at step 5');
              return;
            }
            
            // We have content - continue to step 6
            setTimeout(function() {
              wf1ToStep6();
              
              // Pre-fill content
              wf1ContentLines = [];
              for (var i = 0; i < Math.min(params.contentLines.length, 4); i++) {
                wf1ContentLines.push(parseLabelLine(params.contentLines[i] || ''));
              }
              wf1PopulateEditorFromLines(wf1ContentLines);
              wf1UpdateContentNextBtn();
              
              // If user wants to skip to preview
              if (wantsSkipToPreview) {
                setTimeout(function() {
                  wf1ToStep7();
                  showToast('Ready to print! Check the preview below.', 'success');
                }, 200);
              } else {
                showToast('Review your content and click Next when ready', 'info');
              }
            }, 200);
          }, 200);
        }, 200);
      }, 200);
    }, 200);
  }, 100);
}

// Called when WF1 reaches step 6 â€” no longer used for content fill (handled in aiConvLaunchWF1)
// Kept for compatibility but now just clears stale state
function aiConvFillContentIfPending() {
  // Content is now filled directly in aiConvLaunchWF1
  // This function just clears any stale state
  window._aiConvPendingContent = null;
}

// Continue advancing WF1 through steps based on AI params
function aiConvAdvanceWF1(params) {
  // We're at step 2 (inventory). Auto-continue to step 3.
  if (wf1Step === 2) {
    wf1ToStep3();
  }
  
  setTimeout(function() {
    // At step 3 (content type choice) â€” set job type and quantity
    if (wf1Step === 3) {
      if (params.jobType === 'batch' && params.batchItems && params.batchItems.length > 0) {
        // Set batch
        if (params.quantity) wf1Quantity = params.quantity;
        wf1SetJobType('batch');
      } else {
        // Individual
        if (params.quantity) wf1Quantity = params.quantity;
        wf1SetJobType('individual');
        // Update quantity display if we have one
        if (params.quantity) {
          wf1Quantity = params.quantity;
          var qtyEl = document.getElementById('wf1QtyValue');
          if (qtyEl) qtyEl.textContent = wf1Quantity;
        }
      }
    }
    
    // Auto-continue to step 4 after a moment
    setTimeout(function() {
      wf1ToStep4();
      // Content fill happens via aiConvFillContentIfPending() when step 6 renders
    }, 200);
  }, 200);
}

// Launch WF2 with AI-determined parameters
function aiConvLaunchWF2() {
  var params = window._aiConvWF2Params || {};
  window._aiConvWF2Params = null;
  
  wf2Start();
  
  // If a specific saved content name was referenced, try to find and select it
  if (params.savedContentName) {
    setTimeout(function() {
      // Look for matching content in WF2's content browser
      var cards = document.querySelectorAll('#wf2ContentSelector .wf2-content-card');
      for (var i = 0; i < cards.length; i++) {
        var nameEl = cards[i].querySelector('.wf2-content-card-name');
        if (nameEl && nameEl.textContent.toLowerCase().includes(params.savedContentName.toLowerCase())) {
          cards[i].click();
          showToast('Found matching content', 'success');
          break;
        }
      }
    }, 300);
  }
}

// Launch Full Editor directly with AI-determined parameters
function aiConvLaunchEditor() {
  var params = window._aiConvEditorParams || {};
  window._aiConvEditorParams = null;
  
  // Store print orientation preference if specified
  if (params.printOrientation) {
    window._aiConvPrintOrientation = params.printOrientation;
    showToast('Print orientation: ' + (params.printOrientation === 'col1' ? 'Column 1 first' : params.printOrientation === 'col2' ? 'Column 2 first' : 'Row by row'), 'info');
  }
  
  // Store quantity if specified
  if (params.quantity) {
    window._aiConvQuantity = params.quantity;
  }
  
  // Set label type in settings if specified (for preview)
  if (params.labelType && LABEL_TYPES[params.labelType]) {
    settings.lastLabelType = params.labelType;
    saveSettings();
  }
  
  // Open the Full Editor
  const isTemplate = params.editorMode === 'template';
  openFullEditor(null, isTemplate);
  
  // If paste mode AND clipboard is ready, trigger paste after editor opens
  // If clipboardReady is explicitly false, user was told to go copy first - don't auto-paste
  if (params.editorMode === 'paste' && params.clipboardReady === true) {
    setTimeout(function() {
      pasteToEditor();
    }, 400);
  }
}

// Parse a label line format "alignment,size,color:text"
// Color is optional - format can be "align,size:text" or "align,size,#hex:text"
function parseLabelLine(rawLine) {
  let text = rawLine;
  let align = 'left';
  let fontSize = 11;
  let color = '';
  
  if (!rawLine) return { text: '', align, fontSize, color };
  
  const colonIndex = rawLine.indexOf(':');
  if (colonIndex > 0 && colonIndex < 25) {
    const prefix = rawLine.substring(0, colonIndex);
    const parts = prefix.split(',');
    
    if (parts.length >= 1 && ['left', 'center', 'right'].includes(parts[0])) {
      align = parts[0];
      text = rawLine.substring(colonIndex + 1);
      
      if (parts.length >= 2) {
        const size = parseInt(parts[1]);
        if ([9, 11, 14].includes(size)) {
          fontSize = size;
        }
      }
      
      if (parts.length >= 3 && parts[2]) {
        // Validate hex color format
        const colorVal = parts[2].trim();
        if (/^#[0-9A-Fa-f]{6}$/.test(colorVal)) {
          color = colorVal;
        }
      }
    }
  }
  
  return { text, align, fontSize, color };
}

// ============================================================================
// FULL EDITOR (ported from v1.2.0)
// ============================================================================

// Full editor state
let feEditingId = null;  // ID of text being edited (null = new)
let feIsTemplate = false;
let feIsStyleTemplate = false; // Editing a style template (text disabled)
let feLines = [
  { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
];
let feAlignV = 'center';
let feGraphics = { left: null, right: null };
let feActiveStylePopover = null;
let feGraphicPickerSide = null;

// New: Dirty tracking
let feDirty = false;
let feOriginalState = null;

// New: Border state
let feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };

// New: Barcode state
let feCurrentBarcode = null;

// New: Preview label type
let fePreviewLabelType = '5160';

// Color palette
const FE_COLORS = ['#000000', '#dc2626', '#2563eb', '#16a34a', '#ea580c', '#9333ea', '#78350f', '#6b7280'];

// Font family definitions
const FE_FONTS = [
  { id: 'default', name: 'Default (DM Sans)', family: "'DM Sans', sans-serif" },
  { id: 'serif', name: 'Serif (Merriweather)', family: "'Merriweather', Georgia, serif" },
  { id: 'mono', name: 'Monospace', family: "'JetBrains Mono', monospace" },
  { id: 'script', name: 'Script (Dancing Script)', family: "'Dancing Script', cursive" },
  { id: 'elegant', name: 'Elegant (Playfair)', family: "'Playfair Display', serif" },
  { id: 'handwritten', name: 'Handwritten (Caveat)', family: "'Caveat', cursive" },
  { id: 'formal', name: 'Formal (Cormorant)', family: "'Cormorant Garamond', serif" },
  { id: 'display', name: 'Display (Oswald)', family: "'Oswald', sans-serif" },
  { id: 'fun', name: 'Fun (Pacifico)', family: "'Pacifico', cursive" },
  { id: 'bold', name: 'Bold (Lobster)', family: "'Lobster', cursive" }
];

// Get font family CSS from font ID
function getFontFamily(fontId) {
  const font = FE_FONTS.find(f => f.id === fontId);
  return font ? font.family : FE_FONTS[0].family;
}

// Style template categories (for grouping in dropdowns)
const STYLE_TEMPLATE_CATEGORIES = {
  holiday: { label: 'ðŸŽ„ Holiday', order: 1 },
  wedding: { label: 'ðŸ’’ Wedding', order: 2 },
  birthday: { label: 'ðŸŽ‚ Birthday', order: 3 },
  baby: { label: 'ðŸ‘¶ Baby', order: 4 },
  professional: { label: 'ðŸ’¼ Professional', order: 5 },
  school: { label: 'ðŸ“š School', order: 6 },
  seasonal: { label: 'ðŸ‚ Seasonal', order: 7 },
  simple: { label: 'âœ¨ Simple & Clean', order: 8 }
};

// Built-in Style Templates
// Get import templates (type: 'template') - for batch printing / CSV import
function getImportTemplates() {
  const builtinImport = BUILTIN_TEMPLATES.filter(t => t.type === 'template');
  const userImport = savedTexts.filter(t => t.type === 'template');
  return [...builtinImport, ...userImport];
}

// Get style templates (type: 'style') - for applying visual styles
function getStyleTemplates() {
  const builtinStyles = BUILTIN_TEMPLATES.filter(t => t.type === 'style');
  const userStyles = savedTexts.filter(t => t.type === 'style');
  return [...builtinStyles, ...userStyles];
}

// Alias for backward compatibility
function getAllStyleTemplates() {
  return getStyleTemplates();
}

// Get style template by ID
function getStyleTemplate(id) {
  return getAllStyleTemplates().find(t => t.id === id);
}

// Built-in graphics library (full 83-icon library from v1.8.0)
const FE_GRAPHICS_CATEGORIES = {
  school: { label: 'ðŸ“š School', order: 1 },
  mailing: { label: 'âœ‰ï¸ Mailing', order: 2 },
  winter: { label: 'â„ï¸ Winter', order: 3 },
  spring: { label: 'ðŸŒ· Spring', order: 4 },
  summer: { label: 'â˜€ï¸ Summer/Fall', order: 5 },
  occasion: { label: 'ðŸŽ‰ Occasions', order: 6 },
  symbol: { label: 'âš¡ Symbols', order: 7 }
};

const FE_GRAPHICS_LIBRARY = [
  // School & Education (~15)
  {id:'apple',cat:'school',name:'Apple',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="38" rx="20" ry="22" fill="#ef4444"/><path d="M32 16 Q36 8 42 10" stroke="#16a34a" stroke-width="3" fill="none"/><ellipse cx="34" cy="12" rx="6" ry="4" fill="#22c55e"/></svg>'},
  {id:'book',cat:'school',name:'Book',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 h20 v48 h-20 a4 4 0 0 1 -4 -4 v-40 a4 4 0 0 1 4 -4z" fill="#3b82f6"/><path d="M28 8 h20 a4 4 0 0 1 4 4 v40 a4 4 0 0 1 -4 4 h-20 v-48z" fill="#2563eb"/><line x1="28" y1="8" x2="28" y2="56" stroke="#1d4ed8" stroke-width="2"/><line x1="14" y1="20" x2="24" y2="20" stroke="#93c5fd" stroke-width="2"/><line x1="14" y1="28" x2="22" y2="28" stroke="#93c5fd" stroke-width="2"/></svg>'},
  {id:'pencil',cat:'school',name:'Pencil',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="12,52 8,60 16,56 52,20 48,16" fill="#fbbf24"/><polygon points="52,20 56,16 52,8 48,12 48,16" fill="#f472b6"/><polygon points="8,60 12,52 16,56" fill="#1f2937"/></svg>'},
  {id:'ruler',cat:'school',name:'Ruler',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="16" rx="2" fill="#fbbf24"/><g stroke="#92400e" stroke-width="1.5"><line x1="16" y1="24" x2="16" y2="32"/><line x1="24" y1="24" x2="24" y2="28"/><line x1="32" y1="24" x2="32" y2="32"/><line x1="40" y1="24" x2="40" y2="28"/><line x1="48" y1="24" x2="48" y2="32"/></g></svg>'},
  {id:'scissors',cat:'school',name:'Scissors',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="48" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><circle cx="18" cy="16" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="42" x2="56" y2="28" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="22" x2="56" y2="36" stroke="#6b7280" stroke-width="4"/></svg>'},
  {id:'crayon',cat:'school',name:'Crayon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="40" rx="4" fill="#ef4444"/><polygon points="12,16 32,4 52,16" fill="#fca5a5"/><rect x="20" y="24" width="24" height="8" fill="#fef2f2"/></svg>'},
  {id:'globe',cat:'school',name:'Globe',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="28" r="24" fill="#3b82f6"/><ellipse cx="32" cy="28" rx="10" ry="24" fill="none" stroke="#1d4ed8" stroke-width="2"/><line x1="8" y1="28" x2="56" y2="28" stroke="#1d4ed8" stroke-width="2"/><path d="M12 18 Q32 24 52 18" fill="none" stroke="#1d4ed8" stroke-width="2"/><path d="M12 38 Q32 32 52 38" fill="none" stroke="#1d4ed8" stroke-width="2"/><rect x="28" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'backpack',cat:'school',name:'Backpack',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="44" rx="6" fill="#8b5cf6"/><rect x="20" y="32" width="24" height="16" rx="2" fill="#c4b5fd"/><path d="M20 16 Q20 4 32 4 Q44 4 44 16" fill="none" stroke="#6d28d9" stroke-width="4"/></svg>'},
  {id:'bus',cat:'school',name:'School Bus',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="56" height="28" rx="4" fill="#fbbf24"/><rect x="8" y="24" width="12" height="12" fill="#fef3c7"/><rect x="24" y="24" width="12" height="12" fill="#fef3c7"/><rect x="40" y="24" width="12" height="12" fill="#fef3c7"/><circle cx="16" cy="52" r="6" fill="#1f2937"/><circle cx="48" cy="52" r="6" fill="#1f2937"/><rect x="4" y="14" width="56" height="6" fill="#f59e0b"/></svg>'},
  {id:'gradcap',cat:'school',name:'Graduation Cap',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,8 4,24 32,40 60,24" fill="#1f2937"/><rect x="28" y="24" width="8" height="24" fill="#1f2937"/><path d="M16 28 v16 Q32 56 48 44 v-16" fill="#374151"/><circle cx="56" cy="44" r="4" fill="#fbbf24"/><line x1="56" y1="24" x2="56" y2="44" stroke="#fbbf24" stroke-width="2"/></svg>'},
  {id:'abc',cat:'school',name:'ABC Blocks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="32" width="24" height="24" fill="#ef4444"/><rect x="20" y="20" width="24" height="24" fill="#22c55e"/><rect x="36" y="8" width="24" height="24" fill="#3b82f6"/><text x="16" y="50" text-anchor="middle" fill="white" font-size="14" font-weight="bold">A</text><text x="32" y="38" text-anchor="middle" fill="white" font-size="14" font-weight="bold">B</text><text x="48" y="26" text-anchor="middle" fill="white" font-size="14" font-weight="bold">C</text></svg>'},
  {id:'star',cat:'school',name:'Star',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#f59e0b"/></svg>'},
  {id:'microscope',cat:'school',name:'Microscope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="48" width="24" height="8" rx="2" fill="#6b7280"/><rect x="36" y="12" width="8" height="36" fill="#9ca3af"/><circle cx="40" cy="12" r="8" fill="#3b82f6"/><rect x="16" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'music',cat:'school',name:'Music Note',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="48" rx="10" ry="8" fill="#1f2937"/><rect x="28" y="12" width="4" height="36" fill="#1f2937"/><path d="M32 12 Q48 8 48 20 Q48 28 32 24" fill="#1f2937"/></svg>'},
  {id:'owl',cat:'school',name:'Owl',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="24" fill="#92400e"/><circle cx="22" cy="28" r="10" fill="white"/><circle cx="42" cy="28" r="10" fill="white"/><circle cx="22" cy="28" r="5" fill="#1f2937"/><circle cx="42" cy="28" r="5" fill="#1f2937"/><polygon points="32,34 28,42 36,42" fill="#f59e0b"/><path d="M16 12 Q22 20 32 16 Q42 20 48 12" fill="#78350f"/></svg>'},
  
  // Mailing & Address (~12)
  {id:'mail',cat:'mailing',name:'Envelope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="56" height="36" rx="4" fill="#3b82f6"/><path d="M4 18 L32 36 L60 18" stroke="#1d4ed8" stroke-width="3" fill="none"/></svg>'},
  {id:'mailbox',cat:'mailing',name:'Mailbox',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 24 h48 v24 a8 8 0 0 1 -8 8 h-32 a8 8 0 0 1 -8 -8 z" fill="#3b82f6"/><path d="M8 24 a24 24 0 0 1 48 0" fill="#2563eb"/><rect x="28" y="56" width="8" height="8" fill="#6b7280"/><rect x="44" y="20" width="8" height="16" fill="#ef4444"/></svg>'},
  {id:'stamp',cat:'mailing',name:'Stamp',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="48" height="48" fill="#f5f5f4"/><rect x="12" y="12" width="40" height="40" fill="#3b82f6"/><circle cx="32" cy="32" r="12" fill="#1d4ed8"/><text x="32" y="37" text-anchor="middle" fill="white" font-size="12" font-weight="bold">USA</text></svg>'},
  {id:'home',cat:'mailing',name:'House',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 8 L4 32 L12 32 L12 56 L52 56 L52 32 L60 32 Z" fill="#78716c"/><rect x="26" y="38" width="12" height="18" fill="#292524"/><rect x="18" y="32" width="8" height="8" fill="#7dd3fc"/><rect x="38" y="32" width="8" height="8" fill="#7dd3fc"/></svg>'},
  {id:'pin',cat:'mailing',name:'Location Pin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 58 Q8 34 8 24 A24 24 0 1 1 56 24 Q56 34 32 58z" fill="#ef4444"/><circle cx="32" cy="24" r="10" fill="white"/></svg>'},
  {id:'airplane',cat:'mailing',name:'Airplane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 20 L58 28 L36 32 L36 52 L44 58 L36 56 L32 62 L28 56 L20 58 L28 52 L28 32 L6 28 L28 20 Z" fill="#6b7280"/></svg>'},
  {id:'package',cat:'mailing',name:'Package',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/><rect x="24" y="32" width="16" height="8" fill="white"/></svg>'},
  {id:'fragile',cat:'mailing',name:'Fragile',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8 L44 8 L44 28 Q44 48 32 56 Q20 48 20 28 Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20 L32 32 L28 32 L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'heart',cat:'mailing',name:'Heart',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56 C16 44 4 32 4 20 C4 10 12 4 22 4 C28 4 32 8 32 8 C32 8 36 4 42 4 C52 4 60 10 60 20 C60 32 48 44 32 56Z" fill="#ef4444"/></svg>'},
  {id:'paw',cat:'mailing',name:'Paw Print',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="16" ry="14" fill="#78350f"/><ellipse cx="18" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="46" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="12" cy="36" rx="6" ry="8" fill="#78350f"/><ellipse cx="52" cy="36" rx="6" ry="8" fill="#78350f"/></svg>'},
  {id:'certified',cat:'mailing',name:'Certified',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'priority',cat:'mailing',name:'Priority',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="32" fill="#ef4444"/><text x="32" y="38" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PRIORITY</text></svg>'},
  
  // Winter Holidays (~12)
  {id:'snowflake',cat:'winter',name:'Snowflake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g stroke="#3b82f6" stroke-width="3" fill="none"><line x1="32" y1="4" x2="32" y2="60"/><line x1="8" y1="18" x2="56" y2="46"/><line x1="8" y1="46" x2="56" y2="18"/><line x1="32" y1="12" x2="26" y2="6"/><line x1="32" y1="12" x2="38" y2="6"/><line x1="32" y1="52" x2="26" y2="58"/><line x1="32" y1="52" x2="38" y2="58"/></g></svg>'},
  {id:'tree',cat:'winter',name:'Christmas Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="26" y="50" width="12" height="10" fill="#78350f"/><polygon points="32,4 8,50 56,50" fill="#16a34a"/><polygon points="32,14 14,42 50,42" fill="#22c55e"/><circle cx="32" cy="8" r="4" fill="#fbbf24"/><circle cx="24" cy="32" r="3" fill="#ef4444"/><circle cx="40" cy="36" r="3" fill="#3b82f6"/><circle cx="32" cy="44" r="3" fill="#fbbf24"/></svg>'},
  {id:'candycane',cat:'winter',name:'Candy Cane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="#ef4444" stroke-width="8" stroke-linecap="round"/><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" stroke-dasharray="8 8"/></svg>'},
  {id:'gift',cat:'winter',name:'Gift Box',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="8" fill="#ef4444"/><rect x="12" y="32" width="40" height="24" fill="#fca5a5"/><rect x="28" y="24" width="8" height="32" fill="#dc2626"/><ellipse cx="24" cy="20" rx="8" ry="6" fill="#fbbf24"/><ellipse cx="40" cy="20" rx="8" ry="6" fill="#fbbf24"/></svg>'},
  {id:'ornament',cat:'winter',name:'Ornament',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="36" r="24" fill="#ef4444"/><rect x="28" y="8" width="8" height="8" fill="#fbbf24"/><circle cx="32" cy="12" r="4" fill="#fbbf24" fill-opacity="0.5"/><path d="M20 28 Q32 44 44 28" stroke="#fca5a5" stroke-width="3" fill="none"/></svg>'},
  {id:'stocking',cat:'winter',name:'Stocking',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 4 L44 4 L44 32 Q44 52 28 56 Q12 52 12 40 L12 32 L20 32 Z" fill="#ef4444"/><rect x="16" y="4" width="32" height="8" fill="white"/></svg>'},
  {id:'gingerbread',cat:'winter',name:'Gingerbread',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="14" r="10" fill="#d4a574"/><rect x="22" y="22" width="20" height="20" fill="#d4a574"/><rect x="8" y="26" width="16" height="8" fill="#d4a574"/><rect x="40" y="26" width="16" height="8" fill="#d4a574"/><rect x="24" y="42" width="6" height="16" fill="#d4a574"/><rect x="34" y="42" width="6" height="16" fill="#d4a574"/><circle cx="28" cy="12" r="2" fill="#1f2937"/><circle cx="36" cy="12" r="2" fill="#1f2937"/><path d="M28 18 Q32 22 36 18" stroke="#ef4444" stroke-width="2" fill="none"/></svg>'},
  {id:'menorah',cat:'winter',name:'Menorah',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="24" width="8" height="32" fill="#fbbf24"/><g fill="#fbbf24"><rect x="8" y="32" width="4" height="16"/><rect x="16" y="32" width="4" height="16"/><rect x="24" y="32" width="4" height="16"/><rect x="36" y="32" width="4" height="16"/><rect x="44" y="32" width="4" height="16"/><rect x="52" y="32" width="4" height="16"/></g><rect x="4" y="48" width="56" height="4" fill="#fbbf24"/><g fill="#f97316"><ellipse cx="10" cy="28" rx="3" ry="5"/><ellipse cx="18" cy="28" rx="3" ry="5"/><ellipse cx="26" cy="28" rx="3" ry="5"/><ellipse cx="32" cy="20" rx="3" ry="5"/><ellipse cx="38" cy="28" rx="3" ry="5"/><ellipse cx="46" cy="28" rx="3" ry="5"/><ellipse cx="54" cy="28" rx="3" ry="5"/></g></svg>'},
  {id:'snowman',cat:'winter',name:'Snowman',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="48" r="16" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="26" r="12" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="10" r="8" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="29" cy="8" r="2" fill="#1f2937"/><circle cx="35" cy="8" r="2" fill="#1f2937"/><polygon points="32,10 40,14 32,14" fill="#f97316"/><rect x="24" y="2" width="16" height="4" fill="#1f2937"/><rect x="28" y="0" width="8" height="4" fill="#1f2937"/></svg>'},
  {id:'wreath',cat:'winter',name:'Wreath',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="24" fill="none" stroke="#16a34a" stroke-width="12"/><circle cx="32" cy="8" r="6" fill="#ef4444"/><path d="M28 6 Q32 2 36 6" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'santahat',cat:'winter',name:'Santa Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 52 Q32 32 56 52 L32 8 Z" fill="#ef4444"/><ellipse cx="32" cy="54" rx="28" ry="6" fill="white"/><circle cx="32" cy="10" r="6" fill="white"/></svg>'},
  {id:'mittens',cat:'winter',name:'Mittens',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 24 L12 52 a8 8 0 0 0 8 8 h8 a8 8 0 0 0 8 -8 v-28" fill="#3b82f6"/><path d="M12 32 L4 28 L4 40 L12 40" fill="#3b82f6"/><rect x="12" y="20" width="24" height="8" fill="#93c5fd"/></svg>'},
  
  // Spring (~10)
  {id:'egg',cat:'spring',name:'Easter Egg',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="20" ry="26" fill="#c4b5fd"/><path d="M12 32 Q22 40 32 32 Q42 24 52 32" stroke="#8b5cf6" stroke-width="3" fill="none"/><path d="M12 42 Q22 50 32 42 Q42 34 52 42" stroke="#a78bfa" stroke-width="3" fill="none"/></svg>'},
  {id:'bunny',cat:'spring',name:'Bunny',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="20" ry="18" fill="#fdf4ff"/><circle cx="32" cy="28" r="14" fill="#fdf4ff"/><ellipse cx="22" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="42" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="22" cy="8" rx="3" ry="10" fill="#fbcfe8"/><ellipse cx="42" cy="8" rx="3" ry="10" fill="#fbcfe8"/><circle cx="26" cy="26" r="3" fill="#1f2937"/><circle cx="38" cy="26" r="3" fill="#1f2937"/><ellipse cx="32" cy="34" rx="4" ry="3" fill="#fbcfe8"/></svg>'},
  {id:'flower',cat:'spring',name:'Flower',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><line x1="32" y1="32" x2="32" y2="60" stroke="#22c55e" stroke-width="4"/><circle cx="32" cy="20" r="8" fill="#fbbf24"/><circle cx="20" cy="20" r="8" fill="#f472b6"/><circle cx="44" cy="20" r="8" fill="#f472b6"/><circle cx="24" cy="30" r="8" fill="#f472b6"/><circle cx="40" cy="30" r="8" fill="#f472b6"/><circle cx="32" cy="8" r="8" fill="#f472b6"/></svg>'},
  {id:'butterfly',cat:'spring',name:'Butterfly',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="18" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="46" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="18" cy="44" rx="10" ry="14" fill="#a78bfa"/><ellipse cx="46" cy="44" rx="10" ry="14" fill="#a78bfa"/><rect x="30" y="12" width="4" height="44" fill="#1f2937"/><path d="M30 12 Q24 4 20 8" stroke="#1f2937" stroke-width="2" fill="none"/><path d="M34 12 Q40 4 44 8" stroke="#1f2937" stroke-width="2" fill="none"/></svg>'},
  {id:'chick',cat:'spring',name:'Chick',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="20" ry="20" fill="#fbbf24"/><circle cx="32" cy="24" r="14" fill="#fbbf24"/><circle cx="26" cy="22" r="3" fill="#1f2937"/><circle cx="38" cy="22" r="3" fill="#1f2937"/><polygon points="32,26 28,32 36,32" fill="#f97316"/><path d="M24 10 Q32 4 40 10" stroke="#fbbf24" stroke-width="4" fill="none"/></svg>'},
  {id:'basket',cat:'spring',name:'Basket',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 28 Q8 56 32 56 Q56 56 56 28" fill="#d4a574"/><path d="M8 28 L56 28" stroke="#92400e" stroke-width="2"/><path d="M8 36 L56 36" stroke="#92400e" stroke-width="2"/><path d="M16 28 Q16 8 32 8 Q48 8 48 28" fill="none" stroke="#d4a574" stroke-width="6"/></svg>'},
  {id:'shamrock',cat:'spring',name:'Shamrock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="18" r="12" fill="#22c55e"/><circle cx="20" cy="30" r="12" fill="#22c55e"/><circle cx="44" cy="30" r="12" fill="#22c55e"/><rect x="30" y="38" width="4" height="22" fill="#16a34a"/></svg>'},
  {id:'rainbow',cat:'spring',name:'Rainbow',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 56 Q4 8 60 56" fill="none" stroke="#ef4444" stroke-width="6"/><path d="M10 56 Q10 18 54 56" fill="none" stroke="#f97316" stroke-width="5"/><path d="M16 56 Q16 26 48 56" fill="none" stroke="#fbbf24" stroke-width="5"/><path d="M22 56 Q22 34 42 56" fill="none" stroke="#22c55e" stroke-width="5"/><path d="M28 56 Q28 42 36 56" fill="none" stroke="#3b82f6" stroke-width="5"/></svg>'},
  {id:'umbrella',cat:'spring',name:'Umbrella',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 32 Q4 8 60 32" fill="#ef4444"/><line x1="32" y1="8" x2="32" y2="56" stroke="#78350f" stroke-width="4"/><path d="M32 56 Q24 56 24 48" fill="none" stroke="#78350f" stroke-width="4"/></svg>'},
  {id:'ladybug',cat:'spring',name:'Ladybug',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="22" fill="#ef4444"/><line x1="32" y1="14" x2="32" y2="58" stroke="#1f2937" stroke-width="2"/><circle cx="20" cy="28" r="4" fill="#1f2937"/><circle cx="44" cy="28" r="4" fill="#1f2937"/><circle cx="24" cy="44" r="4" fill="#1f2937"/><circle cx="40" cy="44" r="4" fill="#1f2937"/><circle cx="32" cy="12" r="8" fill="#1f2937"/></svg>'},
  
  // Summer/Fall (~10)
  {id:'sun',cat:'summer',name:'Sun',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="14" fill="#fbbf24"/><g stroke="#fbbf24" stroke-width="3"><line x1="32" y1="4" x2="32" y2="12"/><line x1="32" y1="52" x2="32" y2="60"/><line x1="4" y1="32" x2="12" y2="32"/><line x1="52" y1="32" x2="60" y2="32"/><line x1="12" y1="12" x2="18" y2="18"/><line x1="46" y1="46" x2="52" y2="52"/><line x1="12" y1="52" x2="18" y2="46"/><line x1="46" y1="18" x2="52" y2="12"/></g></svg>'},
  {id:'palm',cat:'summer',name:'Palm Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="28" width="8" height="32" fill="#92400e"/><path d="M32 28 Q16 8 8 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q48 8 56 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q24 4 32 8 Q40 4 32 28" fill="#16a34a"/></svg>'},
  {id:'fireworks',cat:'summer',name:'Fireworks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="4" fill="#ef4444"/><g stroke="#ef4444" stroke-width="2"><line x1="32" y1="24" x2="32" y2="8"/><line x1="32" y1="24" x2="32" y2="40"/><line x1="32" y1="24" x2="16" y2="24"/><line x1="32" y1="24" x2="48" y2="24"/><line x1="32" y1="24" x2="20" y2="12"/><line x1="32" y1="24" x2="44" y2="36"/><line x1="32" y1="24" x2="44" y2="12"/><line x1="32" y1="24" x2="20" y2="36"/></g><circle cx="16" cy="44" r="3" fill="#3b82f6"/><g stroke="#3b82f6" stroke-width="1.5"><line x1="16" y1="44" x2="16" y2="36"/><line x1="16" y1="44" x2="8" y2="44"/><line x1="16" y1="44" x2="24" y2="44"/><line x1="16" y1="44" x2="10" y2="38"/><line x1="16" y1="44" x2="22" y2="50"/></g></svg>'},
  {id:'flag',cat:'summer',name:'Flag',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="4" height="48" fill="#78350f"/><rect x="14" y="8" width="42" height="8" fill="#ef4444"/><rect x="14" y="24" width="42" height="8" fill="#ef4444"/><rect x="14" y="16" width="42" height="8" fill="white"/><rect x="14" y="8" width="16" height="16" fill="#1e40af"/></svg>'},
  {id:'pumpkin',cat:'summer',name:'Pumpkin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="28" ry="20" fill="#f97316"/><ellipse cx="20" cy="40" rx="12" ry="20" fill="#ea580c"/><ellipse cx="44" cy="40" rx="12" ry="20" fill="#ea580c"/><rect x="28" y="8" width="8" height="12" fill="#16a34a"/><path d="M32 8 Q40 4 44 12" stroke="#22c55e" stroke-width="3" fill="none"/></svg>'},
  {id:'ghost',cat:'summer',name:'Ghost',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32 A20 20 0 1 1 52 32 L52 56 L44 48 L36 56 L28 48 L20 56 L12 48 Z" fill="white"/><circle cx="24" cy="28" r="4" fill="#1f2937"/><circle cx="40" cy="28" r="4" fill="#1f2937"/><ellipse cx="32" cy="40" rx="6" ry="4" fill="#1f2937"/></svg>'},
  {id:'bat',cat:'summer',name:'Bat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 24 Q8 16 4 40 Q12 32 20 40 Q16 28 32 32 Q48 28 44 40 Q52 32 60 40 Q56 16 32 24" fill="#1f2937"/><circle cx="28" cy="28" r="2" fill="#ef4444"/><circle cx="36" cy="28" r="2" fill="#ef4444"/></svg>'},
  {id:'witch',cat:'summer',name:'Witch Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,48 56,48" fill="#1f2937"/><ellipse cx="32" cy="48" rx="28" ry="8" fill="#1f2937"/><rect x="20" y="36" width="24" height="6" fill="#f97316"/></svg>'},
  {id:'turkey',cat:'summer',name:'Turkey',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="16" ry="14" fill="#92400e"/><circle cx="24" cy="36" r="10" fill="#78350f"/><circle cx="20" cy="34" r="2" fill="#1f2937"/><polygon points="16,38 8,36 16,34" fill="#f97316"/><path d="M40 12 Q60 8 56 32 Q52 12 40 16" fill="#ef4444"/><path d="M44 12 Q60 12 52 28 Q48 16 44 16" fill="#f97316"/><path d="M48 16 Q56 16 48 28" fill="#fbbf24"/></svg>'},
  {id:'leaf',cat:'summer',name:'Maple Leaf',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 16 L48 12 L40 24 L56 28 L40 36 L48 52 L32 44 L16 52 L24 36 L8 28 L24 24 L16 12 L28 16 Z" fill="#ef4444"/><line x1="32" y1="44" x2="32" y2="60" stroke="#78350f" stroke-width="3"/></svg>'},
  
  // Occasions (~10)
  {id:'cake',cat:'occasion',name:'Birthday Cake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="28" width="48" height="28" rx="4" fill="#f472b6"/><rect x="8" y="28" width="48" height="8" fill="#ec4899"/><rect x="12" y="36" width="40" height="4" fill="#fbbf24"/><rect x="30" y="16" width="4" height="12" fill="#fbbf24"/><ellipse cx="32" cy="12" rx="4" ry="6" fill="#f97316"/></svg>'},
  {id:'balloon',cat:'occasion',name:'Balloon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="24" rx="18" ry="22" fill="#ef4444"/><polygon points="32,44 28,50 36,50" fill="#ef4444"/><path d="M32 50 Q28 56 32 60 Q36 56 32 50" fill="none" stroke="#6b7280" stroke-width="2"/></svg>'},
  {id:'party',cat:'occasion',name:'Party Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,56 56,56" fill="#8b5cf6"/><circle cx="32" cy="8" r="6" fill="#fbbf24"/><circle cx="24" cy="32" r="4" fill="#22c55e"/><circle cx="40" cy="40" r="4" fill="#f472b6"/><circle cx="28" cy="48" r="4" fill="#3b82f6"/></svg>'},
  {id:'ribbon',cat:'occasion',name:'Ribbon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="16" fill="#3b82f6"/><path d="M24 38 L16 60 L32 50 L48 60 L40 38" fill="#2563eb"/><circle cx="32" cy="24" r="8" fill="#1d4ed8"/></svg>'},
  {id:'trophy',cat:'occasion',name:'Trophy',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="20" y="8" width="24" height="28" rx="4" fill="#fbbf24"/><path d="M20 16 Q8 16 8 28 Q8 36 20 36" fill="#f59e0b"/><path d="M44 16 Q56 16 56 28 Q56 36 44 36" fill="#f59e0b"/><rect x="28" y="36" width="8" height="12" fill="#fbbf24"/><rect x="20" y="48" width="24" height="8" fill="#92400e"/></svg>'},
  {id:'medal',cat:'occasion',name:'Medal',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M24 4 L24 28 L32 20 L40 28 L40 4" fill="#3b82f6"/><circle cx="32" cy="40" r="18" fill="#fbbf24"/><circle cx="32" cy="40" r="12" fill="#f59e0b"/><text x="32" y="46" text-anchor="middle" fill="white" font-size="16" font-weight="bold">1</text></svg>'},
  {id:'rattle',cat:'occasion',name:'Baby Rattle',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="20" r="16" fill="#f472b6"/><rect x="28" y="36" width="8" height="20" rx="4" fill="#fbbf24"/><circle cx="26" cy="16" r="4" fill="#fdf4ff"/><circle cx="38" cy="16" r="4" fill="#fdf4ff"/><circle cx="32" cy="24" r="4" fill="#fdf4ff"/></svg>'},
  {id:'rings',cat:'occasion',name:'Wedding Rings',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="32" r="16" fill="none" stroke="#fbbf24" stroke-width="6"/><circle cx="40" cy="32" r="16" fill="none" stroke="#d1d5db" stroke-width="6"/></svg>'},
  {id:'diploma',cat:'occasion',name:'Diploma',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="32" fill="#fef3c7"/><rect x="8" y="16" width="48" height="6" fill="#fcd34d"/><line x1="16" y1="28" x2="48" y2="28" stroke="#92400e" stroke-width="2"/><line x1="16" y1="36" x2="40" y2="36" stroke="#92400e" stroke-width="2"/><circle cx="44" cy="44" r="8" fill="#ef4444"/></svg>'},
  {id:'confetti',cat:'occasion',name:'Confetti',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="8" height="8" fill="#ef4444" transform="rotate(15 12 12)"/><rect x="28" y="4" width="8" height="8" fill="#3b82f6" transform="rotate(-20 32 8)"/><rect x="48" y="12" width="8" height="8" fill="#22c55e" transform="rotate(30 52 16)"/><rect x="4" y="32" width="8" height="8" fill="#f472b6" transform="rotate(-15 8 36)"/><rect x="20" y="28" width="8" height="8" fill="#fbbf24" transform="rotate(25 24 32)"/><rect x="44" y="36" width="8" height="8" fill="#8b5cf6" transform="rotate(-30 48 40)"/><rect x="12" y="48" width="8" height="8" fill="#14b8a6" transform="rotate(10 16 52)"/><rect x="32" y="52" width="8" height="8" fill="#f97316" transform="rotate(-25 36 56)"/></svg>'},
  
  // Symbols & Decorative (~12)
  {id:'arrow',cat:'symbol',name:'Arrow Right',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L48 32 M36 20 L48 32 L36 44" stroke="#1f2937" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'check',cat:'symbol',name:'Checkmark',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="#fff" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'warning',cat:'symbol',name:'Warning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L4 56 L60 56 Z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>'},
  {id:'info',cat:'symbol',name:'Info',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#3b82f6"/><circle cx="32" cy="18" r="4" fill="white"/><rect x="28" y="26" width="8" height="24" fill="white"/></svg>'},
  {id:'phone',cat:'symbol',name:'Phone',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 4 L24 4 L28 16 L20 24 Q28 40 40 48 L48 40 L60 44 L60 56 Q60 60 56 60 Q12 56 8 12 Q8 8 12 4" fill="#22c55e"/></svg>'},
  {id:'at',cat:'symbol',name:'Email @',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="8" fill="none" stroke="#3b82f6" stroke-width="4"/><path d="M40 32 Q40 44 48 44 A20 20 0 1 1 48 20" fill="none" stroke="#3b82f6" stroke-width="4"/></svg>'},
  {id:'web',cat:'symbol',name:'Globe/Web',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="26" fill="none" stroke="#3b82f6" stroke-width="3"/><ellipse cx="32" cy="32" rx="10" ry="26" fill="none" stroke="#3b82f6" stroke-width="3"/><line x1="6" y1="32" x2="58" y2="32" stroke="#3b82f6" stroke-width="3"/><path d="M10 18 Q32 24 54 18" fill="none" stroke="#3b82f6" stroke-width="2"/><path d="M10 46 Q32 40 54 46" fill="none" stroke="#3b82f6" stroke-width="2"/></svg>'},
  {id:'clock',cat:'symbol',name:'Clock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="white" stroke="#1f2937" stroke-width="4"/><line x1="32" y1="32" x2="32" y2="16" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><line x1="32" y1="32" x2="44" y2="32" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><circle cx="32" cy="32" r="3" fill="#ef4444"/></svg>'},
  {id:'camera',cat:'symbol',name:'Camera',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="40" rx="4" fill="#1f2937"/><circle cx="32" cy="36" r="14" fill="#374151"/><circle cx="32" cy="36" r="10" fill="#3b82f6"/><rect x="24" y="8" width="16" height="8" fill="#1f2937"/></svg>'},
  {id:'key',cat:'symbol',name:'Key',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="14" fill="none" stroke="#fbbf24" stroke-width="4"/><line x1="30" y1="26" x2="56" y2="52" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="48" y1="44" x2="56" y2="44" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="40" y1="36" x2="48" y2="36" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/></svg>'},
  {id:'lock',cat:'symbol',name:'Lock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="28" width="40" height="32" rx="4" fill="#6b7280"/><path d="M20 28 v-8 a12 12 0 1 1 24 0 v8" fill="none" stroke="#6b7280" stroke-width="6"/><circle cx="32" cy="44" r="6" fill="#1f2937"/></svg>'},
  {id:'bolt',cat:'symbol',name:'Lightning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="36,4 16,32 28,32 24,60 48,28 36,28" fill="#fbbf24"/></svg>'}
];

// Show a read-only preview modal for built-in templates
function showBuiltinTemplatePreview(templateId) {
  const tpl = getBuiltinTemplate(templateId);
  if (!tpl) {
    showToast('Template not found', 'error');
    return;
  }
  
  const lines = deserializeLines(tpl.text);
  const tokens = tpl.tokens || [];
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  
  // Build preview lines with sample data
  const sampleData = {
    name: 'John Smith',
    first_name: 'John',
    last_name: 'Smith',
    street: '123 Main St',
    city: 'Anytown',
    state: 'CA',
    zip: '12345',
    country: 'USA',
    student_name: 'Emma Johnson',
    room: '101',
    teacher: 'Ms. Wilson',
    level: 'Grade 3',
    company: 'Acme Corp',
    title: 'Software Engineer',
    table_number: '5',
    dish_name: 'Caesar Salad',
    description: 'Contains dairy'
  };
  
  // Replace tokens with sample values for preview
  const previewLines = lines.map(line => {
    let text = line.text;
    tokens.forEach(token => {
      const regex = new RegExp('\\{' + token + '\\}', 'gi');
      text = text.replace(regex, sampleData[token] || '{' + token + '}');
    });
    return { ...line, text };
  });
  
  // Build simple preview HTML
  const previewLinesHtml = previewLines.filter(l => l.text.trim()).map(line => {
    const align = line.align || 'left';
    const fontSize = line.fontSize || 11;
    return `<div style="text-align:${align};font-size:${fontSize}px;line-height:1.3;margin:2px 0;">${escapeHtml(line.text)}</div>`;
  }).join('');
  
  // Calculate preview dimensions
  const aspectRatio = spec.labelW / spec.labelH;
  const previewWidth = Math.min(280, spec.labelW * 72);
  const previewHeight = previewWidth / aspectRatio;
  
  // Build modal content
  const modalContent = `
    <div style="text-align: center; padding: 10px 0 20px;">
      <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px;">${escapeHtml(tpl.name)}</div>
      <div style="font-size: 12px; color: var(--text-muted);">Built-in Template Â· ${spec?.name || labelType}</div>
    </div>
    
    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
      <div style="width:${previewWidth}px;min-height:${previewHeight}px;background:#fff;border:2px solid #888;border-radius:4px;padding:8px 12px;display:flex;flex-direction:column;justify-content:center;color:#000;">
        ${previewLinesHtml || '<div style="color:#888;font-style:italic;">Empty template</div>'}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Template Structure</div>
      <div style="font-family: var(--mono); font-size: 12px; color: var(--text-muted); line-height: 1.6;">
        ${lines.map((l, i) => `<div>Line ${i + 1}: ${escapeHtml(l.text) || '<em style="opacity:0.5">(empty)</em>'}</div>`).join('')}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 20px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Tokens (${tokens.length})</div>
      <div style="display: flex; flex-wrap: wrap; gap: 6px;">
        ${tokens.map(tk => `<span style="background: var(--accent-bg); color: var(--accent-text); padding: 3px 8px; border-radius: 4px; font-size: 12px; font-family: var(--mono);">{${tk}}</span>`).join('')}
      </div>
    </div>
    
    <div style="display: flex; justify-content: center; gap: 12px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeBuiltinPreviewModal()">Close</button>
      <button class="wizard-btn wizard-btn-primary" onclick="closeBuiltinPreviewModal(); showBatchImportModal('${templateId}')">ðŸ“Š Use for Batch Print</button>
    </div>
  `;
  
  showGenericModal('Template Preview', modalContent, 'builtinPreviewModal');
}

function closeBuiltinPreviewModal() {
  closeGenericModal('builtinPreviewModal');
}

function openFullEditor(textId, isTemplate = false, isStyleTemplate = false) {
  feEditingId = textId;
  feIsTemplate = isTemplate;
  feIsStyleTemplate = isStyleTemplate;
  
  // Reset state
  resetFullEditorState();
  
  // Determine preview label type (from source sheet or settings)
  if (window._editorSourceSheetId && sheets[window._editorSourceSheetId]) {
    fePreviewLabelType = sheets[window._editorSourceSheetId].labelType;
  } else {
    fePreviewLabelType = settings.lastLabelType || '5160';
  }
  document.getElementById('fePreviewType').value = fePreviewLabelType;
  
  // Populate style template dropdown
  populateStyleTemplateDropdown();
  
  // Handle style template editor mode
  document.getElementById('feStyleEditorNotice').style.display = isStyleTemplate ? 'block' : 'none';
  document.getElementById('feStyleTemplateRow').style.display = isStyleTemplate ? 'none' : 'flex';
  updateStyleEditorMode();
  
  if (textId) {
    // Load existing text
    const text = getSavedText(textId);
    if (text) {
      document.getElementById('fullEditorTitle').textContent = isStyleTemplate ? 'Edit Style Template' : 'Edit Label';
      document.getElementById('feNameRow').style.display = 'none';
      document.getElementById('feNameEditRow').style.display = 'flex';
      document.getElementById('feNameEdit').value = text.name;
      loadTextIntoFullEditor(text);
      
      // Store original state for dirty tracking
      feOriginalState = captureEditorState();
    }
  } else {
    // New text
    let title = 'New Label';
    if (isStyleTemplate) title = 'New Style Template';
    else if (isTemplate) title = 'New Template';
    document.getElementById('fullEditorTitle').textContent = title;
    document.getElementById('feNameRow').style.display = 'flex';
    document.getElementById('feNameEditRow').style.display = 'none';
    document.getElementById('feName').value = '';
    feOriginalState = null;
  }
  
  // Reset dirty state
  feDirty = false;
  updateDirtyIndicator();
  
  // Show/hide Back to Wizard button
  const backToWizardBtn = document.getElementById('feBackToWizardBtn');
  if (backToWizardBtn) {
    backToWizardBtn.style.display = feOpenedFromWizard ? 'inline-flex' : 'none';
  }
  
  let subtitle = 'Full formatting options';
  if (isStyleTemplate) subtitle = 'Visual design only (no text)';
  else if (isTemplate) subtitle = 'Template with tokens';
  document.getElementById('fullEditorSubtitle').textContent = subtitle;
  document.getElementById('fullEditorOverlay').classList.add('visible');
  updateTokenToggleVisibility(); // Show/hide token panel toggle for templates
  updateFullEditorPreview();
}

// Update editor mode for style template editing (disable text inputs)
function updateStyleEditorMode() {
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) {
      if (feIsStyleTemplate) {
        input.classList.add('style-editor-disabled');
        input.readOnly = true;
        input.placeholder = '(Style preview line ' + i + ')';
        input.value = 'Sample Line ' + i;
        feLines[i - 1].text = 'Sample Line ' + i;
      } else {
        input.classList.remove('style-editor-disabled');
        input.readOnly = false;
      }
    }
  }
  
  // Set default category and label type for new style templates
  if (feIsStyleTemplate && !feEditingId) {
    const catSelect = document.getElementById('feStyleCategory');
    const typeSelect = document.getElementById('feStyleLabelType');
    if (catSelect) catSelect.value = 'simple';
    if (typeSelect) typeSelect.value = fePreviewLabelType || '5160';
  }
}

// Populate the style template dropdown with options
function populateStyleTemplateDropdown() {
  const select = document.getElementById('feStyleTemplateSelect');
  if (!select) return;
  
  // Get current label type for filtering
  const labelType = fePreviewLabelType || '5160';
  const allTemplates = getAllStyleTemplates();
  
  // Group by category
  const byCategory = {};
  for (const cat of Object.keys(STYLE_TEMPLATE_CATEGORIES)) {
    byCategory[cat] = [];
  }
  byCategory['other'] = []; // For user templates without category
  
  for (const tpl of allTemplates) {
    // Filter to current label type (show all if no exact match for variety)
    const cat = tpl.category || 'other';
    if (byCategory[cat]) {
      byCategory[cat].push(tpl);
    } else {
      byCategory['other'].push(tpl);
    }
  }
  
  let html = '<option value="">â€” None (manual styling) â€”</option>';
  
  // Add "Matching" group (same label type)
  const matching = allTemplates.filter(t => t.labelType === labelType);
  if (matching.length > 0) {
    html += `<optgroup label="âœ“ Designed for ${labelType}">`;
    for (const tpl of matching) {
      const catLabel = STYLE_TEMPLATE_CATEGORIES[tpl.category]?.label || tpl.category;
      html += `<option value="${tpl.id}">${tpl.name} (${catLabel.replace(/^[^ ]+ /, '')})</option>`;
    }
    html += '</optgroup>';
  }
  
  // Add category groups
  for (const [catId, catInfo] of Object.entries(STYLE_TEMPLATE_CATEGORIES)) {
    const templates = byCategory[catId].filter(t => t.labelType !== labelType);
    if (templates.length > 0) {
      html += `<optgroup label="${catInfo.label}">`;
      for (const tpl of templates) {
        html += `<option value="${tpl.id}">${tpl.name} (${tpl.labelType})</option>`;
      }
      html += '</optgroup>';
    }
  }
  
  // User templates
  const userTemplates = byCategory['other'].filter(t => !t.builtin);
  if (userTemplates.length > 0) {
    html += '<optgroup label="ðŸ“ My Style Templates">';
    for (const tpl of userTemplates) {
      html += `<option value="${tpl.id}">${tpl.name}</option>`;
    }
    html += '</optgroup>';
  }
  
  select.innerHTML = html;
}

// Apply a style template to the current content
function applyStyleTemplate(templateId) {
  if (!templateId) {
    // Clearing style - do nothing, user wants manual control
    return;
  }
  
  const template = getStyleTemplate(templateId);
  if (!template) {
    showToast('Style template not found', 'error');
    return;
  }
  
  // Apply label-level properties
  feAlignV = template.alignV || 'center';
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === feAlignV);
  });
  
  // Apply border
  if (template.border) {
    feBorder = { ...template.border };
  } else {
    feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  }
  updateBorderUI();
  
  // Apply graphics
  if (template.graphics) {
    // Handle builtin graphic references
    if (template.graphics.left && template.graphics.left.type === 'builtin') {
      const g = FE_GRAPHICS_LIBRARY.find(gr => gr.id === template.graphics.left.id);
      if (g) {
        feGraphics.left = {
          data: 'data:image/svg+xml;base64,' + btoa(g.svg),
          size: 'M'
        };
      }
    } else {
      feGraphics.left = template.graphics.left;
    }
    
    if (template.graphics.right && template.graphics.right.type === 'builtin') {
      const g = FE_GRAPHICS_LIBRARY.find(gr => gr.id === template.graphics.right.id);
      if (g) {
        feGraphics.right = {
          data: 'data:image/svg+xml;base64,' + btoa(g.svg),
          size: 'M'
        };
      }
    } else {
      feGraphics.right = template.graphics.right;
    }
  } else {
    feGraphics = { left: null, right: null };
  }
  renderFeGraphics();
  
  // Apply line styles (only to lines that have text, or all if style template editor)
  if (template.lineStyles) {
    for (let i = 0; i < 4; i++) {
      const style = template.lineStyles[Math.min(i, template.lineStyles.length - 1)];
      if (style) {
        // Only apply style if line has text (or in style editor mode)
        if (feLines[i].text.trim() || feIsStyleTemplate) {
          feLines[i].fontFamily = style.fontFamily || 'default';
          feLines[i].fontSize = style.fontSize || 11;
          feLines[i].bold = style.bold || false;
          feLines[i].italic = style.italic || false;
          feLines[i].underline = style.underline || false;
          feLines[i].strikethrough = style.strikethrough || false;
          feLines[i].color = style.color || '';
          feLines[i].fillColor = style.fillColor || '';
          feLines[i].align = style.align || 'left';
          
          // Update UI
          document.getElementById('feSize' + (i + 1)).textContent = feLines[i].fontSize;
          document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
            btn.classList.toggle('active', btn.dataset.align === feLines[i].align);
          });
          updateFeStyleButtonIndicator(i + 1);
        }
      }
    }
  }
  
  updateFullEditorPreview();
  checkEditorDirty();
  showToast(`Applied "${template.name}" style`, 'success');
}

// Track if editor was opened from wizard (for return navigation)
let feOpenedFromWizard = false;

// Capture current editor state for dirty comparison
function captureEditorState() {
  return JSON.stringify({
    lines: feLines,
    alignV: feAlignV,
    graphics: feGraphics,
    border: feBorder,
    barcode: feCurrentBarcode,
    name: document.getElementById('feNameEdit')?.value || ''
  });
}

// Check if editor is dirty and update indicator
function checkEditorDirty() {
  if (!feOriginalState) {
    // New text - dirty if any content
    const hasContent = feLines.some(l => l.text.trim());
    feDirty = hasContent;
  } else {
    // Existing - compare to original
    feDirty = captureEditorState() !== feOriginalState;
  }
  updateDirtyIndicator();
}

function updateDirtyIndicator() {
  const indicator = document.getElementById('feDirtyIndicator');
  if (indicator) {
    indicator.classList.toggle('visible', feDirty);
  }
}

async function closeFullEditor() {
  // Check for unsaved changes
  if (feDirty) {
    const ok = await showConfirmDialog(
      'You have unsaved changes. Discard them?',
      'Unsaved Changes',
      'Discard',
      'Keep Editing'
    );
    if (!ok) {
      return;
    }
  }
  
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  feDirty = false;
  feOriginalState = null;
  closeFeStylePopovers();
  
  // Clear editor source sheet reference
  window._editorSourceSheetId = null;
  
  // Refresh current tab to ensure data is current (especially for sheet print)
  renderCurrentTab();
}

// Close full editor and return to wizard with content
function closeFullEditorToWizard() {
  // Check if we came from WF1
  if (wf1_fullEditorActive) {
    // Save Full Editor snapshot â€” preserves ALL styles (bold, italic, color, graphics, borders, barcode)
    wf1FeSnapshot = {
      lines: JSON.parse(JSON.stringify(feLines)),
      graphics: JSON.parse(JSON.stringify(feGraphics)),
      alignV: feAlignV,
      border: JSON.parse(JSON.stringify(feBorder)),
      barcode: feCurrentBarcode ? JSON.parse(JSON.stringify(feCurrentBarcode)) : null
    };
    
    // Clear style template selection (user is now using custom Full Editor styles)
    wf1StyleTemplateId = null;
    
    // Clear saved text selection - user has customized content in Full Editor
    // so we should use wf1FeSnapshot and wf1ContentLines, not the original saved text
    wf1SelectedSavedTextId = null;
    
    // Transfer content back to WF1 editor (text, align, fontSize only â€” wizard can display these)
    for (let i = 1; i <= 4; i++) {
      const feInput = document.getElementById('feLine' + i);
      const wf1Input = document.getElementById('wf1Line' + (i));
      if (feInput && wf1Input) {
        wf1Input.value = feInput.value;
        wf1LineAligns[i - 1] = feLines[i - 1].align || 'left';
        wf1LineSizes[i - 1] = feLines[i - 1].fontSize || 11;
      }
    }
    
    // Close full editor
    document.getElementById('fullEditorOverlay').classList.remove('visible');
    feEditingId = null;
    feOpenedFromWizard = false;
    wf1_fullEditorActive = false;
    closeFeStylePopovers();
    
    // Re-open WF1 wizard at step 6
    showWizard('wf1Wizard');
    wf1ShowStep('wf1Step6');
    
    // Update WF1 align/size button states and preview
    for (let i = 1; i <= 4; i++) {
      document.querySelectorAll('.editor-align-btn[data-wf1line="' + i + '"]').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.align === wf1LineAligns[i - 1]);
      });
      document.querySelectorAll('.editor-size-btn[data-wf1line="' + i + '"]').forEach(function(btn) {
        btn.classList.toggle('active', parseInt(btn.dataset.size) === wf1LineSizes[i - 1]);
      });
    }
    
    // Clear style dropdown selection (Full Editor overrides any style template)
    const styleSelect = document.getElementById('wf1StyleSelect');
    if (styleSelect) styleSelect.value = '';
    
    wf1UpdateEditorPreview();
    showToast('Returned to print wizard', 'info');
    return;
  }
  
  // Fallback: close full editor and return to home
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  closeFeStylePopovers();
  showToast('Editor closed', 'info');
}

// ========== TOKEN PANEL FOR TEMPLATES ==========
let feLastFocusedLine = null; // Track which line input was last focused

function toggleFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  const toggle = document.getElementById('feTokenToggle');
  
  if (panel.classList.contains('visible')) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  } else {
    renderFeTokenPanel();
    panel.classList.add('visible');
    toggle.classList.add('active');
  }
}

function renderFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  let html = '';
  
  // Built-in categories
  for (const [category, tokens] of Object.entries(BUILTIN_TOKENS)) {
    html += '<div class="fe-token-category">' + escapeHtml(category) + '</div>';
    html += '<div class="fe-token-grid">';
    tokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Custom tokens
  if (customTokens.length) {
    html += '<div class="fe-token-category">Custom</div>';
    html += '<div class="fe-token-grid">';
    customTokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Add custom token row
  html += '<div class="fe-token-custom-row">';
  html += '<input type="text" id="feCustomTokenInput" placeholder="custom_field" maxlength="30" onkeydown="if(event.key===\'Enter\')addFeCustomToken()">';
  html += '<button onclick="addFeCustomToken()">+ Add</button>';
  html += '</div>';
  
  panel.innerHTML = html;
}

function insertFeToken(tokenName) {
  // Find which line input to insert into
  let input = null;
  
  // Use last focused line, or default to line 1
  if (feLastFocusedLine) {
    input = document.getElementById('feLine' + feLastFocusedLine);
  }
  if (!input) {
    input = document.getElementById('feLine1');
  }
  
  if (!input) return;
  
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const val = input.value;
  const insert = '{' + tokenName + '}';
  
  input.value = val.substring(0, start) + insert + val.substring(end);
  input.selectionStart = input.selectionEnd = start + insert.length;
  input.focus();
  
  // Update feLines state
  const lineNum = parseInt(input.id.replace('feLine', ''));
  if (lineNum >= 1 && lineNum <= 4) {
    feLines[lineNum - 1].text = input.value;
  }
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function addFeCustomToken() {
  const inp = document.getElementById('feCustomTokenInput');
  if (!inp) return;
  
  // Clean the token name: lowercase, underscores for spaces, alphanumeric only
  let name = inp.value.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/^_+|_+$/g, '');
  
  if (!name || !/^[a-z]/.test(name)) {
    inp.style.borderColor = 'var(--error-border)';
    showToast('Token must start with a letter', 'error');
    return;
  }
  
  // Check for duplicates across builtins and custom
  const allBuiltin = Object.values(BUILTIN_TOKENS).flat();
  if (allBuiltin.includes(name) || customTokens.includes(name)) {
    // Already exists - just insert it
    insertFeToken(name);
    inp.value = '';
    inp.style.borderColor = '';
    return;
  }
  
  // Add new custom token
  customTokens.push(name);
  saveCustomTokens();
  renderFeTokenPanel();
  insertFeToken(name);
  inp.value = '';
  inp.style.borderColor = '';
  showToast('Custom token {' + name + '} added', 'success');
}

// Show/hide token toggle based on template mode
function updateTokenToggleVisibility() {
  const tokenToggleRow = document.getElementById('feTokenToggleRow');
  if (tokenToggleRow) {
    tokenToggleRow.style.display = feIsTemplate ? 'flex' : 'none';
  }
  // Close token panel when switching away from template mode
  if (!feIsTemplate) {
    const panel = document.getElementById('feTokenPanel');
    const toggle = document.getElementById('feTokenToggle');
    if (panel) panel.classList.remove('visible');
    if (toggle) toggle.classList.remove('active');
  }
}

// ========== EMOJI PANEL (Full Editor) ==========
function toggleFeEmojiPanel() {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  
  const show = !panel.classList.contains('visible');
  panel.classList.toggle('visible', show);
  toggle.classList.toggle('active', show);
  
  if (show) {
    renderFeEmojiPanel();
    const search = document.getElementById('feEmojiSearch');
    if (search) {
      search.value = '';
      search.focus();
    }
  }
}

function renderFeEmojiPanel(filter) {
  const scroll = document.getElementById('feEmojiScroll');
  const q = (filter || '').toLowerCase().trim();
  let html = '';
  
  EMOJI_DATA.forEach(cat => {
    const filtered = q ? cat.emojis.filter(em => em.n.includes(q) || em.e === q) : cat.emojis;
    if (!filtered.length) return;
    html += '<div class="fe-emoji-category"><div class="fe-emoji-category-label">' + escapeHtml(cat.cat) + '</div><div class="fe-emoji-grid">';
    filtered.forEach(em => {
      html += '<button class="fe-emoji-btn" onclick="insertFeEmoji(\'' + em.e + '\')" title="' + escapeAttr(em.n) + '">' + em.e + '</button>';
    });
    html += '</div></div>';
  });
  
  if (!html) html = '<div style="padding: 16px; text-align: center; font-size: 12px; color: var(--text-muted);">No matches</div>';
  scroll.innerHTML = html;
}

function filterFeEmojis() {
  const search = document.getElementById('feEmojiSearch');
  renderFeEmojiPanel(search ? search.value : '');
}

function insertFeEmoji(emoji) {
  // Determine which input to insert into
  const lineNum = feLastFocusedLine || 1;
  const input = document.getElementById('feLine' + lineNum);
  if (!input) return;
  
  const start = input.selectionStart || input.value.length;
  const end = input.selectionEnd || start;
  input.value = input.value.slice(0, start) + emoji + input.value.slice(end);
  input.focus();
  const pos = start + emoji.length;
  input.setSelectionRange(pos, pos);
  updateFullEditorPreview();
}

// Close emoji panel on click outside
document.addEventListener('click', e => {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  if (panel && panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== toggle && !toggle.contains(e.target)) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  }
});

// ========== OCR SCANNING ==========
async function loadTesseract() {
  if (window.Tesseract) return;
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(script);
  });
}

function openOcrModal() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  
  // Reset UI
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loadingâ€¦';
  document.getElementById('ocrResultLines').innerHTML = '';
  document.getElementById('ocrHint').textContent = '';
  document.getElementById('ocrModal').classList.add('visible');
}

function closeOcrModal() {
  document.getElementById('ocrModal').classList.remove('visible');
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
}

// Paste clipboard text directly into editor line inputs (like v1.2)
async function pasteToEditor() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // Route based on content:
  // - Tabular data (Excel-style with tabs+newlines): always import modal
  // - 8+ plain lines: import modal for bulk processing
  // - 1-7 plain lines: paste first 4 into editor
  if (isTabular || rows.length > 7) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // Paste into editor lines (up to 4 lines)
  const maxLines = Math.min(rows.length, 4);
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('feLine' + (i + 1));
    if (input) {
      input.value = i < maxLines ? rows[i] : '';
    }
  }
  
  updateFullEditorPreview();
  checkEditorDirty();
  
  if (rows.length > 4) {
    showToast('Pasted first 4 of ' + rows.length + ' lines (label limit)', 'success');
  } else {
    showToast('Pasted ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard', 'success');
  }
}

// Clear text lines in the editor
// If a specific line is focused, clear only that line
// If no line is focused, clear all lines
function clearEditorLines() {
  const focusedLine = feLastFocusedLine;
  
  if (focusedLine && focusedLine >= 1 && focusedLine <= 4) {
    // Clear only the focused line
    const input = document.getElementById('feLine' + focusedLine);
    if (input) {
      input.value = '';
      input.focus();
      showToast('Line ' + focusedLine + ' cleared', 'info');
    }
  } else {
    // Clear all lines
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('feLine' + i);
      if (input) {
        input.value = '';
      }
    }
    showToast('All lines cleared', 'info');
  }
  
  updateFePreview();
  checkEditorDirty();
}

function ocrImageAreaClick() {
  if (!ocrImageBlob) {
    document.getElementById('ocrFileInput').click();
  }
}

function handleOcrFile(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  event.target.value = '';
  processOcrImage(file);
}

// Handle paste events for screenshot paste in OCR modal
document.addEventListener('paste', e => {
  const modal = document.getElementById('ocrModal');
  if (!modal || !modal.classList.contains('visible')) return;
  const items = e.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      if (blob) processOcrImage(blob);
      return;
    }
  }
});

function processOcrImage(fileOrBlob) {
  ocrImageBlob = fileOrBlob;
  ocrRotation = 0;
  
  const img = document.getElementById('ocrPreviewImg');
  const url = URL.createObjectURL(fileOrBlob);
  img.onload = () => URL.revokeObjectURL(url);
  img.src = url;
  img.style.display = '';
  img.style.transform = '';
  document.getElementById('ocrPlaceholder').style.display = 'none';
  document.getElementById('ocrImageArea').classList.add('has-image');
  
  document.getElementById('ocrRotationBar').style.display = 'flex';
  document.getElementById('ocrRotationLabel').textContent = '';
  
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  
  runOcr(fileOrBlob);
}

function rotateOcrImage(delta) {
  ocrRotation = ((ocrRotation || 0) + delta + 360) % 360;
  const img = document.getElementById('ocrPreviewImg');
  img.style.transform = 'rotate(' + ocrRotation + 'deg)';
  document.getElementById('ocrRotationLabel').textContent = ocrRotation ? ocrRotation + 'Â°' : '';
}

async function runOcr(imageBlob) {
  document.getElementById('ocrProgressArea').style.display = '';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loading OCR engineâ€¦';
  
  try {
    await loadTesseract();
    document.getElementById('ocrProgressText').textContent = 'Preprocessingâ€¦';
    document.getElementById('ocrProgressFill').style.width = '15%';
    
    const processed = await preprocessOcrImage(imageBlob, ocrRotation);
    
    document.getElementById('ocrProgressText').textContent = 'Scanningâ€¦';
    document.getElementById('ocrProgressFill').style.width = '30%';
    
    const result = await Tesseract.recognize(processed, 'eng', {
      logger: m => {
        if (m.status === 'recognizing text' && m.progress) {
          const pct = 30 + Math.round(m.progress * 65);
          document.getElementById('ocrProgressFill').style.width = pct + '%';
          document.getElementById('ocrProgressText').textContent = Math.round(m.progress * 100) + '%';
        }
      }
    });
    
    document.getElementById('ocrProgressFill').style.width = '100%';
    document.getElementById('ocrProgressText').textContent = 'Done!';
    
    parseOcrResult(result);
    
  } catch (err) {
    document.getElementById('ocrProgressText').textContent = 'Error: ' + err.message;
    document.getElementById('ocrProgressFill').style.background = 'var(--error-text)';
    console.error('OCR error:', err);
  }
}

function preprocessOcrImage(imageBlob, rotation) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(imageBlob);
    img.onload = () => {
      URL.revokeObjectURL(url);
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let w = img.naturalWidth;
        let h = img.naturalHeight;
        const rot = ((rotation || 0) % 360 + 360) % 360;
        const swapDims = (rot === 90 || rot === 270);
        
        // Scale up small images for better OCR
        const minDim = 1500;
        if (w < minDim && h < minDim) {
          const scale = minDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        // Cap very large images
        const maxDim = 4000;
        if (w > maxDim || h > maxDim) {
          const scale = maxDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        
        canvas.width = swapDims ? h : w;
        canvas.height = swapDims ? w : h;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rot * Math.PI / 180);
        ctx.translate(-w / 2, -h / 2);
        ctx.drawImage(img, 0, 0, w, h);
        
        canvas.toBlob(blob => {
          if (blob) resolve(blob);
          else reject(new Error('Failed to preprocess image'));
        }, 'image/png');
        
      } catch (e) {
        reject(e);
      }
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };
    img.src = url;
  });
}

function parseOcrResult(result) {
  ocrResults = [];
  
  if (!result?.data?.lines) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
    renderOcrResults();
    return;
  }
  
  const lines = result.data.lines;
  let totalConf = 0;
  
  for (const line of lines) {
    const text = (line.text || '').trim();
    if (!text) continue;
    const conf = Math.round(line.confidence || 0);
    totalConf += conf;
    ocrResults.push({ text, confidence: conf });
  }
  
  // Show hint based on line count
  if (ocrResults.length === 0) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
  } else if (ocrResults.length > 7) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. Will open import modal for bulk processing.';
  } else if (ocrResults.length > 4) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. First 4 will be used (label limit).';
  } else {
    const avgConf = totalConf / ocrResults.length;
    if (avgConf < 70) {
      document.getElementById('ocrHint').textContent = 'Low confidence results. Check for errors.';
    } else {
      document.getElementById('ocrHint').textContent = '';
    }
  }
  
  renderOcrResults();
}

function renderOcrResults() {
  const container = document.getElementById('ocrResultLines');
  let html = '';
  
  ocrResults.forEach((r, idx) => {
    const isLow = r.confidence < 70;
    html += '<div class="ocr-result-line">' +
      '<input type="text" value="' + escapeAttr(r.text) + '" ' +
        'class="' + (isLow ? 'low-confidence' : '') + '" ' +
        'oninput="updateOcrLine(' + idx + ', this.value)">' +
      '<span class="ocr-conf ' + (isLow ? 'low' : '') + '">' + r.confidence + '%</span>' +
      '<button class="ocr-line-remove" onclick="removeOcrLine(' + idx + ')" title="Remove line">Ã—</button>' +
    '</div>';
  });
  
  container.innerHTML = html;
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = '';
  document.getElementById('ocrConfirmBtn').style.display = ocrResults.length > 0 ? '' : 'none';
  document.getElementById('ocrRescanBtn').style.display = '';
  document.getElementById('ocrNewImageBtn').style.display = '';
}

function updateOcrLine(idx, value) {
  if (ocrResults[idx]) ocrResults[idx].text = value;
}

function removeOcrLine(idx) {
  ocrResults.splice(idx, 1);
  renderOcrResults();
}

function ocrRescan() {
  if (ocrImageBlob) runOcr(ocrImageBlob);
}

function ocrNewImage() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrFileInput').click();
}

function confirmOcr() {
  // Get text from editable OCR result inputs
  const rows = [];
  document.querySelectorAll('#ocrResultLines input').forEach(input => {
    const text = input.value.trim();
    if (text) rows.push(text);
  });
  
  if (rows.length === 0) {
    showToast('No text to import', 'warning');
    return;
  }
  
  closeOcrModal();
  
  // Route based on line count (same rules as paste)
  if (rows.length > 7) {
    // 8+ lines: open import modal for bulk processing
    showImportModal(rows, false);
  } else if (rows.length <= 4) {
    // 1-4 lines: direct to editor (simple case, no mapping needed)
    ocrLmApplyDirect(rows);
  } else {
    // 5-7 lines: show line-mapping UI â€” let user pick which lines go where
    ocrLmShow(rows);
  }
}

// ---- OCR Line-Mapping UI ----
let ocrLmSourceLines = [];
let ocrLmSlots = [null, null, null, null]; // 4 label line slots
let ocrLmSelectedSource = -1;
let ocrLmTargetContext = 'fe'; // 'fe' (Full Editor) or 'wf1' (WF1 editor)

function ocrLmDetectContext() {
  // Determine which editor is active
  const wf1Wizard = document.getElementById('wf1Wizard');
  if (wf1Wizard && (wf1Wizard.classList.contains('active') || wf1Wizard.style.display !== 'none')) {
    return 'wf1';
  }
  return 'fe';
}

function ocrLmShow(rows) {
  ocrLmSourceLines = rows.map(function(text, idx) { return { text: text, idx: idx, assigned: -1 }; });
  ocrLmSlots = [null, null, null, null];
  ocrLmSelectedSource = -1;
  ocrLmTargetContext = ocrLmDetectContext();
  
  // Build and show the line-mapping modal
  let html = '<div class="ocr-line-mapper">' +
    '<div class="ocr-lm-title">Assign scanned lines to label lines</div>' +
    '<div class="ocr-lm-hint">Click a scanned line, then click a label slot to assign it. Or click two scanned lines to merge them.</div>' +
    '<div class="ocr-lm-layout">' +
      '<div class="ocr-lm-source">' +
        '<div class="ocr-lm-label">Scanned Text</div>' +
        '<div class="ocr-lm-source-list" id="ocrLmSourceList"></div>' +
      '</div>' +
      '<div class="ocr-lm-target">' +
        '<div class="ocr-lm-label">Label Lines</div>' +
        '<div class="ocr-lm-target-slots" id="ocrLmTargetSlots"></div>' +
      '</div>' +
    '</div>' +
    '<div class="ocr-lm-actions">' +
      '<button class="btn btn-secondary" onclick="ocrLmAutoAssign()">Auto-fill top 4</button>' +
      '<button class="btn btn-secondary" onclick="ocrLmClearAll()">Clear all</button>' +
    '</div>' +
  '</div>';
  
  showGenericModal('ðŸ“· Map Scanned Text', html, 'ocrLineMapModal', function() {
    // On confirm â€” apply the mapped lines
    ocrLmApplyMapped();
  }, 'Use Mapped Lines');
  
  // Render initial state
  ocrLmRender();
}

function ocrLmRender() {
  const sourceList = document.getElementById('ocrLmSourceList');
  const targetSlots = document.getElementById('ocrLmTargetSlots');
  if (!sourceList || !targetSlots) return;
  
  // Render source lines
  let srcHtml = '';
  ocrLmSourceLines.forEach(function(line, idx) {
    const selected = ocrLmSelectedSource === idx;
    const assigned = line.assigned >= 0;
    srcHtml += '<div class="ocr-lm-source-item' + (selected ? ' selected' : '') + (assigned ? ' assigned' : '') + '" onclick="ocrLmClickSource(' + idx + ')">' +
      '<span class="lm-grip">â˜°</span>' +
      '<span class="lm-text">' + escapeHtml(line.text) + '</span>' +
      (assigned ? '<span class="lm-conf">â†’ Line ' + (line.assigned + 1) + '</span>' : '') +
    '</div>';
  });
  sourceList.innerHTML = srcHtml;
  
  // Render target slots
  let tgtHtml = '';
  for (let i = 0; i < 4; i++) {
    const slot = ocrLmSlots[i];
    const filled = slot !== null;
    const highlight = ocrLmSelectedSource >= 0;
    tgtHtml += '<div class="ocr-lm-slot' + (filled ? ' filled' : '') + (highlight && !filled ? ' highlight' : '') + '" onclick="ocrLmClickSlot(' + i + ')">' +
      '<span class="slot-label">Line ' + (i + 1) + '</span>';
    if (filled) {
      tgtHtml += '<span class="slot-content">' + escapeHtml(slot.text) + '</span>' +
        '<button class="slot-clear" onclick="event.stopPropagation(); ocrLmClearSlot(' + i + ');">Ã—</button>';
    } else {
      tgtHtml += '<span class="slot-placeholder">' + (i === 0 ? 'Click a scanned line, then click here' : 'optional') + '</span>';
    }
    tgtHtml += '</div>';
  }
  targetSlots.innerHTML = tgtHtml;
}

function ocrLmClickSource(idx) {
  if (ocrLmSelectedSource >= 0 && ocrLmSelectedSource !== idx) {
    // Two source lines selected â†’ merge them
    const line1 = ocrLmSourceLines[ocrLmSelectedSource];
    const line2 = ocrLmSourceLines[idx];
    // If either is assigned, unassign first
    if (line1.assigned >= 0) ocrLmClearSlot(line1.assigned);
    if (line2.assigned >= 0) ocrLmClearSlot(line2.assigned);
    // Merge: combine text, remove second line
    line1.text = line1.text + ' ' + line2.text;
    ocrLmSourceLines.splice(idx, 1);
    ocrLmSelectedSource = -1;
    showToast('Lines merged', 'success');
    ocrLmRender();
    return;
  }
  
  if (ocrLmSelectedSource === idx) {
    // Deselect
    ocrLmSelectedSource = -1;
  } else {
    ocrLmSelectedSource = idx;
  }
  ocrLmRender();
}

function ocrLmClickSlot(slotIdx) {
  if (ocrLmSelectedSource < 0) return; // nothing selected
  
  const srcLine = ocrLmSourceLines[ocrLmSelectedSource];
  
  // If this slot already has content, unassign the old source
  if (ocrLmSlots[slotIdx] !== null) {
    const oldSrcIdx = ocrLmSourceLines.findIndex(function(l) { return l.assigned === slotIdx; });
    if (oldSrcIdx >= 0) ocrLmSourceLines[oldSrcIdx].assigned = -1;
  }
  
  // If this source was already assigned to a different slot, clear that slot
  if (srcLine.assigned >= 0) {
    ocrLmSlots[srcLine.assigned] = null;
  }
  
  // Assign
  ocrLmSlots[slotIdx] = { text: srcLine.text, sourceIdx: ocrLmSelectedSource };
  srcLine.assigned = slotIdx;
  ocrLmSelectedSource = -1;
  ocrLmRender();
}

function ocrLmClearSlot(slotIdx) {
  const slot = ocrLmSlots[slotIdx];
  if (slot !== null) {
    // Un-assign the source line
    const srcLine = ocrLmSourceLines.find(function(l) { return l.assigned === slotIdx; });
    if (srcLine) srcLine.assigned = -1;
    ocrLmSlots[slotIdx] = null;
  }
  ocrLmRender();
}

function ocrLmClearAll() {
  ocrLmSlots = [null, null, null, null];
  ocrLmSourceLines.forEach(function(l) { l.assigned = -1; });
  ocrLmSelectedSource = -1;
  ocrLmRender();
}

function ocrLmAutoAssign() {
  ocrLmClearAll();
  const limit = Math.min(ocrLmSourceLines.length, 4);
  for (let i = 0; i < limit; i++) {
    ocrLmSlots[i] = { text: ocrLmSourceLines[i].text, sourceIdx: i };
    ocrLmSourceLines[i].assigned = i;
  }
  ocrLmRender();
}

function ocrLmApplyDirect(rows) {
  // Simple case: 1-4 lines â†’ paste directly into editor
  if (ocrLmDetectContext() === 'wf1') {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('wf1Line' + (i + 1));
      if (input) input.value = i < rows.length ? rows[i] : '';
    }
    wf1UpdateEditorPreview();
    showToast('Imported ' + Math.min(rows.length, 4) + ' line' + (rows.length !== 1 ? 's' : '') + ' from scan', 'success');
  } else {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = i < rows.length ? rows[i] : '';
    }
    updateFePreview();
    checkEditorDirty();
    showToast('Imported ' + Math.min(rows.length, 4) + ' line' + (rows.length !== 1 ? 's' : '') + ' from scan', 'success');
  }
}

function ocrLmApplyMapped() {
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push(ocrLmSlots[i] ? ocrLmSlots[i].text : '');
  }
  
  if (lines.every(function(l) { return !l; })) {
    showToast('No lines mapped â€” assign at least one', 'warning');
    return;
  }
  
  if (ocrLmTargetContext === 'wf1') {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('wf1Line' + (i + 1));
      if (input) input.value = lines[i];
    }
    wf1UpdateEditorPreview();
  } else {
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = lines[i];
    }
    updateFePreview();
    checkEditorDirty();
  }
  
  closeGenericModal('ocrLineMapModal');
  const mapped = lines.filter(function(l) { return l; }).length;
  showToast('Imported ' + mapped + ' line' + (mapped !== 1 ? 's' : '') + ' from scan', 'success');
}

function resetFullEditorState() {
  feLines = [
    { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, fontFamily: 'default', bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
  ];
  feAlignV = 'center';
  feGraphics = { left: null, right: null };
  feCurrentBarcode = null; // Reset barcode state
  feLastFocusedLine = null; // Reset token insertion target
  feIsStyleTemplate = false; // Reset style template mode
  
  // Reset style template dropdown
  const styleTemplateSelect = document.getElementById('feStyleTemplateSelect');
  if (styleTemplateSelect) styleTemplateSelect.value = '';
  
  // Close token panel if open
  const tokenPanel = document.getElementById('feTokenPanel');
  const tokenToggle = document.getElementById('feTokenToggle');
  if (tokenPanel) tokenPanel.classList.remove('visible');
  if (tokenToggle) tokenToggle.classList.remove('active');
  
  // Close emoji panel if open
  const emojiPanel = document.getElementById('feEmojiPanel');
  const emojiToggle = document.getElementById('feEmojiToggle');
  if (emojiPanel) emojiPanel.classList.remove('visible');
  if (emojiToggle) emojiToggle.classList.remove('active');
  
  // Reset inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) input.value = '';
    document.getElementById('feSize' + i).textContent = '11';
    
    // Reset align buttons
    document.querySelectorAll(`.fe-align-btn[data-line="${i}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === 'left');
    });
    
    // Reset style button
    const styleBtn = document.getElementById('feStyleBtn' + i);
    if (styleBtn) styleBtn.classList.remove('has-styles');
  }
  
  // Reset valign buttons
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === 'center');
  });
  
  // Reset border state
  feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  document.getElementById('feBorderTop').classList.remove('active');
  document.getElementById('feBorderBottom').classList.remove('active');
  document.getElementById('feBorderLeft').classList.remove('active');
  document.getElementById('feBorderRight').classList.remove('active');
  document.getElementById('feBorderAll').classList.remove('active');
  document.getElementById('feBorderColor').value = '#000000';
  
  // Reset graphics display
  renderFeGraphics();
  
  // Reset barcode button state
  updateBarcodeButtonState();
}

function loadTextIntoFullEditor(text) {
  // Check if this is a style template (has lineStyles instead of text)
  if (text.type === 'style' && text.lineStyles) {
    // Load from lineStyles array for style templates
    for (let i = 0; i < 4; i++) {
      const style = text.lineStyles[i] || { align: 'left', fontSize: 11, fontFamily: 'default' };
      feLines[i] = {
        text: 'Sample Line ' + (i + 1), // Sample text for preview
        align: style.align || 'left',
        fontSize: style.fontSize || 11,
        fontFamily: style.fontFamily || 'default',
        bold: style.bold || false,
        italic: style.italic || false,
        underline: style.underline || false,
        strikethrough: style.strikethrough || false,
        color: style.color || '',
        fillColor: style.fillColor || '',
        borders: ''
      };
      
      // Update inputs with sample text
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = feLines[i].text;
      document.getElementById('feSize' + (i + 1)).textContent = feLines[i].fontSize;
      
      // Update align buttons
      document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
        btn.classList.toggle('active', btn.dataset.align === feLines[i].align);
      });
      
      // Update style button indicator
      updateFeStyleButtonIndicator(i + 1);
    }
    
    // Set category and label type dropdowns
    const catSelect = document.getElementById('feStyleCategory');
    const typeSelect = document.getElementById('feStyleLabelType');
    if (catSelect) catSelect.value = text.category || 'simple';
    if (typeSelect) typeSelect.value = text.labelType || '5160';
  } else {
    // Regular text/template loading
    const lines = deserializeLines(text.text);
    
    for (let i = 0; i < 4; i++) {
      const line = lines[i] || { text: '', align: 'left', fontSize: 11, fontFamily: 'default' };
      feLines[i] = {
        text: line.text || '',
        align: line.align || 'left',
        fontSize: line.fontSize || 11,
        fontFamily: line.fontFamily || 'default',
        bold: line.bold || false,
        italic: line.italic || false,
        underline: line.underline || false,
        strikethrough: line.strikethrough || false,
        color: line.color || '',
        fillColor: line.fillColor || '',
        borders: line.borders || ''
      };
      
      // Update inputs
      const input = document.getElementById('feLine' + (i + 1));
      if (input) input.value = feLines[i].text;
      document.getElementById('feSize' + (i + 1)).textContent = feLines[i].fontSize;
      
      // Update align buttons
      document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
        btn.classList.toggle('active', btn.dataset.align === feLines[i].align);
      });
      
      // Update style button indicator
      updateFeStyleButtonIndicator(i + 1);
    }
  }
  
  // Load vertical alignment
  feAlignV = text.alignV || 'center';
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === feAlignV);
  });
  
  // Load graphics
  feGraphics = text.graphics ? { ...text.graphics } : { left: null, right: null };
  renderFeGraphics();
  
  // Load border state
  if (text.border) {
    feBorder = { ...text.border };
  } else {
    feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  }
  updateBorderUI();
  
  // Load barcode state
  if (text.barcode && text.barcode.enabled) {
    feCurrentBarcode = { ...text.barcode };
  } else {
    feCurrentBarcode = null;
  }
  updateBarcodeButtonState();
}

function updateBorderUI() {
  document.getElementById('feBorderTop').classList.toggle('active', feBorder.top);
  document.getElementById('feBorderBottom').classList.toggle('active', feBorder.bottom);
  document.getElementById('feBorderLeft').classList.toggle('active', feBorder.left);
  document.getElementById('feBorderRight').classList.toggle('active', feBorder.right);
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  document.getElementById('feBorderAll').classList.toggle('active', allActive);
  document.getElementById('feBorderColor').value = feBorder.color || '#000000';
}

function updateFeStyleButtonIndicator(lineNum) {
  const s = feLines[lineNum - 1];
  const hasStyles = s.bold || s.italic || s.underline || s.strikethrough || s.color || s.fillColor;
  const btn = document.getElementById('feStyleBtn' + lineNum);
  if (btn) btn.classList.toggle('has-styles', hasStyles);
}

// Alignment
function setFeAlign(lineNum, align) {
  feLines[lineNum - 1].align = align;
  document.querySelectorAll(`.fe-align-btn[data-line="${lineNum}"]`).forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// Font size
function stepFeSize(lineNum, delta) {
  const sizes = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24];
  const current = feLines[lineNum - 1].fontSize;
  const idx = sizes.indexOf(current);
  const newIdx = Math.max(0, Math.min(sizes.length - 1, idx + delta));
  feLines[lineNum - 1].fontSize = sizes[newIdx];
  document.getElementById('feSize' + lineNum).textContent = sizes[newIdx];
  updateFullEditorPreview();
  checkEditorDirty();
}

// Vertical alignment
function setFeValign(valign) {
  feAlignV = valign;
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === valign);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== GLOBAL STYLE CONTROLS ==========

function toggleGlobalStyle(styleProp) {
  // Check if all lines have this style
  const allHaveStyle = feLines.every(l => l[styleProp]);
  const newValue = !allHaveStyle;
  
  // Apply to all lines
  for (let i = 0; i < 4; i++) {
    feLines[i][styleProp] = newValue;
    updateFeStyleButtonIndicator(i + 1);
  }
  
  // Update global button
  const btn = document.getElementById('feGlobal' + styleProp.charAt(0).toUpperCase() + styleProp.slice(1));
  if (btn) btn.classList.toggle('active', newValue);
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalAlign(align) {
  for (let i = 0; i < 4; i++) {
    feLines[i].align = align;
    document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === align);
    });
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalFontSize(size) {
  for (let i = 0; i < 4; i++) {
    feLines[i].fontSize = size;
    document.getElementById('feSize' + (i + 1)).textContent = size;
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== BORDER CONTROLS ==========

function toggleFeBorder(side) {
  feBorder[side] = !feBorder[side];
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function toggleAllBorders() {
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  const newValue = !allActive;
  feBorder.top = newValue;
  feBorder.bottom = newValue;
  feBorder.left = newValue;
  feBorder.right = newValue;
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function updateFeBorderColor(color) {
  feBorder.color = color;
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== PREVIEW TYPE SELECTOR ==========

function changeFePreviewType(labelType) {
  fePreviewLabelType = labelType;
  updateFullEditorPreview();
  updateFeGraphicsAvailability();
}

// Update graphics section based on label type restrictions
function updateFeGraphicsAvailability() {
  const spec = LABEL_TYPES[fePreviewLabelType];
  const isRound = spec && spec.category === 'round';
  const isTent = spec && spec.category === 'tent';
  
  // Round and tent labels don't support side graphics
  const graphicsDisabled = isRound || isTent;
  
  const graphicsSection = document.getElementById('feGraphicsSection');
  if (graphicsSection) {
    if (graphicsDisabled) {
      graphicsSection.classList.add('disabled');
      graphicsSection.title = isRound ? 'Graphics not available for round labels' : 'Graphics not available for tent cards';
    } else {
      graphicsSection.classList.remove('disabled');
      graphicsSection.title = '';
    }
  }
  
  // Also update barcode position options if modal is open
  if (document.getElementById('barcodeModal').classList.contains('visible')) {
    updateBarcodePositionButtons();
  }
  
  // Re-render graphics to reflect disabled state
  renderFeGraphics();
}

// Style popover
function toggleFeStylePopover(lineNum) {
  const popover = document.getElementById('feStylePopover' + lineNum);
  const btn = document.getElementById('feStyleBtn' + lineNum);
  
  if (popover.classList.contains('open')) {
    closeFeStylePopovers();
  } else {
    closeFeStylePopovers();
    renderFeStylePopover(lineNum);
    popover.classList.add('open');
    btn.classList.add('popover-open');
    feActiveStylePopover = lineNum;
  }
}

function closeFeStylePopovers() {
  for (let i = 1; i <= 4; i++) {
    const popover = document.getElementById('feStylePopover' + i);
    const btn = document.getElementById('feStyleBtn' + i);
    if (popover) popover.classList.remove('open');
    if (btn) btn.classList.remove('popover-open');
  }
  feActiveStylePopover = null;
}

function renderFeStylePopover(lineNum) {
  const s = feLines[lineNum - 1];
  const popover = document.getElementById('feStylePopover' + lineNum);
  
  // Font family selector
  let html = '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Font</div>';
  html += `<select class="fe-font-select" onchange="setFeFont(${lineNum}, this.value)">`;
  for (const font of FE_FONTS) {
    const selected = (s.fontFamily || 'default') === font.id ? ' selected' : '';
    html += `<option value="${font.id}"${selected} style="font-family:${font.family}">${font.name}</option>`;
  }
  html += '</select></div>';
  
  // Style toggles
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Style</div>';
  html += '<div class="fe-style-toggles">';
  html += `<button class="fe-style-toggle${s.bold ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'bold')"><span class="lbl-b">B</span></button>`;
  html += `<button class="fe-style-toggle${s.italic ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'italic')"><span class="lbl-i">I</span></button>`;
  html += `<button class="fe-style-toggle${s.underline ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'underline')"><span class="lbl-u">U</span></button>`;
  html += `<button class="fe-style-toggle${s.strikethrough ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'strikethrough')"><span class="lbl-s">S</span></button>`;
  html += '</div></div>';
  
  // Text color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Text Color</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.color ? ' active' : ''}" onclick="setFeColor(${lineNum},'color','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.color === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'color','${c}')"></div>`;
  }
  html += '</div></div>';
  
  // Fill color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Background</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.fillColor ? ' active' : ''}" onclick="setFeColor(${lineNum},'fillColor','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.fillColor === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'fillColor','${c}')"></div>`;
  }
  html += '</div></div>';
  
  popover.innerHTML = html;
}

// Set font family for a line
function setFeFont(lineNum, fontId) {
  feLines[lineNum - 1].fontFamily = fontId;
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

function toggleFeStyle(lineNum, prop) {
  const s = feLines[lineNum - 1];
  s[prop] = !s[prop];
  
  // Underline and strikethrough are mutually exclusive
  if (prop === 'underline' && s.underline) s.strikethrough = false;
  if (prop === 'strikethrough' && s.strikethrough) s.underline = false;
  
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

function setFeColor(lineNum, prop, color) {
  feLines[lineNum - 1][prop] = color;
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

// Graphics
function renderFeGraphics() {
  renderFeGraphicSide('left');
  renderFeGraphicSide('right');
}

function renderFeGraphicSide(side) {
  const container = document.getElementById('feGraphic' + (side === 'left' ? 'Left' : 'Right') + 'Content');
  const g = feGraphics[side];
  
  // Check if label type doesn't support graphics
  const spec = LABEL_TYPES[fePreviewLabelType];
  const graphicsDisabled = spec && (spec.category === 'round' || spec.category === 'tent');
  
  if (graphicsDisabled) {
    // Show disabled state
    const reason = spec.category === 'round' ? 'round labels' : 'tent cards';
    container.innerHTML = `<div class="fe-graphic-disabled">
      <span style="opacity: 0.5;">ðŸ–¼</span>
      <span>N/A for ${reason}</span>
    </div>`;
    return;
  }
  
  // Check if barcode is using this slot
  const barcodeUsesSlot = feCurrentBarcode && feCurrentBarcode.enabled && 
    feCurrentBarcode.type === 'qr' && feCurrentBarcode.position === side;
  
  if (barcodeUsesSlot) {
    // Show that barcode is using this slot
    container.innerHTML = `<div class="fe-graphic-barcode-placeholder">
      <span style="font-size: 20px;">â–£</span>
      <span>QR Code</span>
    </div>`;
  } else if (!g || !g.data) {
    container.innerHTML = `<button class="fe-graphic-add" onclick="openFeGraphicPicker('${side}')">ðŸ–¼ Add Graphic</button>`;
  } else {
    let html = `<div class="fe-graphic-thumb" onclick="openFeGraphicPicker('${side}')"><img src="${g.data}"></div>`;
    html += '<div class="fe-graphic-size-pills">';
    for (const size of ['S', 'M', 'L']) {
      html += `<button class="fe-graphic-size-pill${g.size === size ? ' active' : ''}" onclick="setFeGraphicSize('${side}','${size}')">${size}</button>`;
    }
    html += '</div>';
    html += `<button class="fe-graphic-remove" onclick="removeFeGraphic('${side}')">âœ•</button>`;
    container.innerHTML = html;
  }
}

function setFeGraphicSize(side, size) {
  if (feGraphics[side]) {
    feGraphics[side].size = size;
    renderFeGraphicSide(side);
    updateFullEditorPreview();
  }
}

function removeFeGraphic(side) {
  feGraphics[side] = null;
  renderFeGraphicSide(side);
  updateFullEditorPreview();
}

// Graphic picker
function openFeGraphicPicker(side) {
  feGraphicPickerSide = side;
  document.getElementById('feGraphicPicker').classList.add('visible');
  switchFeGpTab('library');
}

function closeFeGraphicPicker() {
  document.getElementById('feGraphicPicker').classList.remove('visible');
  feGraphicPickerSide = null;
}

function switchFeGpTab(tab) {
  document.querySelectorAll('.fe-gp-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  
  const body = document.getElementById('feGpBody');
  
  if (tab === 'library') {
    // Build category filter
    let html = '<div style="margin-bottom:12px;"><select id="feGpCategoryFilter" onchange="renderFeGpLibrary()" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--input-bg);color:var(--text);font-size:14px;">';
    html += '<option value="all">All Categories</option>';
    Object.entries(FE_GRAPHICS_CATEGORIES).sort((a,b) => a[1].order - b[1].order).forEach(([key, cat]) => {
      html += `<option value="${key}">${cat.label}</option>`;
    });
    html += '</select></div>';
    html += '<div id="feGpIconGrid" class="fe-gp-grid"></div>';
    body.innerHTML = html;
    renderFeGpLibrary();
  } else {
    body.innerHTML = `
      <div class="fe-gp-upload-area">
        <button class="fe-gp-upload-btn" onclick="document.getElementById('feGraphicFileInput').click()">
          ðŸ“ Choose Image File
        </button>
        <div style="margin-top:12px;font-size:12px;color:var(--text-muted)">PNG, JPG, or SVG</div>
      </div>
    `;
  }
}

function renderFeGpLibrary() {
  const filter = document.getElementById('feGpCategoryFilter')?.value || 'all';
  const grid = document.getElementById('feGpIconGrid');
  if (!grid) return;
  
  let icons = FE_GRAPHICS_LIBRARY;
  if (filter !== 'all') {
    icons = icons.filter(i => i.cat === filter);
  }
  
  let html = '';
  for (const icon of icons) {
    html += `<div class="fe-gp-icon" onclick="selectFeLibraryGraphic('${icon.id}')" title="${icon.name}">${icon.svg}</div>`;
  }
  grid.innerHTML = html || '<div style="padding:20px;text-align:center;color:var(--text-muted)">No icons in this category</div>';
}

function selectFeLibraryGraphic(iconId) {
  const icon = FE_GRAPHICS_LIBRARY.find(i => i.id === iconId);
  if (icon && feGraphicPickerSide) {
    const dataUrl = 'data:image/svg+xml;base64,' + btoa(icon.svg);
    feGraphics[feGraphicPickerSide] = { data: dataUrl, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  }
}

function handleFeGraphicUpload(event) {
  const file = event.target.files[0];
  if (!file || !feGraphicPickerSide) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    feGraphics[feGraphicPickerSide] = { data: e.target.result, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  };
  reader.readAsDataURL(file);
  event.target.value = '';
}

// Preview
function updateFullEditorPreview() {
  // Get current text from inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) feLines[i - 1].text = input.value;
  }
  
  // Also check for dirty state on text input
  checkEditorDirty();
  
  const previewLabel = document.getElementById('fePreviewLabel');
  const nonEmptyLines = feLines.filter(l => l.text.trim());
  
  // Check if we have a QR code to show
  const hasQR = feCurrentBarcode && feCurrentBarcode.enabled && feCurrentBarcode.type === 'qr';
  const qrPosition = hasQR ? feCurrentBarcode.position : null;
  const qrOnly = qrPosition === 'only';
  
  if (nonEmptyLines.length === 0 && !feGraphics.left && !feGraphics.right && !hasQR) {
    previewLabel.className = 'fe-preview-label empty-preview';
    previewLabel.innerHTML = '<span>Type above to preview</span>';
    previewLabel.style.borderTop = '';
    previewLabel.style.borderBottom = '';
    previewLabel.style.borderLeft = '';
    previewLabel.style.borderRight = '';
    return;
  }
  
  previewLabel.className = 'fe-preview-label';
  
  // Calculate dimensions based on selected preview label type
  const labelType = fePreviewLabelType || settings.lastLabelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const aspectRatio = spec.labelW / spec.labelH;
  const maxWidth = 300;
  const width = Math.min(maxWidth, spec.labelW * 72);
  const height = width / aspectRatio;
  
  previewLabel.style.width = width + 'px';
  previewLabel.style.minHeight = height + 'px';
  
  // Apply border styles
  const borderStyle = '2px solid ' + (feBorder.color || '#000000');
  const noBorder = '2px solid #888';
  previewLabel.style.borderTop = feBorder.top ? borderStyle : noBorder;
  previewLabel.style.borderBottom = feBorder.bottom ? borderStyle : noBorder;
  previewLabel.style.borderLeft = feBorder.left ? borderStyle : noBorder;
  previewLabel.style.borderRight = feBorder.right ? borderStyle : noBorder;
  
  // Set vertical alignment
  if (feAlignV === 'top') {
    previewLabel.style.justifyContent = 'flex-start';
  } else if (feAlignV === 'bottom') {
    previewLabel.style.justifyContent = 'flex-end';
  } else if (feAlignV === 'spread') {
    previewLabel.style.justifyContent = 'space-between';
  } else {
    previewLabel.style.justifyContent = 'center';
  }
  
  // QR Only mode - just show the QR code
  if (qrOnly) {
    const qrDataURL = generatePreviewQR();
    if (qrDataURL) {
      const qrSize = Math.min(height - 10, 80);
      previewLabel.innerHTML = `<div style="display:flex;justify-content:center;align-items:center;width:100%;height:100%;"><img src="${qrDataURL}" style="width:${qrSize}px;height:${qrSize}px;"></div>`;
    } else {
      previewLabel.innerHTML = '<span style="color:var(--text-muted);">QR Code</span>';
    }
    return;
  }
  
  // Build preview HTML
  let html = '';
  
  // Check for graphics or QR in left/right positions
  const hasLeftContent = feGraphics.left || qrPosition === 'left';
  const hasRightContent = feGraphics.right || qrPosition === 'right';
  const hasGraphics = hasLeftContent || hasRightContent;
  
  if (hasGraphics) {
    html += '<div style="display:flex;align-items:center;width:100%;height:100%;">';
    
    // Left side (graphic or QR)
    if (qrPosition === 'left') {
      const qrDataURL = generatePreviewQR();
      const qrSize = Math.min(height - 10, 48);
      if (qrDataURL) {
        html += `<div style="flex-shrink:0;margin-right:6px;"><img src="${qrDataURL}" style="width:${qrSize}px;height:${qrSize}px;"></div>`;
      }
    } else if (feGraphics.left) {
      const size = feGraphics.left.size === 'S' ? 24 : feGraphics.left.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-right:6px;"><img src="${feGraphics.left.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '<div style="flex:1;min-width:0;">';
  }
  
  // Render lines
  for (const line of feLines) {
    if (!line.text.trim()) continue;
    
    const style = buildLineStyleStr(line);
    const align = line.align === 'center' ? 'center' : line.align === 'right' ? 'right' : 'left';
    const parsed = parseLine(line.text);
    
    if (parsed.type === 'split-fill') {
      // Render split layout with fill-lines
      let leftHtml, rightHtml;
      if (parsed.left.type === 'fill') {
        leftHtml = '<span>' + escapeHtml(parsed.left.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>' + (parsed.left.trailing ? '<span>' + escapeHtml(parsed.left.trailing) + '</span>' : '');
      } else {
        leftHtml = '<span>' + escapeHtml(parsed.left.text) + '</span>';
      }
      if (parsed.right.type === 'fill') {
        rightHtml = '<span>' + escapeHtml(parsed.right.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>' + (parsed.right.trailing ? '<span>' + escapeHtml(parsed.right.trailing) + '</span>' : '');
      } else {
        rightHtml = '<span>' + escapeHtml(parsed.right.text) + '</span>';
      }
      html += `<div class="preview-line" style="display:flex;justify-content:space-between;align-items:flex-end;gap:12px;${style}"><div style="display:flex;align-items:flex-end;gap:3px;flex:1;">${leftHtml}</div><div style="display:flex;align-items:flex-end;gap:3px;flex:1;justify-content:flex-end;">${rightHtml}</div></div>`;
    } else if (parsed.type === 'split') {
      html += `<div class="preview-line" style="display:flex;justify-content:space-between;${style}"><span>${escapeHtml(parsed.left)}</span><span>${escapeHtml(parsed.right)}</span></div>`;
    } else if (parsed.type === 'fill') {
      html += `<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;${style}"><span>${escapeHtml(parsed.label)}</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>${parsed.trailing ? '<span>' + escapeHtml(parsed.trailing) + '</span>' : ''}</div>`;
    } else {
      html += `<div class="preview-line align-${align}" style="${style}">${escapeHtml(parsed.text)}</div>`;
    }
  }
  
  if (hasGraphics) {
    html += '</div>';
    
    // Right side (graphic or QR)
    if (qrPosition === 'right') {
      const qrDataURL = generatePreviewQR();
      const qrSize = Math.min(height - 10, 48);
      if (qrDataURL) {
        html += `<div style="flex-shrink:0;margin-left:6px;"><img src="${qrDataURL}" style="width:${qrSize}px;height:${qrSize}px;"></div>`;
      }
    } else if (feGraphics.right) {
      const size = feGraphics.right.size === 'S' ? 24 : feGraphics.right.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-left:6px;"><img src="${feGraphics.right.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '</div>';
  }
  
  previewLabel.innerHTML = html;
  
  // Update dimensions text
  document.getElementById('fePreviewDimensions').textContent = `Avery ${labelType} Â· ${spec.sizeDisplay}`;
}

// Save
function saveFromFullEditor() {
  // Handle style template save differently
  if (feIsStyleTemplate) {
    saveStyleTemplateFromFullEditor();
    return;
  }
  
  // Get lines from state
  const lines = feLines.filter(l => l.text.trim());
  
  if (lines.length === 0) {
    showToast('Enter some text first', 'warning');
    return;
  }
  
  // Serialize lines
  const serialized = serializeLines(feLines.filter(l => l.text.trim()));
  
  // Check if any border is enabled
  const hasBorder = feBorder.top || feBorder.bottom || feBorder.left || feBorder.right;
  
  // Check if barcode is enabled
  const hasBarcode = feCurrentBarcode && feCurrentBarcode.enabled;
  
  if (feEditingId) {
    // Update existing
    const text = getSavedText(feEditingId);
    if (text) {
      // Update name if changed
      const newName = document.getElementById('feNameEdit').value.trim();
      if (newName) {
        text.name = newName;
      }
      
      text.text = serialized;
      text.alignV = feAlignV;
      text.graphics = feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined;
      text.border = hasBorder ? { ...feBorder } : undefined;
      text.barcode = hasBarcode ? { ...feCurrentBarcode } : undefined;
      saveSavedTexts();
      showToast('Saved changes', 'success');
      renderCurrentTab();
    }
  } else {
    // Create new
    const name = document.getElementById('feName').value.trim();
    if (!name) {
      document.getElementById('feName').style.borderColor = 'var(--error-border)';
      document.getElementById('feName').focus();
      return;
    }
    
    const newText = {
      id: generateId('st'),
      name: name,
      text: serialized,
      isTemplate: feIsTemplate,
      alignV: feAlignV,
      graphics: feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined,
      border: hasBorder ? { ...feBorder } : undefined,
      barcode: hasBarcode ? { ...feCurrentBarcode } : undefined,
      tokens: feIsTemplate ? extractTokens(serialized) : []
    };
    
    savedTexts.push(newText);
    saveSavedTexts();
    showToast('Created "' + name + '"', 'success');
    renderCurrentTab();
  }
  
  // Reset dirty state before closing
  feDirty = false;
  feOriginalState = null;
  
  // If opened from WF1 wizard, return to wizard instead of closing
  if (wf1_fullEditorActive) {
    closeFullEditorToWizard();
  } else {
    closeFullEditor();
  }
}

// Save style template from Full Editor
function saveStyleTemplateFromFullEditor() {
  // Get category and label type from dropdowns
  const category = document.getElementById('feStyleCategory')?.value || 'simple';
  const labelType = document.getElementById('feStyleLabelType')?.value || '5160';
  
  // Build lineStyles array from current feLines (without text)
  const lineStyles = feLines.map(line => ({
    fontFamily: line.fontFamily || 'default',
    fontSize: line.fontSize || 11,
    bold: line.bold || false,
    italic: line.italic || false,
    underline: line.underline || false,
    strikethrough: line.strikethrough || false,
    color: line.color || '',
    fillColor: line.fillColor || '',
    align: line.align || 'left'
  }));
  
  // Check if any border is enabled
  const hasBorder = feBorder.top || feBorder.bottom || feBorder.left || feBorder.right;
  
  if (feEditingId) {
    // Update existing style template
    const styleTemplate = getSavedText(feEditingId);
    if (styleTemplate) {
      // Update name if changed
      const newName = document.getElementById('feNameEdit').value.trim();
      if (newName) {
        styleTemplate.name = newName;
      }
      
      styleTemplate.type = 'style';
      styleTemplate.category = category;
      styleTemplate.labelType = labelType;
      styleTemplate.alignV = feAlignV;
      styleTemplate.lineStyles = lineStyles;
      styleTemplate.graphics = feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined;
      styleTemplate.border = hasBorder ? { ...feBorder } : undefined;
      
      saveSavedTexts();
      showToast('Style template saved', 'success');
      renderCurrentTab();
    }
  } else {
    // Create new style template
    const name = document.getElementById('feName').value.trim();
    if (!name) {
      document.getElementById('feName').style.borderColor = 'var(--error-border)';
      document.getElementById('feName').focus();
      return;
    }
    
    const newStyleTemplate = {
      id: generateId('sty'),
      name: name,
      type: 'style',
      category: category,
      labelType: labelType,
      builtin: false,
      alignV: feAlignV,
      lineStyles: lineStyles,
      graphics: feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined,
      border: hasBorder ? { ...feBorder } : undefined
    };
    
    savedTexts.push(newStyleTemplate);
    saveSavedTexts();
    showToast('Created style "' + name + '"', 'success');
    
    // Switch to Styles filter to show the new template
    templateFilterType = 'style';
    renderCurrentTab();
  }
  
  // Reset dirty state before closing
  feDirty = false;
  feOriginalState = null;
  closeFullEditor();
}

// Close popover on click outside
document.addEventListener('click', function(e) {
  if (feActiveStylePopover && !e.target.closest('.fe-style-popover') && !e.target.closest('.fe-style-btn')) {
    closeFeStylePopovers();
  }
});

// Open full editor from wizard (transfers current wizard content)
function openFullEditorFromWizard() {
  // Check if coming from WF1
  if (wf1_fullEditorActive) {
    closeWizard('wf1Wizard');
    feOpenedFromWizard = true;
    openFullEditor(null, false);
    
    // Transfer from WF1 inputs
    for (let i = 1; i <= 4; i++) {
      const wf1Input = document.getElementById('wf1Line' + i);
      const feInput = document.getElementById('feLine' + i);
      if (wf1Input && feInput && wf1Input.value) {
        feInput.value = wf1Input.value;
        feLines[i - 1].text = wf1Input.value;
        feLines[i - 1].align = wf1LineAligns[i - 1] || 'left';
        feLines[i - 1].fontSize = wf1LineSizes[i - 1] || 11;
      }
    }
    updateFullEditorPreview();
    showToast('Switched to full editor. Use "Back to Wizard" when done.', 'info');
    return;
  }
  
  // Fallback: open full editor standalone
  feOpenedFromWizard = false;
  openFullEditor(null, false);
  showToast('Opened full editor', 'info');
}

// ========== TAB NAVIGATION ==========
function switchTab(tabId) {
  currentTab = tabId;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabId);
  });
  
  // Handle workflows tab (workflow hub) vs other tabs (panels)
  const workflowHub = document.getElementById('workflowHub');
  if (tabId === 'workflows') {
    workflowHub.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.remove('active');
    });
    // Refresh Quick Actions when returning to workflow hub
    renderQuickActions();
  } else {
    workflowHub.classList.remove('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.toggle('active', panel.id === 'panel-' + tabId);
    });
    renderCurrentTab();
  }
}

// T10-T11: Quick Actions section - shows last N actions from print history
function renderQuickActions() {
  const container = document.getElementById('quickActionsSection');
  if (!container) return;
  
  const count = settings.quickActionsCount ?? 5;
  
  // If count is 0, hide the section entirely
  if (count === 0) {
    container.style.display = 'none';
    return;
  }
  container.style.display = '';
  
  // Get unique recent actions (deduplicate by content)
  const uniqueActions = [];
  const seenContent = new Set();
  
  for (const entry of printHistory) {
    // Create a key based on the content to deduplicate
    const contentKey = (entry.lines || []).join('|') + '::' + entry.labelType;
    if (!seenContent.has(contentKey)) {
      seenContent.add(contentKey);
      uniqueActions.push(entry);
      if (uniqueActions.length >= count) break;
    }
  }
  
  let html = '<div class="quick-actions-header">' +
    '<span class="quick-actions-label">âš¡ Quick reprint:</span>' +
  '</div>';
  
  if (uniqueActions.length === 0) {
    html += '<div class="quick-actions-empty">Print something to see quick actions here</div>';
  } else {
    html += '<div class="quick-actions-list">';
    
    for (const action of uniqueActions) {
      const lines = action.lines || [];
      // lines[0] may be a string or an object with .text property
      const firstLine = lines[0] ? (typeof lines[0] === 'string' ? lines[0] : lines[0].text || '') : '';
      const preview = firstLine ? escapeHtml(firstLine.substring(0, 40)) : 'Untitled';
      const labelType = action.labelType || '5160';
      const spec = LABEL_TYPES[labelType];
      
      // Format timestamp
      const date = new Date(action.timestamp);
      const timeAgo = formatTimeAgo(date);
      
      // Icon based on label type category
      let icon = 'ðŸ·ï¸';
      if (spec && spec.category === 'badge') icon = 'ðŸ‘‹';
      else if (spec && spec.category === 'tent') icon = 'â›º';
      else if (spec && spec.category === 'round') icon = 'â­•';
      
      html += '<div class="quick-action-item" onclick="quickActionReprint(\'' + action.id + '\')">' +
        '<div class="quick-action-icon">' + icon + '</div>' +
        '<div class="quick-action-content">' +
          '<div class="quick-action-title">' + preview + (lines.length > 1 ? '...' : '') + '</div>' +
          '<div class="quick-action-meta">' + labelType + ' Â· ' + timeAgo + '</div>' +
        '</div>' +
        '<div class="quick-action-badge">Reprint</div>' +
      '</div>';
    }
    
    html += '</div>';
  }
  
  container.innerHTML = html;
}

// Helper: format relative time
function formatTimeAgo(date) {
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return diffMins + 'm ago';
  if (diffHours < 24) return diffHours + 'h ago';
  if (diffDays < 7) return diffDays + 'd ago';
  
  // Format as date
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

// T10: Quick action reprint - launches WF2 with the selected history item
function quickActionReprint(historyId) {
  const entry = printHistory.find(e => e.id === historyId);
  if (!entry) return;
  
  // If entry has a textId, try to launch WF2 with that saved content
  if (entry.textId) {
    const savedText = savedTexts.find(t => t.id === entry.textId);
    if (savedText) {
      wf2Start();
      // Auto-select the saved content
      setTimeout(() => {
        wf2SelectItem({
          type: 'saved',
          id: savedText.id,
          name: savedText.name,
          lines: savedText.lines,
          labelType: savedText.labelType || entry.labelType
        });
        wf2ToStep2();
      }, 50);
      return;
    }
  }
  
  // Otherwise, route through reprint from history (falls back to WF2)
  reprintFromHistory(historyId);
}

function goToTab(tabId) {
  switchTab(tabId);
}

// Navigate to Sheets tab and expand a specific sheet card
function navigateToSheet(sheetId) {
  switchTab('sheets');
  // Give DOM time to render, then scroll to and highlight the sheet
  setTimeout(() => {
    const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + sheetId + '"]');
    if (sheetCard) {
      sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Add highlight animation
      sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
      setTimeout(() => {
        sheetCard.style.boxShadow = '';
      }, 2000);
    }
  }, 100);
}

function renderCurrentTab() {
  // Placeholder â€” each tab will have its own render function
  const stats = getDataStats();
  
  switch(currentTab) {
    case 'sheets':
      renderSheetsTab(stats);
      break;
    case 'saved':
      renderSavedTab(stats);
      break;
    case 'templates':
      renderTemplatesTab(stats);
      break;
    case 'inventory':
      renderInventoryTab(stats);
      break;
    case 'history':
      renderHistoryTab(stats);
      break;
  }
}

// Placeholder render functions â€” will be expanded in future sessions
function renderSheetsTab(stats) {
  const panel = document.getElementById('panel-sheets');
  const sheetList = Object.values(sheets).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
  
  // Separate job sheets from regular sheets, split active vs retired
  const regularSheets = sheetList.filter(s => !s.jobId);
  const activeSheets = regularSheets.filter(s => !s.retired);
  const retiredSheets = regularSheets.filter(s => s.retired);
  const jobSheets = sheetList.filter(s => s.jobId && activeJob && s.jobId === activeJob.id);
  
  let html = '';
  
  // Job banner if active job exists
  if (activeJob) {
    const totalRows = activeJob.list.length;
    const printedRows = activeJob.printedRowIndices.length;
    const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;
    let sheetsComplete = 0;
    activeJob.sheetIds.forEach(shId => {
      const sh = sheets[shId];
      if (!sh) return;
      const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
      const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
      if (printedOnSheet >= rowsOnSheet) sheetsComplete++;
    });
    
    html += '<div class="job-banner">' +
      '<div class="job-banner-header">' +
        '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
        '<div class="job-banner-actions">' +
          '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
          '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
        '</div>' +
      '</div>' +
      '<div class="job-banner-progress">' +
        '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
        '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
      '</div>' +
      '<div class="job-banner-info">' +
        '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
        '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
      '</div>' +
    '</div>';
  }
  
  html += '<div class="tab-header">' +
    '<div class="tab-title">Sheets (' + activeSheets.length + (retiredSheets.length ? ' + ' + retiredSheets.length + ' retired' : '') + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openNewSheetModal()">+ New Sheet</button>' +
    '</div>' +
  '</div>';
  
  if (activeSheets.length === 0 && retiredSheets.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“„</div><div class="panel-placeholder-text">No sheets yet. Create one to start tracking labels.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const sh of activeSheets) {
    const spec = LABEL_TYPES[sh.labelType];
    const lps = spec.cols * spec.rows;
    const total = getPoolSize(sh);
    const printed = getPrintedCount(sh);
    const remaining = total - printed;
    const isActive = sh.id === activeSheetId;
    const sheetCount = sh.sheetCount || 1;
    
    // Get assignments for color-coded grid
    const { assignments, errors } = buildAssignments(sh);
    
    // Build index map for quick lookup: index -> { textId, colorIdx }
    const indexMap = {};
    const textIds = sh.texts ? Object.keys(sh.texts) : [];
    textIds.forEach((textId, colorIdx) => {
      const indices = assignments[textId] || [];
      indices.forEach(idx => { 
        indexMap[idx] = { textId, colorIdx: colorIdx % 8 }; 
      });
    });
    
    // Build grid(s) - show multiple grids for pooled sheets
    let gridHtml = '';
    const printedSet = new Set(sh.printed || []);
    
    if (sheetCount <= 3) {
      // Show all grids side by side
      gridHtml = '<div class="sheet-grids-container">';
      for (let p = 0; p < sheetCount; p++) {
        gridHtml += '<div class="sheet-grid-wrapper">';
        if (sheetCount > 1) {
          gridHtml += '<div class="sheet-grid-label">Sheet ' + (p + 1) + '</div>';
        }
        gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
        for (let i = 0; i < lps; i++) {
          const poolIdx = p * lps + i;
          let cellClass = 'clickable';
          let cellTitle = 'Click to mark as used';
          if (printedSet.has(poolIdx)) {
            cellClass = 'printed clickable';
            cellTitle = 'Click to mark as available';
          } else if (indexMap[poolIdx]) {
            cellClass += ' cell-color-' + indexMap[poolIdx].colorIdx;
          }
          const cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="' + cellTitle + '"';
          gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
        }
        gridHtml += '</div></div>';
      }
      gridHtml += '</div>';
    } else {
      // Show first grid with page controls
      const currentPage = sheetGridPages[sh.id] || 0;
      gridHtml = '<div class="sheet-grids-container">';
      gridHtml += '<div class="sheet-grid-wrapper">';
      gridHtml += '<div class="sheet-grid-label">Sheet ' + (currentPage + 1) + ' of ' + sheetCount + '</div>';
      gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
      for (let i = 0; i < lps; i++) {
        const poolIdx = currentPage * lps + i;
        let cellClass = 'clickable';
        let cellTitle = 'Click to mark as used';
        if (printedSet.has(poolIdx)) {
          cellClass = 'printed clickable';
          cellTitle = 'Click to mark as available';
        } else if (indexMap[poolIdx]) {
          cellClass += ' cell-color-' + indexMap[poolIdx].colorIdx;
        }
        const cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="' + cellTitle + '"';
        gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
      }
      gridHtml += '</div>';
      gridHtml += '<div class="sheet-grid-pagination">' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', -1)"' + (currentPage === 0 ? ' disabled' : '') + '>â†</button>' +
        '<span class="sheet-grid-page-info">' + (currentPage + 1) + ' / ' + sheetCount + '</span>' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', 1)"' + (currentPage >= sheetCount - 1 ? ' disabled' : '') + '>â†’</button>' +
      '</div>';
      gridHtml += '</div></div>';
    }
    
    // Build assigned texts section (only for active sheet)
    let assignedHtml = '';
    let printActionsHtml = '';
    if (isActive) {
      assignedHtml = buildAssignedTextsHtml(sh, assignments, errors);
      printActionsHtml = buildPrintActionsHtml(sh, assignments, errors);
    }
    
    // Build note display if present
    const noteHtml = sh.note ? '<div class="sheet-note-display">' + escapeHtml(sh.note) + '</div>' : '';
    
    html += '<div class="sheet-card' + (isActive ? ' active' : '') + '" data-sheet-id="' + sh.id + '" onclick="selectSheet(\'' + sh.id + '\')">' +
      '<div class="sheet-card-header">' +
        '<div class="sheet-card-info">' +
          '<div class="sheet-card-name">' + escapeHtml(sh.name) + '</div>' +
          '<div class="sheet-card-type">' + spec.name + ' Â· ' + spec.sizeDisplay + '</div>' +
        '</div>' +
        '<div class="sheet-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showSyncSheetModal(\'' + sh.id + '\')" title="Sync grid â€” mark labels as used or available">ðŸ”„</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); printSheetLabel(\'' + sh.id + '\')" title="Print sheet label on back">ðŸ·ï¸</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSheet(\'' + sh.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); openEditSheetModal(\'' + sh.id + '\')" title="Edit">âœï¸</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); retireSheet(\'' + sh.id + '\')" title="Retire â€” hide from print workflows">ðŸ“¦</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSheet(\'' + sh.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
      noteHtml +
      gridHtml +
      '<div class="sheet-stats">' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + remaining + '</span> available</div>' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + printed + '</span> printed</div>' +
        (sheetCount > 1 ? '<div class="sheet-stat"><span class="sheet-stat-value">' + sheetCount + '</span> sheets pooled</div>' : '') +
      '</div>' +
      assignedHtml +
      printActionsHtml +
    '</div>';
  }
  
  // Retired sheets section (collapsible)
  if (retiredSheets.length > 0) {
    html += '<div style="margin-top:16px;border-top:1px solid var(--border);padding-top:12px;">' +
      '<button onclick="document.getElementById(\'retiredSheetsSection\').style.display = document.getElementById(\'retiredSheetsSection\').style.display === \'none\' ? \'block\' : \'none\'; this.querySelector(\'span\').textContent = document.getElementById(\'retiredSheetsSection\').style.display === \'none\' ? \'â–¸\' : \'â–¾\';" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:13px;padding:4px 0;display:flex;align-items:center;gap:6px;">' +
        '<span>â–¸</span> ðŸ“¦ ' + retiredSheets.length + ' retired sheet' + (retiredSheets.length !== 1 ? 's' : '') +
      '</button>' +
      '<div id="retiredSheetsSection" style="display:none;margin-top:8px;">';
    for (const sh of retiredSheets) {
      const spec = LABEL_TYPES[sh.labelType];
      const total = getPoolSize(sh);
      const printed = getPrintedCount(sh);
      const remaining = total - printed;
      const retiredDate = sh.retiredAt ? new Date(sh.retiredAt).toLocaleDateString() : '';
      html += '<div class="sheet-card" style="opacity:0.65;" onclick="event.stopPropagation()">' +
        '<div class="sheet-card-header">' +
          '<div class="sheet-card-info">' +
            '<div class="sheet-card-name" style="text-decoration:line-through;">' + escapeHtml(sh.name) + '</div>' +
            '<div class="sheet-card-type">' + spec.name + ' Â· Retired' + (retiredDate ? ' ' + retiredDate : '') + '</div>' +
          '</div>' +
          '<div class="sheet-card-actions">' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); unretireSheet(\'' + sh.id + '\')" title="Restore to active">â™»ï¸</button>' +
            '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSheet(\'' + sh.id + '\')" title="Delete permanently">ðŸ—‘ï¸</button>' +
          '</div>' +
        '</div>' +
        '<div class="sheet-stats">' +
          '<div class="sheet-stat"><span class="sheet-stat-value">' + remaining + '</span> available</div>' +
          '<div class="sheet-stat"><span class="sheet-stat-value">' + printed + '</span> printed</div>' +
        '</div>' +
      '</div>';
    }
    html += '</div></div>';
  }
  
  html += '</div>';
  panel.innerHTML = html;
}

// Build HTML for assigned texts section
function buildAssignedTextsHtml(sh, assignments, errors) {
  if (!sh.texts) sh.texts = {};
  const textIds = Object.keys(sh.texts);
  const spec = LABEL_TYPES[sh.labelType];
  
  // Build error lookup
  const errorMap = {};
  if (errors) {
    errors.forEach(e => { errorMap[e.textId] = e.message; });
  }
  
  let html = '<div class="assigned-texts-section">' +
    '<div class="assigned-texts-header">' +
      '<span class="assigned-texts-title">Assigned Content</span>' +
      '<button class="btn btn-primary assigned-add-btn" onclick="event.stopPropagation(); showAddTextToSheetModal(\'' + sh.id + '\')">+ Add</button>' +
    '</div>' +
    '<div class="assigned-texts-list">';
  
  if (textIds.length === 0) {
    html += '<div class="assigned-texts-empty">No content assigned. Click "+ Add" to assign content to this sheet.</div>';
  } else {
    textIds.forEach((textId, idx) => {
      const st = getSavedText(textId);
      if (!st) return;
      
      const entry = sh.texts[textId];
      const qty = entry.qty || 0;
      const placement = entry.placement || 'next';
      const colorIdx = idx % 8;
      const assignedCount = assignments && assignments[textId] ? assignments[textId].length : 0;
      const error = errorMap[textId];
      
      // Build placement options
      let placementHtml = '<select class="assigned-text-placement" onclick="event.stopPropagation()" onchange="setTextPlacement(\'' + sh.id + '\', \'' + textId + '\', this.value)">';
      placementHtml += '<option value="next"' + (placement === 'next' ? ' selected' : '') + '>Next Avail</option>';
      for (let c = 1; c <= spec.cols; c++) {
        const val = 'col:' + c;
        placementHtml += '<option value="' + val + '"' + (placement === val ? ' selected' : '') + '>Col ' + c + '</option>';
      }
      placementHtml += '</select>';
      
      const rowClass = error ? 'assigned-text-row has-error' : 'assigned-text-row';
      
      html += '<div class="' + rowClass + '" ondblclick="event.stopPropagation(); openContentEditorFromSheet(\'' + textId + '\', \'' + sh.id + '\')">' +
        '<div class="assigned-text-color text-color-' + colorIdx + '"></div>' +
        '<div class="assigned-text-info">' +
          '<div class="assigned-text-name">' + escapeHtml(st.name) + '</div>' +
          '<div class="assigned-text-spots">' + (error ? '<span style="color:var(--error-text)">' + error + '</span>' : assignedCount + ' label' + (assignedCount !== 1 ? 's' : '')) + '</div>' +
        '</div>' +
        '<div class="assigned-text-controls" ondblclick="event.stopPropagation()">' +
          placementHtml +
          '<div class="assigned-text-qty">' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', -1)">âˆ’</button>' +
            '<span class="qty-val">' + qty + '</span>' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', 1)">+</button>' +
          '</div>' +
        '</div>' +
        '<button class="assigned-text-remove" onclick="event.stopPropagation(); removeTextFromSheet(\'' + sh.id + '\', \'' + textId + '\')" ondblclick="event.stopPropagation()" title="Remove">âœ•</button>' +
      '</div>';
    });
  }
  
  html += '</div></div>';
  return html;
}

// Build print actions HTML for sheet
function buildPrintActionsHtml(sh, assignments, errors) {
  // Count total labels to print
  let totalToPrint = 0;
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  textIds.forEach(textId => {
    if (assignments && assignments[textId]) {
      totalToPrint += assignments[textId].length;
    }
  });
  
  const hasErrors = errors && errors.length > 0;
  const canPrint = totalToPrint > 0 && !hasErrors;
  const printedCount = (sh.printed || []).length;
  const hasUndo = lastPrintJob && lastPrintJob.sheetId === sh.id;
  
  if (textIds.length === 0 && printedCount === 0 && !hasUndo) {
    return ''; // No print section if no content and nothing to reset/undo
  }
  
  let html = '<div class="sheet-print-actions">';
  
  // Print button (only if content is assigned)
  if (textIds.length > 0) {
    html += '<button class="sheet-print-btn" onclick="event.stopPropagation(); printFromSheet(\'' + sh.id + '\')"' + (canPrint ? '' : ' disabled') + '>ðŸ–¨ï¸ Print ' + totalToPrint + ' Label' + (totalToPrint !== 1 ? 's' : '') + '</button>';
    
    if (hasErrors) {
      html += '<span class="sheet-print-summary" style="color:var(--error-text)">Fix placement errors first</span>';
    } else if (totalToPrint === 0) {
      html += '<span class="sheet-print-summary">Set quantities to print</span>';
    }
  }
  
  // Calculate remaining for split button
  const spec = LABEL_TYPES[sh.labelType];
  const poolSize = spec.cols * spec.rows * (sh.sheetCount || 1);
  const remainingCount = poolSize - printedCount;
  const canSplit = printedCount > 0 && remainingCount > 0;
  
  // Secondary actions row (Reset, Undo, Split)
  if (printedCount > 0 || hasUndo) {
    html += '<div class="sheet-secondary-actions">';
    
    // Reset button (if there are printed positions)
    if (printedCount > 0) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); resetSheet(\'' + sh.id + '\')" title="Reset all labels to available">ðŸ”„ Reset Sheet</button>';
    }
    
    // Undo button (if last print was on this sheet)
    if (hasUndo) {
      const undoCount = lastPrintJob.indices.length;
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); undoLastPrint()" title="Undo last print">â†©ï¸ Undo (' + undoCount + ' label' + (undoCount !== 1 ? 's' : '') + ')</button>';
    }
    
    // Split button (if there are both printed and remaining positions)
    if (canSplit) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); showSplitDialog(\'' + sh.id + '\')" title="Split remaining labels into new sheet">âœ‚ï¸ Split (' + remainingCount + ')</button>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  return html;
}

// Select a sheet (make it active)
function selectSheet(sheetId) {
  if (activeSheetId === sheetId) return; // Already selected
  activeSheetId = sheetId;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Set text placement on a sheet
function setTextPlacement(sheetId, textId, value) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  sh.texts[textId].placement = value;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Adjust assigned quantity
function adjustAssignedQty(sheetId, textId, delta) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  const current = sh.texts[textId].qty || 0;
  const newQty = Math.max(0, current + delta);
  sh.texts[textId].qty = newQty;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Remove text from sheet
function removeTextFromSheet(sheetId, textId) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts) return;
  delete sh.texts[textId];
  saveSheets();
  showToast('Content removed from sheet', 'info');
  renderSheetsTab(getDataStats());
}

// Add text to sheet modal
function showAddTextToSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const texts = getTexts();
  const existingIds = new Set(Object.keys(sh.texts || {}));
  const available = texts.filter(t => !existingIds.has(t.id));
  
  if (available.length === 0) {
    showToast('No content available to add. Create new content first.', 'warning');
    return;
  }
  
  // Store sheetId for use in addTextToSheetFromPicker
  window._addTextSheetId = sheetId;
  
  // Build picker content
  const modal = document.getElementById('addTextPickerModal');
  const content = document.getElementById('addTextPickerContent');
  document.getElementById('addTextPickerTitle').textContent = 'Add to "' + sh.name + '"';
  
  let html = '';
  for (const t of available) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 40);
    html += '<div class="saved-card" style="cursor: pointer;" onclick="addTextToSheetFromPicker(\'' + t.id + '\')">' +
      '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="saved-card-preview">' + escapeHtml(preview) + '</div>' +
    '</div>';
  }
  
  content.innerHTML = html;
  modal.classList.add('visible');
}

function closeAddTextPickerModal() {
  document.getElementById('addTextPickerModal').classList.remove('visible');
  window._addTextSheetId = null;
}

// Sheet modal functions
let editingSheetId = null;

function openNewSheetModal() {
  editingSheetId = null;
  document.getElementById('sheetModalTitle').textContent = 'New Sheet';
  document.getElementById('sheetNameInput').value = '';
  document.getElementById('sheetNoteInput').value = '';
  document.getElementById('sheetCountInput').value = '1';
  document.getElementById('sheetCountGroup').style.display = 'block';
  
  // Populate label type dropdown
  const select = document.getElementById('sheetTypeSelect');
  select.innerHTML = '';
  for (const [typeId, spec] of Object.entries(LABEL_TYPES)) {
    const opt = document.createElement('option');
    opt.value = typeId;
    opt.textContent = spec.name + ' (' + spec.cols + 'Ã—' + spec.rows + ')';
    select.appendChild(opt);
  }
  select.disabled = false;
  
  document.getElementById('sheetModal').classList.add('visible');
  setTimeout(() => document.getElementById('sheetNameInput').focus(), 100);
}

function openEditSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  editingSheetId = sheetId;
  document.getElementById('sheetModalTitle').textContent = 'Edit Sheet';
  document.getElementById('sheetNameInput').value = sh.name || '';
  document.getElementById('sheetNoteInput').value = sh.note || '';
  document.getElementById('sheetCountInput').value = sh.sheetCount || 1;
  document.getElementById('sheetCountGroup').style.display = 'none'; // Can't change count after creation
  
  // Populate and lock label type
  const select = document.getElementById('sheetTypeSelect');
  select.innerHTML = '';
  const spec = LABEL_TYPES[sh.labelType];
  const opt = document.createElement('option');
  opt.value = sh.labelType;
  opt.textContent = spec.name + ' (' + spec.cols + 'Ã—' + spec.rows + ')';
  select.appendChild(opt);
  select.disabled = true;
  
  document.getElementById('sheetModal').classList.add('visible');
  setTimeout(() => document.getElementById('sheetNameInput').focus(), 100);
}

function closeSheetModal() {
  document.getElementById('sheetModal').classList.remove('visible');
  editingSheetId = null;
}

function saveSheetModal() {
  const name = document.getElementById('sheetNameInput').value.trim();
  const note = document.getElementById('sheetNoteInput').value.trim();
  const labelType = document.getElementById('sheetTypeSelect').value;
  const sheetCount = parseInt(document.getElementById('sheetCountInput').value) || 1;
  
  if (!name) {
    showToast('Please enter a sheet name', 'error');
    return;
  }
  
  if (editingSheetId) {
    // Edit existing
    const sh = sheets[editingSheetId];
    if (sh) {
      sh.name = name;
      sh.note = note || null;
      saveSheets();
      showToast('Sheet updated', 'success');
    }
  } else {
    // Create new
    const id = generateId('sheet');
    sheets[id] = {
      id,
      name,
      labelType,
      printed: [],
      texts: {},
      note: note || null,
      sheetCount,
      createdAt: Date.now(),
      lastUsedAt: Date.now()
    };
    saveSheets();
    showToast('Sheet created', 'success');
  }
  
  closeSheetModal();
  renderCurrentTab();
}

// Saved text modal functions
let editingSavedTextId = null;

function openNewSavedTextModal() {
  editingSavedTextId = null;
  document.getElementById('savedTextModalTitle').textContent = 'New Saved Text';
  document.getElementById('savedTextNameInput').value = '';
  document.getElementById('savedTextLine1').value = '';
  document.getElementById('savedTextLine2').value = '';
  document.getElementById('savedTextLine3').value = '';
  document.getElementById('savedTextLine4').value = '';
  
  document.getElementById('savedTextModal').classList.add('visible');
  setTimeout(() => document.getElementById('savedTextNameInput').focus(), 100);
}

function openEditSavedTextModal(textId) {
  const st = getSavedText(textId);
  if (!st) return;
  
  editingSavedTextId = textId;
  document.getElementById('savedTextModalTitle').textContent = 'Edit Saved Text';
  document.getElementById('savedTextNameInput').value = st.name || '';
  
  const lines = deserializeLines(st.text);
  document.getElementById('savedTextLine1').value = lines[0] ? getFlatText([lines[0]]) : '';
  document.getElementById('savedTextLine2').value = lines[1] ? getFlatText([lines[1]]) : '';
  document.getElementById('savedTextLine3').value = lines[2] ? getFlatText([lines[2]]) : '';
  document.getElementById('savedTextLine4').value = lines[3] ? getFlatText([lines[3]]) : '';
  
  document.getElementById('savedTextModal').classList.add('visible');
  setTimeout(() => document.getElementById('savedTextNameInput').focus(), 100);
}

function closeSavedTextModal() {
  document.getElementById('savedTextModal').classList.remove('visible');
  editingSavedTextId = null;
}

// Barcode Modal functions for Full Editor
let selectedBarcodeType = null;

function openBarcodeModal() {
  // Get text from Full Editor lines
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) {
      const text = input.value.trim();
      if (text) lines.push(text);
    }
  }
  
  const allText = lines.join('\n');
  
  if (!allText) {
    showToast('Enter some text first', 'warning');
    return;
  }
  
  // Analyze what barcode types are possible
  const analysis = analyzeBarcodeOptions(allText);
  
  // Build the analysis box HTML
  const box = document.getElementById('barcodeAnalysisBox');
  let html = '<div style="font-weight: 600; margin-bottom: 10px;">Select barcode type:</div>';
  
  // QR Code - always available
  const qrOption = analysis.available.find(a => a.type === 'qr');
  html += '<div class="analysis-item available barcode-type-option" data-type="qr" onclick="selectBarcodeType(\'qr\')">' +
    '<span class="barcode-type-radio">â—‹</span> ' +
    '<strong>QR Code</strong> <span style="color: var(--text-muted);">(' + qrOption.note + ')</span>' +
    '</div>';
  
  // Other barcode types (grayed out for now)
  const otherTypes = analysis.available.filter(a => a.type !== 'qr');
  otherTypes.forEach(opt => {
    const available = opt.available;
    const cls = available ? 'available' : 'unavailable';
    const icon = available ? 'â—‹' : 'â—‹';
    const note = opt.note || '';
    const comingSoon = ' <span style="color: var(--text-muted); font-size: 11px;">(coming soon)</span>';
    html += '<div class="analysis-item ' + cls + ' barcode-type-option disabled" data-type="' + opt.type + '">' +
      '<span class="barcode-type-radio">' + icon + '</span> ' +
      '<strong>' + opt.name + '</strong>' + comingSoon +
      (note && !available ? ' <span style="color: var(--text-muted); font-size: 11px;">â€” ' + note + '</span>' : '') +
      '</div>';
  });
  
  // Show suggestion if any
  if (analysis.suggestion) {
    html += '<div class="analysis-suggestion">ðŸ’¡ ' + analysis.suggestion.label + '</div>';
  }
  
  box.innerHTML = html;
  
  // Check if barcode already set, show Remove button
  const removeBtn = document.getElementById('barcodeRemoveBtn');
  if (feCurrentBarcode && feCurrentBarcode.enabled) {
    removeBtn.style.display = 'inline-block';
    // Pre-select the current type and options
    selectedBarcodeType = feCurrentBarcode.type || 'qr';
    selectBarcodeType(selectedBarcodeType, true);
    setBarcodePosition(feCurrentBarcode.position || 'right');
    document.getElementById('barcodeEncodeType').value = feCurrentBarcode.encodeType || 'text';
  } else {
    removeBtn.style.display = 'none';
    selectedBarcodeType = null;
    document.getElementById('barcodeQrOptions').style.display = 'none';
    document.getElementById('barcode1dOptions').style.display = 'none';
  }
  
  document.getElementById('barcodeModal').classList.add('visible');
}

function closeBarcodeModal() {
  document.getElementById('barcodeModal').classList.remove('visible');
  selectedBarcodeType = null;
}

function selectBarcodeType(type, skipAnimation) {
  // Don't allow selecting disabled types
  const option = document.querySelector('.barcode-type-option[data-type="' + type + '"]');
  if (option && option.classList.contains('disabled')) {
    return;
  }
  
  selectedBarcodeType = type;
  
  // Update radio appearance
  document.querySelectorAll('.barcode-type-option').forEach(el => {
    const radio = el.querySelector('.barcode-type-radio');
    if (el.dataset.type === type) {
      el.classList.add('selected');
      radio.textContent = 'â—';
    } else {
      el.classList.remove('selected');
      radio.textContent = 'â—‹';
    }
  });
  
  // Show appropriate options panel
  if (type === 'qr') {
    document.getElementById('barcodeQrOptions').style.display = 'block';
    document.getElementById('barcode1dOptions').style.display = 'none';
    
    // Update position buttons based on existing graphics
    updateBarcodePositionButtons();
  } else {
    document.getElementById('barcodeQrOptions').style.display = 'none';
    document.getElementById('barcode1dOptions').style.display = 'block';
  }
}

function updateBarcodePositionButtons() {
  const leftBtn = document.querySelector('#barcodeModal .barcode-pos-btn[data-pos="left"]');
  const rightBtn = document.querySelector('#barcodeModal .barcode-pos-btn[data-pos="right"]');
  const onlyBtn = document.querySelector('#barcodeModal .barcode-pos-btn[data-pos="only"]');
  
  const hasLeftGraphic = feGraphics && feGraphics.left;
  const hasRightGraphic = feGraphics && feGraphics.right;
  
  // Check if label type doesn't support side positions
  const spec = LABEL_TYPES[fePreviewLabelType];
  const sidePositionsDisabled = spec && (spec.category === 'round' || spec.category === 'tent');
  const sideDisabledReason = sidePositionsDisabled ? 
    (spec.category === 'round' ? 'Not available for round labels' : 'Not available for tent cards') : '';
  
  // Disable left button if graphic exists OR label type doesn't support it
  if (leftBtn) {
    const leftDisabled = hasLeftGraphic || sidePositionsDisabled;
    leftBtn.disabled = leftDisabled;
    leftBtn.classList.toggle('disabled', leftDisabled);
    if (sidePositionsDisabled) {
      leftBtn.title = sideDisabledReason;
    } else if (hasLeftGraphic) {
      leftBtn.title = 'Left graphic slot is occupied';
    } else {
      leftBtn.title = '';
    }
  }
  
  // Disable right button if graphic exists OR label type doesn't support it
  if (rightBtn) {
    const rightDisabled = hasRightGraphic || sidePositionsDisabled;
    rightBtn.disabled = rightDisabled;
    rightBtn.classList.toggle('disabled', rightDisabled);
    if (sidePositionsDisabled) {
      rightBtn.title = sideDisabledReason;
    } else if (hasRightGraphic) {
      rightBtn.title = 'Right graphic slot is occupied';
    } else {
      rightBtn.title = '';
    }
  }
  
  // "Replace Text" is always available
  if (onlyBtn) {
    onlyBtn.disabled = false;
    onlyBtn.classList.remove('disabled');
  }
  
  // If current selection is disabled, switch to an available option
  const currentPos = getBarcodePosition();
  const leftDisabled = hasLeftGraphic || sidePositionsDisabled;
  const rightDisabled = hasRightGraphic || sidePositionsDisabled;
  
  if ((currentPos === 'left' && leftDisabled) || (currentPos === 'right' && rightDisabled)) {
    // Find first available position
    if (!rightDisabled) {
      setBarcodePosition('right');
    } else if (!leftDisabled) {
      setBarcodePosition('left');
    } else {
      setBarcodePosition('only');
    }
  }
}

function setBarcodePosition(pos) {
  const btns = document.querySelectorAll('#barcodeModal .barcode-pos-btn');
  btns.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.pos === pos);
  });
}

function getBarcodePosition() {
  const activeBtn = document.querySelector('#barcodeModal .barcode-pos-btn.active');
  return activeBtn ? activeBtn.dataset.pos : 'right';
}

function applyBarcode() {
  if (!selectedBarcodeType) {
    showToast('Select a barcode type', 'warning');
    return;
  }
  
  if (selectedBarcodeType === 'qr') {
    feCurrentBarcode = {
      enabled: true,
      type: 'qr',
      position: getBarcodePosition(),
      encodeType: document.getElementById('barcodeEncodeType').value
    };
  } else {
    // Future: 1D barcodes
    feCurrentBarcode = {
      enabled: true,
      type: selectedBarcodeType,
      showText: document.getElementById('barcode1dShowText').checked
    };
  }
  
  checkEditorDirty();
  closeBarcodeModal();
  showToast('Barcode added', 'success');
  
  // Update button to show barcode is active
  updateBarcodeButtonState();
}

function removeBarcode() {
  feCurrentBarcode = null;
  checkEditorDirty();
  closeBarcodeModal();
  showToast('Barcode removed', 'success');
  updateBarcodeButtonState();
}

function updateBarcodeButtonState() {
  const btn = document.getElementById('feBarcodeToggle');
  if (btn) {
    if (feCurrentBarcode && feCurrentBarcode.enabled) {
      btn.classList.add('active');
      btn.textContent = 'â–£ Barcode âœ“';
    } else {
      btn.classList.remove('active');
      btn.textContent = 'â–£ Barcode';
    }
  }
  // Update graphics section to show/hide barcode placeholder
  renderFeGraphics();
  // Also update the preview to show/hide QR
  updateFullEditorPreview();
}

// Generate QR code for Full Editor preview
function generatePreviewQR() {
  if (!feCurrentBarcode || !feCurrentBarcode.enabled || feCurrentBarcode.type !== 'qr') {
    return null;
  }
  
  // Get text from feLines
  const textLines = feLines.map(l => l.text || '').filter(Boolean);
  if (textLines.length === 0) return null;
  
  let textToEncode = textLines.join('\n');
  
  // Handle encode type
  if (feCurrentBarcode.encodeType === 'vcard') {
    textToEncode = generateVCard(textLines);
  } else if (feCurrentBarcode.encodeType === 'url' && !textToEncode.startsWith('http')) {
    textToEncode = 'https://' + textToEncode;
  }
  
  try {
    return QRCode.toDataURL(textToEncode, { size: 100, margin: 1 });
  } catch (e) {
    console.error('QR preview generation failed:', e);
    return null;
  }
}

function saveSavedTextModal() {
  const name = document.getElementById('savedTextNameInput').value.trim();
  const line1 = document.getElementById('savedTextLine1').value.trim();
  const line2 = document.getElementById('savedTextLine2').value.trim();
  const line3 = document.getElementById('savedTextLine3').value.trim();
  const line4 = document.getElementById('savedTextLine4').value.trim();
  
  if (!name) {
    showToast('Please enter a name', 'error');
    return;
  }
  
  if (!line1 && !line2 && !line3 && !line4) {
    showToast('Please enter at least one line of text', 'error');
    return;
  }
  
  // Build lines array
  const lines = [];
  if (line1) lines.push({ text: line1, align: 'left', fontSize: 11, bold: false, italic: false });
  if (line2) lines.push({ text: line2, align: 'left', fontSize: 11, bold: false, italic: false });
  if (line3) lines.push({ text: line3, align: 'left', fontSize: 11, bold: false, italic: false });
  if (line4) lines.push({ text: line4, align: 'left', fontSize: 11, bold: false, italic: false });
  
  if (editingSavedTextId) {
    // Edit existing
    const updates = {
      name,
      text: serializeLines(lines)
    };
    updateSavedText(editingSavedTextId, updates);
    showToast('Saved text updated', 'success');
  } else {
    // Create new
    createSavedText(name, lines, {});
    showToast('Saved text created', 'success');
  }
  
  closeSavedTextModal();
  renderCurrentTab();
}

// Generic simple modal close
function closeSimpleModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.remove('visible');
  }
}

// Generic modal close (alias)
function closeModal(modalId) {
  closeSimpleModal(modalId);
}

// Add text to sheet from picker
function addTextToSheetFromPicker(textId) {
  const sheetId = window._addTextSheetId;
  if (!sheetId) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  if (!sh.texts) sh.texts = {};
  
  if (sh.texts[textId]) {
    showToast('Content already assigned to this sheet', 'warning');
    return;
  }
  
  sh.texts[textId] = { qty: 0, placement: 'next' }; // Default to 0, user sets qty
  saveSheets();
  closeAddTextPickerModal();
  showToast('Content added. Set quantity to see it on the grid.', 'success');
  renderSheetsTab(getDataStats());
}

// Change sheet grid page (for multi-sheet pools)
function changeSheetPage(sheetId, delta) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const sheetCount = sh.sheetCount || 1;
  const current = sheetGridPages[sheetId] || 0;
  const newPage = Math.max(0, Math.min(sheetCount - 1, current + delta));
  sheetGridPages[sheetId] = newPage;
  renderSheetsTab(getDataStats());
}

// Open content editor from sheet (double-click)
function openContentEditorFromSheet(textId, sheetId) {
  const st = getSavedText(textId);
  if (!st) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  // Store the source sheet so we can set the preview label type
  window._editorSourceSheetId = sheetId;
  
  // Open the full editor with this content
  openFullEditor(textId, st.type === 'template');
}

// Print from sheet - the main print flow
function printFromSheet(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  // Reload sheets from localStorage to ensure fresh data
  loadSheets();
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const { assignments, errors } = buildAssignments(sh);
  
  if (errors && errors.length > 0) {
    showToast('Fix placement errors before printing', 'error');
    return;
  }
  
  // Collect all positions and their content
  const printManifest = [];
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  
  textIds.forEach(textId => {
    const indices = assignments[textId] || [];
    const st = getSavedText(textId);
    if (!st || indices.length === 0) return;
    
    const lines = deserializeLines(st.text);
    const graphics = st.graphics || { left: null, right: null };
    const alignV = st.alignV || 'center';
    const border = st.border || null;
    const barcode = st.barcode || null;
    
    indices.forEach(idx => {
      printManifest.push({ idx, lines, graphics, alignV, border, textId, barcode });
    });
  });
  
  if (printManifest.length === 0) {
    showToast('Nothing to print. Set quantities first.', 'warning');
    return;
  }
  
  // Sort by position
  printManifest.sort((a, b) => a.idx - b.idx);
  
  // Build print HTML
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Use iframe for printing (like v1.2)
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  
  // Wait for iframe to render, then print
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  // After print dialog closes, ask user to confirm
  const totalLabels = printManifest.length;
  showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer.\n\nDid the print complete successfully?',
    'ðŸ–¨ï¸ Confirm Print',
    'Yes, printed OK',
    false,
    (confirmed) => {
      if (confirmed) {
        // Mark positions as printed
        const positionsPrinted = printManifest.map(m => m.idx);
        markPositionsPrinted(sheetId, positionsPrinted);
        
        // Store quantities before resetting (for undo)
        const prevQtys = {};
        textIds.forEach(textId => {
          if (sh.texts[textId]) {
            prevQtys[textId] = sh.texts[textId].qty || 0;
            sh.texts[textId].qty = 0;
          }
        });
        saveSheets();
        
        // Stash for undo (from v1.2)
        lastPrintJob = {
          sheetId: sheetId,
          indices: positionsPrinted,
          textQtys: prevQtys
        };
        
        // Add to print history
        // Build a name from the texts being printed
        const textNames = textIds.map(tid => {
          const t = getSavedText(tid);
          return t ? t.name : 'Unknown';
        }).join(', ');
        addPrintHistoryEntry({
          textName: textNames || 'Mixed labels',
          sheetId: sh.id,
          sheetName: sh.name,
          labelType: sh.labelType,
          count: totalLabels,
          textIds: textIds
        });
        
        // Show success and refresh
        const remaining = getRemainingCount(sh);
        if (remaining > 0) {
          showToast('Printed! ' + remaining + ' spots left on "' + sh.name + '"', 'success');
        } else {
          showToast('"' + sh.name + '" is now full. Select or create another sheet.', 'success');
        }
        renderSheetsTab(getDataStats());
      } else {
        // User cancelled - no changes
        showToast('Print cancelled â€” no labels marked as used', 'warning');
        renderSheetsTab(getDataStats());
      }
    }
  );
}

// ========== UNDO/RESET FUNCTIONS (ported from v1.2) ==========

// Undo the last print job - restores printed positions and quantities
function undoLastPrint() {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  if (!lastPrintJob) {
    showToast('Nothing to undo', 'warning');
    return;
  }
  
  const sh = sheets[lastPrintJob.sheetId];
  if (!sh) {
    lastPrintJob = null;
    showToast('Sheet no longer exists', 'error');
    return;
  }
  
  const count = lastPrintJob.indices.length;
  showConfirm(
    'Undo the last print on "' + sh.name + '"?\n\nThis will unmark ' + count + ' position' + (count !== 1 ? 's' : '') + ' as used and restore the quantities.',
    'â†©ï¸ Undo Last Print',
    'Undo',
    false,
    (confirmed) => {
      if (!confirmed) return;
      
      // Remove printed indices
      const undoSet = new Set(lastPrintJob.indices);
      sh.printed = (sh.printed || []).filter(i => !undoSet.has(i));
      
      // Restore text quantities
      if (lastPrintJob.textQtys && sh.texts) {
        for (const [textId, qty] of Object.entries(lastPrintJob.textQtys)) {
          if (sh.texts[textId]) {
            sh.texts[textId].qty = qty;
          }
        }
      }
      
      saveSheets();
      const undoneSheetId = lastPrintJob.sheetId;
      const undoneName = sh.name;
      lastPrintJob = null; // Clear undo state
      
      // Refresh view
      renderSheetsTab(getDataStats());
      showToast('Print undone â€” positions restored on "' + undoneName + '"', 'success');
    }
  );
}

// Reset all printed positions on a sheet
function resetSheet(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const printedCount = (sh.printed || []).length;
  if (printedCount === 0) {
    showToast('No used labels to reset on "' + sh.name + '"', 'warning');
    return;
  }
  
  showConfirm(
    'Reset "' + sh.name + '" to all labels available?\n\nThis will unmark ' + printedCount + ' used position' + (printedCount !== 1 ? 's' : '') + ' and set all quantities to 0.\n\nThis is useful when you replace the physical sheet with a fresh one.',
    'ðŸ”„ Reset Sheet',
    'Reset All',
    true,
    (confirmed) => {
      if (!confirmed) return;
      
      sh.printed = [];
      
      // Reset all text quantities to 0
      if (sh.texts) {
        for (const entry of Object.values(sh.texts)) {
          entry.qty = 0;
        }
      }
      
      saveSheets();
      lastPrintJob = null; // Undo no longer relevant
      
      const spec = LABEL_TYPES[sh.labelType] || LABEL_TYPES['5160'];
      const total = spec.cols * spec.rows * (sh.sheetCount || 1);
      
      renderSheetsTab(getDataStats());
      showToast('"' + sh.name + '" reset â€” all ' + total + ' labels available', 'success');
    }
  );
}

// Toggle a printed cell back to available (click on printed cell)
function toggleCellPrinted(sheetId, idx) {
  const sh = sheets[sheetId];
  if (!sh) return;
  if (!sh.printed) sh.printed = [];
  
  const pos = sh.printed.indexOf(idx);
  if (pos === -1) {
    // Not printed â€” mark as used
    sh.printed.push(idx);
    showToast('Position marked as used', 'success');
  } else {
    // Printed â€” mark as available
    sh.printed.splice(pos, 1);
    showToast('Position marked as available', 'success');
  }
  
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Show sync sheet modal for bulk editing grid state
function showSyncSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const total = getPoolSize(sh);
  const printedCount = getPrintedCount(sh);
  const availableCount = total - printedCount;
  
  let content = '<div style="margin-bottom:16px;">' +
    '<p style="margin:0 0 8px;color:var(--text-muted);">Use this to sync LabelKeeper with the physical sheet if they\'ve gotten out of sync.</p>' +
    '<p style="margin:0;font-size:13px;"><strong>Current state:</strong> ' + availableCount + ' available, ' + printedCount + ' used</p>' +
  '</div>';
  
  content += '<div style="display:flex;flex-direction:column;gap:8px;">';
  
  // Quick actions
  content += '<div style="font-weight:600;margin-bottom:4px;">Quick Actions</div>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetMarkAllUsed(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">â¬›</span> Mark all as used (sheet is full)' +
  '</button>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetMarkAllAvailable(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">â¬œ</span> Mark all as available (fresh sheet)' +
  '</button>';
  
  content += '<button class="wf1-inv-btn" onclick="syncSheetSetUsedCount(\'' + sheetId + '\')" style="text-align:left;padding:10px 12px;">' +
    '<span style="font-size:16px;margin-right:8px;">ðŸ”¢</span> Set number of used labels...' +
  '</button>';
  
  content += '</div>';
  
  content += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);font-size:12px;color:var(--text-muted);">' +
    '<strong>Tip:</strong> You can also click individual cells in the grid to toggle them.' +
  '</div>';
  
  showGenericModal('Sync Sheet: ' + escapeHtml(sh.name), content, 'syncSheetModal');
}

// Mark all positions as used
function syncSheetMarkAllUsed(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const total = getPoolSize(sh);
  
  sh.printed = Array.from({ length: total }, (_, i) => i);
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast('All ' + total + ' labels marked as used', 'success');
}

// Mark all positions as available
function syncSheetMarkAllAvailable(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const total = getPoolSize(sh);
  sh.printed = [];
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast('All ' + total + ' labels marked as available', 'success');
}

// Set a specific number of used labels (marks from position 0)
async function syncSheetSetUsedCount(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const total = getPoolSize(sh);
  const currentUsed = getPrintedCount(sh);
  
  const input = await showPromptDialog(
    'How many labels have been used? (0-' + total + ')',
    'Set Used Count',
    currentUsed.toString()
  );
  if (input === null) return;
  
  const count = parseInt(input);
  if (isNaN(count) || count < 0 || count > total) {
    showToast('Please enter a number between 0 and ' + total, 'warning');
    return;
  }
  
  // Mark first N positions as used (row-by-row order)
  sh.printed = Array.from({ length: count }, (_, i) => i);
  saveSheets();
  closeGenericModal('syncSheetModal');
  renderSheetsTab(getDataStats());
  showToast(count + ' labels marked as used, ' + (total - count) + ' available', 'success');
}

// ========== SPLIT REMAINING LABELS (ported from v1.2) ==========

// Show the split remaining labels dialog
function showSplitDialog(sheetId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Sheet modifications only available on primary device', 'info');
    return;
  }
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  // Count open positions and physical sheets with open spots
  let openCount = 0;
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    let sheetOpen = 0;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!printed.has(i)) sheetOpen++;
    }
    if (sheetOpen > 0) {
      sheetsWithOpen.push({ physicalSheet: p, open: sheetOpen });
      openCount += sheetOpen;
    }
  }
  
  if (openCount === 0) {
    showToast('No remaining labels to split', 'warning');
    return;
  }
  
  document.getElementById('splitSummary').textContent = openCount + ' open label' + (openCount !== 1 ? 's' : '') + ' across ' + sheetsWithOpen.length + ' physical sheet' + (sheetsWithOpen.length !== 1 ? 's' : '');
  
  // Default name suggestion
  const specName = spec.name.split(' /')[0];
  document.getElementById('splitName').value = 'Leftover ' + specName + ' - ' + new Date().toLocaleDateString('en-US', { month: 'short' });
  
  // If only one physical sheet with open spots, hide split/together choice
  const splitModeGroup = document.getElementById('splitModeGroup');
  if (sheetsWithOpen.length <= 1) {
    splitModeGroup.style.display = 'none';
  } else {
    splitModeGroup.style.display = '';
  }
  
  // Store current sheet ID for execute
  document.getElementById('splitModal').dataset.sheetId = sheetId;
  
  document.getElementById('splitModal').classList.add('visible');
  document.getElementById('splitName').focus();
}

// Execute the split operation
function executeSplit() {
  const sheetId = document.getElementById('splitModal').dataset.sheetId;
  const sh = sheets[sheetId];
  if (!sh) {
    closeSimpleModal('splitModal');
    return;
  }
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  const name = document.getElementById('splitName').value.trim();
  if (!name) {
    document.getElementById('splitName').style.borderColor = 'var(--danger)';
    return;
  }
  
  const splitMode = document.querySelector('input[name="splitMode"]:checked').value;
  const textMode = document.querySelector('input[name="splitTexts"]:checked').value;
  
  // Identify physical sheets with open positions
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    const localPrinted = [];
    let hasOpen = false;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (printed.has(i)) {
        localPrinted.push(i % lps); // remap to local index
      } else {
        hasOpen = true;
      }
    }
    if (hasOpen) {
      sheetsWithOpen.push({ physicalSheet: p, localPrinted });
    }
  }
  
  if (sheetsWithOpen.length === 0) {
    closeSimpleModal('splitModal');
    return;
  }
  
  // Build text associations if keeping
  const textsToCarry = {};
  if (textMode === 'keep' && sh.texts) {
    for (const [textId, entry] of Object.entries(sh.texts)) {
      textsToCarry[textId] = { qty: 0, placement: entry.placement || 'next' };
    }
  }
  
  if (splitMode === 'separate' && sheetsWithOpen.length > 1) {
    // Create one new sheet per physical sheet with open spots
    sheetsWithOpen.forEach((info, idx) => {
      const newId = generateId('sheet');
      const suffix = sheetsWithOpen.length > 1 ? ' #' + (idx + 1) : '';
      sheets[newId] = {
        id: newId,
        name: name + suffix,
        printed: [...info.localPrinted],
        labelType: sh.labelType,
        sheetCount: 1,
        texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
        createdAt: Date.now() + idx
      };
    });
  } else {
    // Keep together as one pool
    const newId = generateId('sheet');
    const newCount = sheetsWithOpen.length;
    // Remap printed positions to new contiguous pool
    const newPrinted = [];
    sheetsWithOpen.forEach((info, newPage) => {
      info.localPrinted.forEach(localIdx => {
        newPrinted.push(newPage * lps + localIdx);
      });
    });
    sheets[newId] = {
      id: newId,
      name: name,
      printed: newPrinted,
      labelType: sh.labelType,
      sheetCount: newCount,
      texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
      createdAt: Date.now()
    };
  }
  
  // Reduce original sheet or delete it entirely
  const fullyConsumed = count - sheetsWithOpen.length;
  if (fullyConsumed === 0) {
    // All physical sheets had open positions â€” original is now empty, delete it
    delete sheets[sheetId];
    // Switch active sheet to the first newly created one
    const newIds = Object.keys(sheets).filter(id => sheets[id].createdAt >= Date.now() - 1000);
    activeSheetId = newIds.length > 0 ? newIds[0] : Object.keys(sheets)[0] || null;
  } else if (fullyConsumed > 0 && fullyConsumed < count) {
    // Keep only the consumed physical sheets in the original
    sh.sheetCount = fullyConsumed;
    // Remove printed indices that belong to split-off sheets
    const keepRange = fullyConsumed * lps;
    sh.printed = sh.printed.filter(i => i < keepRange);
  }
  
  saveSheets();
  closeSimpleModal('splitModal');
  
  renderSheetsTab(getDataStats());
  showToast('Split remaining labels into new sheet' + (splitMode === 'separate' && sheetsWithOpen.length > 1 ? 's' : ''), 'success');
}

// ========== CLIPBOARD IMPORT (ported from v1.2) ==========

let importRows = [];           // Raw clipboard rows
let importIsTabular = false;   // Tabular mode (tabs + newlines)
let importLinesPerLabel = 1;   // Plain list: lines per label
let importColMap = [];         // Tabular: column â†’ line mapping
let importTemplateTokenMap = []; // Per-column: token name (string) or null (skip)

// Paste data handler - detects images (routes to OCR) or text (opens import modal)
async function pasteData() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // If >4 rows or tabular data with multiple rows, open import modal
  if (rows.length > 4 || (isTabular && rows.length > 1)) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // â‰¤4 plain rows: show quick import (create single text from clipboard)
  showQuickImportModal(rows);
}

// Show quick import for small clipboard data (1-4 lines)
function showQuickImportModal(rows) {
  const maxLines = Math.min(rows.length, 4);
  const lines = [];
  for (let i = 0; i < maxLines; i++) {
    lines.push({ text: rows[i], align: 'left', fontSize: 11 });
  }
  
  // Create temporary text for preview
  const previewHtml = renderMiniPreview(lines, false, null);
  
  showConfirm(
    'Import ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard?\n\nPreview:\n' + rows.slice(0, maxLines).join('\n'),
    'ðŸ“‹ Import from Clipboard',
    'Import as New Content',
    false,
    (confirmed) => {
      if (confirmed) {
        // Create new saved text
        const newText = {
          id: generateId('text'),
          name: 'Imported ' + new Date().toLocaleTimeString(),
          text: serializeLines(lines),
          alignV: 'center',
          type: 'text',
          graphics: null,
          createdAt: Date.now()
        };
        savedTexts.push(newText);
        saveTexts();
        showToast('Created "' + newText.name + '" from clipboard', 'success');
        renderSavedTab(getDataStats());
      }
    }
  );
}

// Show full import modal for larger datasets
function showImportModal(rows, isTabular) {
  importRows = rows;
  importIsTabular = isTabular;
  importLinesPerLabel = 1;
  importColMap = [];
  importTemplateTokenMap = [];
  
  // Populate template dropdown
  const tplSelect = document.getElementById('importTemplateSelect');
  let tplOpts = '<option value="">No Template (manual)</option>';
  const templates = getTemplates();
  templates.forEach(t => {
    tplOpts += '<option value="' + t.id + '">' + escapeHtml(t.name) + '</option>';
  });
  tplSelect.innerHTML = tplOpts;
  
  if (isTabular) {
    const parsed = rows.map(r => r.split('\t').map(c => c.trim()));
    const colCount = Math.max(...parsed.map(r => r.length));
    importColMap = new Array(colCount).fill(0);
    
    document.getElementById('importSummary').textContent = parsed.length + ' rows Ã— ' + colCount + ' columns detected';
    document.getElementById('importPlainControls').style.display = 'none';
    document.getElementById('importTabularControls').style.display = '';
    buildImportColMappingUI();
  } else {
    document.getElementById('importSummary').textContent = rows.length + ' lines detected from clipboard';
    document.getElementById('importPlainControls').style.display = '';
    document.getElementById('importTabularControls').style.display = 'none';
    document.getElementById('linesPerLabelVal').textContent = '1';
  }
  
  // Populate sheet dropdown
  const sheetSelect = document.getElementById('importSheetAssign');
  let sheetOpts = '<option value="">â€” Don\'t assign â€”</option>';
  for (const [id, sh] of Object.entries(sheets)) {
    const spec = LABEL_TYPES[sh.labelType];
    const pool = spec.cols * spec.rows * (sh.sheetCount || 1);
    const used = (sh.printed || []).length;
    const assigned = Object.values(sh.texts || {}).reduce((s, t) => s + (t.qty || 0), 0);
    const avail = pool - used - assigned;
    sheetOpts += '<option value="' + id + '">' + escapeHtml(sh.name) + ' (' + avail + ' spots)</option>';
  }
  sheetSelect.innerHTML = sheetOpts;
  if (activeSheetId && sheets[activeSheetId]) sheetSelect.value = activeSheetId;
  
  document.getElementById('importBaseName').value = '';
  updateImportPreview();
  
  document.getElementById('importTextModal').classList.add('visible');
  document.getElementById('importBaseName').focus();
}

// Build column mapping UI for tabular data
function buildImportColMappingUI() {
  if (!importIsTabular) return;
  const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
  const colCount = Math.max(...parsed.map(r => r.length));
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  let mapHtml = '';
  if (tpl && tpl.tokens && tpl.tokens.length) {
    // Template mode: map columns to tokens
    document.getElementById('importColMappingTitle').textContent = 'Map columns to template tokens:';
    const headers = parsed.length > 0 ? parsed[0] : [];
    const autoMap = autoMapColumns(headers.map(h => h || ''), tpl.tokens);
    importTemplateTokenMap = [];
    
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      const autoToken = autoMap[c] || null;
      importTemplateTokenMap.push(autoToken);
      
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportTokenMap(' + c + ', this.value)">';
      mapHtml += '<option value="">Skip</option>';
      tpl.tokens.forEach(t => {
        mapHtml += '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>';
      });
      mapHtml += '</select></div>';
    }
  } else {
    // Manual mode: map columns to line numbers
    document.getElementById('importColMappingTitle').textContent = 'Map columns to label lines:';
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportColMap(' + c + ', this.value)">';
      mapHtml += '<option value="0"' + (importColMap[c] === 0 ? ' selected' : '') + '>Skip</option>';
      for (let ln = 1; ln <= 4; ln++) {
        mapHtml += '<option value="' + ln + '"' + (importColMap[c] === ln ? ' selected' : '') + '>â†’ Line ' + ln + '</option>';
      }
      mapHtml += '</select></div>';
    }
  }
  document.getElementById('importColMapping').innerHTML = mapHtml;
}

function onImportTemplateChange() {
  if (importIsTabular) {
    buildImportColMappingUI();
  }
  updateImportPreview();
}

function updateImportTokenMap(colIdx, tokenName) {
  importTemplateTokenMap[colIdx] = tokenName || null;
  updateImportPreview();
}

function stepLinesPerLabel(delta) {
  importLinesPerLabel = Math.max(1, Math.min(4, importLinesPerLabel + delta));
  document.getElementById('linesPerLabelVal').textContent = importLinesPerLabel;
  updateImportPreview();
}

function updateImportColMap(colIdx, val) {
  importColMap[colIdx] = parseInt(val);
  updateImportPreview();
}

// Generate preview records from import data
function getImportRecords() {
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  const records = [];
  
  if (importIsTabular) {
    const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
    
    if (tpl && tpl.tokens && tpl.tokens.length) {
      // Template mode: generate records by filling tokens
      parsed.forEach(row => {
        const tokenValues = {};
        importTemplateTokenMap.forEach((token, colIdx) => {
          if (token && row[colIdx]) {
            tokenValues[token] = row[colIdx];
          }
        });
        if (Object.keys(tokenValues).length > 0) {
          // Apply template
          const filledLines = applyTemplateTokens(tpl, tokenValues);
          records.push({ lines: filledLines, alignV: tpl.alignV || 'center' });
        }
      });
    } else {
      // Manual mode: map columns to lines
      parsed.forEach(row => {
        const lines = [];
        importColMap.forEach((lineNum, colIdx) => {
          if (lineNum > 0 && row[colIdx]) {
            while (lines.length < lineNum) {
              lines.push({ text: '', align: 'left', fontSize: 11 });
            }
            lines[lineNum - 1] = { text: row[colIdx], align: 'left', fontSize: 11 };
          }
        });
        if (lines.some(l => l.text)) {
          records.push({ lines, alignV: 'center' });
        }
      });
    }
  } else {
    // Plain list mode: group by lines per label
    for (let i = 0; i < importRows.length; i += importLinesPerLabel) {
      const lines = [];
      for (let j = 0; j < importLinesPerLabel && i + j < importRows.length; j++) {
        lines.push({ text: importRows[i + j], align: 'left', fontSize: 11 });
      }
      records.push({ lines, alignV: 'center' });
    }
  }
  
  return records;
}

// Apply template tokens to generate lines
function applyTemplateTokens(tpl, tokenValues) {
  const sourceLines = deserializeLines(tpl.text);
  return sourceLines.map(line => {
    let text = line.text;
    for (const [token, value] of Object.entries(tokenValues)) {
      text = text.replace(new RegExp('\\{' + token + '\\}', 'g'), value);
    }
    // Remove any unfilled tokens
    text = text.replace(/\{[^}]+\}/g, '').trim();
    return { ...line, text };
  });
}

function updateImportPreview() {
  const records = getImportRecords();
  const previewArea = document.getElementById('importPreviewArea');
  
  if (records.length === 0) {
    previewArea.innerHTML = '<span style="color:var(--text-muted)">No records to preview</span>';
    document.getElementById('importRecordCount').textContent = '';
    return;
  }
  
  // Show first 3 records
  let html = '';
  for (let i = 0; i < Math.min(3, records.length); i++) {
    html += '<div class="import-preview-label">';
    records[i].lines.forEach(line => {
      if (line.text) {
        html += '<div style="text-align:' + line.align + '">' + escapeHtml(line.text) + '</div>';
      }
    });
    html += '</div>';
  }
  if (records.length > 3) {
    html += '<div style="display:flex;align-items:center;color:var(--text-muted);font-size:12px">+' + (records.length - 3) + ' more</div>';
  }
  previewArea.innerHTML = html;
  
  document.getElementById('importRecordCount').textContent = records.length + ' record' + (records.length !== 1 ? 's' : '');
  
  // Update name preview
  const baseName = document.getElementById('importBaseName').value.trim() || 'Text';
  document.getElementById('importNamePreview').textContent = 'Will create: "' + baseName + ' 1", "' + baseName + ' 2", etc.';
}

// Execute import - create saved texts from parsed data
function executeImport() {
  const records = getImportRecords();
  if (!records.length) {
    closeModal('importTextModal');
    return;
  }
  
  const baseName = document.getElementById('importBaseName').value.trim() || 'Imported';
  const sheetId = document.getElementById('importSheetAssign').value;
  
  // Create saved texts
  const newIds = [];
  records.forEach((rec, idx) => {
    const newText = {
      id: generateId('text'),
      name: baseName + ' ' + (idx + 1),
      text: serializeLines(rec.lines),
      alignV: rec.alignV || 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now() + idx
    };
    savedTexts.push(newText);
    newIds.push(newText.id);
  });
  saveTexts();
  
  // Assign to sheet if selected
  if (sheetId && sheets[sheetId]) {
    const sh = sheets[sheetId];
    if (!sh.texts) sh.texts = {};
    newIds.forEach(id => {
      sh.texts[id] = { qty: 1, placement: 'next' };
    });
    saveSheets();
  }
  
  closeModal('importTextModal');
  
  showToast('Imported ' + records.length + ' text' + (records.length !== 1 ? 's' : ''), 'success');
  
  // Refresh tabs
  renderSavedTab(getDataStats());
  if (sheetId) {
    renderSheetsTab(getDataStats());
  }
}

// Build inline style string for a line object (bold, italic, color, etc.)
function buildLineStyleStr(line) {
  let style = 'font-size:' + (line.fontSize || 11) + 'pt;';
  // Add font family
  if (line.fontFamily && line.fontFamily !== 'default') {
    style += 'font-family:' + getFontFamily(line.fontFamily) + ';';
  }
  if (line.bold) style += 'font-weight:bold;';
  if (line.italic) style += 'font-style:italic;';
  if (line.underline && line.strikethrough) style += 'text-decoration:underline line-through;';
  else if (line.underline) style += 'text-decoration:underline;';
  else if (line.strikethrough) style += 'text-decoration:line-through;';
  if (line.color) style += 'color:' + line.color + ';';
  if (line.fillColor) style += 'background-color:' + line.fillColor + ';';
  return style;
}

// Render a single line object to print-ready HTML (handles split, fill, split-fill syntax)
function renderPrintLineHtml(line) {
  if (!line.text && line.text !== '') return '';
  const text = line.text || '';
  if (!text.trim()) return '';

  const style = buildLineStyleStr(line);
  const parsed = parseLine(text);

  if (parsed.type === 'split-fill') {
    // Split with fill-lines on one or both sides
    let leftHtml, rightHtml;
    if (parsed.left.type === 'fill') {
      leftHtml = '<span class="fill-label">' + escapeHtml(parsed.left.label) + '</span><span class="fill-rule"></span>' + (parsed.left.trailing ? '<span class="fill-label">' + escapeHtml(parsed.left.trailing) + '</span>' : '');
    } else {
      leftHtml = '<span>' + escapeHtml(parsed.left.text) + '</span>';
    }
    if (parsed.right.type === 'fill') {
      rightHtml = '<span class="fill-label">' + escapeHtml(parsed.right.label) + '</span><span class="fill-rule"></span>' + (parsed.right.trailing ? '<span class="fill-label">' + escapeHtml(parsed.right.trailing) + '</span>' : '');
    } else {
      rightHtml = '<span>' + escapeHtml(parsed.right.text) + '</span>';
    }
    return '<div class="print-line align-split-fill" style="' + style + '"><div class="split-fill-left">' + leftHtml + '</div><div class="split-fill-right">' + rightHtml + '</div></div>';
  }
  if (parsed.type === 'split') {
    return '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
  }
  if (parsed.type === 'fill') {
    return '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
  }
  // Normal text
  const alignClass = 'align-' + (line.align || 'left');
  return '<div class="print-line ' + alignClass + '" style="' + style + '">' + escapeHtml(text) + '</div>';
}

// Build print HTML for sheet-based printing
function buildSheetPrintHtml(sh, manifest) {
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const isTentCard = spec.category === 'tent';
  const isRound = spec.category === 'round';
  
  // Build CSS
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; }';
  html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; }';
  html += '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }';
  html += '.print-label-gfx { flex-direction:row; align-items:stretch; }';
  html += '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }';
  html += '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }';
  html += '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }';
  html += '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }';
  html += '.print-line.align-left { justify-content:flex-start; text-align:left; }';
  html += '.print-line.align-center { justify-content:center; text-align:center; }';
  html += '.print-line.align-right { justify-content:flex-end; text-align:right; }';
  html += '.print-line.align-split { justify-content:space-between; text-align:left; }';
  html += '.print-line.align-split > span { min-width:0; overflow:hidden; text-overflow:ellipsis; }';
  html += '.print-line.align-split-fill { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; }';
  html += '.print-line.align-split-fill .split-fill-left, .print-line.align-split-fill .split-fill-right { display:flex; align-items:flex-end; gap:3px; flex:1; }';
  html += '.print-line.align-split-fill .split-fill-right { justify-content:flex-end; }';
  html += '.print-line.align-split-fill .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  html += '.print-line.align-split-fill .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }';
  html += '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  // Round label styling
  if (isRound) {
    html += '.print-label.round-label { border-radius:50%; justify-content:center; align-items:center; text-align:center; }';
    html += '.print-label.round-label .print-text-zone { align-items:center; justify-content:center; }';
    html += '.print-label.round-label .print-line { justify-content:center; text-align:center; }';
  }
  // Tent card fold line styling
  if (isTentCard) {
    html += '.print-label.tent-card { position:relative; padding:0; }';
    html += '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #ccc; z-index:1; }';
    html += '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }';
    html += '.tent-top { top:0; height:50%; }';
    html += '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }';
  }
  // Label boundary debugging rectangles
  if (settings.showLabelBoundaries) {
    html += '.label-boundary { position:absolute; border:1px solid #ccc; box-sizing:border-box; pointer-events:none; }';
    if (isRound) {
      html += '.label-boundary { border-radius:50%; }';
    }
  }
  html += '</style></head><body>';
  
  // Group manifest by physical page
  const pages = {};
  manifest.forEach(item => {
    const pageNum = Math.floor(item.idx / lps);
    if (!pages[pageNum]) pages[pageNum] = [];
    pages[pageNum].push(item);
  });
  
  // Helper to get flex alignment string
  function getFlexAlign(alignV) {
    if (alignV === 'top') return 'flex-start';
    if (alignV === 'bottom') return 'flex-end';
    if (alignV === 'spread') return 'space-between';
    return 'center';
  }
  
  // Helper to generate QR code data URL
  function getQRDataURL(item, spec) {
    const bc = item.barcode;
    if (!bc || !bc.enabled) return null;
    
    // Build text to encode
    let textToEncode = item.lines.map(l => l.text || '').filter(Boolean).join('\n');
    
    // Handle different encode types
    if (bc.encodeType === 'vcard') {
      const lineTexts = item.lines.map(l => l.text || '');
      textToEncode = generateVCard(lineTexts);
    } else if (bc.encodeType === 'url' && !textToEncode.startsWith('http')) {
      textToEncode = 'https://' + textToEncode;
    }
    
    // Calculate QR size based on label height (roughly 80% of label height)
    const qrSize = Math.floor(spec.labelH * 96 * 0.8); // 96 DPI
    
    try {
      return QRCode.toDataURL(textToEncode, { size: qrSize, margin: 1 });
    } catch (e) {
      console.error('QR generation failed:', e);
      return null;
    }
  }
  
  // Render each page
  Object.keys(pages).sort((a, b) => parseInt(a) - parseInt(b)).forEach((pageNum, pi, arr) => {
    const breakStyle = pi < arr.length - 1 ? 'page-break-after:always;' : '';
    html += '<div class="print-sheet" style="' + breakStyle + '">';
    
    // Get manual print offsets from settings
    const offsetTop = settings.printOffsetTop || 0;
    const offsetLeft = settings.printOffsetLeft || 0;
    
    // Safari vertical compression - reduces vertical positions to fit Safari's smaller printable area
    const safariVScale = isSafari ? (settings.safariVScale ?? 1.0) : 1.0;
    
    // Draw label boundaries for ALL positions if enabled (for alignment testing)
    if (settings.showLabelBoundaries) {
      for (let idx = 0; idx < lps; idx++) {
        const row = Math.floor(idx / spec.cols);
        const col = idx % spec.cols;
        const bTop = (spec.topMargin + row * (spec.labelH + spec.vGutter)) * safariVScale + offsetTop;
        const bHeight = spec.labelH * safariVScale;
        const bLeft = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
        html += '<div class="label-boundary" style="top:' + bTop + 'in;left:' + bLeft + 'in;width:' + spec.labelW + 'in;height:' + bHeight + 'in;"></div>';
      }
    }
    
    pages[pageNum].forEach(item => {
      const localIdx = item.idx % lps;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;
      
      const top = (spec.topMargin + row * (spec.labelH + spec.vGutter)) * safariVScale + offsetTop;
      const labelH = spec.labelH * safariVScale;
      const left = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
      
      // Use renderPrintLineHtml for each line (same as v1.2)
      const linesHtml = item.lines.map(l => renderPrintLineHtml(l)).join('');
      const gfx = item.graphics;
      const hasGfx = gfx && (gfx.left || gfx.right);
      const bc = item.barcode;
      const hasQR = bc && bc.enabled && bc.type === 'qr';
      
      if (isTentCard) {
        // Tent card rendering (no QR support for now)
        html += '<div class="print-label tent-card" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;">';
        html += '<div class="fold-line"></div>';
        html += '<div class="tent-top"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '<div class="tent-bottom"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '</div>';
      } else if (isRound) {
        // Round label rendering - content centered
        if (hasQR && bc.position === 'only') {
          // QR code only for round label
          const qrDataURL = getQRDataURL(item, spec);
          const qrSize = (spec.labelW * 0.7).toFixed(3); // QR is 70% of label diameter
          html += '<div class="print-label round-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;">';
          html += '<div class="print-qr" style="width:' + qrSize + 'in;height:' + qrSize + 'in;"><img src="' + qrDataURL + '"></div>';
          html += '</div>';
        } else {
          // Text centered in round label (graphics and side QR not practical for round)
          html += '<div class="print-label round-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.15in;">';
          html += '<div class="print-text-zone">' + linesHtml + '</div>';
          html += '</div>';
        }
      } else if (hasQR) {
        // QR code layout
        const qrDataURL = getQRDataURL(item, spec);
        const qrPosition = bc.position || 'right';
        const qrSize = (spec.labelH * 0.85).toFixed(3); // QR is ~85% of label height
        
        if (qrPosition === 'only') {
          // QR code only, no text
          html += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.05in;justify-content:center;align-items:center;">';
          html += '<div class="print-qr" style="width:' + qrSize + 'in;height:' + qrSize + 'in;"><img src="' + qrDataURL + '"></div>';
          html += '</div>';
        } else {
          // QR + text layout
          let innerHtml = '';
          if (qrPosition === 'left') {
            innerHtml += '<div class="print-qr" style="width:' + qrSize + 'in;height:' + qrSize + 'in;"><img src="' + qrDataURL + '"></div>';
            innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(item.alignV) + ';padding-left:0.08in;">' + linesHtml + '</div>';
          } else {
            // right (default)
            innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(item.alignV) + ';padding-right:0.08in;">' + linesHtml + '</div>';
            innerHtml += '<div class="print-qr" style="width:' + qrSize + 'in;height:' + qrSize + 'in;"><img src="' + qrDataURL + '"></div>';
          }
          html += '<div class="print-label print-label-qr" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.08in 0.12in;flex-direction:row;align-items:stretch;">' + innerHtml + '</div>';
        }
      } else if (hasGfx) {
        // Graphics layout (same as v1.2)
        const usableW = spec.labelW - 0.24;
        let innerHtml = '';
        if (gfx.left && gfx.left.data) {
          const leftW = (usableW * (gfx.left.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + leftW + 'in;"><img src="' + gfx.left.data + '"></div>';
        }
        innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
        if (gfx.right && gfx.right.data) {
          const rightW = (usableW * (gfx.right.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + rightW + 'in;"><img src="' + gfx.right.data + '"></div>';
        }
        html += '<div class="print-label print-label-gfx" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.08in 0.12in;">' + innerHtml + '</div>';
      } else {
        // Standard label (same as v1.2)
        html += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + labelH + 'in;padding:0.08in 0.12in;justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
      }
    });
    
    // Close print-sheet
    html += '</div>';
  });
  
  html += '</body></html>';
  return html;
}

function renderSavedTab(stats) {
  const panel = document.getElementById('panel-saved');
  const texts = getTexts();
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Content (' + texts.length + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openFullEditor(null, false)">+ New</button>' +
    '</div>' +
  '</div>';
  
  if (texts.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ’¾</div><div class="panel-placeholder-text">No saved content yet. Create one or save text from the Print workflow.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const t of texts) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 60);
    
    // Find sheets this content is assigned to
    const assignedSheets = Object.values(sheets).filter(sh => sh.texts && sh.texts[t.id]);
    
    // Build clickable sheet links
    let sheetLinksHtml = '';
    if (assignedSheets.length > 0) {
      const links = assignedSheets.map(sh => 
        '<a href="#" onclick="event.stopPropagation(); event.preventDefault(); navigateToSheet(\'' + sh.id + '\');" style="color:var(--accent-text);text-decoration:underline;">' + escapeHtml(sh.name) + '</a>'
      ).join(', ');
      sheetLinksHtml = '<div class="saved-card-sheets" style="font-size:11px;color:var(--text-muted);margin-top:4px;">ðŸ“„ ' + links + '</div>';
    }
    
    // QR badge
    const hasQR = t.barcode && t.barcode.enabled;
    const qrBadge = hasQR ? ' <span class="badge" style="background:var(--accent-bg);color:var(--accent-text);font-size:10px;">QR</span>' : '';
    
    html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', false)">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + qrBadge + '</div>' +
          '<div class="saved-card-preview">' + escapeHtml(preview) + (preview.length >= 60 ? 'â€¦' : '') + '</div>' +
          sheetLinksHtml +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

// Template filter state
let templateFilterType = 'import'; // 'import' or 'style'

function renderTemplatesTab(stats) {
  const panel = document.getElementById('panel-templates');
  
  // Get counts for both types
  const importTemplates = getImportTemplates();
  const styleTemplates = getStyleTemplates();
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Templates</div>' +
  '</div>';
  
  // Filter tabs
  html += '<div class="template-filter-tabs">' +
    '<button class="template-filter-btn' + (templateFilterType === 'import' ? ' active' : '') + '" onclick="setTemplateFilter(\'import\')">' +
      'ðŸ“‹ Import (' + importTemplates.length + ')' +
    '</button>' +
    '<button class="template-filter-btn' + (templateFilterType === 'style' ? ' active' : '') + '" onclick="setTemplateFilter(\'style\')">' +
      'ðŸŽ¨ Styles (' + styleTemplates.length + ')' +
    '</button>' +
    (templateFilterType === 'style' ? '<button class="tab-action-btn" onclick="openFullEditor(null, false, true)" style="margin-left:auto;">+ New Style</button>' : '') +
  '</div>';
  
  html += '<div class="tab-content-list">';
  
  if (templateFilterType === 'import') {
    // Show import templates
    const userTemplates = importTemplates.filter(t => !t.builtin);
    const builtinTemplates = importTemplates.filter(t => t.builtin);
    
    // User templates first
    for (const t of userTemplates) {
      const tokens = t.tokens || [];
      html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', true)">' +
        '<div class="saved-card-header">' +
          '<div>' +
            '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
            '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
          '</div>' +
          '<div class="saved-card-actions">' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
            '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
          '</div>' +
        '</div>' +
      '</div>';
    }
    
    // Built-in templates
    for (const t of builtinTemplates) {
      const tokens = t.tokens || [];
      html += '<div class="saved-card" style="opacity: 0.85; cursor: pointer;" onclick="showBuiltinTemplatePreview(\'' + t.id + '\')">' +
        '<div class="saved-card-header">' +
          '<div>' +
            '<div class="saved-card-name">' + escapeHtml(t.name) + ' <span class="badge">Built-in</span></div>' +
            '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
          '</div>' +
          '<div class="saved-card-actions">' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
          '</div>' +
        '</div>' +
      '</div>';
    }
    
    if (importTemplates.length === 0) {
      html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“‹</div><div class="panel-placeholder-text">No import templates yet.<br>Create one in the Full Editor with tokens like {name}.</div></div>';
    }
  } else {
    // Show style templates
    const userStyles = styleTemplates.filter(t => !t.builtin);
    const builtinStyles = styleTemplates.filter(t => t.builtin);
    
    // User style templates first
    for (const t of userStyles) {
      const catInfo = STYLE_TEMPLATE_CATEGORIES[t.category] || { label: t.category || 'Custom' };
      html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', false, true)">' +
        '<div class="saved-card-header">' +
          '<div>' +
            '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
            '<div class="saved-card-preview">' + catInfo.label + ' Â· ' + (t.labelType || '5160') + '</div>' +
          '</div>' +
          '<div class="saved-card-actions">' +
            '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
            '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
          '</div>' +
        '</div>' +
      '</div>';
    }
    
    // Built-in style templates grouped by category
    const byCategory = {};
    for (const t of builtinStyles) {
      const cat = t.category || 'simple';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push(t);
    }
    
    for (const [catId, catInfo] of Object.entries(STYLE_TEMPLATE_CATEGORIES)) {
      const templates = byCategory[catId] || [];
      if (templates.length === 0) continue;
      
      html += '<div class="style-category-header">' + catInfo.label + '</div>';
      for (const t of templates) {
        html += '<div class="saved-card" style="opacity: 0.85; cursor: pointer;" onclick="previewStyleTemplate(\'' + t.id + '\')">' +
          '<div class="saved-card-header">' +
            '<div>' +
              '<div class="saved-card-name">' + escapeHtml(t.name) + ' <span class="badge">Built-in</span></div>' +
              '<div class="saved-card-preview">' + (t.labelType || '5160') + '</div>' +
            '</div>' +
          '</div>' +
        '</div>';
      }
    }
  }
  
  html += '</div>';
  panel.innerHTML = html;
}

function setTemplateFilter(filter) {
  templateFilterType = filter;
  renderTemplatesTab();
}

function previewStyleTemplate(id) {
  const template = getStyleTemplate(id);
  if (!template) return;
  
  // Show a preview modal or open in Full Editor
  const catInfo = STYLE_TEMPLATE_CATEGORIES[template.category] || { label: 'Style' };
  showToast(template.name + ' - ' + catInfo.label + ' style for ' + template.labelType, 'info');
}

// G8: Build burn rate display HTML for inventory card
function buildBurnRateHtml(typeId) {
  const burn = getInventoryBurnRate(typeId);
  if (!burn) return '';

  let html = '<div class="inventory-burn-rate">';
  html += '<div class="inventory-burn-stat">ðŸ“ˆ <strong>' + burn.totalConsumed + '</strong> sheets used in ' + formatDuration(burn.daysSinceStart) + '</div>';

  if (burn.ratePerMonth >= 0.1) {
    html += '<div class="inventory-burn-stat">ðŸ”¥ <strong>~' + burn.ratePerMonth + '</strong>/month</div>';
  }

  if (burn.weeksLeft !== null && burn.ratePerMonth >= 0.1) {
    const cls = burn.weeksLeft <= 2 ? ' danger' : burn.weeksLeft <= 6 ? ' warn' : '';
    if (burn.weeksLeft <= 0) {
      html += '<div class="inventory-burn-stat danger">âš ï¸ Out of stock now</div>';
    } else {
      html += '<div class="inventory-burn-stat' + cls + '">â³ <strong>~' + burn.weeksLeft + ' week' + (burn.weeksLeft !== 1 ? 's' : '') + '</strong> left at this rate</div>';
    }
  }

  html += '</div>';
  return html;
}

function formatDuration(days) {
  if (days < 7) return days + ' day' + (days !== 1 ? 's' : '');
  if (days < 30) { const w = Math.floor(days / 7); return w + ' week' + (w !== 1 ? 's' : ''); }
  const m = Math.round(days / 30);
  return m + ' month' + (m !== 1 ? 's' : '');
}

function renderInventoryTab(stats) {
  const panel = document.getElementById('panel-inventory');
  const types = Object.keys(inventory);
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Inventory</div>' +
    '<div class="tab-actions"><button class="tab-action-btn" onclick="showAddInventoryModal()">+ Add Label Type</button></div>' +
  '</div>';
  
  if (types.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“¦</div><div class="panel-placeholder-text">Inventory tracking not set up yet.<br>Click "Add Label Type" above to get started.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const typeId of types) {
    const spec = LABEL_TYPES[typeId];
    const summary = getInventorySummary(typeId);
    if (!spec || !summary) continue;
    
    const statusClass = summary.stock === 0 && summary.partialSheets === 0 ? 'inv-empty' : summary.isLow ? 'inv-low' : 'inv-ok';
    const statusIcon = summary.stock === 0 && summary.partialSheets === 0 ? 'ðŸ”´' : summary.isLow ? 'ðŸŸ¡' : 'ðŸŸ¢';
    const statusText = summary.stock === 0 && summary.partialSheets === 0 ? 'Out of stock' : summary.isLow ? 'Low stock' : 'In stock';
    
    // Calculate breakdown bar percentages
    const totalSheetCount = summary.stock + summary.assignedUnusedSheets + summary.assignedPartialSheets;
    const shelfPct = totalSheetCount > 0 ? (summary.stock / totalSheetCount * 100) : 0;
    const assignedPct = totalSheetCount > 0 ? (summary.assignedUnusedSheets / totalSheetCount * 100) : 0;
    const partialPct = totalSheetCount > 0 ? (summary.assignedPartialSheets / totalSheetCount * 100) : 0;
    
    html += '<div class="inventory-card">' +
      '<div class="inventory-card-header">' +
        '<div class="inventory-card-type">' +
          '<span class="inventory-card-name">' + typeId + '</span>' +
          '<span class="inventory-card-desc">' + spec.desc + ' Â· ' + spec.sizeDisplay + '</span>' +
        '</div>' +
        '<div class="inventory-card-status ' + statusClass + '">' + statusIcon + ' ' + statusText + '</div>' +
      '</div>' +
      
      // Breakdown bar
      '<div class="inventory-breakdown">' +
        '<div class="inventory-breakdown-bar">' +
          (shelfPct > 0 ? '<div class="inventory-breakdown-segment shelf" style="width:' + shelfPct + '%"></div>' : '') +
          (assignedPct > 0 ? '<div class="inventory-breakdown-segment assigned" style="width:' + assignedPct + '%"></div>' : '') +
          (partialPct > 0 ? '<div class="inventory-breakdown-segment partial" style="width:' + partialPct + '%"></div>' : '') +
        '</div>' +
        '<div class="inventory-breakdown-legend">' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot shelf"></span>' +
            '<span>Shelf stock: <span class="inventory-breakdown-value">' + summary.stock + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot assigned"></span>' +
            '<span>Assigned (unused): <span class="inventory-breakdown-value">' + summary.assignedUnusedSheets + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot partial"></span>' +
            '<span>Assigned (partial): <span class="inventory-breakdown-value">' + summary.assignedPartialSheets + '</span></span>' +
          '</div>' +
        '</div>' +
      '</div>' +
      
      '<div class="inventory-card-body">' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalSheets + '</div>' +
          '<div class="inventory-stat-label">Total sheets</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalLabels + '</div>' +
          '<div class="inventory-stat-label">Available labels</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.fullyConsumed + '</div>' +
          '<div class="inventory-stat-label">Consumed sheets</div>' +
        '</div>' +
      '</div>' +
      buildBurnRateHtml(typeId) +
      '<div class="inventory-card-actions">' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', -1)" title="Remove 1 sheet">âˆ’</button>' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', 1)" title="Add 1 sheet">+</button>' +
        '<button class="inventory-adjust-btn wide" onclick="showAdjustInventoryModal(\'' + typeId + '\')">Set Stock</button>' +
        '<button class="inventory-adjust-btn danger" onclick="confirmRemoveInventory(\'' + typeId + '\')" title="Remove from tracking">ðŸ—‘ï¸</button>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

function renderHistoryTab(stats) {
  const panel = document.getElementById('panel-history');
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Print History</div>' +
    (printHistory.length > 0 ? '<div class="tab-actions"><button class="tab-action-btn-secondary tab-action-btn" onclick="confirmClearHistory()">Clear History</button></div>' : '') +
  '</div>';
  
  if (printHistory.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“œ</div><div class="panel-placeholder-text">No print history yet. Print some labels to see them here.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  // Get unique label types for filter dropdown
  const labelTypes = [...new Set(printHistory.map(e => e.labelType || '5160'))].sort();
  
  // Filters
  html += '<div class="history-filters">' +
    '<input type="text" class="history-search" id="historySearch" placeholder="Search by nameâ€¦" value="' + escapeAttr(historySearchQuery) + '" oninput="updateHistorySearch(this.value)">' +
    '<select class="history-filter-select" id="historyTypeFilter" onchange="updateHistoryTypeFilter(this.value)">' +
      '<option value="all"' + (historyTypeFilter === 'all' ? ' selected' : '') + '>All Types</option>' +
      labelTypes.map(t => '<option value="' + t + '"' + (historyTypeFilter === t ? ' selected' : '') + '>' + t + '</option>').join('') +
    '</select>' +
  '</div>';
  
  // Bulk actions bar (shown when items selected)
  if (historySelectedIds.size > 0) {
    html += '<div class="history-bulk-actions">' +
      '<span class="history-bulk-count">' + historySelectedIds.size + ' selected</span>' +
      '<button class="history-bulk-btn secondary" onclick="clearHistorySelection()">Clear</button>' +
      '<button class="history-bulk-btn" onclick="bulkReprintHistory()">Reprint Selected</button>' +
    '</div>';
  }
  
  // Filter entries
  const filtered = printHistory.filter(entry => {
    if (historyTypeFilter !== 'all' && (entry.labelType || '5160') !== historyTypeFilter) return false;
    if (historySearchQuery) {
      const q = historySearchQuery.toLowerCase();
      const name = (entry.textName || 'Labels').toLowerCase();
      if (!name.includes(q)) return false;
    }
    return true;
  }).slice(0, 100);
  
  if (filtered.length === 0) {
    html += '<div class="history-no-results">No matching entries found</div>';
    panel.innerHTML = html;
    return;
  }
  
  // Group by date
  const groups = {};
  for (const entry of filtered) {
    const date = new Date(entry.timestamp);
    const dateKey = getDateGroupKey(date);
    if (!groups[dateKey]) groups[dateKey] = { label: getDateGroupLabel(date), entries: [] };
    groups[dateKey].entries.push(entry);
  }
  
  // Render groups
  for (const key of Object.keys(groups).sort().reverse()) {
    const group = groups[key];
    html += '<div class="history-date-group">' +
      '<div class="history-date-header">' + escapeHtml(group.label) + '</div>' +
      '<div class="history-group-list">';
    
    for (const entry of group.entries) {
      const date = new Date(entry.timestamp);
      const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      const isSelected = historySelectedIds.has(entry.id);
      
      html += '<div class="history-card' + (isSelected ? ' selected' : '') + '">' +
        '<input type="checkbox" class="history-card-checkbox" ' + (isSelected ? 'checked' : '') + ' onchange="toggleHistorySelection(\'' + entry.id + '\', this.checked)">' +
        '<div class="history-card-icon">ðŸ·ï¸</div>' +
        '<div class="history-card-info">' +
          '<div class="history-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
          '<div class="history-card-meta">' + timeStr + ' Â· ' + (entry.count || 1) + ' label' + ((entry.count || 1) !== 1 ? 's' : '') + ' Â· ' + (entry.labelType || '5160') + '</div>' +
        '</div>' +
        '<button class="history-card-action" onclick="reprintFromHistory(\'' + entry.id + '\')">Reprint</button>' +
      '</div>';
    }
    
    html += '</div></div>';
  }
  
  panel.innerHTML = html;
}

// History filter helpers
function getDateGroupKey(date) {
  return date.toISOString().split('T')[0]; // YYYY-MM-DD
}

function getDateGroupLabel(date) {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
  
  if (dateOnly.getTime() === todayOnly.getTime()) return 'Today';
  if (dateOnly.getTime() === yesterdayOnly.getTime()) return 'Yesterday';
  
  // Check if this week
  const weekAgo = new Date(todayOnly);
  weekAgo.setDate(weekAgo.getDate() - 7);
  if (dateOnly > weekAgo) {
    return date.toLocaleDateString('en-US', { weekday: 'long' });
  }
  
  return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
}

function updateHistorySearch(query) {
  historySearchQuery = query;
  renderHistoryTab();
}

function updateHistoryTypeFilter(type) {
  historyTypeFilter = type;
  renderHistoryTab();
}

function toggleHistorySelection(id, checked) {
  if (checked) {
    historySelectedIds.add(id);
  } else {
    historySelectedIds.delete(id);
  }
  renderHistoryTab();
}

function clearHistorySelection() {
  historySelectedIds.clear();
  renderHistoryTab();
}

function bulkReprintHistory() {
  if (historySelectedIds.size === 0) return;
  
  // Get selected entries
  const entries = printHistory.filter(e => historySelectedIds.has(e.id));
  if (entries.length === 0) return;
  
  // For now, just reprint the first one and show a message
  // Future enhancement: batch reprint all selected
  if (entries.length === 1) {
    reprintFromHistory(entries[0].id);
  } else {
    showToast('Reprinting first selected item. Batch reprint coming soon!', 'info');
    reprintFromHistory(entries[0].id);
  }
  
  clearHistorySelection();
}

// ============================================================================
// WF1: PRINT SOMETHING NEW â€” Unified Print Workflow
// ============================================================================
// Replaces both "Print Labels" and "Print a Mailing List" wizards.
// Steps: 1=LabelType, 2=Inventory, 3=ContentType+Qty, 4=Feasibility,
//        5=SheetPicker, 6=Content, 7=Preview, 8=PostPrint

let wf1Step = 1;
let wf1LabelType = null;
let wf1JobType = null; // 'individual' | 'batch'
let wf1Quantity = 1;
let wf1TargetSheet = null;
let wf1ContentLines = [];
let wf1BatchContent = [];
let wf1InvAddVisible = false;

// Full Editor round-trip snapshot â€” preserves rich styles (bold, color, graphics, etc.)
let wf1FeSnapshot = null; // { lines: [...], graphics: {...}, alignV: '...', border: {...} }

// Style template applied in WF1 simple editor
let wf1StyleTemplateId = null;

const WF1_TOTAL_STEPS = 8;

// ============================================================================
// PHASE 3: Intelligent Workflow State Integration
// ============================================================================
// wf1Spec tracks the current print job's inferred state
// wf1Inferences stores the inference results for display

let wf1Spec = null;           // PrintJobSpec from Phase 1
let wf1Inferences = null;     // Inference results from Phase 2
let wf1InferenceSummary = null; // Summary: { canSkipSteps, needsInput, ... }

/**
 * Initialize the inference engine for this print job
 * Called at the start of WF1 to get smart suggestions
 */
function wf1InitInferences(hints = {}) {
  // Create fresh spec
  wf1Spec = createPrintJobSpec('wf1');
  
  // Run all inferences with any provided hints
  const result = runAllInferences(wf1Spec, hints);
  
  wf1Inferences = result.inferences;
  wf1InferenceSummary = result.summary;
  
  // Phase 4: Apply learning adjustments to inferences
  if (typeof applyLearningToInference === 'function') {
    for (const element of Object.keys(wf1Inferences)) {
      const adjusted = applyLearningToInference(wf1Inferences[element], element);
      if (adjusted !== wf1Inferences[element]) {
        wf1Inferences[element] = adjusted;
        // Update spec element if confidence changed
        if (wf1Spec[element]) {
          wf1Spec[element].confidence = adjusted.confidence;
        }
      }
    }
    // Recalculate summary after adjustments
    wf1InferenceSummary = summarizeInferences(wf1Inferences);
  }
  
  // Debug log if in dev mode
  if (window._pjs) {
    console.log('[Phase 3/4] WF1 inferences initialized:');
    logInferences(wf1Inferences, 'wf1-start');
    console.log('[Phase 3/4] Summary:', wf1InferenceSummary);
  }
  
  return result;
}

/**
 * Get the UI mode for a specific workflow element
 * Returns: 'skip' | 'confirm' | 'narrowed' | 'full'
 */
function wf1GetUIMode(elementName) {
  if (!wf1Spec || !wf1Spec[elementName]) return 'full';
  return getElementUIMode(wf1Spec[elementName]);
}

/**
 * Check if we should skip a step due to high confidence inference
 */
function wf1ShouldSkipStep(stepNumber) {
  if (!wf1InferenceSummary) return false;
  
  // Map steps to elements
  const stepElementMap = {
    1: 'labelType',
    3: 'contentMode',  // contentMode + quantity
    5: 'sheetSelection'
  };
  
  const element = stepElementMap[stepNumber];
  if (!element) return false;
  
  return wf1InferenceSummary.canSkipSteps.includes(element);
}

/**
 * Accept an inferred value for an element (user confirmed or auto-accepted)
 */
function wf1AcceptInference(elementName) {
  if (!wf1Spec || !wf1Inferences || !wf1Inferences[elementName]) return;
  
  const inf = wf1Inferences[elementName];
  
  // Phase 4: Record acceptance for learning
  if (typeof recordAcceptance === 'function') {
    recordAcceptance(elementName, inf.value, inf.source);
  }
  
  // Update the spec element as confirmed
  updateSpecElement(wf1Spec, elementName, {
    value: inf.value,
    confidence: CONFIDENCE_LEVELS.HIGH,
    source: inf.source + '-confirmed'
  });
  
  // Track in metadata
  wf1Spec._meta.skippedSteps.push(elementName);
}

/**
 * Reject an inferred value - user wants to choose manually
 */
function wf1RejectInference(elementName) {
  if (!wf1Spec) return;
  
  // Mark as rejected so we don't suggest it again
  markRejected(wf1Spec, elementName);
  
  // Track in metadata
  wf1Spec._meta.edits.push({
    element: elementName,
    action: 'rejected-inference',
    timestamp: Date.now()
  });
}

/**
 * Update the smart summary bar with current inferences
 */
function wf1UpdateSmartSummary() {
  const container = document.getElementById('wf1SmartSummary');
  const itemsContainer = document.getElementById('wf1SmartSummaryItems');
  
  if (!container || !itemsContainer) return;
  
  // Only show if we have high-confidence inferences
  if (!wf1InferenceSummary || wf1InferenceSummary.highConfidenceCount === 0) {
    container.classList.remove('visible');
    return;
  }
  
  let html = '';
  
  // Add items for each high/medium confidence inference
  const elementLabels = {
    labelType: 'Label',
    quantity: 'Qty',
    contentMode: 'Mode',
    sheetSelection: 'Sheet',
    postPrint: 'After'
  };
  
  for (const [element, label] of Object.entries(elementLabels)) {
    if (!wf1Inferences || !wf1Inferences[element]) continue;
    
    const inf = wf1Inferences[element];
    if (inf.confidence === 'high' || inf.confidence === 'medium') {
      const confClass = inf.confidence === 'high' ? 'high' : 'medium';
      const displayValue = wf1FormatInferenceValue(element, inf.value);
      
      html += '<div class="wf1-smart-item ' + confClass + '">' +
        '<span class="wf1-smart-item-label">' + label + ':</span> ' +
        '<span class="wf1-smart-item-value">' + displayValue + '</span>' +
        '<span class="wf1-smart-item-edit" onclick="wf1EditInference(\'' + element + '\')" title="Change">âœŽ</span>' +
      '</div>';
    }
  }
  
  if (html) {
    itemsContainer.innerHTML = html;
    container.classList.add('visible');
  } else {
    container.classList.remove('visible');
  }
}

/**
 * Format inference values for display
 */
function wf1FormatInferenceValue(element, value) {
  if (value === null) return 'â€”';
  
  switch (element) {
    case 'labelType':
      return value; // e.g., "5160"
    case 'quantity':
      return value + ' label' + (value !== 1 ? 's' : '');
    case 'contentMode':
      return value === 'same' ? 'Same on all' : 'Different each';
    case 'sheetSelection':
      if (value === 'new') return 'New sheet';
      if (value === 'specific') return 'Existing sheet';
      if (value === 'multi') return 'Multiple sheets';
      return value;
    case 'postPrint':
      if (value === 'track') return 'Track usage';
      if (value === 'dedicate') return 'Dedicate sheet';
      return value;
    default:
      return String(value);
  }
}

/**
 * Handle clicking edit on an inferred value
 */
function wf1EditInference(element) {
  // Map elements to steps
  const elementStepMap = {
    labelType: 1,
    contentMode: 3,
    quantity: 3,
    sheetSelection: 5,
    postPrint: 8
  };
  
  const step = elementStepMap[element];
  if (!step) return;
  
  // Reject the inference so user can choose
  wf1RejectInference(element);
  
  // Navigate to that step
  wf1Step = step;
  wf1ShowStep('wf1Step' + step);
  
  // Re-render the step content if needed
  if (step === 1) wf1RenderTypeGrid();
  // Add other step renderers as needed
}

/**
 * Apply inference to WF1 state when auto-accepting
 */
function wf1ApplyInferenceToState(element) {
  if (!wf1Inferences || !wf1Inferences[element]) return;
  
  const value = wf1Inferences[element].value;
  
  switch (element) {
    case 'labelType':
      wf1LabelType = value;
      settings.lastLabelType = value;
      saveSettings();
      break;
    case 'quantity':
      wf1Quantity = value;
      break;
    case 'contentMode':
      wf1JobType = value === 'same' ? 'individual' : 'batch';
      break;
    // sheetSelection and postPrint handled at those steps
  }
}

// ============================================================================
// PHASE 3B: Step Skipping
// ============================================================================
// Tracks which steps have been auto-skipped and allows editing

let wf1SkippedSteps = [];       // Array of skipped element names
let wf1SkippedDetailsOpen = false; // Whether the details panel is expanded

/**
 * Phase 3B: Check if we should auto-skip to a later step
 * Called when entering a step to see if we can skip ahead
 * Returns the target step number, or null if no skip
 */
function wf1CheckAutoSkip(currentStep) {
  if (!wf1InferenceSummary || !wf1Inferences) return null;
  
  // Only auto-skip if we have high-confidence inferences
  const canSkip = wf1InferenceSummary.canSkipSteps || [];
  
  // Map steps to elements that can be skipped
  const skipConfig = {
    1: { element: 'labelType', nextStep: 2 },
    // Step 2 (inventory) always shows
    3: { element: 'contentMode', nextStep: 4, alsoApply: 'quantity' },
    // Step 4 (feasibility) always shows
    // Step 5 (sheet selection) - complex logic, handled separately
    // Step 6 (content) - user must create content
    // Step 7 (preview) - user must review
    // Step 8 (post-print) - user must choose
  };
  
  const config = skipConfig[currentStep];
  if (!config) return null;
  
  // Check if we can skip this element
  if (canSkip.includes(config.element)) {
    return {
      targetStep: config.nextStep,
      element: config.element,
      alsoApply: config.alsoApply
    };
  }
  
  return null;
}

/**
 * Phase 3B: Execute an auto-skip from one step to another
 * Applies the inferred values and advances the wizard
 */
function wf1ExecuteAutoSkip(fromStep, skipInfo) {
  if (!skipInfo) return false;
  
  // Apply the primary inference
  wf1AcceptInference(skipInfo.element);
  wf1ApplyInferenceToState(skipInfo.element);
  
  // Track as skipped
  if (!wf1SkippedSteps.includes(skipInfo.element)) {
    wf1SkippedSteps.push(skipInfo.element);
  }
  
  // Apply any secondary inferences
  if (skipInfo.alsoApply && wf1Inferences[skipInfo.alsoApply]) {
    const secInf = wf1Inferences[skipInfo.alsoApply];
    if (secInf.confidence === 'high') {
      wf1AcceptInference(skipInfo.alsoApply);
      wf1ApplyInferenceToState(skipInfo.alsoApply);
      if (!wf1SkippedSteps.includes(skipInfo.alsoApply)) {
        wf1SkippedSteps.push(skipInfo.alsoApply);
      }
    }
  }
  
  // Log the skip
  if (window._pjs) {
    console.log(`[Phase 3B] Auto-skipped step ${fromStep}, applied: ${skipInfo.element}` + 
      (skipInfo.alsoApply ? ` + ${skipInfo.alsoApply}` : ''));
  }
  
  return true;
}

/**
 * Phase 3B: Update the skipped steps banner
 * Shows summary of auto-skipped choices with option to expand
 */
function wf1UpdateSkippedBanner() {
  const banner = document.getElementById('wf1SkippedBanner');
  const countEl = document.getElementById('wf1SkippedCount');
  const detailsEl = document.getElementById('wf1SkippedDetails');
  const toggleEl = document.getElementById('wf1SkippedToggle');
  
  if (!banner) return;
  
  // Only show if we have skipped steps
  if (!wf1SkippedSteps || wf1SkippedSteps.length === 0) {
    banner.classList.remove('visible');
    return;
  }
  
  // Update count text
  const count = wf1SkippedSteps.length;
  countEl.textContent = count === 1 ? '(1 choice)' : `(${count} choices)`;
  
  // Build details HTML
  const elementInfo = {
    labelType: { label: 'Label Type', step: 1 },
    quantity: { label: 'Quantity', step: 3 },
    contentMode: { label: 'Content Mode', step: 3 },
    sheetSelection: { label: 'Sheet', step: 5 },
    postPrint: { label: 'After Printing', step: 8 }
  };
  
  let detailsHtml = '';
  
  for (const element of wf1SkippedSteps) {
    const info = elementInfo[element] || { label: element, step: 1 };
    const inf = wf1Inferences?.[element];
    if (!inf) continue;
    
    const displayValue = wf1FormatInferenceValue(element, inf.value);
    const reason = wf1GetSourceDescription(inf.source);
    
    detailsHtml += `<div class="wf1-skipped-item">
      <div class="wf1-skipped-item-info">
        <span class="wf1-skipped-item-label">${info.label}</span>
        <span class="wf1-skipped-item-value">${displayValue}</span>
        <span class="wf1-skipped-item-reason">${reason}</span>
      </div>
      <button class="wf1-skipped-item-edit" onclick="wf1EditSkippedElement('${element}', ${info.step})">Change</button>
    </div>`;
  }
  
  detailsEl.innerHTML = detailsHtml;
  
  // Update toggle button state
  toggleEl.textContent = wf1SkippedDetailsOpen ? 'Hide details' : 'Show details';
  detailsEl.classList.toggle('expanded', wf1SkippedDetailsOpen);
  
  // Show banner
  banner.classList.add('visible');
}

/**
 * Phase 3B: Toggle skipped details panel
 */
function wf1ToggleSkippedDetails() {
  wf1SkippedDetailsOpen = !wf1SkippedDetailsOpen;
  wf1UpdateSkippedBanner();
}

/**
 * Phase 3B: Edit a skipped element - navigate back to that step
 */
function wf1EditSkippedElement(element, targetStep) {
  // Reject the inference so user can choose
  wf1RejectInference(element);
  
  // Remove from skipped list
  wf1SkippedSteps = wf1SkippedSteps.filter(e => e !== element);
  
  // Navigate to that step
  wf1Step = targetStep;
  
  // Render the appropriate step content
  switch (targetStep) {
    case 1:
      wf1RenderTypeGrid();
      break;
    case 3:
      wf1JobType = null;
      document.getElementById('wf1QtyRow').style.display = 'none';
      document.getElementById('wf1Step3Actions').style.display = 'none';
      break;
    case 5:
      wf1RenderSheetPicker();
      break;
  }
  
  wf1ShowStep('wf1Step' + targetStep);
  
  // Update the banner (may hide it now)
  wf1UpdateSkippedBanner();
  
  // Log
  if (window._pjs) {
    console.log(`[Phase 3B] User editing skipped element: ${element} â†’ step ${targetStep}`);
  }
}

/**
 * Phase 3B: Reset skipped steps tracking
 * Called when starting a new wizard
 */
function wf1ResetSkippedSteps() {
  wf1SkippedSteps = [];
  wf1SkippedDetailsOpen = false;
  
  const banner = document.getElementById('wf1SkippedBanner');
  if (banner) banner.classList.remove('visible');
}

// ============================================================================
// PHASE 3C: Confirm Mode
// ============================================================================
// One-click confirmation for medium confidence suggestions

let wf1ConfirmAlternativesVisible = false; // Whether alternatives panel is expanded

/**
 * Phase 3C: Check if we should show confirm mode for a step
 * Returns confirm info if medium confidence, null otherwise
 */
function wf1CheckConfirmMode(stepNumber) {
  if (!wf1Inferences) return null;
  
  // Map steps to elements
  const stepElementMap = {
    1: 'labelType',
    3: 'contentMode'
  };
  
  const element = stepElementMap[stepNumber];
  if (!element || !wf1Inferences[element]) return null;
  
  const inf = wf1Inferences[element];
  
  // Only show confirm for medium confidence
  if (inf.confidence !== 'medium') return null;
  
  return {
    element: element,
    value: inf.value,
    confidence: inf.confidence,
    source: inf.source,
    alternatives: inf.alternatives || []
  };
}

/**
 * Phase 3C: Render the confirm card for medium confidence suggestion
 */
function wf1RenderConfirmCard(stepNumber) {
  const container = document.getElementById('wf1ConfirmCard');
  if (!container) return;
  
  const confirmInfo = wf1CheckConfirmMode(stepNumber);
  
  // Hide if no confirm mode needed
  if (!confirmInfo) {
    container.style.display = 'none';
    return;
  }
  
  wf1ConfirmAlternativesVisible = false;
  
  // Get value display info based on element type
  let valueDisplay = {};
  
  if (confirmInfo.element === 'labelType') {
    const spec = LABEL_TYPES[confirmInfo.value];
    valueDisplay = {
      id: confirmInfo.value,
      desc: spec ? spec.desc : 'Label',
      meta: spec ? spec.sizeDisplay + ' Â· ' + (spec.cols * spec.rows) + '/sheet' : ''
    };
  } else if (confirmInfo.element === 'contentMode') {
    valueDisplay = {
      id: confirmInfo.value === 'same' ? 'ðŸ·ï¸' : 'ðŸ“‹',
      desc: confirmInfo.value === 'same' ? 'Same content on every label' : 'Different content on each label',
      meta: confirmInfo.value === 'same' ? 'One design, printed multiple times' : 'A mailing list, name tags, or unique labels'
    };
  }
  
  const sourceText = wf1GetSourceDescription(confirmInfo.source);
  
  // Build alternatives HTML (for "Not this?" panel)
  let altHtml = '';
  if (confirmInfo.element === 'labelType') {
    // Get top 3 alternatives from inventory
    const alts = getTopAlternativeTypes(confirmInfo.value, 3);
    for (const alt of alts) {
      const spec = LABEL_TYPES[alt.typeId];
      altHtml += '<div class="wf1-confirm-alt-item" onclick="wf1ConfirmSelectAlternative(\'' + alt.typeId + '\')">' +
        '<div class="wf1-confirm-alt-info">' +
          '<span class="wf1-confirm-alt-id">' + alt.typeId + '</span>' +
          '<span class="wf1-confirm-alt-desc">' + spec.desc + '</span>' +
        '</div>' +
        '<span class="wf1-confirm-alt-action">Select â†’</span>' +
      '</div>';
    }
  } else if (confirmInfo.element === 'contentMode') {
    // Show the other content mode option
    const otherMode = confirmInfo.value === 'same' ? 'batch' : 'individual';
    const otherDisplay = otherMode === 'individual' ? 
      { icon: 'ðŸ·ï¸', title: 'Same content on every label' } :
      { icon: 'ðŸ“‹', title: 'Different content on each label' };
    
    altHtml += '<div class="wf1-confirm-alt-item" onclick="wf1ConfirmSelectContentMode(\'' + otherMode + '\')">' +
      '<div class="wf1-confirm-alt-info">' +
        '<span class="wf1-confirm-alt-id">' + otherDisplay.icon + '</span>' +
        '<span class="wf1-confirm-alt-desc">' + otherDisplay.title + '</span>' +
      '</div>' +
      '<span class="wf1-confirm-alt-action">Select â†’</span>' +
    '</div>';
  }
  
  container.innerHTML = 
    '<div class="wf1-confirm-header">' +
      '<div class="wf1-confirm-icon">ðŸ¤”</div>' +
      '<div class="wf1-confirm-title">' +
        '<div class="wf1-confirm-title-main">Is this what you need?</div>' +
        '<div class="wf1-confirm-title-reason">' + sourceText + '</div>' +
      '</div>' +
    '</div>' +
    '<div class="wf1-confirm-value">' +
      '<div class="wf1-confirm-value-main">' +
        '<span class="wf1-confirm-value-id">' + valueDisplay.id + '</span>' +
        '<span class="wf1-confirm-value-desc">' + valueDisplay.desc + '</span>' +
      '</div>' +
      '<span class="wf1-confirm-value-meta">' + valueDisplay.meta + '</span>' +
    '</div>' +
    '<div class="wf1-confirm-actions">' +
      '<button class="wf1-confirm-btn-yes" onclick="wf1ConfirmAccept(' + stepNumber + ')">Yes, use this <span>â†’</span></button>' +
      '<button class="wf1-confirm-btn-no" onclick="wf1ConfirmShowAlternatives()">Not this?</button>' +
    '</div>' +
    '<div class="wf1-confirm-alternatives" id="wf1ConfirmAlternatives">' +
      '<div class="wf1-confirm-alt-header">Other options:</div>' +
      '<div class="wf1-confirm-alt-list">' + altHtml + '</div>' +
      '<button class="wf1-confirm-show-all" onclick="wf1ConfirmShowAll(' + stepNumber + ')">Show all options â†“</button>' +
    '</div>';
  
  container.style.display = 'block';
}

/**
 * Phase 3C: Get top alternative label types from inventory
 */
function getTopAlternativeTypes(excludeType, count) {
  const alternatives = [];
  
  for (const typeId of TYPE_ORDER) {
    if (typeId === excludeType) continue;
    
    const inv = inventory[typeId];
    if (inv && inv.stock > 0) {
      alternatives.push({
        typeId: typeId,
        stock: inv.stock
      });
      if (alternatives.length >= count) break;
    }
  }
  
  return alternatives;
}

/**
 * Phase 3C: User accepted the confirm suggestion
 */
function wf1ConfirmAccept(stepNumber) {
  const confirmInfo = wf1CheckConfirmMode(stepNumber);
  if (!confirmInfo) return;
  
  console.log('[Phase 3C] User confirmed:', confirmInfo.element, '=', confirmInfo.value);
  
  // Apply the inference
  wf1AcceptInference(confirmInfo.element);
  wf1ApplyInferenceToState(confirmInfo.element);
  
  // Hide the confirm card
  const container = document.getElementById('wf1ConfirmCard');
  if (container) container.style.display = 'none';
  
  // Advance to next step
  if (stepNumber === 1) {
    wf1ToStep2();
  } else if (stepNumber === 3) {
    wf1ToStep4();
  }
}

/**
 * Phase 3C: Show alternatives panel
 */
function wf1ConfirmShowAlternatives() {
  wf1ConfirmAlternativesVisible = !wf1ConfirmAlternativesVisible;
  
  const panel = document.getElementById('wf1ConfirmAlternatives');
  if (panel) {
    panel.classList.toggle('visible', wf1ConfirmAlternativesVisible);
  }
}

/**
 * Phase 3C: User selected an alternative label type
 */
function wf1ConfirmSelectAlternative(typeId) {
  console.log('[Phase 3C] User selected alternative:', typeId);
  
  // Phase 4: Record correction for learning
  if (typeof recordCorrection === 'function' && wf1Inferences?.labelType) {
    recordCorrection('labelType', wf1Inferences.labelType.value, typeId, wf1Inferences.labelType.source);
  }
  
  // Reject the inference (user chose different)
  wf1RejectInference('labelType');
  
  // Select the alternative
  wf1LabelType = typeId;
  
  // Hide confirm card
  const container = document.getElementById('wf1ConfirmCard');
  if (container) container.style.display = 'none';
  
  // Advance
  wf1ToStep2();
}

/**
 * Phase 3C: User selected alternative content mode
 */
function wf1ConfirmSelectContentMode(mode) {
  console.log('[Phase 3C] User selected alternative content mode:', mode);
  
  // Phase 4: Record correction for learning
  if (typeof recordCorrection === 'function' && wf1Inferences?.contentMode) {
    recordCorrection('contentMode', wf1Inferences.contentMode.value, mode, wf1Inferences.contentMode.source);
  }
  
  // Reject the inference
  wf1RejectInference('contentMode');
  
  // Set the mode and advance
  wf1SetJobTypeAndAdvance(mode);
  
  // Hide confirm card
  const container = document.getElementById('wf1ConfirmCard');
  if (container) container.style.display = 'none';
}

/**
 * Phase 3C: User wants to see all options (dismiss confirm card)
 */
function wf1ConfirmShowAll(stepNumber) {
  console.log('[Phase 3C] User wants all options for step:', stepNumber);
  
  // Reject the inference so it doesn't auto-suggest again
  const stepElementMap = { 1: 'labelType', 3: 'contentMode' };
  const element = stepElementMap[stepNumber];
  if (element) wf1RejectInference(element);
  
  // Hide confirm card
  const container = document.getElementById('wf1ConfirmCard');
  if (container) container.style.display = 'none';
  
  // Re-render the step without confirm mode (grid will show)
  if (stepNumber === 1) {
    wf1RenderTypeGrid();
  }
}

// ============================================================================
// Phase 3D: Narrowed Mode - Show filtered options for LOW confidence
// ============================================================================

// Track narrowed mode state
let wf1NarrowedSelection = null;

/**
 * Phase 3D: Check if we should show narrowed mode for a step
 * @param {number} stepNumber - The wizard step number
 * @returns {Object|null} - Narrowed info or null if not applicable
 */
function wf1CheckNarrowedMode(stepNumber) {
  if (!wf1Inferences) return null;
  
  // Map steps to elements
  const stepElementMap = {
    1: 'labelType',
    3: 'contentMode'
  };
  
  const element = stepElementMap[stepNumber];
  if (!element || !wf1Inferences[element]) return null;
  
  const inf = wf1Inferences[element];
  
  // Only show narrowed for low confidence
  if (inf.confidence !== 'low') return null;
  
  // Get relevant options to narrow to
  let narrowedOptions = [];
  
  if (element === 'labelType') {
    // For low confidence, show types in stock plus the suggested one
    narrowedOptions = getNarrowedLabelTypes(inf.value, 5);
  }
  
  // Need at least 2 options for narrowed mode to make sense
  if (narrowedOptions.length < 2) return null;
  
  return {
    element: element,
    value: inf.value,
    confidence: inf.confidence,
    source: inf.source,
    options: narrowedOptions
  };
}

/**
 * Phase 3D: Get narrowed label type options (in-stock + suggested)
 * @param {string} suggestedType - The inferred type
 * @param {number} maxOptions - Maximum options to show
 * @returns {Array} - Array of {typeId, stock, suggested} objects
 */
function getNarrowedLabelTypes(suggestedType, maxOptions) {
  const options = [];
  const addedTypes = new Set();
  
  // First, add the suggested type if it exists
  if (suggestedType && LABEL_TYPES[suggestedType]) {
    const inv = inventory[suggestedType];
    options.push({
      typeId: suggestedType,
      stock: inv ? inv.stock : 0,
      suggested: true
    });
    addedTypes.add(suggestedType);
  }
  
  // Then add types that are in stock, ordered by TYPE_ORDER
  for (const typeId of TYPE_ORDER) {
    if (options.length >= maxOptions) break;
    if (addedTypes.has(typeId)) continue;
    
    const inv = inventory[typeId];
    if (inv && inv.stock > 0) {
      options.push({
        typeId: typeId,
        stock: inv.stock,
        suggested: false
      });
      addedTypes.add(typeId);
    }
  }
  
  // If we still don't have enough, add recently used types
  if (options.length < Math.min(3, maxOptions) && settings.lastLabelType) {
    const lastType = settings.lastLabelType;
    if (!addedTypes.has(lastType) && LABEL_TYPES[lastType]) {
      const inv = inventory[lastType];
      options.push({
        typeId: lastType,
        stock: inv ? inv.stock : 0,
        suggested: false
      });
    }
  }
  
  return options;
}

/**
 * Phase 3D: Render the narrowed card for low confidence
 * @param {number} stepNumber - The wizard step number
 */
function wf1RenderNarrowedCard(stepNumber) {
  const container = document.getElementById('wf1NarrowedCard');
  if (!container) return;
  
  const narrowedInfo = wf1CheckNarrowedMode(stepNumber);
  
  // Hide if no narrowed mode needed
  if (!narrowedInfo) {
    container.style.display = 'none';
    return;
  }
  
  wf1NarrowedSelection = null;
  
  const sourceText = wf1GetSourceDescription(narrowedInfo.source);
  
  // Build options HTML
  let optionsHtml = '';
  
  for (const opt of narrowedInfo.options) {
    const spec = LABEL_TYPES[opt.typeId];
    const lps = spec.cols * spec.rows;
    
    let classes = 'wf1-narrowed-option';
    if (opt.suggested) classes += ' suggested';
    
    let stockBadge = '';
    if (opt.stock > 0) {
      stockBadge = '<span class="wf1-narrowed-option-stock">ðŸ“¦ ' + opt.stock + '</span>';
    }
    
    optionsHtml += '<div class="' + classes + '" data-type="' + opt.typeId + '" onclick="wf1NarrowedSelect(\'' + opt.typeId + '\')" ondblclick="wf1NarrowedSelectAndContinue(\'' + opt.typeId + '\')">' +
      '<div class="wf1-narrowed-option-main">' +
        '<span class="wf1-narrowed-option-id">' + opt.typeId + '</span>' +
        '<span class="wf1-narrowed-option-desc">' + spec.desc + '</span>' +
      '</div>' +
      '<span class="wf1-narrowed-option-meta">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet' + stockBadge + '</span>' +
    '</div>';
  }
  
  container.innerHTML = 
    '<div class="wf1-narrowed-header">' +
      '<div class="wf1-narrowed-icon">ðŸ”</div>' +
      '<div class="wf1-narrowed-title">' +
        '<div class="wf1-narrowed-title-main">Select a label type</div>' +
        '<div class="wf1-narrowed-title-reason">' + sourceText + ' â€” showing relevant options</div>' +
      '</div>' +
    '</div>' +
    '<div class="wf1-narrowed-options">' + optionsHtml + '</div>' +
    '<div class="wf1-narrowed-actions">' +
      '<button class="wf1-narrowed-show-all" onclick="wf1NarrowedShowAll(' + stepNumber + ')">Show all ' + Object.keys(LABEL_TYPES).length + ' label types â†“</button>' +
      '<button class="wf1-narrowed-continue" id="wf1NarrowedContinueBtn" onclick="wf1NarrowedContinue(' + stepNumber + ')" disabled>Select a type</button>' +
    '</div>';
  
  container.style.display = 'block';
  
  console.log('[Phase 3D] Rendered narrowed card with', narrowedInfo.options.length, 'options');
}

/**
 * Phase 3D: User selected an option in narrowed mode
 * @param {string} typeId - The selected label type
 */
function wf1NarrowedSelect(typeId) {
  wf1NarrowedSelection = typeId;
  
  // Update visual selection
  document.querySelectorAll('#wf1NarrowedCard .wf1-narrowed-option').forEach(opt => {
    opt.classList.toggle('selected', opt.dataset.type === typeId);
  });
  
  // Enable continue button
  const btn = document.getElementById('wf1NarrowedContinueBtn');
  if (btn) {
    btn.disabled = false;
    btn.textContent = 'Continue â†’';
  }
  
  console.log('[Phase 3D] Selected:', typeId);
}

/**
 * Phase 3D: Double-click to select and immediately continue
 * @param {string} typeId - The selected label type
 */
function wf1NarrowedSelectAndContinue(typeId) {
  wf1NarrowedSelect(typeId);
  wf1NarrowedContinue(1);
}

/**
 * Phase 3D: Continue with the narrowed selection
 * @param {number} stepNumber - The wizard step number
 */
function wf1NarrowedContinue(stepNumber) {
  if (!wf1NarrowedSelection) return;
  
  console.log('[Phase 3D] Continuing with selection:', wf1NarrowedSelection);
  
  // Phase 4: Track learning - was this the suggested one or different?
  if (typeof recordAcceptance === 'function' && typeof recordCorrection === 'function' && wf1Inferences?.labelType) {
    const inferredValue = wf1Inferences.labelType.value;
    if (wf1NarrowedSelection === inferredValue) {
      // User accepted the suggestion
      recordAcceptance('labelType', wf1NarrowedSelection, 'narrowed-selection');
    } else {
      // User picked something different from narrowed list
      recordCorrection('labelType', inferredValue, wf1NarrowedSelection, 'narrowed-selection');
    }
  }
  
  // Accept the selection
  wf1LabelType = wf1NarrowedSelection;
  
  // Hide narrowed card
  const container = document.getElementById('wf1NarrowedCard');
  if (container) container.style.display = 'none';
  
  // Update inference tracking if available
  if (wf1Inferences && wf1Inferences.labelType) {
    wf1Inferences.labelType.value = wf1NarrowedSelection;
    wf1Inferences.labelType.source = 'narrowed-selection';
  }
  
  // Move to next step
  wf1ToStep2();
}

/**
 * Phase 3D: Show all options (exit narrowed mode)
 * @param {number} stepNumber - The wizard step number
 */
function wf1NarrowedShowAll(stepNumber) {
  console.log('[Phase 3D] User wants all options for step:', stepNumber);
  
  // Reject the inference so it shows full grid
  const stepElementMap = { 1: 'labelType', 3: 'contentMode' };
  const element = stepElementMap[stepNumber];
  if (element) wf1RejectInference(element);
  
  // Hide narrowed card
  const container = document.getElementById('wf1NarrowedCard');
  if (container) container.style.display = 'none';
  
  // Re-render the grid (will now show full grid)
  if (stepNumber === 1) {
    wf1RenderTypeGrid();
  }
}

function wf1Start() {
  // Block satellite from printing
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  // Reset state
  wf1Step = 1;
  wf1LabelType = settings.lastLabelType || '5160';
  wf1JobType = null;
  wf1Quantity = 1;
  wf1TargetSheet = null;
  wf1ContentLines = [];
  wf1BatchContent = [];
  wf1InvAddVisible = false;
  wf1SelectedSheet = null;
  wf1MultiSheetPlan = null;
  wf1Orientation = 'next'; // T3: Reset orientation
  wf1SelectedSavedTextId = null;
  wf1PrintResult = null;
  wf1_aiActive = false;
  wf1_fullEditorActive = false;
  wf1FeSnapshot = null;
  wf1StyleTemplateId = null;
  wf1LineAligns = ['left', 'left', 'left', 'left'];
  wf1LineSizes = [11, 11, 11, 11];
  
  // Phase 3: Initialize inference engine
  wf1Spec = null;
  wf1Inferences = null;
  wf1InferenceSummary = null;
  wf1InitInferences();
  
  // Phase 3B: Reset skipped steps tracking
  wf1ResetSkippedSteps();
  
  // Render Step 1
  wf1RenderTypeGrid();
  wf1UpdateProgress();
  
  // Phase 3: Update smart summary bar
  wf1UpdateSmartSummary();
  
  // Show wizard
  showWizard('wf1Wizard');
  wf1ShowStep('wf1Step1');
}

function wf1Close() {
  // Process any checked post-print options before closing
  wf1ProcessPostPrintOptions();
  
  closeWizard('wf1Wizard');
  wf1Step = 1;
}

// Process checked post-print options
function wf1ProcessPostPrintOptions() {
  const result = wf1PrintResult;
  if (!result) return;
  
  // Check if save list was selected (batch jobs)
  const saveListCheckbox = document.getElementById('wf1PostSaveList');
  if (saveListCheckbox && saveListCheckbox.checked) {
    wf1DoSaveList();
  }
  
  // Multi-sheet jobs only have the save list option
  if (result.isMultiSheet) return;
  
  // Check if link content was selected
  const linkCheckbox = document.getElementById('wf1PostLinkContent');
  if (linkCheckbox && linkCheckbox.checked) {
    wf1DoLinkContent();
  }
  
  // Check if split sheet was selected
  const splitCheckbox = document.getElementById('wf1PostSplitSheet');
  if (splitCheckbox && splitCheckbox.checked) {
    wf1DoSplitRemaining();
  }
}

// Save batch list data for reprinting
function wf1DoSaveList() {
  if (!wf1BatchContent || wf1BatchContent.length === 0) return;
  
  // Create a saved list object
  const listId = 'list_' + Date.now();
  const savedList = {
    id: listId,
    name: 'Batch List (' + wf1BatchContent.length + ' items) - ' + new Date().toLocaleDateString(),
    createdAt: Date.now(),
    labelType: wf1LabelType,
    content: wf1BatchContent, // Array of line arrays
    template: wf1BatchSelectedTemplate,
    columnMap: wf1BatchColumnMap
  };
  
  // Store in savedLists
  if (!window.savedLists) window.savedLists = [];
  savedLists.push(savedList);
  saveSavedLists();
  
  // Update the most recent print history entry to reference this list
  if (printHistory && printHistory.length > 0) {
    const lastEntry = printHistory[printHistory.length - 1];
    if (lastEntry.textName && lastEntry.textName.startsWith('Batch')) {
      lastEntry.savedListId = listId;
      savePrintHistory();
    }
  }
  
  showToast('List saved! You can reprint via "Print Something Again"', 'success');
}

// Load and save savedLists from localStorage
function loadSavedLists() {
  try {
    const stored = localStorage.getItem('lk_savedLists');
    if (stored) {
      window.savedLists = JSON.parse(stored);
    } else {
      window.savedLists = [];
    }
  } catch (e) {
    window.savedLists = [];
  }
}

function saveSavedLists() {
  try {
    localStorage.setItem('lk_savedLists', JSON.stringify(savedLists));
  } catch (e) {
    console.error('Failed to save lists:', e);
  }
}

function getSavedList(listId) {
  if (!savedLists) loadSavedLists();
  return savedLists.find(l => l.id === listId);
}

// Link content to sheet (silent version for checkbox flow)
function wf1DoLinkContent() {
  const result = wf1PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  let textId = wf1SelectedSavedTextId;
  
  // Save content if not already saved
  if (!textId) {
    const newText = {
      id: generateId('text'),
      name: generateContentName(wf1ContentLines, wf1LabelType),
      text: serializeLines(wf1ContentLines.map(function(l) {
        return { text: l.text, align: l.align, fontSize: l.fontSize, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' };
      })),
      alignV: 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now()
    };
    savedTexts.push(newText);
    saveSavedTexts();
    textId = newText.id;
  }
  
  // Link to sheet
  if (!sh.texts) sh.texts = {};
  if (!sh.texts[textId]) {
    sh.texts[textId] = { qty: 0, placement: 'next' };
  }
  saveSheets();
  
  showToast('Content linked to sheet', 'success');
}

// Split remaining labels into new sheet (silent version for checkbox flow)
function wf1DoSplitRemaining() {
  const result = wf1PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const remaining = getRemainingCount(sh);
  
  if (remaining <= 0 || remaining >= lps) return;
  
  // Find unused positions
  const printedSet = new Set(sh.printed || []);
  const unusedPositions = [];
  for (let i = 0; i < lps; i++) {
    if (!printedSet.has(i)) unusedPositions.push(i);
  }
  
  // Create new sheet with these positions pre-marked as "available"
  // Actually, we mark the USED positions as printed, so new sheet starts fresh
  // and original sheet gets all unused marked as printed (sheet is "done")
  
  // Mark all remaining positions as printed on original sheet
  sh.printed = Array.from({ length: lps }, (_, i) => i);
  saveSheets();
  
  // Create new sheet  
  const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
  const newSheetName = spec.desc + ' #' + (existingCount + 1) + ' (split)';
  const newSheetId = createSheet(newSheetName, wf1LabelType, 1);
  
  // Mark positions that were already used on the original as printed on new sheet
  // (inverse of what we want available)
  const newSheet = sheets[newSheetId];
  const usedOnOriginal = [];
  for (let i = 0; i < lps; i++) {
    if (!unusedPositions.includes(i)) usedOnOriginal.push(i);
  }
  newSheet.printed = usedOnOriginal;
  saveSheets();
  
  showToast('Split ' + remaining + ' labels into "' + newSheetName + '"', 'success');
}

function wf1ShowStep(stepId) {
  const wizard = document.getElementById('wf1Wizard');
  wizard.querySelectorAll('.wizard-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
  wf1UpdateProgress();
}

function wf1UpdateProgress() {
  const container = document.getElementById('wf1Progress');
  let html = '';
  for (let i = 1; i <= WF1_TOTAL_STEPS; i++) {
    let cls = 'wf1-progress-dot';
    if (i === wf1Step) cls += ' active';
    else if (i < wf1Step) cls += ' done';
    html += '<div class="' + cls + '"></div>';
  }
  container.innerHTML = html;
}

function wf1Back() {
  if (wf1Step <= 1) {
    wf1Close();
    return;
  }
  
  // Special handling for batch sub-steps within step 6
  if (wf1Step === 6 && wf1JobType === 'batch') {
    if (wf1BatchSubStep === 'preview') {
      wf1BatchSubStep = 'map';
      wf1RenderBatchMapStep();
      return;
    } else if (wf1BatchSubStep === 'map') {
      wf1BatchSubStep = 'template';
      wf1RenderBatchTemplateStep();
      return;
    } else if (wf1BatchSubStep === 'template') {
      wf1BatchSubStep = 'upload';
      wf1RenderBatchUpload(document.getElementById('wf1ContentArea'));
      return;
    }
  }
  
  wf1Step--;
  wf1ShowStep('wf1Step' + wf1Step);
}

// ---- STEP 1: Label Type Picker ----

function wf1RenderTypeGrid() {
  const grid = document.getElementById('wf1TypeGrid');
  const lastUsed = settings.lastLabelType;
  
  // Phase 3: Check for inferred label type
  const inferredType = wf1Inferences?.labelType?.value;
  const inferredConfidence = wf1Inferences?.labelType?.confidence;
  const inferredSource = wf1Inferences?.labelType?.source;
  
  // Phase 3C/3D: Check UI mode
  const uiMode = wf1GetUIMode('labelType');
  
  // Phase 3D: Check if we should show narrowed mode for low confidence
  if (inferredConfidence === 'low' && uiMode === 'narrowed') {
    // Show narrowed card for low confidence
    wf1RenderNarrowedCard(1);
    // Hide confirm card
    const confirmCard = document.getElementById('wf1ConfirmCard');
    if (confirmCard) confirmCard.style.display = 'none';
    // Hide the full grid - narrowed card replaces it
    grid.style.display = 'none';
    return;
  } else {
    // Show grid, hide narrowed card
    grid.style.display = '';
    const narrowedCard = document.getElementById('wf1NarrowedCard');
    if (narrowedCard) narrowedCard.style.display = 'none';
  }
  
  // Phase 3C: Check if we should show confirm mode for medium confidence
  if (inferredConfidence === 'medium' && uiMode !== 'rejected') {
    // Show confirm card for medium confidence
    wf1RenderConfirmCard(1);
    // Still render grid below, but user sees confirm card first
  } else {
    // Hide confirm card if not medium confidence
    const confirmCard = document.getElementById('wf1ConfirmCard');
    if (confirmCard) confirmCard.style.display = 'none';
  }
  
  // If high confidence and not rejected, pre-select the inferred type
  if (inferredType && inferredConfidence === 'high' && uiMode !== 'rejected') {
    wf1LabelType = inferredType;
  }
  
  let html = '';
  
  // Phase 3: Show suggestion banner if we have a high-confidence inference
  // (Skip banner for medium - handled by confirm card)
  if (inferredType && inferredConfidence === 'high' && uiMode !== 'rejected') {
    const spec = LABEL_TYPES[inferredType];
    const sourceText = wf1GetSourceDescription(inferredSource);
    
    html += '<div class="wf1-inference-banner high">' +
      '<div class="wf1-inference-banner-icon">âœ¨</div>' +
      '<div class="wf1-inference-banner-content">' +
        '<div class="wf1-inference-banner-title">Suggested: ' + inferredType + ' ' + spec.desc + '</div>' +
        '<div class="wf1-inference-banner-reason">' + sourceText + '</div>' +
      '</div>' +
      '<button class="wf1-inference-use-btn" onclick="wf1AcceptInferredType()">Use This â†’</button>' +
    '</div>';
  }
  
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === wf1LabelType;
    const isLast = typeId === lastUsed;
    const isInferred = typeId === inferredType;
    
    // Inventory badge
    const inv = inventory[typeId];
    let invBadge = '';
    if (inv && inv.stock > 0) {
      invBadge = '<div class="wf1-type-card-badge">ðŸ“¦ ' + inv.stock + ' sheet' + (inv.stock !== 1 ? 's' : '') + '</div>';
    }
    
    // Category badge
    let catBadge = '';
    if (spec.category === 'badge') catBadge = ' ðŸ·ï¸';
    else if (spec.category === 'tent') catBadge = ' â›º';
    else if (spec.category === 'round') catBadge = ' â­•';
    
    // Build class list
    let cardClass = 'wf1-type-card';
    if (selected) cardClass += ' selected';
    if (isLast) cardClass += ' last-used';
    if (isInferred && !selected) cardClass += ' inferred';
    
    html += '<div class="' + cardClass + '" data-type="' + typeId + '" onclick="wf1SelectType(\'' + typeId + '\')" ondblclick="wf1SelectTypeAndAdvance(\'' + typeId + '\')">' +
      '<div class="wf1-type-card-id">' + typeId + catBadge + '</div>' +
      '<div class="wf1-type-card-desc">' + spec.desc + '</div>' +
      '<div class="wf1-type-card-meta">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet</div>' +
      invBadge +
    '</div>';
  }
  grid.innerHTML = html;
}

/**
 * Phase 3: Get human-readable description of inference source
 */
function wf1GetSourceDescription(source) {
  const descriptions = {
    'sheet-locked': 'Based on selected sheet',
    'content-match': 'Matches your saved content',
    'inventory-only': 'Only type in stock',
    'history': 'Based on your recent prints',
    'auto-best': 'Most available labels',
    'batch-count': 'Based on import data',
    'template-type': 'Based on template',
    'dedicated': 'Dedicated sheet exists',
    'default': 'Default selection',
    'narrowed-selection': 'Selected from suggestions'
  };
  return descriptions[source] || 'Smart suggestion';
}

/**
 * Phase 3: Accept inferred label type and advance
 */
function wf1AcceptInferredType() {
  if (!wf1Inferences?.labelType?.value) return;
  
  wf1LabelType = wf1Inferences.labelType.value;
  wf1AcceptInference('labelType');
  wf1ApplyInferenceToState('labelType');
  wf1ToStep2();
}

function wf1SelectType(typeId) {
  wf1LabelType = typeId;
  
  // Update visual selection
  document.querySelectorAll('#wf1TypeGrid .wf1-type-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.type === typeId);
  });
}

// T1: Double-click to select AND advance to next step
function wf1SelectTypeAndAdvance(typeId) {
  wf1SelectType(typeId);
  wf1ToStep2();
}

function wf1ToStep2() {
  if (!wf1LabelType) return;
  
  // Phase 4: Track learning if user selected from full grid (bypassed inference)
  // This happens when user clicked "Show all" then selected from grid
  // Skip if inference was already accepted (tracked via wf1AcceptInference)
  if (typeof recordAcceptance === 'function' && typeof recordCorrection === 'function' && wf1Inferences?.labelType) {
    const inferredValue = wf1Inferences.labelType.value;
    const inferredConfidence = wf1Inferences.labelType.confidence;
    const wasAccepted = wf1Spec?._meta?.skippedSteps?.includes('labelType');
    
    // Only track if there was a non-NONE inference that user bypassed (not already tracked)
    if (inferredValue && inferredConfidence !== 'none' && !wasAccepted) {
      if (wf1LabelType === inferredValue) {
        // User manually selected same as inference (rare but possible)
        recordAcceptance('labelType', wf1LabelType, 'grid-selection-matched');
      } else {
        // User selected something different from the inference
        recordCorrection('labelType', inferredValue, wf1LabelType, 'grid-selection');
      }
    }
  }
  
  // Save as last used
  settings.lastLabelType = wf1LabelType;
  saveSettings();
  
  wf1Step = 2;
  wf1RenderInventoryCheck();
  wf1ShowStep('wf1Step2');
}

// ---- STEP 2: Inventory Check ----

function wf1RenderInventoryCheck() {
  const content = document.getElementById('wf1InventoryContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const summary = getInventorySummary(wf1LabelType);
  const inv = getInventoryForType(wf1LabelType);
  
  wf1InvAddVisible = false;
  
  let html = '';
  
  if (inv && summary.stock > 0) {
    // Scenario A: Has stock
    const totalLabels = summary.totalLabels;
    const stockLabels = summary.stockLabels;
    
    if (summary.isLow) {
      // Low stock warning â€” still double-clickable to continue
      html += '<div class="wf1-inventory-status low-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
        '<div class="wf1-inventory-icon">âš ï¸</div>' +
        '<div class="wf1-inventory-msg">You\'re running low on ' + wf1LabelType + '</div>' +
        '<div class="wf1-inventory-detail">' + summary.stock + ' sheet' + (summary.stock !== 1 ? 's' : '') + ' in stock (' + stockLabels + ' labels)';
      
      if (summary.partialLabels > 0) {
        html += ', plus ' + summary.partialLabels + ' available on existing sheets';
      }
      html += '.</div>' +
        '<div class="wf1-inventory-actions">' +
          '<button class="wf1-inv-btn" onclick="event.stopPropagation(); wf1ShowInlineAdd()">Add more stock</button>' +
        '</div>' +
      '</div>';
    } else {
      // Plenty of stock â€” double-click to advance
      html += '<div class="wf1-inventory-status has-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
        '<div class="wf1-inventory-icon">âœ…</div>' +
        '<div class="wf1-inventory-msg">You have ' + summary.stock + ' sheet' + (summary.stock !== 1 ? 's' : '') + ' of ' + wf1LabelType + '</div>' +
        '<div class="wf1-inventory-detail">' + totalLabels + ' labels available';
      
      if (summary.partialLabels > 0) {
        html += ' (' + stockLabels + ' in stock + ' + summary.partialLabels + ' on existing sheets)';
      }
      html += '.</div></div>';
    }
  } else if (inv && summary.stock === 0 && summary.partialLabels > 0) {
    // No stock but has partial sheets with spots â€” still clickable
    html += '<div class="wf1-inventory-status low-stock" ondblclick="wf1ToStep3()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-inventory-icon">âš ï¸</div>' +
      '<div class="wf1-inventory-msg">No sheets of ' + wf1LabelType + ' in stock</div>' +
      '<div class="wf1-inventory-detail">You have ' + summary.partialLabels + ' labels available on existing sheets, but no fresh sheets.</div>' +
      '<div class="wf1-inventory-actions">' +
        '<button class="wf1-inv-btn" onclick="event.stopPropagation(); wf1ShowInlineAdd()">Add stock</button>' +
      '</div>' +
    '</div>';
  } else {
    // Scenario B: No stock recorded at all
    html += '<div class="wf1-inventory-status no-stock">' +
      '<div class="wf1-inventory-icon">ðŸ“¦</div>' +
      '<div class="wf1-inventory-msg">I don\'t show you having any Avery ' + wf1LabelType + ' labels on hand.</div>' +
      '<div class="wf1-inventory-detail">' + spec.desc + ' â€” ' + spec.sizeDisplay + ', ' + lps + ' labels per sheet</div>' +
      '<div class="wf1-inventory-actions">' +
        '<button class="wf1-inv-btn primary" onclick="wf1ShowInlineAdd()">Yes, I have some â€” add to inventory</button>' +
        '<button class="wf1-inv-btn" onclick="wf1SkipInventory()">Continue without tracking</button>' +
      '</div>' +
    '</div>';
  }
  
  // Inline add area (hidden initially)
  html += '<div class="wf1-inv-add-inline" id="wf1InvAddInline" style="display:none;">' +
    '<label for="wf1InvAddQty">How many sheets of ' + wf1LabelType + ' do you have?</label>' +
    '<input type="number" id="wf1InvAddQty" min="1" max="500" value="10" inputmode="numeric">' +
    '<div class="wf1-inv-add-actions">' +
      '<button class="wf1-inv-btn primary" onclick="wf1SaveInlineInventory()">Save</button>' +
      '<button class="wf1-inv-btn" onclick="wf1HideInlineAdd()">Cancel</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
}

function wf1ShowInlineAdd() {
  wf1InvAddVisible = true;
  document.getElementById('wf1InvAddInline').style.display = 'block';
  document.getElementById('wf1InvAddQty').focus();
}

function wf1HideInlineAdd() {
  wf1InvAddVisible = false;
  document.getElementById('wf1InvAddInline').style.display = 'none';
}

function wf1SaveInlineInventory() {
  const qty = parseInt(document.getElementById('wf1InvAddQty').value) || 0;
  if (qty <= 0) {
    showToast('Enter a number of sheets', 'warning');
    return;
  }
  
  // Save to inventory
  const existing = inventory[wf1LabelType];
  const oldStock = existing ? existing.stock : 0;
  inventory[wf1LabelType] = {
    stock: qty,
    lowThreshold: existing ? existing.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  addInventoryEvent(wf1LabelType, 'add', qty - oldStock, inventory[wf1LabelType].stock);
  
  showToast(qty + ' sheet' + (qty !== 1 ? 's' : '') + ' of ' + wf1LabelType + ' added to inventory', 'success');
  
  // Re-render the inventory check with updated data
  wf1RenderInventoryCheck();
}

function wf1SkipInventory() {
  // User chose to continue without tracking inventory
  // Just advance to step 3
  wf1ToStep3();
}

function wf1ToStep3() {
  wf1Step = 3;
  wf1JobType = null; // Reset in case coming back
  
  // Reset quantity display
  document.getElementById('wf1QtyRow').style.display = 'none';
  document.getElementById('wf1QtyHint').style.display = 'none';
  document.getElementById('wf1Step3Actions').style.display = 'none';
  
  // Reset visual selection on content choices
  document.querySelectorAll('.wf1-content-choice').forEach(c => {
    c.style.borderColor = '';
    c.style.background = '';
  });
  
  // Phase 3B: Check if we can auto-skip this step
  const skipInfo = wf1CheckAutoSkip(3);
  if (skipInfo && wf1Inferences?.contentMode?.confidence === 'high') {
    // Auto-apply contentMode inference
    wf1ExecuteAutoSkip(3, skipInfo);
    
    // Update skipped banner
    wf1UpdateSkippedBanner();
    
    // Skip to step 4 (feasibility)
    wf1ToStep4();
    return;
  }
  
  wf1ShowStep('wf1Step3');
}

// ---- STEP 3: Content Type + Quantity ----

function wf1SetJobType(type) {
  wf1JobType = type;
  
  // Highlight selected choice
  const choices = document.querySelectorAll('.wf1-content-choice');
  choices.forEach(c => {
    c.style.borderColor = '';
    c.style.background = '';
  });
  const idx = type === 'individual' ? 0 : 1;
  choices[idx].style.borderColor = 'var(--accent)';
  choices[idx].style.background = 'var(--accent-bg)';
  
  if (type === 'individual') {
    // Show quantity picker for individual
    const spec = LABEL_TYPES[wf1LabelType];
    const lps = spec.cols * spec.rows;
    document.getElementById('wf1QtyRow').style.display = 'flex';
    document.getElementById('wf1QtyHint').style.display = 'block';
    document.getElementById('wf1QtyHint').textContent = lps + ' labels per sheet of ' + wf1LabelType;
    document.getElementById('wf1QtyValue').textContent = wf1Quantity;
    document.getElementById('wf1QtyMinus').disabled = wf1Quantity <= 1;
  } else {
    // Batch â€” quantity determined by list, hide picker
    document.getElementById('wf1QtyRow').style.display = 'none';
    document.getElementById('wf1QtyHint').style.display = 'none';
  }
  
  // Show next button
  document.getElementById('wf1Step3Actions').style.display = 'flex';
}

// T1: Double-click to set job type and advance
function wf1SetJobTypeAndAdvance(type) {
  wf1SetJobType(type);
  // For batch, advance immediately. For individual, user may want to adjust quantity first.
  if (type === 'batch') {
    setTimeout(() => wf1ToStep3B(), 100);
  }
}

// Step 3B: CSV Upload for batch (happens before feasibility so we know the qty)
function wf1ToStep3B() {
  // Reset batch state
  wf1BatchCsvData = [];
  wf1BatchCsvColumns = [];
  wf1BatchContent = [];
  wf1BatchSelectedTemplate = null;
  wf1BatchColumnMap = {};
  wf1BatchSubStep = 'upload';
  
  // Render CSV upload in Step 3's area (reuse the step visually)
  const contentArea = document.getElementById('wf1Step3Content');
  const question = document.getElementById('wf1Step3Question');
  
  question.textContent = 'Import your list';
  
  let html = '<div class="wf1-batch-upload">';
  html += '<div class="wf1-batch-upload-zone" id="wf1BatchDropZone">';
  html += '<div class="wf1-batch-upload-icon">ðŸ“„</div>';
  html += '<div class="wf1-batch-upload-text">Drop a CSV or Excel file here</div>';
  html += '<div class="wf1-batch-upload-or">or</div>';
  html += '<button class="wf1-inv-btn" onclick="document.getElementById(\'wf1BatchFileInput\').click()">Choose File</button>';
  html += '<input type="file" id="wf1BatchFileInput" accept=".csv,.xlsx,.xls,.txt" style="display:none" onchange="wf1HandleBatchFile(this.files[0])">';
  html += '</div>';
  html += '<div class="wf1-batch-paste-option" style="margin-top:12px;text-align:center;">';
  html += '<button class="wf1-inv-btn" onclick="wf1ShowPasteArea()">ðŸ“‹ Paste from clipboard</button>';
  html += '</div>';
  html += '<div id="wf1BatchPasteArea" style="display:none;margin-top:12px;">';
  html += '<textarea id="wf1BatchPasteText" placeholder="Paste your data here (tab or comma separated)" style="width:100%;height:100px;font-family:monospace;font-size:12px;padding:8px;border:2px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);color:var(--text);"></textarea>';
  html += '<button class="wf1-inv-btn primary" onclick="wf1ProcessPastedData()" style="margin-top:8px;">Process Data</button>';
  html += '</div>';
  html += '</div>';
  
  contentArea.innerHTML = html;
  
  // Setup drag and drop
  const dropZone = document.getElementById('wf1BatchDropZone');
  dropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    dropZone.style.borderColor = 'var(--accent)';
    dropZone.style.background = 'var(--accent-bg)';
  });
  dropZone.addEventListener('dragleave', function(e) {
    dropZone.style.borderColor = '';
    dropZone.style.background = '';
  });
  dropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    dropZone.style.borderColor = '';
    dropZone.style.background = '';
    if (e.dataTransfer.files.length > 0) {
      wf1HandleBatchFile(e.dataTransfer.files[0]);
    }
  });
  
  // Hide qty row and update actions
  document.getElementById('wf1QtyRow').style.display = 'none';
  document.getElementById('wf1QtyHint').style.display = 'none';
  document.getElementById('wf1Step3Actions').style.display = 'none';
}

function wf1ShowPasteArea() {
  document.getElementById('wf1BatchPasteArea').style.display = 'block';
  document.getElementById('wf1BatchPasteText').focus();
}

function wf1ProcessPastedData() {
  const text = document.getElementById('wf1BatchPasteText').value.trim();
  if (!text) {
    showToast('Please paste some data first', 'warning');
    return;
  }
  wf1ParseBatchData(text, 'pasted data');
}

// After CSV is loaded in Step 3B, proceed to feasibility
function wf1CsvLoadedProceed() {
  if (wf1BatchCsvData.length === 0) {
    showToast('No data loaded', 'warning');
    return;
  }
  // Now proceed to Step 4 (feasibility) - we have the real qty now
  wf1ToStep4();
}

function wf1AdjustQty(delta) {
  const newQty = wf1Quantity + delta;
  if (newQty < 1 || newQty > 999) return;
  wf1Quantity = newQty;
  document.getElementById('wf1QtyValue').textContent = wf1Quantity;
  document.getElementById('wf1QtyMinus').disabled = wf1Quantity <= 1;
}

function wf1ToStep4() {
  if (!wf1JobType) return;
  
  wf1Step = 4;
  wf1RenderFeasibility();
  wf1ShowStep('wf1Step4');
}

// ---- STEP 4: Feasibility Check ----

function wf1RenderFeasibility() {
  const content = document.getElementById('wf1FeasibilityContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // T6: For batch jobs, if content isn't loaded yet, show a different message
  // BatchContent is populated at Step 6 (after this step), so we can't do a real check yet
  if (wf1JobType === 'batch' && wf1BatchContent.length === 0) {
    // Gather inventory info for display
    const matchingSheets = Object.values(sheets).filter(s => s.labelType === wf1LabelType && !s.retired);
    let spotsOnSheets = 0;
    for (const sh of matchingSheets) {
      spotsOnSheets += getRemainingCount(sh);
    }
    const inv = inventory[wf1LabelType];
    const stockSheets = (inv && inv.stock > 0) ? inv.stock : 0;
    const stockLabels = stockSheets * lps;
    const totalAvailable = spotsOnSheets + stockLabels;
    
    let html = '<div class="wf1-feasibility ok" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">ðŸ“‹</div>' +
      '<div class="wf1-feas-msg">Ready for your list</div>' +
      '<div class="wf1-feas-detail">You\'ll import a list next. Currently you have ' + totalAvailable + ' label' + (totalAvailable !== 1 ? 's' : '') + ' available';
    
    if (spotsOnSheets > 0 && stockLabels > 0) {
      html += ' (' + spotsOnSheets + ' on existing sheets + ' + stockLabels + ' in stock)';
    } else if (spotsOnSheets > 0) {
      html += ' on existing sheets';
    } else if (stockLabels > 0) {
      html += ' in stock';
    }
    html += '.</div></div>';
    
    content.innerHTML = html;
    return;
  }
  
  const qty = wf1JobType === 'batch' ? wf1BatchContent.length : wf1Quantity;
  
  // Gather available spots across existing sheets + inventory
  const matchingSheets = Object.values(sheets).filter(s => s.labelType === wf1LabelType && !s.retired);
  let spotsOnSheets = 0;
  for (const sh of matchingSheets) {
    spotsOnSheets += getRemainingCount(sh);
  }
  
  const inv = inventory[wf1LabelType];
  const stockSheets = (inv && inv.stock > 0) ? inv.stock : 0;
  const stockLabels = stockSheets * lps;
  const totalAvailable = spotsOnSheets + stockLabels;
  
  let html = '';
  
  if (totalAvailable >= qty && (spotsOnSheets >= qty || stockSheets > 0)) {
    // Scenario A: Plenty of room â€” double-click to advance
    html += '<div class="wf1-feasibility ok" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">âœ…</div>' +
      '<div class="wf1-feas-msg">You have enough labels</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + '. You have ' + totalAvailable + ' available';
    
    if (spotsOnSheets > 0 && stockLabels > 0) {
      html += ' (' + spotsOnSheets + ' on existing sheets + ' + stockLabels + ' in stock)';
    } else if (spotsOnSheets > 0) {
      html += ' on existing sheets';
    } else {
      html += ' in stock';
    }
    html += '.</div></div>';
    
  } else if (totalAvailable >= qty) {
    // Scenario B: Tight but doable â€” double-click to advance
    const sheetsNeededFromStock = Math.ceil(Math.max(0, qty - spotsOnSheets) / lps);
    html += '<div class="wf1-feasibility warn" ondblclick="wf1ToStep5()" style="cursor:pointer;" title="Double-click to continue">' +
      '<div class="wf1-feas-icon">âš ï¸</div>' +
      '<div class="wf1-feas-msg">Tight, but doable</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + '. ' +
      'You have ' + spotsOnSheets + ' spots on existing sheets and ' + stockSheets + ' fresh sheet' + (stockSheets !== 1 ? 's' : '') + ' (' + stockLabels + ' labels) in stock. ' +
      'That\'s ' + totalAvailable + ' total â€” enough, but it\'ll use ' + sheetsNeededFromStock + ' sheet' + (sheetsNeededFromStock !== 1 ? 's' : '') + ' from stock.</div></div>';
    
  } else {
    // Scenario C: Not enough
    const deficit = qty - totalAvailable;
    const extraSheetsNeeded = Math.ceil(deficit / lps);
    html += '<div class="wf1-feasibility error">' +
      '<div class="wf1-feas-icon">âš ï¸</div>' +
      '<div class="wf1-feas-msg">Not enough labels</div>' +
      '<div class="wf1-feas-detail">You need ' + qty + ' label' + (qty !== 1 ? 's' : '') + ' but only have ' + totalAvailable + ' available. ' +
      'You\'ll need about ' + extraSheetsNeeded + ' more sheet' + (extraSheetsNeeded !== 1 ? 's' : '') + ' of ' + wf1LabelType + '.</div>' +
      '<div class="wf1-feas-actions">' +
        '<button class="wf1-inv-btn" onclick="wf1FeasAdjustQty()">Adjust quantity</button>' +
        '<button class="wf1-inv-btn" onclick="wf1FeasAddStock()">Add more stock</button>' +
        '<button class="wf1-inv-btn" onclick="wf1ToStep5()">Continue with what I have</button>' +
      '</div></div>';
  }
  
  content.innerHTML = html;
}

function wf1FeasAdjustQty() {
  // Go back to step 3 to adjust quantity
  wf1Step = 3;
  wf1ShowStep('wf1Step3');
}

function wf1FeasAddStock() {
  // Show inline add within the feasibility step
  const content = document.getElementById('wf1FeasibilityContent');
  content.innerHTML += '<div class="wf1-inv-add-inline" style="display:block; margin-top: 12px;">' +
    '<label for="wf1FeasAddQty">How many sheets of ' + wf1LabelType + ' to add?</label>' +
    '<input type="number" id="wf1FeasAddQty" min="1" max="500" value="10" inputmode="numeric">' +
    '<div class="wf1-inv-add-actions">' +
      '<button class="wf1-inv-btn primary" onclick="wf1FeasSaveStock()">Save</button>' +
      '<button class="wf1-inv-btn" onclick="wf1RenderFeasibility()">Cancel</button>' +
    '</div>' +
  '</div>';
  document.getElementById('wf1FeasAddQty').focus();
}

function wf1FeasSaveStock() {
  const qty = parseInt(document.getElementById('wf1FeasAddQty').value) || 0;
  if (qty <= 0) { showToast('Enter a number of sheets', 'warning'); return; }
  
  const existing = inventory[wf1LabelType];
  const currentStock = (existing && existing.stock) ? existing.stock : 0;
  inventory[wf1LabelType] = {
    stock: currentStock + qty,
    lowThreshold: existing ? existing.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  addInventoryEvent(wf1LabelType, 'add', qty, inventory[wf1LabelType].stock);
  showToast(qty + ' sheets added to inventory', 'success');
  wf1RenderFeasibility();
}

// ---- STEP 5: Sheet Selection ----

function wf1ToStep5() {
  wf1Step = 5;
  wf1SelectedSheet = null;
  wf1RenderSheetPicker();
  wf1ShowStep('wf1Step5');
}

let wf1SelectedSheet = null; // { id, isNew } or { id: '__multi__', plan }
let wf1MultiSheetPlan = null;
let wf1Orientation = 'next'; // 'next' | 'col1' | 'col2' (T3)

// T3: Get position indices in order based on orientation
// orientation: 'next' = sequential (0,1,2,3...), 'col1' = column 1 first, 'col2' = column 2 first
function wf1GetPositionOrder(cols, rows, orientation) {
  const positions = [];
  const lps = cols * rows;
  
  // Check if orientation is a column preference (col1, col2, col3, etc.)
  const colMatch = orientation.match(/^col(\d+)$/);
  if (colMatch) {
    const startCol = parseInt(colMatch[1]) - 1; // Convert to 0-indexed (col1 â†’ 0, col2 â†’ 1, etc.)
    
    // Start from the specified column, then cycle through remaining columns
    for (let offset = 0; offset < cols; offset++) {
      const c = (startCol + offset) % cols;
      for (let r = 0; r < rows; r++) {
        positions.push(r * cols + c);
      }
    }
  } else {
    // 'next' = sequential row-by-row
    for (let i = 0; i < lps; i++) {
      positions.push(i);
    }
  }
  
  return positions;
}

// T3: Find next N available positions respecting orientation
function wf1FindNextPositions(sh, spec, qty, orientation) {
  const lps = spec.cols * spec.rows;
  const printedSet = new Set(sh.printed || []);
  const positionOrder = wf1GetPositionOrder(spec.cols, spec.rows, orientation);
  
  const nextPositions = [];
  for (const idx of positionOrder) {
    if (!printedSet.has(idx)) {
      nextPositions.push(idx);
      if (nextPositions.length >= qty) break;
    }
  }
  return nextPositions;
}

function wf1BuildMultiSheetPlan(matchingSheets, lps, totalQty, hasStock, inv) {
  const steps = [];
  let remaining = totalQty;
  let newSheetsNeeded = 0;
  
  // First, fill existing sheets (sorted by most remaining capacity)
  const sortedSheets = matchingSheets.slice().sort(function(a, b) { return b.remaining - a.remaining; });
  for (const sh of sortedSheets) {
    if (remaining <= 0) break;
    const use = Math.min(sh.remaining, remaining);
    if (use > 0) {
      steps.push({ sheetId: sh.id, sheetName: sh.name, count: use, isNew: false, remaining: sh.remaining });
      remaining -= use;
    }
  }
  
  // Then, create new sheets from stock as needed
  const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
  while (remaining > 0) {
    const use = Math.min(lps, remaining);
    steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
    remaining -= use;
    newSheetsNeeded++;
  }
  
  return { steps: steps, totalLabels: totalQty, newSheetsNeeded: newSheetsNeeded, stockAvail: stockAvail };
}

// Build a compact mini-grid showing used/available/next-print positions for a sheet
function wf1BuildMiniGrid(sh, spec, qty) {
  const lps = spec.cols * spec.rows;
  const printedSet = new Set(sh.printed || []);
  
  // T3: Use orientation-aware position finding
  const nextPositionsList = wf1FindNextPositions(sh, spec, qty, wf1Orientation);
  const nextPositions = new Set(nextPositionsList);
  
  // Only show first physical page for simplicity
  let html = '<div class="wf1-sheet-mini-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 10) + 'px;">';
  for (let i = 0; i < lps; i++) {
    let cls = 'wf1-sheet-mini-cell';
    if (printedSet.has(i)) {
      cls += ' used';
    } else if (nextPositions.has(i)) {
      cls += ' next';
    }
    html += '<div class="' + cls + '"></div>';
  }
  html += '</div>';
  html += '<div class="wf1-sheet-grid-legend">' +
    '<span class="leg-avail">Available</span>' +
    '<span class="leg-used">Used</span>' +
    '<span class="leg-next">Next print</span>' +
  '</div>';
  return html;
}

// Build mini-grid for a new (empty) sheet â€” shows orientation-aware next positions
function wf1BuildMiniGridForNew(spec, qty) {
  const lps = spec.cols * spec.rows;
  // Create a fake empty sheet to reuse position finding logic
  const fakeSheet = { printed: [], sheetCount: 1 };
  const nextPositionsList = wf1FindNextPositions(fakeSheet, spec, qty, wf1Orientation);
  const nextPositions = new Set(nextPositionsList);
  
  let html = '<div class="wf1-sheet-mini-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 10) + 'px;">';
  for (let i = 0; i < lps; i++) {
    let cls = 'wf1-sheet-mini-cell';
    if (nextPositions.has(i)) {
      cls += ' next';
    }
    html += '<div class="' + cls + '"></div>';
  }
  html += '</div>';
  return html;
}

function wf1RenderSheetPicker() {
  const content = document.getElementById('wf1SheetPickerContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const qty = wf1JobType === 'batch' ? (wf1BatchContent.length || wf1Quantity) : wf1Quantity;
  
  // Check if we're in "mixed" mode - picking a sheet for remainder only
  const isMixedMode = wf1MultiSheetPlan && wf1MultiSheetPlan.pendingRemainder > 0;
  const remainderQty = isMixedMode ? wf1MultiSheetPlan.pendingRemainder : qty;
  
  // Find matching non-retired sheets with spots
  const matchingSheets = Object.values(sheets)
    .filter(s => s.labelType === wf1LabelType && !s.retired)
    .map(sh => {
      const remaining = getRemainingCount(sh);
      const isDedicated = sh.texts && Object.keys(sh.texts).length > 0;
      const daysSinceUse = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / 86400000) : null;
      const isStale = daysSinceUse !== null && daysSinceUse > 30;
      return { ...sh, remaining, isDedicated, daysSinceUse, isStale };
    })
    .filter(sh => sh.remaining > 0)
    .sort((a, b) => {
      // Sort: sheets with enough room first, then by most recently used
      const targetQty = isMixedMode ? remainderQty : qty;
      const aFits = a.remaining >= targetQty ? 1 : 0;
      const bFits = b.remaining >= targetQty ? 1 : 0;
      if (aFits !== bFits) return bFits - aFits;
      return (b.lastUsedAt || 0) - (a.lastUsedAt || 0);
    });
  
  const inv = inventory[wf1LabelType];
  const hasStock = inv && inv.stock > 0;
  
  let html = '';
  
  // Show mixed mode header if applicable
  if (isMixedMode) {
    html += '<div class="wf1-mixed-mode-header">';
    html += '<div class="wf1-mixed-mode-icon">ðŸ”€</div>';
    html += '<div class="wf1-mixed-mode-text">';
    html += '<strong>' + wf1MultiSheetPlan.newSheetsNeeded + ' new sheet' + (wf1MultiSheetPlan.newSheetsNeeded !== 1 ? 's' : '') + '</strong> will print ' + (wf1MultiSheetPlan.newSheetsNeeded * lps) + ' labels.';
    html += '<br>Pick an existing sheet for the <strong>remaining ' + remainderQty + '</strong>:';
    html += '</div>';
    html += '</div>';
  }
  
  html += '<div class="wf1-sheet-list">';
  
  // Existing sheets
  for (const sh of matchingSheets) {
    const selected = wf1SelectedSheet && wf1SelectedSheet.id === sh.id;
    let metaStr = '';
    if (sh.isDedicated) {
      metaStr += '<span class="wf1-sheet-badge dedicated">Dedicated</span>';
    } else {
      metaStr += '<span class="wf1-sheet-badge open">Open</span>';
    }
    if (sh.lastUsedAt) {
      metaStr += ' Â· Last used: ' + new Date(sh.lastUsedAt).toLocaleDateString();
    } else {
      metaStr += ' Â· Created: ' + new Date(sh.createdAt || sh.created || Date.now()).toLocaleDateString();
    }
    
    let warningHtml = '';
    if (sh.isStale) {
      warningHtml = '<div class="wf1-sheet-warning">âš ï¸ Not used in ' + sh.daysSinceUse + ' days. Can you confirm you still have it?';
      if (!sh.hasBackLabel) {
        warningHtml += ' <button onclick="event.stopPropagation(); wf1PrintIdLabel(\'' + sh.id + '\')" style="background:none;border:none;color:var(--accent);cursor:pointer;font-size:11px;text-decoration:underline;padding:0;margin-left:4px;">Print ID label</button>';
      }
      warningHtml += '</div>';
    }
    if (sh.remaining < qty) {
      warningHtml += '<div class="wf1-sheet-warning">Only ' + sh.remaining + ' spots â€” you need ' + qty + '. Will need another sheet too.</div>';
    }
    
    html += '<div class="wf1-sheet-card' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'' + sh.id + '\')" ondblclick="wf1SelectSheetAndAdvance(\'' + sh.id + '\')">' +
      '<div class="wf1-sheet-icon">ðŸ“„</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">' + escapeHtml(sh.name) + '</div>' +
        '<div class="wf1-sheet-meta">' + metaStr + '</div>' +
        warningHtml +
        wf1BuildMiniGrid(sh, spec, qty) +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + sh.remaining + '/' + (lps * (sh.sheetCount || 1)) + '</div>' +
    '</div>';
  }
  
  // Create new sheet option
  if (hasStock) {
    const selected = wf1SelectedSheet && wf1SelectedSheet.isNew;
    const emptyGridHtml = wf1BuildMiniGridForNew(spec, qty);
    html += '<div class="wf1-sheet-card create-new' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'__new__\')" ondblclick="wf1SelectSheetAndAdvance(\'__new__\')">' +
      '<div class="wf1-sheet-icon">âž•</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">Create new sheet from stock</div>' +
        '<div class="wf1-sheet-meta">' + inv.stock + ' sheet' + (inv.stock !== 1 ? 's' : '') + ' available in inventory</div>' +
        emptyGridHtml +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + lps + '/' + lps + '</div>' +
    '</div>';
  } else if (matchingSheets.length === 0) {
    // No sheets and no stock
    const selected = wf1SelectedSheet && wf1SelectedSheet.isNew;
    const emptyGridHtml = wf1BuildMiniGridForNew(spec, qty);
    html += '<div class="wf1-sheet-card create-new' + (selected ? ' selected' : '') + '" onclick="wf1SelectSheet(\'__new__\')" ondblclick="wf1SelectSheetAndAdvance(\'__new__\')" style="border-color:var(--warning, #ca8a04);">' +
      '<div class="wf1-sheet-icon">âž•</div>' +
      '<div class="wf1-sheet-info">' +
        '<div class="wf1-sheet-name">Create new sheet</div>' +
        '<div class="wf1-sheet-meta" style="color:var(--warning,#ca8a04);">No stock tracked â€” will create without deducting inventory</div>' +
        emptyGridHtml +
        (selected ? wf1BuildOrientationPicker(spec) : '') +
      '</div>' +
      '<div class="wf1-sheet-spots">' + lps + '/' + lps + '</div>' +
    '</div>';
  }
  
  html += '</div>';
  
  // Multi-sheet spanning plan: if qty exceeds any single sheet's capacity, show a plan
  const bestSingleRemaining = Math.max(0, ...matchingSheets.map(s => s.remaining), hasStock ? lps : 0);
  if (qty > bestSingleRemaining && qty > 0) {
    // Build a multi-sheet plan
    const plan = wf1BuildMultiSheetPlan(matchingSheets, lps, qty, hasStock, inv);
    if (plan.steps.length > 1) {
      wf1MultiSheetPlan = plan;
      html += '<div class="wf1-multisheet-plan">';
      html += '<div class="wf1-multisheet-title">ðŸ“‹ Multi-sheet print plan</div>';
      html += '<div style="font-size:12px;color:var(--text);margin-bottom:8px;">This job needs ' + qty + ' labels across ' + plan.steps.length + ' sheets:</div>';
      html += '<div class="wf1-multisheet-steps">';
      plan.steps.forEach(function(step, i) {
        const label = step.isNew ? 'âž• New sheet from stock' : escapeHtml(step.sheetName);
        html += '<div class="wf1-multisheet-step">' +
          '<div class="step-num">' + (i + 1) + '</div>' +
          '<div class="step-detail">' + label + '</div>' +
          '<div class="step-count">' + step.count + ' labels</div>' +
        '</div>';
      });
      html += '</div>';
      if (plan.newSheetsNeeded > 0) {
        html += '<div class="wf1-multisheet-note">Will use ' + plan.newSheetsNeeded + ' sheet' + (plan.newSheetsNeeded !== 1 ? 's' : '') + ' from inventory. You\'ll print one page at a time.</div>';
      }
      html += '</div>';
      // Auto-select the multi-sheet plan
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: plan };
    }
  }
  
  // "Can't find a sheet?" link for retiring lost sheets (G5)
  if (matchingSheets.length > 0) {
    html += '<div style="text-align:center;margin-top:10px;">' +
      '<button onclick="wf1ShowRetirePrompt()" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:12px;text-decoration:underline;">Can\'t find one of these sheets?</button>' +
    '</div>';
  }
  
  content.innerHTML = html;
  
  // Auto-select if only one option (and not multi-sheet)
  if (!wf1SelectedSheet) {
    if (matchingSheets.length === 1 && !hasStock) {
      wf1SelectSheet(matchingSheets[0].id);
    } else if (matchingSheets.length === 0) {
      wf1SelectSheet('__new__');
    }
  }
  
  document.getElementById('wf1SheetNextBtn').disabled = !wf1SelectedSheet;
}

// T3: Build orientation picker HTML for in-card display (only for multi-column labels)
function wf1BuildOrientationPicker(spec) {
  if (spec.cols < 2) return '';
  
  let html = '<div class="wf1-orientation-section" onclick="event.stopPropagation()">' +
    '<div class="wf1-orientation-label">Print order</div>' +
    '<div class="wf1-orientation-options">' +
      '<div class="wf1-orientation-opt' + (wf1Orientation === 'next' ? ' selected' : '') + '" onclick="event.stopPropagation(); wf1SetOrientation(\'next\')">' +
        '<div class="wf1-orientation-opt-icon">â†’</div>' +
        '<div class="wf1-orientation-opt-text">Row by row</div>' +
      '</div>';
  
  // Add a column option for each column in the label type
  for (let c = 1; c <= spec.cols; c++) {
    const colKey = 'col' + c;
    html += '<div class="wf1-orientation-opt' + (wf1Orientation === colKey ? ' selected' : '') + '" onclick="event.stopPropagation(); wf1SetOrientation(\'' + colKey + '\')">' +
      '<div class="wf1-orientation-opt-icon">â†“' + c + '</div>' +
      '<div class="wf1-orientation-opt-text">Col ' + c + ' first</div>' +
    '</div>';
  }
  
  html += '</div></div>';
  return html;
}

// T3: Set print orientation and re-render to update mini-grids
function wf1SetOrientation(orientation) {
  wf1Orientation = orientation;
  wf1RenderSheetPicker();
}

// G3: Print sheet ID label from the sheet picker
function wf1PrintIdLabel(sheetId) {
  printSheetLabel(sheetId);
  if (sheets[sheetId]) {
    sheets[sheetId].hasBackLabel = true;
    saveSheets();
  }
  showToast('Sheet ID label sent to printer', 'success');
  // Re-render to remove the "Print ID label" link
  wf1RenderSheetPicker();
}

function wf1SelectSheet(idOrNew) {
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec ? spec.cols * spec.rows : 30;
  const qty = wf1JobType === 'batch' ? (wf1BatchContent.length || wf1Quantity) : wf1Quantity;
  
  // Check if we're in mixed mode (picking sheet for remainder only)
  const isMixedMode = wf1MultiSheetPlan && wf1MultiSheetPlan.pendingRemainder > 0;
  
  if (isMixedMode && idOrNew !== '__new__' && idOrNew !== '__multi__') {
    // User picked an existing sheet for the remainder - complete the plan
    const sh = sheets[idOrNew];
    if (!sh) return;
    
    const remainder = wf1MultiSheetPlan.pendingRemainder;
    const sheetRemaining = getRemainingCount(sh);
    
    if (sheetRemaining < remainder) {
      showToast('This sheet only has ' + sheetRemaining + ' spots, need ' + remainder, 'warning');
      return;
    }
    
    // Add this sheet to the plan for the remainder
    wf1MultiSheetPlan.steps.push({
      sheetId: sh.id,
      sheetName: sh.name,
      count: remainder,
      isNew: false,
      remaining: sheetRemaining
    });
    delete wf1MultiSheetPlan.pendingRemainder; // Plan is complete
    
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
    wf1RenderSheetPicker();
    document.getElementById('wf1SheetNextBtn').disabled = false;
    return;
  }
  
  // Clear multi-sheet plan when user explicitly picks a single sheet (not in mixed mode)
  if (idOrNew !== '__multi__' && !isMixedMode) {
    wf1MultiSheetPlan = null;
  }
  
  if (idOrNew === '__new__') {
    // Check if batch needs multiple sheets
    if (wf1JobType === 'batch' && qty > lps) {
      const sheetsNeeded = Math.ceil(qty / lps);
      const inv = inventory[wf1LabelType];
      const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
      
      if (sheetsNeeded > stockAvail) {
        showToast('Not enough sheets in stock. Need ' + sheetsNeeded + ', have ' + stockAvail, 'warning');
        return;
      }
      
      // Build a multi-sheet plan using new sheets
      const steps = [];
      let remaining = qty;
      for (let i = 0; i < sheetsNeeded; i++) {
        const use = Math.min(lps, remaining);
        steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
        remaining -= use;
      }
      wf1MultiSheetPlan = { steps: steps, totalLabels: qty, newSheetsNeeded: sheetsNeeded, stockAvail: stockAvail };
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
      showToast('This job will use ' + sheetsNeeded + ' sheets from stock', 'info');
    } else {
      wf1SelectedSheet = { isNew: true, id: null };
    }
  } else if (idOrNew === '__multi__') {
    // Multi-sheet plan already set
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
  } else {
    // User selected a specific existing sheet
    const sh = sheets[idOrNew];
    const sheetRemaining = sh ? getRemainingCount(sh) : 0;
    
    // Check if batch job exceeds this sheet's capacity
    if (wf1JobType === 'batch' && qty > sheetRemaining) {
      // Build a multi-sheet plan starting with their selected sheet
      const matchingSheets = Object.values(sheets)
        .filter(function(s) { return s.labelType === wf1LabelType && !s.retired && s.id !== idOrNew; })
        .map(function(s) { return { id: s.id, name: s.name, remaining: getRemainingCount(s) }; })
        .filter(function(s) { return s.remaining > 0; });
      
      const inv = inventory[wf1LabelType];
      const hasStock = inv && inv.stock > 0;
      
      // Start plan with selected sheet
      const steps = [];
      let remaining = qty;
      
      if (sheetRemaining > 0) {
        steps.push({ sheetId: idOrNew, sheetName: sh.name, count: Math.min(sheetRemaining, remaining), isNew: false, remaining: sheetRemaining });
        remaining -= sheetRemaining;
      }
      
      // Add other existing sheets
      const sortedSheets = matchingSheets.slice().sort(function(a, b) { return b.remaining - a.remaining; });
      for (const other of sortedSheets) {
        if (remaining <= 0) break;
        const use = Math.min(other.remaining, remaining);
        if (use > 0) {
          steps.push({ sheetId: other.id, sheetName: other.name, count: use, isNew: false, remaining: other.remaining });
          remaining -= use;
        }
      }
      
      // Add new sheets from stock as needed
      let newSheetsNeeded = 0;
      while (remaining > 0) {
        const use = Math.min(lps, remaining);
        steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
        remaining -= use;
        newSheetsNeeded++;
      }
      
      // Check if we have enough stock
      const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
      if (newSheetsNeeded > stockAvail) {
        showToast('Not enough labels. Need ' + newSheetsNeeded + ' more sheet(s), have ' + stockAvail + ' in stock.', 'warning');
        return;
      }
      
      wf1MultiSheetPlan = { steps: steps, totalLabels: qty, newSheetsNeeded: newSheetsNeeded, stockAvail: stockAvail };
      wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
      showToast('Job spans ' + steps.length + ' sheet(s), starting with "' + sh.name + '"', 'info');
    } else {
      wf1SelectedSheet = { isNew: false, id: idOrNew };
    }
  }
  
  // Re-render to show orientation picker in selected card
  wf1RenderSheetPicker();
  
  document.getElementById('wf1SheetNextBtn').disabled = !wf1SelectedSheet;
}

// T1: Double-click to select sheet and advance
function wf1SelectSheetAndAdvance(idOrNew) {
  wf1SelectSheet(idOrNew);
  setTimeout(() => wf1ToStep6(), 100);
}

// G5: "Can't find this sheet?" â€” retire directly from workflow
async function wf1ShowRetirePrompt() {
  const matchingSheets = Object.values(sheets)
    .filter(function(s) { return s.labelType === wf1LabelType && !s.retired && getRemainingCount(s) > 0; });
  
  if (matchingSheets.length === 0) return;
  
  let pickHtml = '<p style="margin-bottom:12px;">Select the sheet you can\'t find. It will be retired (hidden from print workflows) but not deleted â€” you can restore it later from the Sheets tab.</p>';
  matchingSheets.forEach(function(sh) {
    pickHtml += '<button onclick="wf1RetireFromPicker(\'' + sh.id + '\')" style="display:block;width:100%;text-align:left;padding:10px 12px;margin-bottom:6px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-sm);cursor:pointer;color:var(--text);font-size:13px;">' +
      '<strong>' + escapeHtml(sh.name) + '</strong> â€” ' + getRemainingCount(sh) + ' spots remaining' +
    '</button>';
  });
  
  showGenericModal('Can\'t Find a Sheet?', pickHtml, 'retireFromWfModal');
}

function wf1RetireFromPicker(id) {
  closeGenericModal('retireFromWfModal');
  retireSheet(id);
  // Re-render the sheet picker with updated list
  wf1RenderSheetPicker();
}

// ---- STEP 6: Content Creation ----

function wf1ToStep6() {
  if (!wf1SelectedSheet) return;
  
  wf1Step = 6;
  wf1RenderContentStep();
  wf1ShowStep('wf1Step6');
  
  // Check if AI conversational layer has pending content to fill
  setTimeout(function() { aiConvFillContentIfPending(); }, 150);
}

// WF1 batch state
let wf1BatchCsvData = [];
let wf1BatchCsvColumns = [];
let wf1BatchSelectedTemplate = null;
let wf1BatchColumnMap = {};
let wf1BatchSubStep = 'upload'; // 'upload' | 'template' | 'map' | 'preview'

function wf1RenderContentStep() {
  const area = document.getElementById('wf1ContentArea');
  const actions = document.getElementById('wf1Step6Actions');
  
  if (wf1JobType === 'individual') {
    wf1RenderIndividualEditor(area);
    actions.style.display = 'flex';
  } else {
    // Batch â€” CSV is already loaded from Step 3B, go straight to template selection
    if (wf1BatchCsvData.length > 0) {
      wf1BatchSubStep = 'template';
      wf1RenderBatchTemplateStep();
    } else {
      // Fallback: if somehow we got here without data, show upload
      wf1BatchSubStep = 'upload';
      wf1RenderBatchUpload(area);
    }
    actions.style.display = 'flex';
    document.getElementById('wf1ContentNextBtn').disabled = true;
  }
}

function wf1RenderIndividualEditor(area) {
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'What should the labels say?';
  
  let html = '<div class="wf1-editor-wrapper">';
  
  // Tool buttons
  html += '<div class="wf1-editor-tools">';
  if (typeof openAIGenerate === 'function' && localStorage.getItem('lk_ai_key')) {
    html += '<button class="wf1-editor-tool-btn" onclick="wf1UseAI()">âœ¨ Ask AI</button>';
  }
  html += '<button class="wf1-editor-tool-btn" onclick="wf1UseSaved()">ðŸ“‚ Use Saved</button>';
  html += '<button class="wf1-editor-tool-btn" onclick="wf1UseFullEditor()">ðŸŽ¨ Full Editor</button>';
  html += '<button class="wf1-editor-tool-btn" onclick="openOcrModal()">ðŸ“· Scan</button>';
  html += '</div>';
  
  // Style template dropdown
  html += '<div class="wf1-style-row">';
  html += '<label>ðŸŽ¨ Style</label>';
  html += '<select class="wf1-style-select" id="wf1StyleSelect" onchange="wf1ApplyStyleTemplate(this.value)">';
  html += wf1GetStyleDropdownOptions();
  html += '</select>';
  html += '</div>';
  
  // 4-line editor
  html += '<div class="editor-lines">';
  for (let i = 1; i <= 4; i++) {
    const placeholder = i === 1 ? 'Line 1' : 'Line ' + i + ' (optional)';
    html += '<div class="editor-line">' +
      '<input type="text" class="editor-line-input" id="wf1Line' + i + '" placeholder="' + placeholder + '" maxlength="100" oninput="wf1UpdateEditorPreview()" onpaste="setTimeout(wf1UpdateEditorPreview,0)">' +
      '<div class="editor-controls">' +
        '<button class="editor-align-btn active" data-wf1line="' + i + '" data-align="left" onclick="wf1SetAlign(' + i + ',\'left\')" title="Left">â—€</button>' +
        '<button class="editor-align-btn" data-wf1line="' + i + '" data-align="center" onclick="wf1SetAlign(' + i + ',\'center\')" title="Center">â—†</button>' +
        '<button class="editor-align-btn" data-wf1line="' + i + '" data-align="right" onclick="wf1SetAlign(' + i + ',\'right\')" title="Right">â–¶</button>' +
        '<button class="editor-size-btn size-s" data-wf1line="' + i + '" data-size="9" onclick="wf1SetSize(' + i + ',9)" title="Small">A</button>' +
        '<button class="editor-size-btn size-m active" data-wf1line="' + i + '" data-size="11" onclick="wf1SetSize(' + i + ',11)" title="Medium">A</button>' +
        '<button class="editor-size-btn size-l" data-wf1line="' + i + '" data-size="14" onclick="wf1SetSize(' + i + ',14)" title="Large">A</button>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  
  // Preview
  html += '<div class="editor-preview-section">' +
    '<div class="editor-preview-label">Preview</div>' +
    '<div class="editor-preview-frame">' +
      '<div class="editor-preview-label-box" id="wf1PreviewBox">' +
        '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>' +
      '</div>' +
    '</div>' +
  '</div>';
  
  html += '</div>';
  area.innerHTML = html;
  
  // If we already have content lines (from AI, saved, full editor), populate them
  if (wf1ContentLines.length > 0) {
    wf1PopulateEditorFromLines(wf1ContentLines);
  }
  
  // Restore style template selection if we have one
  if (wf1StyleTemplateId) {
    const styleSelect = document.getElementById('wf1StyleSelect');
    if (styleSelect) styleSelect.value = wf1StyleTemplateId;
  }
  
  // Set up paste listeners on the WF1 editor inputs
  setTimeout(function() {
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('wf1Line' + i);
      if (input) {
        input.addEventListener('paste', function(e) {
          setTimeout(function() { wf1HandlePaste(); }, 50);
        });
      }
    }
  }, 100);
  
  wf1UpdateContentNextBtn();
}

// WF1 editor alignment/size state
let wf1LineAligns = ['left', 'left', 'left', 'left'];
let wf1LineSizes = [11, 11, 11, 11];

function wf1SetAlign(lineNum, align) {
  wf1LineAligns[lineNum - 1] = align;
  // Update button states
  document.querySelectorAll('.editor-align-btn[data-wf1line="' + lineNum + '"]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  wf1UpdateEditorPreview();
}

function wf1SetSize(lineNum, size) {
  wf1LineSizes[lineNum - 1] = size;
  document.querySelectorAll('.editor-size-btn[data-wf1line="' + lineNum + '"]').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
  });
  wf1UpdateEditorPreview();
}

// Generate style dropdown options for WF1 editor
function wf1GetStyleDropdownOptions() {
  const labelType = wf1LabelType || '5160';
  const allTemplates = getAllStyleTemplates();
  
  let html = '<option value="">â€” Plain text (no style) â€”</option>';
  
  // Add "Matching" group (same label type)
  const matching = allTemplates.filter(t => t.labelType === labelType);
  if (matching.length > 0) {
    html += '<optgroup label="âœ“ Designed for ' + labelType + '">';
    for (const tpl of matching) {
      const catLabel = STYLE_TEMPLATE_CATEGORIES[tpl.category]?.label || tpl.category;
      html += '<option value="' + tpl.id + '">' + tpl.name + ' (' + catLabel.replace(/^[^ ]+ /, '') + ')</option>';
    }
    html += '</optgroup>';
  }
  
  // Add category groups for other label types
  const byCategory = {};
  for (const cat of Object.keys(STYLE_TEMPLATE_CATEGORIES)) {
    byCategory[cat] = [];
  }
  byCategory['other'] = [];
  
  for (const tpl of allTemplates) {
    if (tpl.labelType === labelType) continue; // Already shown in matching
    const cat = tpl.category || 'other';
    if (byCategory[cat]) {
      byCategory[cat].push(tpl);
    } else {
      byCategory['other'].push(tpl);
    }
  }
  
  for (const [catId, catInfo] of Object.entries(STYLE_TEMPLATE_CATEGORIES)) {
    const templates = byCategory[catId];
    if (templates && templates.length > 0) {
      html += '<optgroup label="' + catInfo.label + '">';
      for (const tpl of templates) {
        html += '<option value="' + tpl.id + '">' + tpl.name + ' (' + tpl.labelType + ')</option>';
      }
      html += '</optgroup>';
    }
  }
  
  // User templates
  const userTemplates = (byCategory['other'] || []).filter(t => !t.builtin);
  if (userTemplates.length > 0) {
    html += '<optgroup label="ðŸ“ My Style Templates">';
    for (const tpl of userTemplates) {
      html += '<option value="' + tpl.id + '">' + tpl.name + '</option>';
    }
    html += '</optgroup>';
  }
  
  return html;
}

// Apply a style template in WF1 wizard editor
function wf1ApplyStyleTemplate(templateId) {
  wf1StyleTemplateId = templateId || null;
  
  if (!templateId) {
    // Clearing style â€” reset to defaults but keep text
    wf1FeSnapshot = null;
    wf1LineAligns = ['left', 'left', 'left', 'left'];
    wf1LineSizes = [11, 11, 11, 11];
    
    // Update button states
    for (let i = 1; i <= 4; i++) {
      document.querySelectorAll('.editor-align-btn[data-wf1line="' + i + '"]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.align === 'left');
      });
      document.querySelectorAll('.editor-size-btn[data-wf1line="' + i + '"]').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.size) === 11);
      });
    }
    
    wf1UpdateEditorPreview();
    return;
  }
  
  const template = getStyleTemplate(templateId);
  if (!template) {
    showToast('Style template not found', 'error');
    return;
  }
  
  // Create wf1FeSnapshot from style template (this carries through to print)
  const lines = [];
  for (let i = 0; i < 4; i++) {
    const style = template.lineStyles ? template.lineStyles[Math.min(i, template.lineStyles.length - 1)] : null;
    const input = document.getElementById('wf1Line' + (i + 1));
    const text = input ? input.value : '';
    
    lines.push({
      text: text,
      fontFamily: style?.fontFamily || 'default',
      fontSize: style?.fontSize || 11,
      align: style?.align || 'left',
      bold: style?.bold || false,
      italic: style?.italic || false,
      underline: style?.underline || false,
      strikethrough: style?.strikethrough || false,
      color: style?.color || '',
      fillColor: style?.fillColor || '',
      borders: ''
    });
  }
  
  // Build graphics from template
  let graphics = { left: null, right: null };
  if (template.graphics) {
    if (template.graphics.left && template.graphics.left.type === 'builtin') {
      const g = FE_GRAPHICS_LIBRARY.find(gr => gr.id === template.graphics.left.id);
      if (g) {
        graphics.left = { data: 'data:image/svg+xml;base64,' + btoa(g.svg), size: 'M' };
      }
    } else if (template.graphics.left) {
      graphics.left = template.graphics.left;
    }
    
    if (template.graphics.right && template.graphics.right.type === 'builtin') {
      const g = FE_GRAPHICS_LIBRARY.find(gr => gr.id === template.graphics.right.id);
      if (g) {
        graphics.right = { data: 'data:image/svg+xml;base64,' + btoa(g.svg), size: 'M' };
      }
    } else if (template.graphics.right) {
      graphics.right = template.graphics.right;
    }
  }
  
  // Create snapshot that will be used at print time
  wf1FeSnapshot = {
    lines: lines,
    graphics: graphics,
    alignV: template.alignV || 'center',
    border: template.border || { top: false, bottom: false, left: false, right: false, color: '#000000' }
  };
  
  // Update WF1 simple editor to reflect style (align/size from template)
  for (let i = 0; i < 4; i++) {
    const style = template.lineStyles ? template.lineStyles[Math.min(i, template.lineStyles.length - 1)] : null;
    if (style) {
      wf1LineAligns[i] = style.align || 'left';
      wf1LineSizes[i] = style.fontSize || 11;
      
      // Update button states
      document.querySelectorAll('.editor-align-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.align === wf1LineAligns[i]);
      });
      document.querySelectorAll('.editor-size-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.size) === wf1LineSizes[i]);
      });
    }
  }
  
  wf1UpdateEditorPreview();
  showToast('Applied "' + template.name + '" style', 'success');
}

function wf1UpdateEditorPreview() {
  const box = document.getElementById('wf1PreviewBox');
  if (!box) return;
  
  // Check for graphics and barcode from snapshot
  const hasLeftGfx = wf1FeSnapshot && wf1FeSnapshot.graphics && wf1FeSnapshot.graphics.left;
  const hasRightGfx = wf1FeSnapshot && wf1FeSnapshot.graphics && wf1FeSnapshot.graphics.right;
  const hasBarcode = wf1FeSnapshot && wf1FeSnapshot.barcode && wf1FeSnapshot.barcode.enabled;
  const barcodePosition = hasBarcode ? wf1FeSnapshot.barcode.position : null;
  const barcodeOnly = barcodePosition === 'only';
  
  // Determine if we have left/right side content (graphics or QR)
  const hasLeftContent = hasLeftGfx || barcodePosition === 'left';
  const hasRightContent = hasRightGfx || barcodePosition === 'right';
  const hasSideContent = hasLeftContent || hasRightContent;
  
  // Build line objects for canonical renderer
  let hasContent = false;
  const lineObjects = [];
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wf1Line' + i);
    if (!input) continue;
    const text = input.value.trim();
    if (!text) continue;
    hasContent = true;
    
    const align = wf1LineAligns[i - 1];
    const size = wf1LineSizes[i - 1];
    
    // Get style from snapshot if available (from style template or Full Editor)
    const snap = wf1FeSnapshot && wf1FeSnapshot.lines[i - 1];
    
    // Build line object for canonical renderer
    const lineObj = {
      text: text,
      align: align,
      fontSize: size
    };
    
    if (snap) {
      if (snap.fontFamily) lineObj.fontFamily = snap.fontFamily;
      if (snap.color) lineObj.color = snap.color;
      if (snap.bold) lineObj.bold = snap.bold;
      if (snap.italic) lineObj.italic = snap.italic;
      if (snap.underline) lineObj.underline = snap.underline;
    }
    
    lineObjects.push(lineObj);
  }
  
  // Use canonical renderer for lines
  const linesHtml = renderLabelPreviewHtml(lineObjects);
  
  // Generate QR code if enabled
  let qrDataUrl = null;
  if (hasBarcode && wf1FeSnapshot.barcode.type === 'qr') {
    qrDataUrl = wf1GeneratePreviewQR();
  }
  
  let html = '';
  
  // QR Only mode - just show the QR code centered
  if (barcodeOnly && qrDataUrl) {
    html = '<div style="display:flex;justify-content:center;align-items:center;width:100%;height:100%;min-height:60px;"><img src="' + qrDataUrl + '" style="width:50px;height:50px;"></div>';
    box.innerHTML = html;
    wf1UpdateContentNextBtn();
    return;
  }
  
  if (!hasContent && !hasSideContent) {
    html = '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>';
  } else if (hasSideContent) {
    // Build layout with graphics/QR on sides
    html = '<div style="display:flex;align-items:center;width:100%;gap:6px;">';
    
    // Left side
    if (barcodePosition === 'left' && qrDataUrl) {
      html += '<div style="flex-shrink:0;"><img src="' + qrDataUrl + '" style="width:40px;height:40px;"></div>';
    } else if (hasLeftGfx) {
      const gfx = wf1FeSnapshot.graphics.left;
      const size = gfx.size === 'S' ? 24 : gfx.size === 'L' ? 48 : 36;
      html += '<div style="flex-shrink:0;"><img src="' + gfx.data + '" style="width:' + size + 'px;height:' + size + 'px;object-fit:contain;"></div>';
    }
    
    // Text zone
    html += '<div style="flex:1;min-width:0;">' + linesHtml + '</div>';
    
    // Right side
    if (barcodePosition === 'right' && qrDataUrl) {
      html += '<div style="flex-shrink:0;"><img src="' + qrDataUrl + '" style="width:40px;height:40px;"></div>';
    } else if (hasRightGfx) {
      const gfx = wf1FeSnapshot.graphics.right;
      const size = gfx.size === 'S' ? 24 : gfx.size === 'L' ? 48 : 36;
      html += '<div style="flex-shrink:0;"><img src="' + gfx.data + '" style="width:' + size + 'px;height:' + size + 'px;object-fit:contain;"></div>';
    }
    
    html += '</div>';
  } else {
    html = linesHtml || '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>';
  }
  
  // Show rich formatting badge for styles that aren't visually shown in preview (borders, etc.)
  if (hasContent && wf1FeSnapshot) {
    const hasBorder = wf1FeSnapshot.border && (wf1FeSnapshot.border.top || wf1FeSnapshot.border.bottom || wf1FeSnapshot.border.left || wf1FeSnapshot.border.right);
    
    if (hasBorder) {
      html += '<div class="wf1-rich-badge">ðŸŽ¨ Border styling will be applied when printed</div>';
    }
  }
  
  box.innerHTML = html;
  
  wf1UpdateContentNextBtn();
}

// Generate QR code for WF1 wizard preview (similar to Full Editor's generatePreviewQR)
function wf1GeneratePreviewQR() {
  if (!wf1FeSnapshot || !wf1FeSnapshot.barcode || !wf1FeSnapshot.barcode.enabled || wf1FeSnapshot.barcode.type !== 'qr') {
    return null;
  }
  
  // Get text from wizard inputs
  const textLines = [];
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wf1Line' + i);
    if (input && input.value.trim()) {
      textLines.push(input.value.trim());
    }
  }
  if (textLines.length === 0) return null;
  
  let textToEncode = textLines.join('\n');
  
  // Handle encode type
  if (wf1FeSnapshot.barcode.encodeType === 'vcard') {
    textToEncode = generateVCard(textLines);
  } else if (wf1FeSnapshot.barcode.encodeType === 'url' && !textToEncode.startsWith('http')) {
    textToEncode = 'https://' + textToEncode;
  }
  
  try {
    return QRCode.toDataURL(textToEncode, { size: 100, margin: 1 });
  } catch (e) {
    console.error('WF1 QR preview generation failed:', e);
    return null;
  }
}

function wf1GetEditorLines() {
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wf1Line' + i);
    if (!input) continue;
    const text = input.value;
    if (text.trim()) {
      // If we have a Full Editor snapshot (or style template), use its styles
      // Style templates keep the snapshot even if text is edited
      const snap = wf1FeSnapshot && wf1FeSnapshot.lines[i - 1];
      if (snap) {
        lines.push({
          text: text,
          align: wf1LineAligns[i - 1],
          fontSize: wf1LineSizes[i - 1],
          fontFamily: snap.fontFamily || 'default',
          bold: snap.bold || false,
          italic: snap.italic || false,
          underline: snap.underline || false,
          strikethrough: snap.strikethrough || false,
          color: snap.color || '',
          fillColor: snap.fillColor || '',
          borders: snap.borders || ''
        });
      } else {
        lines.push({
          text: text,
          align: wf1LineAligns[i - 1],
          fontSize: wf1LineSizes[i - 1],
          fontFamily: 'default',
          bold: false, italic: false, underline: false, strikethrough: false,
          color: '', fillColor: '', borders: ''
        });
      }
    }
  }
  return lines;
}

function wf1PopulateEditorFromLines(lines) {
  // Reset aligns/sizes
  wf1LineAligns = ['left', 'left', 'left', 'left'];
  wf1LineSizes = [11, 11, 11, 11];
  
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('wf1Line' + (i + 1));
    if (!input) continue;
    if (i < lines.length) {
      input.value = lines[i].text || '';
      wf1LineAligns[i] = lines[i].align || 'left';
      wf1LineSizes[i] = lines[i].fontSize || 11;
    } else {
      input.value = '';
    }
    
    // Update button states
    document.querySelectorAll('.editor-align-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === wf1LineAligns[i]);
    });
    document.querySelectorAll('.editor-size-btn[data-wf1line="' + (i + 1) + '"]').forEach(btn => {
      btn.classList.toggle('active', parseInt(btn.dataset.size) === wf1LineSizes[i]);
    });
  }
  wf1UpdateEditorPreview();
}

function wf1HandlePaste() {
  // Check if pasted content is LabelKeeper format
  const line1 = document.getElementById('wf1Line1');
  if (!line1) return;
  const text = line1.value;
  const parsed = parseLabelKeeperFormat(text);
  if (parsed && parsed.lines) {
    wf1ContentLines = parsed.lines;
    if (parsed.qty) wf1Quantity = parsed.qty;
    if (parsed.type) wf1LabelType = parsed.type;
    wf1PopulateEditorFromLines(wf1ContentLines);
    showToast('LabelKeeper content pasted!', 'success');
  }
}

function wf1UpdateContentNextBtn() {
  const btn = document.getElementById('wf1ContentNextBtn');
  if (!btn) return;
  
  if (wf1JobType === 'individual') {
    const lines = wf1GetEditorLines();
    btn.disabled = lines.length === 0;
  } else {
    btn.disabled = wf1BatchContent.length === 0;
  }
}

// Tool buttons for individual editor
function wf1UseAI() {
  // Use the existing AI generate flow â€” it populates wizLine1-4
  // We need to bridge: AI writes to wizLine1-4, we read from wf1Line1-4
  // Simplest: temporarily wire AI to write to wf1Line inputs
  wf1_aiActive = true;
  openAIGenerate();
}

let wf1_aiActive = false;

function wf1UseSaved() {
  // Show a quick picker modal of saved texts
  const savedList = savedTexts.filter(t => t.type !== 'template');
  if (savedList.length === 0) {
    showToast('No saved content yet', 'info');
    return;
  }
  
  let html = '<div style="max-height:300px; overflow-y:auto;">';
  for (const t of savedList) {
    const lines = deserializeLines(t.text);
    const preview = lines.map(l => l.text).join(' Â· ');
    html += '<div class="wf1-batch-template-item" onclick="wf1LoadSaved(\'' + t.id + '\'); closeGenericModal(\'wf1UseSavedModal\');">' +
      '<div class="wf1-batch-template-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="wf1-batch-template-preview">' + escapeHtml(preview.substring(0, 60)) + '</div>' +
    '</div>';
  }
  html += '</div>';
  
  showGenericModal('ðŸ“‚ Choose Saved Content', html, 'wf1UseSavedModal');
}

function wf1LoadSaved(textId) {
  const t = savedTexts.find(s => s.id === textId);
  if (!t) return;
  wf1ContentLines = deserializeLines(t.text);
  wf1SelectedSavedTextId = textId;
  wf1PopulateEditorFromLines(wf1ContentLines);
  // Close the confirm dialog if open
  const modal = document.getElementById('confirmModal');
  if (modal) modal.style.display = 'none';
  showToast('Loaded: ' + t.name, 'success');
}

let wf1SelectedSavedTextId = null;

function wf1UseFullEditor() {
  // Populate the classic wizard inputs first so Full Editor can read them
  for (let i = 1; i <= 4; i++) {
    const wf1Input = document.getElementById('wf1Line' + i);
    const wizInput = document.getElementById('wizLine' + i);
    if (wf1Input && wizInput) {
      wizInput.value = wf1Input.value;
    }
  }
  
  // Flag that we're coming from WF1
  wf1_fullEditorActive = true;
  openFullEditorFromWizard();
}

let wf1_fullEditorActive = false;

// ---- BATCH PATH (Step 6) ----

function wf1RenderBatchUpload(area) {
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Import your list';
  
  let html = '<div class="wf1-batch-section">' +
    '<div class="wf1-batch-upload" onclick="document.getElementById(\'wf1BatchFileInput\').click()">' +
      '<div class="wf1-batch-upload-icon">ðŸ“</div>' +
      '<div class="wf1-batch-upload-text">Click to upload a CSV or TSV file</div>' +
    '</div>' +
  '</div>';
  
  // Also offer paste
  html += '<div style="text-align:center; font-size:12px; color:var(--text-muted); margin: 8px 0;">â€” or â€”</div>';
  html += '<div class="wf1-batch-section">' +
    '<textarea id="wf1BatchPasteArea" placeholder="Paste your data here (tab-separated or comma-separated)" ' +
    'style="width:100%; min-height:80px; padding:10px; border:2px solid var(--border); border-radius:var(--radius-sm); font-family:inherit; font-size:13px; resize:vertical; background:var(--surface); color:var(--text); box-sizing:border-box;" ' +
    'onchange="wf1HandleBatchPaste()"></textarea>' +
    '<button class="wf1-inv-btn" style="margin-top:8px;" onclick="wf1HandleBatchPaste()">Parse pasted data</button>' +
  '</div>';
  
  if (area) area.innerHTML = html;
}

function wf1HandleBatchFile(fileOrInput) {
  // Accept either a File object or an input element
  const file = fileOrInput instanceof File ? fileOrInput : (fileOrInput.files ? fileOrInput.files[0] : null);
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    wf1ParseBatchData(e.target.result, file.name);
  };
  reader.readAsText(file);
}

function wf1HandleBatchPaste() {
  const textarea = document.getElementById('wf1BatchPasteArea');
  if (!textarea) return;
  const text = textarea.value.trim();
  if (!text) { showToast('Nothing to parse', 'warning'); return; }
  wf1ParseBatchData(text, 'pasted data');
}

// Parse a single CSV/TSV line with support for quoted fields
function parseCSVLine(line, delimiter) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (ch === delimiter && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += ch;
    }
  }
  result.push(current);
  return result;
}

function wf1ParseBatchData(text, sourceName) {
  // Detect delimiter
  const firstLine = text.split('\n')[0];
  const tabCount = (firstLine.match(/\t/g) || []).length;
  const commaCount = (firstLine.match(/,/g) || []).length;
  const delimiter = tabCount > commaCount ? '\t' : ',';
  
  const lines = text.trim().split('\n').filter(l => l.trim());
  if (lines.length < 2) {
    showToast('Need at least a header row and one data row', 'warning');
    return;
  }
  
  // Parse header
  const header = parseCSVLine(lines[0], delimiter);
  wf1BatchCsvColumns = header.map(h => h.trim());
  
  // Parse data rows
  wf1BatchCsvData = [];
  for (let i = 1; i < lines.length; i++) {
    const vals = parseCSVLine(lines[i], delimiter);
    const record = {};
    for (let c = 0; c < wf1BatchCsvColumns.length; c++) {
      record[wf1BatchCsvColumns[c]] = (vals[c] || '').trim();
    }
    wf1BatchCsvData.push(record);
  }
  
  showToast('Parsed ' + wf1BatchCsvData.length + ' rows from ' + sourceName, 'success');
  wf1Quantity = wf1BatchCsvData.length;
  
  // If we're in Step 3B (early batch flow), show success and proceed button
  if (wf1BatchSubStep === 'upload') {
    wf1ShowBatchLoadedSuccess();
  } else {
    // Old flow (if called from step 6) - go to template
    wf1BatchSubStep = 'template';
    wf1RenderBatchTemplateStep();
  }
}

// Show success message after CSV loaded in Step 3B
function wf1ShowBatchLoadedSuccess() {
  const contentArea = document.getElementById('wf1Step3Content');
  if (!contentArea) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const totalNeeded = wf1BatchCsvData.length;
  const fullSheetsNeeded = Math.floor(totalNeeded / lps);
  const remainder = totalNeeded % lps;
  const totalSheetsNeeded = remainder > 0 ? fullSheetsNeeded + 1 : fullSheetsNeeded;
  const leftoverOnLastSheet = remainder > 0 ? lps - remainder : 0;
  
  // Check inventory
  const inv = inventory[wf1LabelType];
  const stockAvail = (inv && inv.stock > 0) ? inv.stock : 0;
  
  // Check existing sheets with space - EXCLUDE dedicated sheets by default
  const allSheets = Object.values(sheets)
    .filter(s => s.labelType === wf1LabelType && !s.retired)
    .map(s => ({ 
      id: s.id, 
      name: s.name, 
      remaining: getRemainingCount(s),
      isDedicated: s.texts && Object.keys(s.texts).length > 0
    }))
    .filter(s => s.remaining > 0)
    .sort((a, b) => b.remaining - a.remaining);
  
  // Separate open vs dedicated sheets
  const openSheets = allSheets.filter(s => !s.isDedicated);
  const dedicatedSheets = allSheets.filter(s => s.isDedicated);
  
  // Use open sheets by default (checkbox can include dedicated)
  const includeDedicated = document.getElementById('wf1IncludeDedicatedCheck')?.checked || false;
  const existingSheets = includeDedicated ? allSheets : openSheets;
  
  const spotsOnExisting = existingSheets.reduce((sum, s) => sum + s.remaining, 0);
  const spotsOnDedicated = dedicatedSheets.reduce((sum, s) => sum + s.remaining, 0);
  const totalAvailable = (stockAvail * lps) + spotsOnExisting;
  
  // Find best single sheet (if one can fit the entire job)
  const singleSheetFit = existingSheets.find(s => s.remaining >= totalNeeded);
  
  // Update question
  const question = document.getElementById('wf1Step3Question');
  question.textContent = 'Plan your print job';
  
  let html = '<div class="wf1-batch-planning">';
  
  // Summary
  html += '<div class="wf1-plan-summary">';
  html += '<div class="wf1-plan-count">' + totalNeeded + ' labels</div>';
  html += '<div class="wf1-plan-detail">Columns: ' + wf1BatchCsvColumns.join(', ') + '</div>';
  html += '</div>';
  
  // Show dedicated sheets checkbox if there are any
  if (dedicatedSheets.length > 0) {
    html += '<div class="wf1-dedicated-toggle">';
    html += '<label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;">';
    html += '<input type="checkbox" id="wf1IncludeDedicatedCheck" onchange="wf1ShowBatchLoadedSuccess()"' + (includeDedicated ? ' checked' : '') + '>';
    html += '<span>Include dedicated sheets (' + spotsOnDedicated + ' spots on ' + dedicatedSheets.length + ' sheet' + (dedicatedSheets.length !== 1 ? 's' : '') + ')</span>';
    html += '</label>';
    html += '</div>';
  }
  
  // Check if we can handle it at all
  const maxAvailable = (stockAvail * lps) + allSheets.reduce((sum, s) => sum + s.remaining, 0);
  if (maxAvailable < totalNeeded) {
    html += '<div class="wf1-plan-warning">';
    html += '<div class="wf1-feas-icon">âš ï¸</div>';
    html += '<div class="wf1-feas-msg">Not enough labels!</div>';
    html += '<div class="wf1-feas-detail">You need ' + totalNeeded + ' but only have ' + maxAvailable + ' available.</div>';
    html += '<button class="wf1-inv-btn" onclick="wf1ToStep3B()" style="margin-top:12px;">Load different file</button>';
    html += '</div>';
    contentArea.innerHTML = html + '</div>';
    return;
  }
  
  // Show planning options
  html += '<div class="wf1-plan-options">';
  
  // OPTION 1: All new sheets from stock (simplest - no choices needed)
  if (stockAvail >= totalSheetsNeeded) {
    const isOnlyOption = existingSheets.length === 0;
    html += '<div class="wf1-plan-option' + (isOnlyOption ? ' recommended' : '') + '" onclick="wf1SelectPlanOption(\'allnew\')">';
    html += '<div class="wf1-plan-option-icon">' + (isOnlyOption ? 'â­' : 'ðŸ“¦') + '</div>';
    html += '<div class="wf1-plan-option-content">';
    html += '<div class="wf1-plan-option-title">Use ' + totalSheetsNeeded + ' new sheet' + (totalSheetsNeeded !== 1 ? 's' : '') + ' from stock</div>';
    html += '<div class="wf1-plan-option-desc">';
    if (leftoverOnLastSheet > 0) {
      html += 'Last sheet will have ' + leftoverOnLastSheet + ' unused spot' + (leftoverOnLastSheet !== 1 ? 's' : '');
    } else {
      html += 'Sheets will be completely filled';
    }
    html += '</div></div></div>';
  }
  
  // OPTION 2: New sheets for full pages + pick existing sheet for remainder
  // Only show if: we have existing sheets AND job needs more than 1 sheet AND we have stock for full sheets
  if (existingSheets.length > 0 && fullSheetsNeeded > 0 && stockAvail >= fullSheetsNeeded && remainder > 0) {
    // Find existing sheets that can fit the remainder
    const fittingSheets = existingSheets.filter(s => s.remaining >= remainder);
    
    if (fittingSheets.length > 0) {
      html += '<div class="wf1-plan-option recommended" onclick="wf1SelectPlanOption(\'newPlusExisting\')">';
      html += '<div class="wf1-plan-option-icon">â­</div>';
      html += '<div class="wf1-plan-option-content">';
      html += '<div class="wf1-plan-option-title">' + fullSheetsNeeded + ' new + pick existing for last ' + remainder + '</div>';
      html += '<div class="wf1-plan-option-desc">' + fittingSheets.length + ' of your sheets can fit the remaining ' + remainder + ' label' + (remainder !== 1 ? 's' : '') + '</div>';
      html += '</div></div>';
    }
  }
  
  // OPTION 3: Use existing sheets only (if they have enough capacity)
  if (existingSheets.length > 0 && spotsOnExisting >= totalNeeded) {
    // Check if single sheet can handle it vs needing multiple
    const singleFit = existingSheets.find(s => s.remaining >= totalNeeded);
    
    html += '<div class="wf1-plan-option recommended" onclick="wf1SelectPlanOption(\'pickExisting\')">';
    html += '<div class="wf1-plan-option-icon">â­</div>';
    html += '<div class="wf1-plan-option-content">';
    if (singleFit) {
      html += '<div class="wf1-plan-option-title">Use existing sheet</div>';
      html += '<div class="wf1-plan-option-desc">"' + escapeHtml(singleFit.name) + '" has ' + singleFit.remaining + ' spots â€” fits entire job</div>';
    } else {
      html += '<div class="wf1-plan-option-title">Use existing sheets</div>';
      html += '<div class="wf1-plan-option-desc">Pick which sheets to use (' + spotsOnExisting + ' total spots available)</div>';
    }
    html += '</div></div>';
  }
  
  // No options available warning
  if (stockAvail < totalSheetsNeeded && spotsOnExisting < totalNeeded) {
    html += '<div class="wf1-plan-warning" style="margin-top:8px;">';
    html += '<div class="wf1-feas-icon">âš ï¸</div>';
    html += '<div class="wf1-feas-msg">Not enough labels available</div>';
    html += '<div class="wf1-feas-detail">Need ' + totalNeeded + ' labels. Have ' + spotsOnExisting + ' on existing sheets + ' + (stockAvail * lps) + ' in stock.</div>';
    html += '</div>';
  }
  
  html += '</div>'; // end options
  
  // Load different file link
  html += '<div style="text-align:center;margin-top:16px;">';
  html += '<button class="wf1-inv-btn" onclick="wf1ToStep3B()">â† Load different file</button>';
  html += '</div>';
  
  html += '</div>'; // end planning
  
  contentArea.innerHTML = html;
}

// Handle plan option selection
function wf1SelectPlanOption(option, sheetId) {
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const totalNeeded = wf1BatchCsvData.length;
  const fullSheetsNeeded = Math.floor(totalNeeded / lps);
  const remainder = totalNeeded % lps;
  const totalSheetsNeeded = remainder > 0 ? fullSheetsNeeded + 1 : fullSheetsNeeded;
  
  // Check dedicated sheets setting
  const includeDedicated = document.getElementById('wf1IncludeDedicatedCheck')?.checked || false;
  
  if (option === 'allnew') {
    // Build plan using all new sheets - no user choices needed
    const steps = [];
    let remaining = totalNeeded;
    for (let i = 0; i < totalSheetsNeeded; i++) {
      const use = Math.min(lps, remaining);
      steps.push({ sheetId: null, sheetName: null, count: use, isNew: true, remaining: lps });
      remaining -= use;
    }
    wf1MultiSheetPlan = { steps: steps, totalLabels: totalNeeded, newSheetsNeeded: totalSheetsNeeded };
    wf1SelectedSheet = { isNew: false, id: '__multi__', plan: wf1MultiSheetPlan };
    
    // Skip sheet picker, go directly to template/mapping (Step 6)
    wf1ToStep6();
    
  } else if (option === 'newPlusExisting') {
    // Use new sheets for full pages, user picks existing sheet for remainder
    // Build partial plan with new sheets, go to picker to select existing
    const steps = [];
    for (let i = 0; i < fullSheetsNeeded; i++) {
      steps.push({ sheetId: null, sheetName: null, count: lps, isNew: true, remaining: lps });
    }
    // Store partial plan - user will pick the sheet for remainder
    wf1MultiSheetPlan = { 
      steps: steps, 
      totalLabels: totalNeeded, 
      newSheetsNeeded: fullSheetsNeeded, 
      pendingRemainder: remainder,
      includeDedicated: includeDedicated
    };
    wf1ToStep5(); // Go to sheet picker to select existing sheet for remainder
    
  } else if (option === 'pickExisting') {
    // User wants to use existing sheets only - go to picker
    wf1MultiSheetPlan = { 
      existingOnly: true, 
      totalLabels: totalNeeded,
      includeDedicated: includeDedicated
    };
    wf1ToStep5(); // Go to sheet picker
    
  } else {
    // Fallback - go to sheet picker with no preset plan
    wf1MultiSheetPlan = null;
    wf1SelectedSheet = null;
    wf1ToStep5();
  }
}

function wf1RenderBatchTemplateStep() {
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Choose a template for your labels';
  
  // Find templates that match the label type or are generic
  const templates = savedTexts.filter(t => t.type === 'template');
  
  // Auto-detect best template based on CSV columns
  const bestTemplate = wf1DetectBestTemplate(wf1BatchCsvColumns, templates);
  
  let html = '<div class="wf1-batch-status success">' +
    'âœ… ' + wf1BatchCsvData.length + ' rows loaded. Columns: ' + wf1BatchCsvColumns.join(', ') +
  '</div>';
  
  html += '<div class="wf1-batch-section" style="margin-top:16px;">';
  html += '<div class="wf1-batch-section-title">Select a template</div>';
  html += '<div class="wf1-batch-template-list">';
  
  // Built-in address template
  const addressMatch = bestTemplate === '__address__' ? ' selected' : '';
  html += '<div class="wf1-batch-template-item' + addressMatch + '" onclick="wf1SelectBatchTemplate(\'__address__\')">' +
    '<div class="wf1-batch-template-header">' +
      '<div class="wf1-batch-template-name">ðŸ“¬ Standard Address' + (bestTemplate === '__address__' ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
      '<button class="wf1-template-edit-btn" onclick="event.stopPropagation(); wf1CloneBuiltinTemplate(\'__address__\')" title="Clone & customize">âœï¸</button>' +
    '</div>' +
    '<div class="wf1-batch-template-preview">{name} Â· {address} Â· {city}, {state} {zip}</div>' +
  '</div>';
  
  // Built-in name tag template
  const nametagMatch = bestTemplate === '__nametag__' ? ' selected' : '';
  html += '<div class="wf1-batch-template-item' + nametagMatch + '" onclick="wf1SelectBatchTemplate(\'__nametag__\')">' +
    '<div class="wf1-batch-template-header">' +
      '<div class="wf1-batch-template-name">ðŸ‘‹ Name Tag' + (bestTemplate === '__nametag__' ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
      '<button class="wf1-template-edit-btn" onclick="event.stopPropagation(); wf1CloneBuiltinTemplate(\'__nametag__\')" title="Clone & customize">âœï¸</button>' +
    '</div>' +
    '<div class="wf1-batch-template-preview">{name} Â· {title}</div>' +
  '</div>';
  
  // User templates
  for (const t of templates) {
    const lines = deserializeLines(t.text);
    const preview = lines.map(l => l.text).join(' Â· ');
    const isMatch = bestTemplate === t.id ? ' selected' : '';
    html += '<div class="wf1-batch-template-item' + isMatch + '" onclick="wf1SelectBatchTemplate(\'' + t.id + '\')">' +
      '<div class="wf1-batch-template-header">' +
        '<div class="wf1-batch-template-name">' + escapeHtml(t.name) + (bestTemplate === t.id ? ' <span style="font-size:11px;color:var(--accent);">âœ“ Best match</span>' : '') + '</div>' +
        '<button class="wf1-template-edit-btn" onclick="event.stopPropagation(); wf1EditUserTemplate(\'' + t.id + '\')" title="Edit template">âœï¸</button>' +
      '</div>' +
      '<div class="wf1-batch-template-preview">' + escapeHtml(preview.substring(0, 80)) + '</div>' +
    '</div>';
  }
  
  // Option to create new template
  html += '<div class="wf1-batch-template-item create-new" onclick="wf1CreateNewTemplate()">' +
    '<div class="wf1-batch-template-name">âž• Create new template</div>' +
    '<div class="wf1-batch-template-preview">Design a custom template for this batch</div>' +
  '</div>';
  
  html += '</div></div>';
  area.innerHTML = html;
  document.getElementById('wf1ContentNextBtn').disabled = true;
  
  // If we have a clear best match, auto-select it after a short delay
  if (bestTemplate) {
    setTimeout(function() {
      wf1SelectBatchTemplate(bestTemplate);
    }, 500);
  }
}

// Store batch workflow state for returning after template edit
let wf1BatchReturnState = null;

// Clone a built-in template and open for editing
function wf1CloneBuiltinTemplate(builtinId) {
  let templateText, templateName, templateTokens;
  
  if (builtinId === '__address__') {
    templateText = '{name}\n{address}\n{city}, {state} {zip}';
    templateName = 'Address (Custom)';
    templateTokens = ['name', 'address', 'city', 'state', 'zip'];
  } else if (builtinId === '__nametag__') {
    templateText = '{name}\n{title}';
    templateName = 'Name Tag (Custom)';
    templateTokens = ['name', 'title'];
  } else {
    return;
  }
  
  // Create new template
  const newTemplate = {
    id: 'tpl_' + Date.now(),
    name: templateName,
    type: 'template',
    text: templateText,
    tokens: templateTokens,
    createdAt: Date.now()
  };
  savedTexts.push(newTemplate);
  saveSavedTexts();
  
  // Save batch state so we can return
  wf1BatchReturnState = {
    labelType: wf1LabelType,
    csvData: wf1BatchCsvData,
    csvColumns: wf1BatchCsvColumns,
    selectedSheet: wf1SelectedSheet,
    multiSheetPlan: wf1MultiSheetPlan,
    returnToTemplateId: newTemplate.id
  };
  
  showToast('Template cloned! Customize it in the editor.', 'success');
  
  // Open full editor with the new template
  openFullEditorForTemplate(newTemplate.id);
}

// Edit an existing user template
function wf1EditUserTemplate(templateId) {
  // Save batch state so we can return
  wf1BatchReturnState = {
    labelType: wf1LabelType,
    csvData: wf1BatchCsvData,
    csvColumns: wf1BatchCsvColumns,
    selectedSheet: wf1SelectedSheet,
    multiSheetPlan: wf1MultiSheetPlan,
    returnToTemplateId: templateId
  };
  
  // Open full editor with the template
  openFullEditorForTemplate(templateId);
}

// Create a brand new template
function wf1CreateNewTemplate() {
  // Create blank template
  const newTemplate = {
    id: 'tpl_' + Date.now(),
    name: 'Batch Template ' + new Date().toLocaleDateString(),
    type: 'template',
    text: '{field1}\n{field2}',
    tokens: ['field1', 'field2'],
    createdAt: Date.now()
  };
  savedTexts.push(newTemplate);
  saveSavedTexts();
  
  // Save batch state so we can return
  wf1BatchReturnState = {
    labelType: wf1LabelType,
    csvData: wf1BatchCsvData,
    csvColumns: wf1BatchCsvColumns,
    selectedSheet: wf1SelectedSheet,
    multiSheetPlan: wf1MultiSheetPlan,
    returnToTemplateId: newTemplate.id
  };
  
  showToast('New template created! Customize it in the editor.', 'success');
  
  // Open full editor with the new template
  openFullEditorForTemplate(newTemplate.id);
}

// Open full editor for a template and set up return to batch workflow
function openFullEditorForTemplate(templateId) {
  const template = savedTexts.find(t => t.id === templateId);
  if (!template) return;
  
  // Load template into full editor
  const lines = deserializeLines(template.text);
  fullEditorLines = lines.length > 0 ? lines : [{ text: '', align: 'left', fontSize: 11, bold: false, italic: false }];
  fullEditorGraphics = template.graphics || { left: null, right: null };
  fullEditorAlignV = template.alignV || 'center';
  fullEditorBorder = template.border || null;
  fullEditorCurrentTemplateId = templateId;
  
  // Show the full editor modal
  const modal = document.getElementById('fullEditorModal');
  if (modal) {
    modal.style.display = 'flex';
    renderFullEditor();
    
    // Add a "Return to Batch" button
    const actions = modal.querySelector('.full-editor-actions');
    if (actions && !document.getElementById('fullEditorReturnBatchBtn')) {
      const returnBtn = document.createElement('button');
      returnBtn.id = 'fullEditorReturnBatchBtn';
      returnBtn.className = 'editor-btn';
      returnBtn.style.cssText = 'background:var(--accent);color:white;';
      returnBtn.textContent = 'â† Save & Return to Batch';
      returnBtn.onclick = function() {
        wf1SaveTemplateAndReturn();
      };
      actions.insertBefore(returnBtn, actions.firstChild);
    }
  }
}

// Save template changes and return to batch workflow
function wf1SaveTemplateAndReturn() {
  if (!wf1BatchReturnState) {
    closeFullEditor();
    return;
  }
  
  // Save current editor state to template
  const templateId = fullEditorCurrentTemplateId || wf1BatchReturnState.returnToTemplateId;
  const template = savedTexts.find(t => t.id === templateId);
  
  if (template) {
    template.text = serializeLines(fullEditorLines);
    template.graphics = fullEditorGraphics;
    template.alignV = fullEditorAlignV;
    template.border = fullEditorBorder;
    template.tokens = extractTokens(template.text);
    template.modifiedAt = Date.now();
    saveSavedTexts();
    showToast('Template saved!', 'success');
  }
  
  // Close editor
  closeFullEditor();
  
  // Remove the return button
  const returnBtn = document.getElementById('fullEditorReturnBatchBtn');
  if (returnBtn) returnBtn.remove();
  
  // Restore batch state
  wf1LabelType = wf1BatchReturnState.labelType;
  wf1BatchCsvData = wf1BatchReturnState.csvData;
  wf1BatchCsvColumns = wf1BatchReturnState.csvColumns;
  wf1SelectedSheet = wf1BatchReturnState.selectedSheet;
  wf1MultiSheetPlan = wf1BatchReturnState.multiSheetPlan;
  
  // Re-render template step with the edited template
  wf1BatchSubStep = 'template';
  wf1RenderBatchTemplateStep();
  
  // Auto-select the template we just edited
  setTimeout(function() {
    wf1SelectBatchTemplate(wf1BatchReturnState.returnToTemplateId);
    wf1BatchReturnState = null;
  }, 300);
}

// Detect the best template based on CSV column names
function wf1DetectBestTemplate(columns, userTemplates) {
  const colsLower = columns.map(c => c.toLowerCase().trim());
  
  // Address template tokens and aliases
  const addressTokens = {
    'name': ['name', 'full name', 'recipient', 'contact'],
    'address': ['address', 'street', 'street address', 'addr'],
    'city': ['city', 'town'],
    'state': ['state', 'province', 'st'],
    'zip': ['zip', 'zipcode', 'postal', 'postal code', 'postcode']
  };
  
  // Name tag tokens
  const nametagTokens = {
    'name': ['name', 'full name', 'guest', 'attendee'],
    'title': ['title', 'position', 'role', 'job title', 'company']
  };
  
  // Score each template
  let bestId = null;
  let bestScore = 0;
  
  // Score address template
  let addressScore = 0;
  for (const [token, aliases] of Object.entries(addressTokens)) {
    if (colsLower.some(c => aliases.includes(c) || aliases.some(a => c.includes(a)))) {
      addressScore++;
    }
  }
  if (addressScore >= 3) { // Need at least name + address + city to be confident
    if (addressScore > bestScore) {
      bestScore = addressScore;
      bestId = '__address__';
    }
  }
  
  // Score name tag template
  let nametagScore = 0;
  for (const [token, aliases] of Object.entries(nametagTokens)) {
    if (colsLower.some(c => aliases.includes(c) || aliases.some(a => c.includes(a)))) {
      nametagScore++;
    }
  }
  if (nametagScore === 2) { // Need both name and title
    if (nametagScore > bestScore || (nametagScore === bestScore && addressScore < 3)) {
      bestScore = nametagScore;
      bestId = '__nametag__';
    }
  }
  
  // Score user templates
  for (const t of userTemplates) {
    const tokens = extractTokens(t.text);
    let score = 0;
    for (const token of tokens) {
      const tokenLower = token.toLowerCase();
      if (colsLower.some(c => c === tokenLower || c.includes(tokenLower) || tokenLower.includes(c))) {
        score++;
      }
    }
    // Prefer templates where most tokens match
    const matchRatio = tokens.length > 0 ? score / tokens.length : 0;
    if (matchRatio >= 0.5 && score > bestScore) {
      bestScore = score;
      bestId = t.id;
    }
  }
  
  return bestId;
}

function wf1SelectBatchTemplate(templateId) {
  // Resolve template
  if (templateId === '__address__') {
    wf1BatchSelectedTemplate = {
      text: '{name}\n{address}\n{city}, {state} {zip}',
      lines: [
        { text: '{name}', align: 'left', fontSize: 11 },
        { text: '{address}', align: 'left', fontSize: 11 },
        { text: '{city}, {state} {zip}', align: 'left', fontSize: 11 }
      ],
      tokens: ['name', 'address', 'city', 'state', 'zip']
    };
  } else if (templateId === '__nametag__') {
    wf1BatchSelectedTemplate = {
      text: '{name}\n{title}',
      lines: [
        { text: '{name}', align: 'center', fontSize: 14 },
        { text: '{title}', align: 'center', fontSize: 11 }
      ],
      tokens: ['name', 'title']
    };
  } else {
    const t = savedTexts.find(s => s.id === templateId);
    if (!t) return;
    const lines = deserializeLines(t.text);
    const tokens = extractTokens(t.text);
    wf1BatchSelectedTemplate = { text: t.text, lines, tokens };
  }
  
  // Highlight selected
  document.querySelectorAll('.wf1-batch-template-item').forEach(item => {
    item.classList.remove('selected');
  });
  event.currentTarget.classList.add('selected');
  
  // Auto-map columns to tokens (returns token->column object)
  wf1BatchColumnMap = wf1AutoMapColumnsToTokens(wf1BatchCsvColumns, wf1BatchSelectedTemplate.tokens);
  
  wf1BatchSubStep = 'map';
  setTimeout(function() { wf1RenderBatchMapStep(); }, 200);
}

// Auto-map CSV columns to template tokens, returning {token: column} object
function wf1AutoMapColumnsToTokens(columns, tokens) {
  const mapping = {};
  const usedColumns = new Set();
  
  // Expanded aliases for better matching
  const aliases = {
    'name': ['name', 'full name', 'fullname', 'full_name', 'student name', 'student_name', 'guest', 'guest name', 'recipient', 'contact'],
    'address': ['address', 'street', 'street address', 'address1', 'address_1', 'street_address', 'addr', 'mailing address'],
    'city': ['city', 'town', 'municipality'],
    'state': ['state', 'province', 'region', 'st'],
    'zip': ['zip', 'zip code', 'zipcode', 'postal', 'postal code', 'postal_code', 'postcode'],
    'title': ['title', 'job title', 'position', 'role'],
    'company': ['company', 'organization', 'org', 'employer', 'business'],
    'phone': ['phone', 'telephone', 'tel', 'mobile', 'cell', 'phone number'],
    'email': ['email', 'email address', 'e-mail'],
    'first_name': ['first name', 'first', 'fname', 'given name', 'given_name', 'firstname'],
    'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name', 'lastname']
  };
  
  for (const token of tokens) {
    const tokenLower = token.toLowerCase().replace(/_/g, ' ');
    const tokenAliases = aliases[token] || [tokenLower];
    
    // Try to find a matching column
    for (const col of columns) {
      if (usedColumns.has(col)) continue;
      const colLower = col.toLowerCase().trim();
      
      // Exact match
      if (colLower === tokenLower || colLower === token) {
        mapping[token] = col;
        usedColumns.add(col);
        break;
      }
      
      // Alias match
      if (tokenAliases.some(a => a === colLower || colLower.includes(a) || a.includes(colLower))) {
        mapping[token] = col;
        usedColumns.add(col);
        break;
      }
    }
  }
  
  return mapping;
}

function wf1RenderBatchMapStep() {
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Map your columns to the template';
  
  let html = '<div class="wf1-batch-mapping">';
  
  for (const token of wf1BatchSelectedTemplate.tokens) {
    html += '<div class="wf1-batch-map-row">' +
      '<label>{' + token + '}</label>' +
      '<select onchange="wf1UpdateBatchMap(\'' + token + '\', this.value)">';
    
    html += '<option value="">â€” skip â€”</option>';
    for (const col of wf1BatchCsvColumns) {
      const selected = wf1BatchColumnMap[token] === col ? ' selected' : '';
      html += '<option value="' + escapeHtml(col) + '"' + selected + '>' + escapeHtml(col) + '</option>';
    }
    html += '</select></div>';
  }
  
  html += '</div>';
  
  // Preview button
  html += '<div style="margin-top:16px; text-align:center;">' +
    '<button class="wf1-inv-btn primary" onclick="wf1RenderBatchPreview()">Preview labels â†’</button>' +
    '<button class="wf1-inv-btn" onclick="wf1BatchSubStep=\'template\'; wf1RenderBatchTemplateStep();" style="margin-left:8px;">Change template</button>' +
  '</div>';
  
  area.innerHTML = html;
}

function wf1UpdateBatchMap(token, col) {
  if (col) {
    wf1BatchColumnMap[token] = col;
  } else {
    delete wf1BatchColumnMap[token];
  }
}

function wf1RenderBatchPreview() {
  // Build batch content from CSV + template + mapping
  wf1BatchContent = [];
  
  for (const record of wf1BatchCsvData) {
    const lines = [];
    for (const tl of wf1BatchSelectedTemplate.lines) {
      let text = tl.text;
      text = text.replace(/\{([a-z][a-z0-9_]*)\}/gi, function(match, token) {
        const key = token.toLowerCase();
        const mappedCol = wf1BatchColumnMap[key];
        if (mappedCol && record[mappedCol]) {
          return record[mappedCol];
        }
        return '';
      });
      if (text.trim()) {
        lines.push({ ...tl, text: text });
      }
    }
    if (lines.length > 0) {
      wf1BatchContent.push(lines);
    }
  }
  
  wf1Quantity = wf1BatchContent.length;
  wf1BatchSubStep = 'preview';
  
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Preview your labels';
  
  let html = '<div class="wf1-batch-preview-header">';
  html += '<div class="wf1-batch-preview-count">' + wf1BatchContent.length + ' label' + (wf1BatchContent.length !== 1 ? 's' : '') + ' from your list</div>';
  html += '<div class="wf1-batch-preview-hint">Click âœï¸ to make quick edits</div>';
  html += '</div>';
  html += '<div class="wf1-batch-preview-scroll">';
  
  const showCount = Math.min(wf1BatchContent.length, 20); // Show more for editing
  for (let i = 0; i < showCount; i++) {
    html += '<div class="wf1-batch-preview-label" id="wf1BatchLabel' + i + '">';
    html += '<div class="wf1-batch-label-content">';
    for (const line of wf1BatchContent[i]) {
      html += '<div style="text-align:' + (line.align || 'left') + '; font-size:' + (line.fontSize || 11) + 'px;">' + escapeHtml(line.text) + '</div>';
    }
    html += '</div>';
    html += '<button class="wf1-batch-edit-btn" onclick="wf1EditBatchLabel(' + i + ')" title="Edit this label">âœï¸</button>';
    html += '</div>';
  }
  if (wf1BatchContent.length > showCount) {
    html += '<div class="wf1-batch-more-labels">';
    html += '<span>...and ' + (wf1BatchContent.length - showCount) + ' more</span>';
    html += '<button class="wf1-inv-btn" onclick="wf1ShowAllBatchLabels()" style="margin-left:10px;font-size:11px;padding:4px 8px;">Show all</button>';
    html += '</div>';
  }
  html += '</div>';
  
  // Edit mapping button
  html += '<div style="margin-top:12px; text-align:center;">' +
    '<button class="wf1-inv-btn" onclick="wf1BatchSubStep=\'map\'; wf1RenderBatchMapStep();">â† Edit field mapping</button>' +
  '</div>';
  
  area.innerHTML = html;
  
  document.getElementById('wf1ContentNextBtn').disabled = wf1BatchContent.length === 0;
}

// Show all batch labels (for large lists)
function wf1ShowAllBatchLabels() {
  const area = document.getElementById('wf1ContentArea');
  const question = document.getElementById('wf1ContentQuestion');
  question.textContent = 'Preview your labels';
  
  let html = '<div class="wf1-batch-preview-header">';
  html += '<div class="wf1-batch-preview-count">' + wf1BatchContent.length + ' label' + (wf1BatchContent.length !== 1 ? 's' : '') + '</div>';
  html += '<div class="wf1-batch-preview-hint">Click âœï¸ to make quick edits</div>';
  html += '</div>';
  html += '<div class="wf1-batch-preview-scroll" style="max-height:400px;">';
  
  for (let i = 0; i < wf1BatchContent.length; i++) {
    html += '<div class="wf1-batch-preview-label" id="wf1BatchLabel' + i + '">';
    html += '<div class="wf1-batch-label-content">';
    for (const line of wf1BatchContent[i]) {
      html += '<div style="text-align:' + (line.align || 'left') + '; font-size:' + (line.fontSize || 11) + 'px;">' + escapeHtml(line.text) + '</div>';
    }
    html += '</div>';
    html += '<button class="wf1-batch-edit-btn" onclick="wf1EditBatchLabel(' + i + ')" title="Edit this label">âœï¸</button>';
    html += '</div>';
  }
  html += '</div>';
  
  // Edit mapping button
  html += '<div style="margin-top:12px; text-align:center;">' +
    '<button class="wf1-inv-btn" onclick="wf1BatchSubStep=\'map\'; wf1RenderBatchMapStep();">â† Edit field mapping</button>' +
  '</div>';
  
  area.innerHTML = html;
}

// Edit a single batch label inline
function wf1EditBatchLabel(index) {
  const labelDiv = document.getElementById('wf1BatchLabel' + index);
  if (!labelDiv) return;
  
  const lines = wf1BatchContent[index];
  
  let html = '<div class="wf1-batch-label-edit">';
  for (let i = 0; i < lines.length; i++) {
    html += '<input type="text" class="wf1-batch-edit-input" id="wf1BatchEdit' + index + '_' + i + '" value="' + escapeHtml(lines[i].text) + '" data-line="' + i + '">';
  }
  // Option to add a line
  html += '<div class="wf1-batch-edit-actions">';
  html += '<button class="wf1-batch-edit-save" onclick="wf1SaveBatchLabel(' + index + ')">Save</button>';
  html += '<button class="wf1-batch-edit-cancel" onclick="wf1CancelBatchEdit(' + index + ')">Cancel</button>';
  html += '<button class="wf1-batch-edit-delete" onclick="wf1DeleteBatchLabel(' + index + ')" title="Remove this label">ðŸ—‘ï¸</button>';
  html += '</div>';
  html += '</div>';
  
  labelDiv.innerHTML = html;
  labelDiv.classList.add('editing');
  
  // Focus first input
  const firstInput = document.getElementById('wf1BatchEdit' + index + '_0');
  if (firstInput) firstInput.focus();
}

// Save edited batch label
function wf1SaveBatchLabel(index) {
  const lines = wf1BatchContent[index];
  
  for (let i = 0; i < lines.length; i++) {
    const input = document.getElementById('wf1BatchEdit' + index + '_' + i);
    if (input) {
      lines[i].text = input.value;
    }
  }
  
  // Re-render this label
  wf1RenderSingleBatchLabel(index);
  showToast('Label updated', 'success');
}

// Cancel editing
function wf1CancelBatchEdit(index) {
  wf1RenderSingleBatchLabel(index);
}

// Delete a batch label
async function wf1DeleteBatchLabel(index) {
  const ok = await showConfirmDialog(
    'Remove this label from the batch?',
    'Remove Label',
    'Remove',
    'Cancel'
  );
  if (!ok) return;
  
  wf1BatchContent.splice(index, 1);
  wf1Quantity = wf1BatchContent.length;
  
  // Re-render the entire preview
  wf1RenderBatchPreview();
  showToast('Label removed', 'info');
}

// Re-render a single batch label (after edit)
function wf1RenderSingleBatchLabel(index) {
  const labelDiv = document.getElementById('wf1BatchLabel' + index);
  if (!labelDiv || !wf1BatchContent[index]) return;
  
  labelDiv.classList.remove('editing');
  
  let html = '<div class="wf1-batch-label-content">';
  for (const line of wf1BatchContent[index]) {
    html += '<div style="text-align:' + (line.align || 'left') + '; font-size:' + (line.fontSize || 11) + 'px;">' + escapeHtml(line.text) + '</div>';
  }
  html += '</div>';
  html += '<button class="wf1-batch-edit-btn" onclick="wf1EditBatchLabel(' + index + ')" title="Edit this label">âœï¸</button>';
  
  labelDiv.innerHTML = html;
}

// ---- STEP 7: Preview & Print ----

function wf1ToStep7() {
  if (wf1JobType === 'individual') {
    wf1ContentLines = wf1GetEditorLines();
    if (wf1ContentLines.length === 0) {
      showToast('Enter some text first', 'warning');
      return;
    }
  } else {
    if (wf1BatchContent.length === 0) {
      showToast('No batch content to print', 'warning');
      return;
    }
  }
  
  wf1Step = 7;
  wf1RenderPreview();
  wf1ShowStep('wf1Step7');
}

function wf1RenderPreview() {
  const content = document.getElementById('wf1PreviewContent');
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const qty = wf1JobType === 'batch' ? wf1BatchContent.length : wf1Quantity;
  
  // Sheet info
  let sheetName = 'New sheet';
  let sheetHasBackLabel = false;
  let sheetObj = null;
  const isNewSheet = wf1SelectedSheet && wf1SelectedSheet.isNew;
  const isMultiSheet = wf1SelectedSheet && wf1SelectedSheet.id === '__multi__';
  
  if (wf1SelectedSheet && !isNewSheet && !isMultiSheet) {
    sheetObj = sheets[wf1SelectedSheet.id];
    if (sheetObj) {
      sheetName = sheetObj.name;
      sheetHasBackLabel = sheetObj.hasBackLabel || false;
    }
  }
  
  let html = '<div class="wf1-preview-summary">' +
    'Printing <strong>' + qty + ' label' + (qty !== 1 ? 's' : '') + '</strong> on <strong>' + escapeHtml(sheetName) + '</strong> (' + wf1LabelType + ')' +
  '</div>';
  
  // === SHEET LOADING INSTRUCTIONS ===
  html += '<div class="wf1-sheet-instructions" style="margin:16px 0; padding:16px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm);">';
  html += '<div style="font-weight:600; color:var(--text); margin-bottom:8px; display:flex; align-items:center; gap:8px;">ðŸ–¨ï¸ Load Paper</div>';
  
  if (isMultiSheet && wf1MultiSheetPlan) {
    // Multi-sheet job
    const plan = wf1MultiSheetPlan;
    html += '<div style="font-size:13px; color:var(--text-muted); line-height:1.5;">';
    html += 'This job requires <strong>' + plan.steps.length + ' sheet' + (plan.steps.length > 1 ? 's' : '') + '</strong>. ';
    html += 'You\'ll be prompted to load each sheet as needed.';
    html += '</div>';
  } else if (isNewSheet) {
    // New sheet from stock
    const inv = getInventory(wf1LabelType);
    const hasStock = inv && inv.stock > 0;
    html += '<div style="font-size:13px; color:var(--text); line-height:1.5;">';
    if (hasStock) {
      html += '<strong>Get a fresh sheet</strong> of ' + spec.name + ' (' + wf1LabelType + ') from your stock and load it into your printer.';
      html += '<div style="margin-top:6px; font-size:12px; color:var(--text-muted);">You have ' + inv.stock + ' unused sheet' + (inv.stock > 1 ? 's' : '') + ' in inventory.</div>';
    } else {
      html += '<strong>Get a sheet</strong> of ' + spec.name + ' (' + wf1LabelType + ') and load it into your printer.';
    }
    html += '</div>';
  } else if (sheetObj) {
    // Existing tracked sheet
    html += '<div style="font-size:13px; color:var(--text); line-height:1.5;">';
    html += '<strong>Find your sheet:</strong> "' + escapeHtml(sheetObj.name) + '"';
    
    // Add identifying info
    const identifiers = [];
    if (sheetHasBackLabel) {
      identifiers.push('has an ID label on the back');
    }
    const usedCount = (sheetObj.printed || []).length;
    const remaining = lps - usedCount;
    if (usedCount > 0) {
      identifiers.push(usedCount + ' of ' + lps + ' labels already used');
    }
    
    if (identifiers.length > 0) {
      html += '<div style="margin-top:4px; font-size:12px; color:var(--text-muted);">This sheet ' + identifiers.join(', ') + '.</div>';
    }
    
    html += '<div style="margin-top:8px;">Load this sheet according to your printer\'s instructions for label sheets.</div>';
    html += '</div>';
  }
  
  html += '</div>';
  // === END SHEET LOADING INSTRUCTIONS ===
  
  // Get any rich formatting from Full Editor snapshot
  let graphics = null;
  let border = null;
  let barcode = null;
  let alignV = 'center';
  
  if (wf1FeSnapshot) {
    graphics = wf1FeSnapshot.graphics || null;
    border = wf1FeSnapshot.border || null;
    barcode = wf1FeSnapshot.barcode ? { ...wf1FeSnapshot.barcode } : null;
    alignV = wf1FeSnapshot.alignV || 'center';
    
    // Generate QR data if barcode is enabled (barcode object doesn't store data, it's generated at render time)
    if (barcode && barcode.enabled && barcode.type === 'qr' && wf1ContentLines.length > 0) {
      const textLines = wf1ContentLines.map(l => l.text || '').filter(Boolean);
      if (textLines.length > 0) {
        let textToEncode = textLines.join('\n');
        if (barcode.encodeType === 'vcard') {
          textToEncode = generateVCard(textLines);
        } else if (barcode.encodeType === 'url' && !textToEncode.startsWith('http')) {
          textToEncode = 'https://' + textToEncode;
        }
        barcode.data = textToEncode;
      }
    }
  }
  
  if (wf1JobType === 'individual') {
    // Show full label preview with unified renderer (includes graphics, border, barcode, alignV)
    html += '<div class="wf1-preview-frame">';
    html += renderUnifiedLabelPreview({
      lines: wf1ContentLines,
      graphics: graphics,
      border: border,
      barcode: barcode,
      alignV: alignV,
      labelType: wf1LabelType
    }, { showPlaceholder: false });
    html += '</div>';
  } else {
    // Batch preview â€” show first few using canonical renderer
    html += '<div class="wf1-batch-preview-count">' + qty + ' unique labels from your list</div>';
    html += '<div class="wf1-batch-preview-scroll">';
    const showCount = Math.min(qty, 5);
    for (let i = 0; i < showCount; i++) {
      html += '<div class="wf1-batch-preview-label">';
      html += renderLabelPreviewHtml(wf1BatchContent[i]);
      html += '</div>';
    }
    if (qty > showCount) {
      html += '<div style="font-size:12px; color:var(--text-muted); text-align:center; padding:8px;">...and ' + (qty - showCount) + ' more</div>';
    }
    html += '</div>';
  }
  
  // Option to print ID label on back first (only for single sheets without one, not multi-sheet)
  if (!sheetHasBackLabel && !isMultiSheet && wf1SelectedSheet && !wf1SelectedSheet.isNew) {
    html += '<div class="wf1-preview-option" style="margin-top:16px; padding:12px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm);">' +
      '<label style="display:flex; align-items:flex-start; gap:10px; cursor:pointer;">' +
        '<input type="checkbox" id="wf1PrintBackFirst" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">Also print ID label on back</div>' +
          '<div style="font-size:12px; color:var(--text-muted); margin-top:2px;">Prints a 2-page job: labels on front, sheet identifier on back. Works automatically with duplex printers.</div>' +
        '</div>' +
      '</label>' +
    '</div>';
  }
  
  // Safari print preview warning
  if (isSafari) {
    html += '<div class="safari-print-notice">ðŸŽ Safari\'s print preview may show labels slightly shifted â€” this is a Safari limitation. The actual printed output will be positioned correctly.</div>';
  }
  
  content.innerHTML = html;
}

// ---- PRINT EXECUTION ----

function wf1ExecutePrint() {
  // Check if user wants to print ID label on back first
  const printBackFirst = document.getElementById('wf1PrintBackFirst');
  if (printBackFirst && printBackFirst.checked) {
    wf1PrintBackLabelFirst();
    return;
  }
  
  if (wf1JobType === 'individual') {
    wf1ExecuteIndividualPrint();
  } else {
    wf1ExecuteBatchPrint();
  }
}

// Print ID label on back first, then prompt to flip and print labels
function wf1PrintBackLabelFirst() {
  // Create sheet if needed (so we have an ID to print)
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const spec = LABEL_TYPES[wf1LabelType];
    const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
    const sheetName = spec.desc + ' #' + (existingCount + 1);
    sheetId = createSheet(sheetName, wf1LabelType, 1);
    // Update selection to point to new sheet
    wf1SelectedSheet = { isNew: false, id: sheetId };
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  // Defensive check: ensure we have a valid sheet
  if (!sheetId || sheetId === '__multi__') {
    console.error('wf1PrintBackLabelFirst: Invalid sheetId:', sheetId);
    showToast('Cannot print back label for multi-sheet jobs', 'warning');
    // Fall back to regular print without back label - handle multi-sheet properly
    if (wf1SelectedSheet && wf1SelectedSheet.id === '__multi__' && wf1MultiSheetPlan) {
      // Multi-sheet job - use multi-sheet batch print
      wf1ExecuteMultiSheetBatchPrint();
    } else if (wf1JobType === 'batch') {
      wf1ExecuteBatchPrint();
    } else {
      // For individual jobs with no valid sheet, we need to create one first
      if (wf1SelectedSheet && wf1SelectedSheet.isNew) {
        const spec = LABEL_TYPES[wf1LabelType];
        const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
        const newSheetName = spec.desc + ' #' + (existingCount + 1);
        const newSheetId = createSheet(newSheetName, wf1LabelType, 1);
        wf1SelectedSheet = { isNew: false, id: newSheetId };
      }
      wf1ExecuteIndividualPrint();
    }
    return;
  }
  
  const sh = sheets[sheetId];
  if (!sh) {
    console.error('wf1PrintBackLabelFirst: Sheet not found for id:', sheetId);
    showToast('Sheet not found', 'error');
    return;
  }
  
  // Mark sheet as having back label
  sheets[sheetId].hasBackLabel = true;
  saveSheets();
  
  // Build combined 2-page print: Page 1 = labels (front), Page 2 = ID label (back)
  // This works with duplex printers automatically
  if (wf1JobType === 'individual') {
    wf1ExecuteCombinedPrint(sheetId, isNewSheet);
  } else {
    wf1ExecuteCombinedBatchPrint(sheetId, isNewSheet);
  }
}

// Execute combined print job: labels on page 1, ID label on page 2
function wf1ExecuteCombinedPrint(sheetId, isNewSheet) {
  const spec = LABEL_TYPES[wf1LabelType];
  const sh = sheets[sheetId];
  
  // Find positions respecting orientation
  const positions = wf1FindNextPositions(sh, spec, wf1Quantity, wf1Orientation);
  
  // Build print manifest
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let barcode = null;
  let resolvedLines = wf1ContentLines;
  
  if (wf1SelectedSavedTextId) {
    const savedText = getSavedText(wf1SelectedSavedTextId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
      barcode = savedText.barcode || null;
    }
  } else if (wf1FeSnapshot) {
    graphics = wf1FeSnapshot.graphics || { left: null, right: null };
    alignV = wf1FeSnapshot.alignV || 'center';
    border = wf1FeSnapshot.border || null;
    barcode = wf1FeSnapshot.barcode || null;
  }
  
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border, barcode: barcode };
  });
  
  // Build combined HTML: labels page + ID label page
  const printHtml = buildCombinedPrintHtml(sh, printManifest, sheetId);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store for post-print
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: positions.length };
  
  // Move to post-print confirmation
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

// Build combined print HTML: Page 1 = labels, Page 2 = ID label on back
function buildCombinedPrintHtml(sh, manifest, sheetId) {
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const isTentCard = spec.category === 'tent';
  const isRound = spec.category === 'round';
  const printed = new Set(sh.printed || []);
  const remaining = lps - printed.size;
  const createdDate = new Date(sh.createdAt || Date.now()).toLocaleDateString();
  
  // Build CSS (same as buildSheetPrintHtml)
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += '@media print { .print-sheet, .id-page { page-break-after: always; page-break-inside: avoid; } }';
  html += 'html, body { margin: 0; padding: 0; }';
  html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; page-break-after: always; page-break-inside: avoid; }';
  html += '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }';
  html += '.print-label-gfx { flex-direction:row; align-items:stretch; }';
  html += '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }';
  html += '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }';
  html += '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }';
  html += '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }';
  html += '.print-line.align-left { justify-content:flex-start; text-align:left; }';
  html += '.print-line.align-center { justify-content:center; text-align:center; }';
  html += '.print-line.align-right { justify-content:flex-end; text-align:right; }';
  html += '.print-line.align-split { justify-content:space-between; text-align:left; }';
  html += '.print-line.align-split > span { min-width:0; overflow:hidden; text-overflow:ellipsis; }';
  html += '.print-line.align-split-fill { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; }';
  html += '.print-line.align-split-fill .split-fill-left, .print-line.align-split-fill .split-fill-right { display:flex; align-items:flex-end; gap:3px; flex:1; }';
  html += '.print-line.align-split-fill .split-fill-right { justify-content:flex-end; }';
  html += '.print-line.align-split-fill .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  html += '.print-line.align-split-fill .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }';
  html += '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  if (isRound) {
    html += '.print-label.round-label { border-radius:50%; justify-content:center; align-items:center; text-align:center; }';
    html += '.print-label.round-label .print-text-zone { align-items:center; justify-content:center; }';
    html += '.print-label.round-label .print-line { justify-content:center; text-align:center; }';
  }
  if (isTentCard) {
    html += '.print-label.tent-card { position:relative; padding:0; }';
    html += '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #ccc; z-index:1; }';
    html += '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }';
    html += '.tent-top { top:0; height:50%; }';
    html += '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }';
  }
  // ID label page styles - must force new page
  html += '.id-page { width: 8.5in; min-height: 11in; height: 11in; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif; page-break-before: always; page-break-inside: avoid; box-sizing: border-box; }';
  html += '.id-label { border: 2px solid #333; border-radius: 8px; padding: 24px 32px; text-align: center; max-width: 4in; }';
  html += '.id-label h2 { margin: 0 0 6px; font-size: 18px; }';
  html += '.id-label .type { font-size: 14px; color: #555; margin-bottom: 12px; }';
  html += '.id-label .details { font-size: 11px; color: #777; margin-top: 10px; line-height: 1.5; }';
  html += '.id-label .id-code { font-family: monospace; font-size: 10px; color: #999; margin-top: 8px; word-break: break-all; }';
  html += '</style></head><body>';
  
  // PAGE 1: Labels (front of sheet)
  html += '<div class="print-sheet">';
  
  // Use the same label rendering logic as buildSheetPrintHtml
  manifest.forEach(function(item) {
    const idx = item.idx % lps;
    const row = Math.floor(idx / spec.cols);
    const col = idx % spec.cols;
    
    const top = spec.topMargin + row * (spec.labelH + spec.vGutter);
    const left = spec.leftMargin + col * (spec.labelW + spec.hGutter);
    
    const hasGraphics = item.graphics && (item.graphics.left || item.graphics.right);
    const alignV = item.alignV || 'center';
    const flexAlign = alignV === 'top' ? 'flex-start' : alignV === 'bottom' ? 'flex-end' : alignV === 'spread' ? 'space-between' : 'center';
    
    let borderStyle = '';
    if (item.border) {
      const bc = item.border.color || '#000';
      if (item.border.top) borderStyle += 'border-top:2px solid ' + bc + ';';
      if (item.border.bottom) borderStyle += 'border-bottom:2px solid ' + bc + ';';
      if (item.border.left) borderStyle += 'border-left:2px solid ' + bc + ';';
      if (item.border.right) borderStyle += 'border-right:2px solid ' + bc + ';';
    }
    
    // Determine label class
    let labelClass = 'print-label';
    if (isRound) labelClass += ' round-label';
    else if (hasGraphics) labelClass += ' print-label-gfx';
    
    html += '<div class="' + labelClass + '" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.05in;justify-content:' + flexAlign + ';' + borderStyle + '">';
    
    if (hasGraphics && item.graphics.left) {
      const size = item.graphics.left.size === 'S' ? 0.3 : item.graphics.left.size === 'L' ? 0.6 : 0.45;
      html += '<div class="print-graphic" style="width:' + size + 'in;height:' + size + 'in;margin-right:0.05in;"><img src="' + item.graphics.left.data + '"></div>';
    }
    
    html += '<div class="print-text-zone" style="justify-content:' + flexAlign + ';">';
    for (const line of item.lines) {
      if (!line.text) continue;
      const parsed = parseLine(line.text);
      let style = 'font-size:' + (line.fontSize || 11) + 'px;';
      if (line.bold) style += 'font-weight:bold;';
      if (line.italic) style += 'font-style:italic;';
      if (line.underline) style += 'text-decoration:underline;';
      if (line.color) style += 'color:' + line.color + ';';
      
      if (parsed.type === 'fill') {
        html += '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span></div>';
      } else if (parsed.type === 'split') {
        html += '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
      } else {
        html += '<div class="print-line align-' + (line.align || 'left') + '" style="' + style + '">' + escapeHtml(line.text) + '</div>';
      }
    }
    html += '</div>';
    
    if (hasGraphics && item.graphics.right) {
      const size = item.graphics.right.size === 'S' ? 0.3 : item.graphics.right.size === 'L' ? 0.6 : 0.45;
      html += '<div class="print-graphic" style="width:' + size + 'in;height:' + size + 'in;margin-left:0.05in;"><img src="' + item.graphics.right.data + '"></div>';
    }
    
    html += '</div>';
  });
  
  html += '</div>';
  
  // PAGE 2: ID label (back of sheet)
  html += '<div class="id-page">';
  html += '<div class="id-label">';
  html += '<h2>' + escapeHtml(sh.name) + '</h2>';
  html += '<div class="type">' + sh.labelType + ' â€” ' + escapeHtml(spec.desc) + '</div>';
  html += '<div style="font-size:13px;">' + remaining + ' of ' + lps + ' labels available</div>';
  html += '<div class="details">Created: ' + createdDate + '<br>Sheet count: ' + (sh.sheetCount || 1) + '</div>';
  html += '<div class="id-code">' + sheetId + '</div>';
  html += '</div>';
  html += '</div>';
  
  html += '</body></html>';
  return html;
}

// Combined batch print with ID label on back
function wf1ExecuteCombinedBatchPrint(sheetId, isNewSheet) {
  // For now, just call the regular batch print flow
  // Multi-page batch with back label is complex - would need significant refactoring
  // Fall back to the simpler two-step approach for batch
  wf1ExecuteBatchPrint();
}

// Continue printing labels after ID label was printed on back (legacy - kept for safety)
function wf1ContinuePrintAfterBack() {
  if (wf1JobType === 'individual') {
    wf1ExecuteIndividualPrint();
  } else {
    wf1ExecuteBatchPrint();
  }
}

function wf1ExecuteIndividualPrint() {
  // Guard against multi-sheet selection (shouldn't happen, but defensive)
  if (wf1SelectedSheet && wf1SelectedSheet.id === '__multi__') {
    console.error('wf1ExecuteIndividualPrint called with multi-sheet selection - redirecting to batch');
    wf1ExecuteBatchPrint();
    return;
  }
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // Create or get sheet
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const existingCount = Object.values(sheets).filter(s => s.labelType === wf1LabelType).length;
    const sheetName = spec.desc + ' #' + (existingCount + 1);
    sheetId = createSheet(sheetName, wf1LabelType, 1);
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  const sh = sheets[sheetId];
  
  // Verify sheet exists
  if (!sh) {
    console.error('wf1ExecuteIndividualPrint: Sheet not found for id:', sheetId);
    showToast('Sheet not found - please select a sheet', 'error');
    return;
  }
  
  // T3: Find positions respecting orientation
  const positions = wf1FindNextPositions(sh, spec, wf1Quantity, wf1Orientation);
  
  // Build print manifest matching the canonical printFromSheet pattern
  // This ensures graphics, alignV, borders, and Safari compression all work
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let barcode = null;
  let resolvedLines = wf1ContentLines;
  
  if (wf1SelectedSavedTextId) {
    const savedText = getSavedText(wf1SelectedSavedTextId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
      barcode = savedText.barcode || null;
    }
  } else if (wf1FeSnapshot) {
    // Use Full Editor snapshot for graphics, alignV, border, barcode when returning from Full Editor
    graphics = wf1FeSnapshot.graphics || { left: null, right: null };
    alignV = wf1FeSnapshot.alignV || 'center';
    border = wf1FeSnapshot.border || null;
    barcode = wf1FeSnapshot.barcode || null;
  }
  
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border, barcode: barcode };
  });
  
  // Use the canonical buildSheetPrintHtml (same as sheets tab print button)
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store for post-print
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: positions.length };
  
  // Move to post-print confirmation
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

function wf1ExecuteBatchPrint() {
  // Check if this is a multi-sheet plan
  if (wf1SelectedSheet && wf1SelectedSheet.id === '__multi__' && wf1MultiSheetPlan) {
    wf1ExecuteMultiSheetBatchPrint();
    return;
  }
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  const count = wf1BatchContent.length;
  const sheetsNeeded = Math.ceil(count / lps);
  
  // Create sheet for batch
  let sheetId;
  let isNewSheet = wf1SelectedSheet.isNew;
  if (isNewSheet) {
    const sheetName = 'Batch ' + new Date().toLocaleDateString();
    sheetId = createSheet(sheetName, wf1LabelType, sheetsNeeded);
  } else {
    sheetId = wf1SelectedSheet.id;
  }
  
  const sh = sheets[sheetId];
  
  // Resolve template graphics/alignV/border if a template was used
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  if (wf1BatchSelectedTemplate) {
    const tpl = getBuiltinTemplate(wf1BatchSelectedTemplate.id) || savedTexts.find(function(s) { return s.id === wf1BatchSelectedTemplate.id; });
    if (tpl) {
      graphics = tpl.graphics || { left: null, right: null };
      alignV = tpl.alignV || 'center';
      border = tpl.border || null;
    }
  }
  
  // Build print manifest using the canonical format (G10: same path as individual prints)
  // T3: Use orientation-aware position order
  const positionOrder = wf1GetPositionOrder(spec.cols, spec.rows, wf1Orientation);
  const printed = new Set(sh.printed || []);
  const printManifest = [];
  let orderIdx = 0;
  for (let i = 0; i < count; i++) {
    // Find next available position in orientation order
    while (orderIdx < positionOrder.length && printed.has(positionOrder[orderIdx])) orderIdx++;
    // Handle multi-page sheets by extending into next page if needed
    let posIdx;
    if (orderIdx < positionOrder.length) {
      posIdx = positionOrder[orderIdx];
    } else {
      // For multi-page sheets, continue into subsequent pages sequentially
      posIdx = lps + (orderIdx - positionOrder.length);
      while (printed.has(posIdx)) posIdx++;
    }
    printManifest.push({ idx: posIdx, lines: wf1BatchContent[i], graphics: graphics, alignV: alignV, border: border });
    orderIdx++;
  }
  
  // Use canonical buildSheetPrintHtml â€” gets graphics, styles, Safari compression, borders
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Build positions array for post-print
  const positions = printManifest.map(function(item) { return item.idx; });
  
  wf1PrintResult = { sheetId, positions, isNewSheet, totalLabels: count, isBatch: true };
  
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

// Multi-sheet batch print: prints across multiple existing + new sheets
function wf1ExecuteMultiSheetBatchPrint() {
  const plan = wf1MultiSheetPlan;
  if (!plan || !plan.steps.length) return;
  
  const spec = LABEL_TYPES[wf1LabelType];
  const lps = spec.cols * spec.rows;
  
  // Resolve template graphics/alignV/border
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  if (wf1BatchSelectedTemplate) {
    const tpl = getBuiltinTemplate(wf1BatchSelectedTemplate.id) || savedTexts.find(function(s) { return s.id === wf1BatchSelectedTemplate.id; });
    if (tpl) {
      graphics = tpl.graphics || { left: null, right: null };
      alignV = tpl.alignV || 'center';
      border = tpl.border || null;
    }
  }
  
  // Build combined print HTML across all sheets
  let fullHtml = '';
  let contentIdx = 0; // tracks position in wf1BatchContent
  const sheetResults = []; // track what was printed on each sheet
  
  for (let si = 0; si < plan.steps.length; si++) {
    const step = plan.steps[si];
    let sheetId;
    let isNew = step.isNew;
    
    if (isNew) {
      const sheetName = 'Batch ' + new Date().toLocaleDateString() + (plan.steps.length > 1 ? ' (' + (si + 1) + ')' : '');
      sheetId = createSheet(sheetName, wf1LabelType, 1);
    } else {
      sheetId = step.sheetId;
    }
    
    const sh = sheets[sheetId];
    const printed = new Set(sh.printed || []);
    const manifest = [];
    let posIdx = 0;
    
    for (let li = 0; li < step.count && contentIdx < wf1BatchContent.length; li++) {
      while (posIdx < lps * sh.sheetCount && printed.has(posIdx)) posIdx++;
      manifest.push({ idx: posIdx, lines: wf1BatchContent[contentIdx], graphics: graphics, alignV: alignV, border: border });
      posIdx++;
      contentIdx++;
    }
    
    // Build this sheet's print HTML
    const sheetHtml = buildSheetPrintHtml(sh, manifest);
    
    // Extract body content (strip the DOCTYPE/head/body wrapper) for combining
    if (si === 0) {
      fullHtml = sheetHtml; // first sheet gets the full document
    } else {
      // Extract the print-sheet divs from subsequent sheets and append before </body>
      const bodyMatch = sheetHtml.match(/<body>([\s\S]*)<\/body>/);
      if (bodyMatch) {
        fullHtml = fullHtml.replace('</body>', bodyMatch[1] + '</body>');
      }
    }
    
    sheetResults.push({
      sheetId: sheetId,
      sheetName: sh.name,
      positions: manifest.map(function(m) { return m.idx; }),
      isNew: isNew,
      count: manifest.length
    });
  }
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(fullHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store multi-sheet result for post-print
  wf1PrintResult = {
    isMultiSheet: true,
    sheetResults: sheetResults,
    totalLabels: wf1BatchContent.length,
    isBatch: true
  };
  
  wf1Step = 8;
  wf1RenderPostPrint();
  wf1ShowStep('wf1Step8');
}

let wf1PrintResult = null;

// ---- STEP 8: Post-Print ----

function wf1RenderPostPrint() {
  const content = document.getElementById('wf1PostPrintContent');
  const result = wf1PrintResult;
  if (!result) { content.innerHTML = '<p>Error: no print result</p>'; return; }
  
  let sheetDetailHtml = '';
  if (result.isMultiSheet) {
    sheetDetailHtml = '<div class="wf1-postprint-detail">Printed across ' + result.sheetResults.length + ' sheets:</div>' +
      '<div class="wf1-postprint-sheets">';
    result.sheetResults.forEach(function(sr) {
      const sh = sheets[sr.sheetId];
      sheetDetailHtml += '<div class="wf1-postprint-sheet-row"><span class="sheet-icon">ðŸ“„</span> "' + escapeHtml(sh ? sh.name : sr.sheetName) + '" â€” ' + sr.count + ' labels</div>';
    });
    sheetDetailHtml += '</div>';
  } else {
    const sh = sheets[result.sheetId];
    const sheetName = sh ? sh.name : 'Unknown';
    sheetDetailHtml = '<div class="wf1-postprint-detail">Printing on "' + escapeHtml(sheetName) + '"</div>';
  }
  
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">ðŸ–¨ï¸</div>' +
    '<div class="wf1-postprint-msg">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' sent to printer</div>' +
    sheetDetailHtml +
    '<div class="wf1-postprint-actions">' +
      '<button class="wf1-postprint-btn primary" onclick="wf1ConfirmPrint(true)">' +
        '<span>âœ…</span><span>Yes, it printed correctly</span>' +
      '</button>' +
      '<button class="wf1-postprint-btn" onclick="wf1ConfirmPrint(false)">' +
        '<span>âŒ</span><span>No, something went wrong â€” don\'t mark as used</span>' +
      '</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
  
  // Hide the Done button until they confirm
  document.getElementById('wf1Step8Actions').style.display = 'none';
}

function wf1ConfirmPrint(success) {
  const result = wf1PrintResult;
  if (!result) return;
  
  if (success) {
    if (result.isMultiSheet) {
      // Multi-sheet: mark positions on all sheets, adjust inventory for new sheets
      let newSheetCount = 0;
      for (const sr of result.sheetResults) {
        markPositionsPrinted(sr.sheetId, sr.positions);
        if (sr.isNew) newSheetCount++;
      }
      // Decrement inventory for all new sheets used
      if (newSheetCount > 0 && inventory[wf1LabelType] && inventory[wf1LabelType].stock > 0) {
        inventory[wf1LabelType].stock = Math.max(0, inventory[wf1LabelType].stock - newSheetCount);
        saveInventory();
        addInventoryEvent(wf1LabelType, 'print', -newSheetCount, inventory[wf1LabelType].stock);
      }
      // Add to print history
      addPrintHistoryEntry({
        textName: 'Batch (' + result.totalLabels + ') across ' + result.sheetResults.length + ' sheets',
        count: result.totalLabels,
        labelType: wf1LabelType,
        sheetId: result.sheetResults[0].sheetId,
        sheetName: result.sheetResults.map(function(sr) { return sheets[sr.sheetId] ? sheets[sr.sheetId].name : sr.sheetName; }).join(', '),
        lines: null,
        textId: null
      });
    } else {
      const sh = sheets[result.sheetId];
      
      // Decrement inventory on new sheet
      if (result.isNewSheet && inventory[wf1LabelType] && inventory[wf1LabelType].stock > 0) {
        inventory[wf1LabelType].stock--;
        saveInventory();
        addInventoryEvent(wf1LabelType, 'print', -1, inventory[wf1LabelType].stock);
      }
      
      // Mark positions as printed
      markPositionsPrinted(result.sheetId, result.positions);
      
      // Add to print history
      let textName;
      if (result.isBatch) {
        textName = 'Batch (' + result.totalLabels + ')';
      } else {
        textName = wf1SelectedSavedTextId ? (getSavedText(wf1SelectedSavedTextId)?.name) : generateContentName(wf1ContentLines, wf1LabelType);
      }
      addPrintHistoryEntry({
        textName: textName || 'Custom text',
        count: result.totalLabels,
        labelType: wf1LabelType,
        sheetId: result.sheetId,
        sheetName: sh ? sh.name : 'Unknown',
        lines: result.isBatch ? null : wf1ContentLines,
        textId: wf1SelectedSavedTextId || null
      });
    }
    
    // Show post-print options
    wf1ShowPostPrintOptions();
    
  } else {
    // Cancelled
    if (result.isMultiSheet) {
      // Delete all newly created sheets
      for (const sr of result.sheetResults) {
        if (sr.isNew) {
          delete sheets[sr.sheetId];
        }
      }
      saveSheets();
    } else if (result.isNewSheet) {
      delete sheets[result.sheetId];
      saveSheets();
    }
    
    const content = document.getElementById('wf1PostPrintContent');
    content.innerHTML = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">â†©ï¸</div>' +
      '<div class="wf1-postprint-msg">Print cancelled</div>' +
      '<div class="wf1-postprint-detail">No labels were marked as used.</div>' +
    '</div>';
    
    document.getElementById('wf1Step8Actions').style.display = 'flex';
  }
}

function wf1ShowPostPrintOptions() {
  const result = wf1PrintResult;
  
  // For multi-sheet, show a summary of all sheets used
  if (result.isMultiSheet) {
    const content = document.getElementById('wf1PostPrintContent');
    let detailHtml = '';
    result.sheetResults.forEach(function(sr) {
      const sh = sheets[sr.sheetId];
      const rem = sh ? getRemainingCount(sh) : 0;
      detailHtml += '<div class="wf1-postprint-sheet-row"><span class="sheet-icon">ðŸ“„</span> "' + escapeHtml(sh ? sh.name : sr.sheetName) + '" â€” ' + rem + ' spots remaining</div>';
    });
    
    let html = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">âœ…</div>' +
      '<div class="wf1-postprint-msg">Print confirmed!</div>' +
      '<div class="wf1-postprint-detail">' + result.totalLabels + ' labels printed across ' + result.sheetResults.length + ' sheets.</div>' +
      '<div class="wf1-postprint-sheets">' + detailHtml + '</div>';
    
    // Add save list option for batch multi-sheet jobs
    if (result.isBatch && wf1BatchContent && wf1BatchContent.length > 0) {
      html += '<div class="wf1-postprint-options" style="margin-top:16px;">' +
        '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer;">' +
          '<input type="checkbox" id="wf1PostSaveList" style="margin-top:3px;" checked>' +
          '<div>' +
            '<div style="font-weight:500; color:var(--text);">ðŸ’¾ Save list for reprinting</div>' +
            '<div style="font-size:12px; color:var(--text-muted);">Stores your ' + wf1BatchContent.length + ' labels so you can reprint them later via "Print Something Again"</div>' +
          '</div>' +
        '</label>' +
      '</div>';
    }
    
    html += '</div>';
    content.innerHTML = html;
    document.getElementById('wf1Step8Actions').style.display = 'flex';
    return;
  }
  
  const sh = sheets[result.sheetId];
  const remaining = sh ? getRemainingCount(sh) : 0;
  const lps = LABEL_TYPES[wf1LabelType].cols * LABEL_TYPES[wf1LabelType].rows;
  
  const content = document.getElementById('wf1PostPrintContent');
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">âœ…</div>' +
    '<div class="wf1-postprint-msg">Print confirmed!</div>' +
    '<div class="wf1-postprint-detail">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' printed. "' + escapeHtml(sh ? sh.name : '') + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' remaining.</div>';
  
  // Build checkbox options
  const hasLinkOption = !result.isBatch && remaining > 0;
  const hasSplitOption = remaining > 0 && remaining < lps;
  const hasSaveListOption = result.isBatch && wf1BatchContent && wf1BatchContent.length > 0;
  
  if (hasLinkOption || hasSplitOption || hasSaveListOption) {
    html += '<div class="wf1-postprint-options" style="margin-top:16px;">';
    
    // Save list option for batch jobs
    if (hasSaveListOption) {
      html += '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer; margin-bottom:8px;">' +
        '<input type="checkbox" id="wf1PostSaveList" style="margin-top:3px;" checked>' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">ðŸ’¾ Save list for reprinting</div>' +
          '<div style="font-size:12px; color:var(--text-muted);">Stores your ' + wf1BatchContent.length + ' labels so you can reprint them later via "Print Something Again"</div>' +
        '</div>' +
      '</label>';
    }
    
    if (hasLinkOption) {
      html += '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer; margin-bottom:8px;">' +
        '<input type="checkbox" id="wf1PostLinkContent" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">ðŸ”— Link content to this sheet</div>' +
          '<div style="font-size:12px; color:var(--text-muted);">Makes reprinting easier â€” use "Print Something Again" next time</div>' +
        '</div>' +
      '</label>';
    }
    
    if (hasSplitOption) {
      html += '<label class="wf1-postprint-checkbox" style="display:flex; align-items:flex-start; gap:10px; padding:10px; background:var(--surface-alt); border:1px solid var(--border); border-radius:var(--radius-sm); cursor:pointer;">' +
        '<input type="checkbox" id="wf1PostSplitSheet" style="margin-top:3px;">' +
        '<div>' +
          '<div style="font-weight:500; color:var(--text);">âœ‚ï¸ Split remaining ' + remaining + ' labels into new sheet</div>' +
          '<div style="font-size:12px; color:var(--text-muted);">Physically cut off the unused labels and track them separately. Useful if you want to store the remaining labels in a different location or use them for a different purpose.</div>' +
        '</div>' +
      '</label>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  content.innerHTML = html;
  
  document.getElementById('wf1Step8Actions').style.display = 'flex';
}

function wf1LinkContent() {
  const result = wf1PrintResult;
  if (!result) return;
  
  // Use existing linkContentToSheet logic adapted for WF1
  const sh = sheets[result.sheetId];
  if (!sh) return;
  
  let textId = wf1SelectedSavedTextId;
  
  // Save content if not already saved
  if (!textId) {
    const newText = {
      id: generateId('text'),
      name: generateContentName(wf1ContentLines, wf1LabelType),
      text: serializeLines(wf1ContentLines.map(function(l) {
        return { text: l.text, align: l.align, fontSize: l.fontSize, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' };
      })),
      alignV: 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now()
    };
    savedTexts.push(newText);
    saveSavedTexts();
    textId = newText.id;
  }
  
  // Link to sheet
  if (!sh.texts) sh.texts = {};
  if (!sh.texts[textId]) {
    sh.texts[textId] = { qty: 0, placement: 'next' };
  }
  saveSheets();
  
  showToast('Content linked! Use "Print Something Again" next time.', 'success');
  
  // Update display
  wf1ShowPostPrintOptions();
}

// G3: Print a sheet identification label on the back of a physical sheet
function printSheetLabel(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) { showToast('Sheet not found', 'error'); return; }
  const spec = LABEL_TYPES[sh.labelType];
  if (!spec) return;

  const lps = spec.cols * spec.rows;
  const printed = new Set(sh.printed || []);
  const remaining = lps - printed.size;
  const createdDate = new Date(sh.createdAt || Date.now()).toLocaleDateString();

  // Build a simple centered identification label that prints on standard letter paper
  // Uses a centered box â€” user flips the sheet and feeds it back through
  const deepLinkUrl = window.location.origin + window.location.pathname + '?action=openSheet&sheetId=' + encodeURIComponent(sheetId);

  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; width: 8.5in; height: 11in; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif; }';
  html += '.id-label { border: 2px solid #333; border-radius: 8px; padding: 24px 32px; text-align: center; max-width: 4in; }';
  html += '.id-label h2 { margin: 0 0 6px; font-size: 18px; }';
  html += '.id-label .type { font-size: 14px; color: #555; margin-bottom: 12px; }';
  html += '.id-label .details { font-size: 11px; color: #777; margin-top: 10px; line-height: 1.5; }';
  html += '.id-label .id-code { font-family: monospace; font-size: 10px; color: #999; margin-top: 8px; word-break: break-all; }';
  html += '</style></head><body>';
  html += '<div class="id-label">';
  html += '<h2>' + escapeHtml(sh.name) + '</h2>';
  html += '<div class="type">' + sh.labelType + ' â€” ' + escapeHtml(spec.desc) + '</div>';
  html += '<div style="font-size:13px;">' + remaining + ' of ' + lps + ' labels available</div>';
  html += '<div class="details">Created: ' + createdDate + '<br>Sheet count: ' + (sh.sheetCount || 1) + '</div>';
  html += '<div class="id-code">' + sheetId + '</div>';
  html += '</div>';
  html += '</body></html>';

  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(html);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
}

function wf1PrintBackLabel() {
  const result = wf1PrintResult;
  if (!result) return;
  
  printSheetLabel(result.sheetId);
  
  // Mark as having back label
  if (sheets[result.sheetId]) {
    sheets[result.sheetId].hasBackLabel = true;
    saveSheets();
  }
  
  showToast('Sheet ID label sent to printer', 'success');
}

function wf1SplitRemaining() {
  const result = wf1PrintResult;
  if (!result) return;
  
  showSplitDialog(result.sheetId);
}

// ---- Data Model Updates (G1, G4, G5 fixes) ----

// Update markPositionsPrinted to also set lastUsedAt (G1 fix)
const _originalMarkPositionsPrinted = markPositionsPrinted;
markPositionsPrinted = function(sheetId, positions) {
  _originalMarkPositionsPrinted(sheetId, positions);
  if (sheets[sheetId]) {
    sheets[sheetId].lastUsedAt = Date.now();
    saveSheets();
  }
};

// Update createSheet to include new fields (G4, G5)
const _originalCreateSheet = createSheet;
createSheet = function(name, labelType, sheetCount = 1, note = '') {
  const id = _originalCreateSheet(name, labelType, sheetCount, note);
  if (sheets[id]) {
    sheets[id].lastUsedAt = null;
    sheets[id].hasBackLabel = false;
    sheets[id].retired = false;
    sheets[id].retiredAt = null;
    saveSheets();
  }
  return id;
};


// ============================================================================
// WF2: PRINT SOMETHING AGAIN â€” Reprint Workflow
// ============================================================================
// Steps: 1=SelectContent, 2=Quantity, 3=SheetValidation, 4=Preview, 5=PostPrint

let wf2Step = 1;
let wf2SelectedItem = null; // { type: 'dedicated'|'history'|'saved', id, textId, sheetId, labelType, lines, lastQty, textName }
let wf2Quantity = 1;
let wf2SelectedSheet = null; // { id, isNew }
let wf2LabelType = null;
let wf2ContentLines = [];
let wf2PrintResult = null;
let wf2SearchQuery = '';

const WF2_TOTAL_STEPS = 5;

function wf2Start() {
  // Block satellite
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  // Reset state
  wf2Step = 1;
  wf2SelectedItem = null;
  wf2Quantity = 1;
  wf2SelectedSheet = null;
  wf2LabelType = null;
  wf2ContentLines = [];
  wf2PrintResult = null;
  wf2SearchQuery = '';
  
  // Check if we have anything to reprint
  const hasDedicated = wf2GetDedicatedSheetItems().length > 0;
  const hasHistory = printHistory.length > 0;
  const hasSaved = getTexts().length > 0;
  
  if (!hasDedicated && !hasHistory && !hasSaved) {
    showToast('Nothing to reprint yet. Print something new first!', 'info');
    return;
  }
  
  // Render and show
  wf2RenderContentSelector();
  wf2UpdateProgress();
  showWizard('wf2Wizard');
  wf2ShowStep('wf2Step1');
}

function wf2Close() {
  closeWizard('wf2Wizard');
  wf2Step = 1;
}

function wf2ShowStep(stepId) {
  const wizard = document.getElementById('wf2Wizard');
  wizard.querySelectorAll('.wizard-step').forEach(s => s.classList.remove('active'));
  document.getElementById(stepId).classList.add('active');
  wf2UpdateProgress();
}

function wf2UpdateProgress() {
  let html = '';
  for (let i = 1; i <= WF2_TOTAL_STEPS; i++) {
    let cls = 'wf2-progress-dot';
    if (i === wf2Step) cls += ' active';
    else if (i < wf2Step) cls += ' done';
    html += '<div class="' + cls + '"></div>';
  }
  document.getElementById('wf2Progress').innerHTML = html;
}

function wf2Back() {
  if (wf2Step <= 1) {
    wf2Close();
    return;
  }
  wf2Step--;
  wf2ShowStep('wf2Step' + wf2Step);
}

// --- Helper: Get dedicated sheet items ---
function wf2GetDedicatedSheetItems() {
  const items = [];
  for (const sh of Object.values(sheets)) {
    if (sh.retired || !sh.texts) continue;
    const textIds = Object.keys(sh.texts);
    if (textIds.length === 0) continue;
    for (const textId of textIds) {
      const text = getSavedText(textId);
      if (!text) continue;
      const remaining = getRemainingCount(sh);
      items.push({
        type: 'dedicated',
        id: 'ded_' + sh.id + '_' + textId,
        textId: textId,
        sheetId: sh.id,
        sheetName: sh.name,
        labelType: sh.labelType,
        textName: text.name || getFlatTextFromSaved(text),
        remaining: remaining,
        lastUsedAt: sh.lastUsedAt,
        text: text
      });
    }
  }
  return items;
}

// Helper to get flat text preview from a saved text object
function getFlatTextFromSaved(t) {
  if (t.text) {
    // Parse serialized lines
    try {
      const lines = t.text.split('\n').map(l => {
        const parts = l.split('||');
        return parts[0] || '';
      });
      return lines.filter(l => l.trim()).join(' / ').substring(0, 40);
    } catch(e) { return t.text.substring(0, 40); }
  }
  return 'Label';
}

// --- Step 1: Select content ---
function wf2RenderContentSelector() {
  const container = document.getElementById('wf2ContentSelector');
  const dedicated = wf2GetDedicatedSheetItems();
  const allSaved = getTexts();
  
  let html = '';
  
  // Search bar (show if we have enough items)
  if (dedicated.length + printHistory.length + allSaved.length > 5) {
    html += '<div class="wf2-search-row">' +
      '<input type="text" class="wf2-search-input" placeholder="Search..." ' +
        'id="wf2SearchInput" oninput="wf2FilterContent(this.value)">' +
    '</div>';
  }
  
  html += '<div class="wf2-content-list" id="wf2ContentList">';
  html += wf2BuildContentListHtml('');
  html += '</div>';
  
  container.innerHTML = html;
  
  // Update next button state
  document.getElementById('wf2Step1NextBtn').disabled = !wf2SelectedItem;
}

function wf2BuildContentListHtml(filter) {
  const dedicated = wf2GetDedicatedSheetItems();
  const allSaved = getTexts();
  const f = filter.toLowerCase().trim();
  let html = '';
  let hasResults = false;
  
  // Section 1: Dedicated sheet assignments (quick reprints)
  const filteredDed = dedicated.filter(d => !f || d.textName.toLowerCase().includes(f) || d.sheetName.toLowerCase().includes(f));
  if (filteredDed.length > 0) {
    html += '<div class="wf2-section-label">ðŸ“Œ Quick Reprint â€” Linked to Sheets</div>';
    for (const item of filteredDed) {
      const selected = wf2SelectedItem && wf2SelectedItem.id === item.id ? ' selected' : '';
      const remaining = item.remaining;
      const spec = LABEL_TYPES[item.labelType];
      const typeName = spec ? spec.name : item.labelType;
      
      // Get last print info from history
      const histMatch = printHistory.find(e => e.textId === item.textId || e.sheetId === item.sheetId);
      const lastQty = histMatch ? histMatch.count : null;
      const lastDate = histMatch ? new Date(histMatch.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : null;
      
      // Build context line
      let contextLine = 'On "' + escapeHtml(item.sheetName) + '" Â· ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' left Â· ' + typeName;
      if (lastQty && lastDate) {
        contextLine += '<br><span style="color:var(--text-muted);">Last printed: ' + lastQty + ' on ' + lastDate + '</span>';
      }
      
      // Can we do quick reprint?
      const canQuickPrint = lastQty && remaining >= lastQty;
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(item.id) + '\', \'dedicated\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(item.id) + '\', \'dedicated\')">' +
        '<div class="wf2-content-card-icon">ðŸ·ï¸</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(item.textName) + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
        '<div class="wf2-content-card-actions">' +
          (canQuickPrint ? '<button class="wf2-quick-btn" onclick="event.stopPropagation(); wf2QuickReprint(\'' + escapeAttr(item.id) + '\', \'dedicated\', ' + lastQty + ')" title="Print ' + lastQty + ' label' + (lastQty !== 1 ? 's' : '') + ' immediately">âš¡ Print ' + lastQty + '</button>' : '') +
          '<div class="wf2-content-card-badge dedicated">Linked</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  // Section 2: Recent print history
  // Filter out batch entries that don't have saved list data (they can't be reprinted)
  const filteredHist = printHistory.filter(e => {
    // Apply search filter
    if (f && !(
      (e.textName && e.textName.toLowerCase().includes(f)) ||
      (e.sheetName && e.sheetName.toLowerCase().includes(f))
    )) return false;
    
    // If it's a batch job, it must have savedListId to be reprintable
    if (e.textName && e.textName.startsWith('Batch')) {
      return e.savedListId && getSavedList(e.savedListId);
    }
    
    return true;
  }).slice(0, 10);
  if (filteredHist.length > 0) {
    html += '<div class="wf2-section-label">ðŸ• Recent Prints</div>';
    for (const entry of filteredHist) {
      const id = 'hist_' + entry.id;
      const selected = wf2SelectedItem && wf2SelectedItem.id === id ? ' selected' : '';
      const date = new Date(entry.timestamp);
      const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      const count = entry.count || 1;
      const spec = LABEL_TYPES[entry.labelType];
      const typeName = spec ? spec.name : entry.labelType;
      
      // Check if this is a batch job with saved list
      const isBatch = entry.textName && entry.textName.startsWith('Batch');
      const savedList = entry.savedListId ? getSavedList(entry.savedListId) : null;
      
      // Check if same sheet still exists and has room
      const sh = entry.sheetId ? sheets[entry.sheetId] : null;
      const sheetRemaining = sh ? getRemainingCount(sh) : 0;
      const canQuickPrint = !isBatch && sh && !sh.retired && sheetRemaining >= count;
      
      // Build context
      let contextLine = dateStr + ' Â· ' + count + ' label' + (count !== 1 ? 's' : '') + ' Â· ' + typeName;
      if (savedList) {
        contextLine += '<br><span style="color:var(--accent);">ðŸ“‹ List saved â€” ' + savedList.content.length + ' items</span>';
      } else if (sh && !sh.retired) {
        contextLine += '<br><span style="color:var(--text-muted);">Sheet: "' + escapeHtml(sh.name) + '" (' + sheetRemaining + ' spot' + (sheetRemaining !== 1 ? 's' : '') + ' left)</span>';
      }
      
      // Icon based on type
      const icon = isBatch ? 'ðŸ“‹' : 'ðŸ“œ';
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(id) + '\', \'history\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(id) + '\', \'history\')">' +
        '<div class="wf2-content-card-icon">' + icon + '</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
        '<div class="wf2-content-card-actions">' +
          (canQuickPrint ? '<button class="wf2-quick-btn" onclick="event.stopPropagation(); wf2QuickReprint(\'' + escapeAttr(id) + '\', \'history\', ' + count + ')" title="Print ' + count + ' label' + (count !== 1 ? 's' : '') + ' on same sheet">âš¡ Same</button>' : '') +
          '<div class="wf2-content-card-badge history">' + (isBatch ? 'Batch' : 'History') + '</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  // Section 3: All saved content
  const filteredSaved = allSaved.filter(t => !f || 
    (t.name && t.name.toLowerCase().includes(f)) ||
    (t.text && t.text.toLowerCase().includes(f))
  );
  if (filteredSaved.length > 0) {
    html += '<div class="wf2-section-label">ðŸ’¾ Saved Content</div>';
    for (const t of filteredSaved) {
      const id = 'saved_' + t.id;
      const selected = wf2SelectedItem && wf2SelectedItem.id === id ? ' selected' : '';
      const preview = getFlatTextFromSaved(t);
      
      // Find last print for this content
      const histMatch = printHistory.find(e => e.textId === t.id);
      let contextLine = escapeHtml(preview);
      if (histMatch) {
        const histDate = new Date(histMatch.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        contextLine += '<br><span style="color:var(--text-muted);">Last printed: ' + histMatch.count + ' on ' + histDate + '</span>';
      }
      
      html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectItem(\'' + escapeAttr(id) + '\', \'saved\')" ondblclick="wf2SelectItemAndAdvance(\'' + escapeAttr(id) + '\', \'saved\')">' +
        '<div class="wf2-content-card-icon">ðŸ“</div>' +
        '<div class="wf2-content-card-info">' +
          '<div class="wf2-content-card-title">' + escapeHtml(t.name || 'Untitled') + '</div>' +
          '<div class="wf2-content-card-meta">' + contextLine + '</div>' +
        '</div>' +
      '</div>';
    }
    hasResults = true;
  }
  
  if (!hasResults) {
    html += '<div class="wf2-empty">' +
      '<div class="wf2-empty-icon">ðŸ”</div>' +
      '<div class="wf2-empty-text">' + (f ? 'No results for "' + escapeHtml(f) + '"' : 'Nothing to reprint yet') + '</div>' +
    '</div>';
  }
  
  return html;
}

// Quick reprint: skip all questions, go directly to preview with pre-filled values
function wf2QuickReprint(id, type, qty) {
  // Select the item first
  wf2SelectItem(id, type);
  
  // Set quantity
  wf2Quantity = qty;
  wf2ContentLines = wf2SelectedItem.lines;
  
  // Set the sheet
  if (wf2SelectedItem.sheetId && sheets[wf2SelectedItem.sheetId]) {
    wf2SelectedSheet = sheets[wf2SelectedItem.sheetId];
  } else {
    // Find a matching sheet with room
    const matchingSheets = Object.values(sheets).filter(s => 
      s.labelType === wf2LabelType && !s.retired && getRemainingCount(s) >= qty
    );
    wf2SelectedSheet = matchingSheets.length > 0 ? matchingSheets[0] : null;
  }
  
  if (!wf2SelectedSheet) {
    // No sheet available, fall back to regular flow
    showToast('No sheet with enough room available', 'warning');
    wf2ToStep2();
    return;
  }
  
  // Jump directly to preview (Step 4)
  wf2Step = 4;
  wf2RenderPreview();
  wf2ShowStep('wf2Step4');
}

function wf2FilterContent(query) {
  wf2SearchQuery = query;
  const list = document.getElementById('wf2ContentList');
  if (list) list.innerHTML = wf2BuildContentListHtml(query);
}

function wf2SelectItem(id, type) {
  if (type === 'dedicated') {
    const items = wf2GetDedicatedSheetItems();
    const item = items.find(d => d.id === id);
    if (!item) return;
    
    // Resolve content lines from saved text
    const text = item.text;
    const lines = wf2ResolveLinesFromSavedText(text);
    
    wf2SelectedItem = {
      type: 'dedicated',
      id: id,
      textId: item.textId,
      sheetId: item.sheetId,
      labelType: item.labelType,
      lines: lines,
      lastQty: null, // Look up from history
      textName: item.textName
    };
    
    // Try to find last quantity from print history for this text
    const histMatch = printHistory.find(e => e.textId === item.textId || e.sheetId === item.sheetId);
    if (histMatch) wf2SelectedItem.lastQty = histMatch.count;
    
  } else if (type === 'history') {
    const entryId = id.replace('hist_', '');
    const entry = printHistory.find(e => e.id === entryId);
    if (!entry) return;
    
    // Check if this is a batch job with saved list
    const isBatch = entry.textName && entry.textName.startsWith('Batch');
    const savedList = entry.savedListId ? getSavedList(entry.savedListId) : null;
    
    if (isBatch && savedList) {
      // Batch job with saved list - load batch content
      wf2SelectedItem = {
        type: 'batch',
        id: id,
        savedListId: entry.savedListId,
        sheetId: entry.sheetId || null,
        labelType: entry.labelType || savedList.labelType || '5160',
        batchContent: savedList.content, // Array of line arrays
        lastQty: entry.count || savedList.content.length,
        textName: entry.textName || 'Batch List'
      };
    } else {
      // Regular history entry
      // Try to get full lines from history entry or reconstruct from saved text
      let lines;
      if (entry.lines && entry.lines.length > 0) {
        lines = entry.lines;
      } else if (entry.textId) {
        const text = getSavedText(entry.textId);
        if (text) lines = wf2ResolveLinesFromSavedText(text);
      }
      if (!lines || lines.length === 0) {
        lines = [{ text: entry.textName || 'Label', align: 'left', fontSize: 11 }];
      }
      
      wf2SelectedItem = {
        type: 'history',
        id: id,
        textId: entry.textId || null,
        sheetId: entry.sheetId || null,
        labelType: entry.labelType || '5160',
        lines: lines,
        lastQty: entry.count || 1,
        textName: entry.textName || 'Labels'
      };
    }
    
  } else if (type === 'saved') {
    const textId = id.replace('saved_', '');
    const text = getSavedText(textId);
    if (!text) return;
    
    const lines = wf2ResolveLinesFromSavedText(text);
    
    // Find which label type this was last printed with
    const histMatch = printHistory.find(e => e.textId === textId);
    
    wf2SelectedItem = {
      type: 'saved',
      id: id,
      textId: textId,
      sheetId: histMatch ? histMatch.sheetId : null,
      labelType: histMatch ? histMatch.labelType : (settings.lastLabelType || '5160'),
      lines: lines,
      lastQty: histMatch ? histMatch.count : null,
      textName: text.name || getFlatTextFromSaved(text)
    };
  }
  
  wf2LabelType = wf2SelectedItem.labelType;
  
  // Re-render list to show selection
  const list = document.getElementById('wf2ContentList');
  if (list) list.innerHTML = wf2BuildContentListHtml(wf2SearchQuery);
  
  // Enable next button
  document.getElementById('wf2Step1NextBtn').disabled = false;
}

// Resolve a saved text object into lines array for printing
function wf2ResolveLinesFromSavedText(text) {
  if (!text || !text.text) return [{ text: 'Label', align: 'left', fontSize: 11 }];
  
  // Use the standard deserializeLines function for correct parsing
  try {
    return deserializeLines(text.text);
  } catch(e) {
    return [{ text: text.text.substring(0, 100), align: 'left', fontSize: 11 }];
  }
}

// T1: Double-click to select item and advance
function wf2SelectItemAndAdvance(id, type) {
  wf2SelectItem(id, type);
  setTimeout(() => wf2ToStep2(), 100);
}

// --- Step 2: Quantity check ---
function wf2ToStep2() {
  if (!wf2SelectedItem) return;
  
  wf2Step = 2;
  
  // For batch items, skip quantity step - they reprint the whole list
  if (wf2SelectedItem.type === 'batch') {
    wf2Quantity = wf2SelectedItem.batchContent.length;
    wf2BatchContent = wf2SelectedItem.batchContent;
    wf2IsBatchReprint = true;
    wf2RenderBatchQuantityCheck();
  } else {
    wf2Quantity = wf2SelectedItem.lastQty || 1;
    wf2ContentLines = wf2SelectedItem.lines;
    wf2IsBatchReprint = false;
    wf2RenderQuantityCheck();
  }
  
  wf2ShowStep('wf2Step2');
}

// Track batch reprint state
let wf2BatchContent = [];
let wf2IsBatchReprint = false;

// Render quantity check for batch reprints
function wf2RenderBatchQuantityCheck() {
  const container = document.getElementById('wf2QuantityContent');
  const item = wf2SelectedItem;
  const count = item.batchContent.length;
  const spec = LABEL_TYPES[wf2LabelType];
  const perSheet = spec ? (spec.cols * spec.rows) : 30;
  const sheetsNeeded = Math.ceil(count / perSheet);
  
  const html = '<div class="wf2-qty-section">' +
    '<div class="wf2-qty-prompt">Reprinting saved list with <strong>' + count + ' labels</strong></div>' +
    '<div class="wf2-batch-reprint-preview">' +
      '<div class="wf2-batch-preview-scroll" style="max-height:200px;">' +
        item.batchContent.slice(0, 5).map(function(lines, i) {
          return '<div class="wf2-batch-preview-item">' + 
            lines.map(function(l) { return '<div>' + escapeHtml(l.text) + '</div>'; }).join('') +
          '</div>';
        }).join('') +
        (count > 5 ? '<div style="text-align:center;color:var(--text-muted);font-size:12px;padding:8px;">...and ' + (count - 5) + ' more</div>' : '') +
      '</div>' +
    '</div>' +
    '<div class="wf2-qty-hint">' + count + ' labels = ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : '') + ' of ' + (spec ? spec.name : wf2LabelType) + '</div>' +
  '</div>';
  
  container.innerHTML = html;
}

function wf2RenderQuantityCheck() {
  const container = document.getElementById('wf2QuantityContent');
  const item = wf2SelectedItem;
  const spec = LABEL_TYPES[wf2LabelType];
  const labelsPerSheet = spec ? (spec.cols * spec.rows) : 30;
  
  let promptHtml = '';
  if (item.lastQty) {
    promptHtml = '<div class="wf2-qty-prompt">Last time you printed <strong>' + item.lastQty + '</strong> of these. Same amount?</div>';
  } else {
    promptHtml = '<div class="wf2-qty-prompt">How many copies of <strong>"' + escapeHtml(item.textName) + '"</strong>?</div>';
  }
  
  const html = '<div class="wf2-qty-section">' +
    promptHtml +
    '<div class="wf2-qty-controls">' +
      '<button class="wf2-qty-btn" id="wf2QtyMinus" onclick="wf2AdjustQty(-1)"' + (wf2Quantity <= 1 ? ' disabled' : '') + '>âˆ’</button>' +
      '<div class="wf2-qty-value" id="wf2QtyValue">' + wf2Quantity + '</div>' +
      '<button class="wf2-qty-btn" onclick="wf2AdjustQty(1)">+</button>' +
    '</div>' +
    '<div class="wf2-qty-hint" id="wf2QtyHint">' + wf2GetQtyHint() + '</div>' +
  '</div>';
  
  container.innerHTML = html;
}

function wf2AdjustQty(delta) {
  wf2Quantity = Math.max(1, wf2Quantity + delta);
  document.getElementById('wf2QtyValue').textContent = wf2Quantity;
  document.getElementById('wf2QtyMinus').disabled = wf2Quantity <= 1;
  document.getElementById('wf2QtyHint').textContent = wf2GetQtyHint();
}

function wf2GetQtyHint() {
  const spec = LABEL_TYPES[wf2LabelType];
  if (!spec) return '';
  const perSheet = spec.cols * spec.rows;
  if (wf2Quantity <= perSheet) {
    return wf2Quantity + ' label' + (wf2Quantity !== 1 ? 's' : '') + ' (' + spec.name + ', ' + perSheet + ' per sheet)';
  }
  const sheetsNeeded = Math.ceil(wf2Quantity / perSheet);
  return wf2Quantity + ' labels = ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : '') + ' of ' + spec.name;
}

// --- Step 3: Sheet validation ---
function wf2ToStep3() {
  // T8: Skip sheet picker if we already know the sheet and it's ready
  const item = wf2SelectedItem;
  if (item && item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    const sh = sheets[item.sheetId];
    const remaining = getRemainingCount(sh);
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    const isStale = daysSince !== null && daysSince > 30;
    
    // Auto-skip if: has room AND not stale
    if (remaining >= wf2Quantity && !isStale) {
      wf2SelectedSheet = { id: item.sheetId, isNew: false };
      wf2Step = 4; // Skip to preview
      wf2RenderPreview();
      wf2ShowStep('wf2Step4');
      return;
    }
  }
  
  wf2Step = 3;
  wf2RenderSheetCheck();
  wf2ShowStep('wf2Step3');
}

function wf2RenderSheetCheck() {
  const container = document.getElementById('wf2SheetContent');
  const item = wf2SelectedItem;
  
  // Find matching sheets for this label type
  // T9: Filter out dedicated sheets that are for OTHER content (not this textId)
  const matchingSheets = Object.values(sheets).filter(s => {
    if (s.labelType !== wf2LabelType || s.retired) return false;
    
    // Check if this is a dedicated sheet
    const isDedicated = s.texts && Object.keys(s.texts).length > 0;
    if (isDedicated) {
      // T9: Only show dedicated sheets if they contain THIS content
      // (i.e., the textId we're reprinting is already on this sheet)
      const textIds = Object.keys(s.texts);
      const isForThisContent = item.textId && textIds.includes(item.textId);
      if (!isForThisContent) return false; // Hide dedicated sheets for other content
    }
    
    return true;
  });
  
  // Pre-select logic:
  // 1. If dedicated, pre-select the dedicated sheet
  // 2. If history, pre-select last-used sheet
  // 3. Otherwise, let user pick
  let preSelectId = null;
  if (item.type === 'dedicated' && item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    preSelectId = item.sheetId;
  } else if (item.sheetId && sheets[item.sheetId] && !sheets[item.sheetId].retired) {
    preSelectId = item.sheetId;
  }
  
  let html = '';
  
  // Show status message for pre-selected dedicated sheet
  if (preSelectId) {
    const sh = sheets[preSelectId];
    const remaining = getRemainingCount(sh);
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    
    if (remaining >= wf2Quantity) {
      // Enough room
      if (daysSince !== null && daysSince > 30) {
        let staleExtra = '';
        if (!sh.hasBackLabel) {
          staleExtra = ' <button onclick="event.stopPropagation(); wf2PrintIdLabel(\'' + sh.id + '\')" style="background:none;border:none;color:var(--accent);cursor:pointer;font-size:11px;text-decoration:underline;padding:0;margin-left:4px;">Print ID label</button>';
        }
        html += '<div class="wf2-sheet-status warn">' +
          '<div class="wf2-sheet-status-icon">âš ï¸</div>' +
          '<div class="wf2-sheet-status-text">Sheet "' + escapeHtml(sh.name) + '" was last used ' + daysSince + ' days ago. Can you confirm you still have it?' + staleExtra + '</div>' +
        '</div>';
      } else {
        html += '<div class="wf2-sheet-status ok">' +
          '<div class="wf2-sheet-status-icon">âœ…</div>' +
          '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' available â€” plenty of room for ' + wf2Quantity + '.</div>' +
        '</div>';
      }
    } else if (remaining > 0) {
      html += '<div class="wf2-sheet-status warn">' +
        '<div class="wf2-sheet-status-icon">âš ï¸</div>' +
        '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" only has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' but you need ' + wf2Quantity + '. You can print what fits, or pick another sheet.</div>' +
      '</div>';
    } else {
      html += '<div class="wf2-sheet-status error">' +
        '<div class="wf2-sheet-status-icon">âŒ</div>' +
        '<div class="wf2-sheet-status-text">"' + escapeHtml(sh.name) + '" is full. Pick another sheet or create a new one.</div>' +
      '</div>';
      preSelectId = null; // Don't pre-select a full sheet
    }
  }
  
  // Sheet picker list (reuse WF1 sheet picker pattern)
  html += '<div class="wf2-content-list" style="max-height:280px;">';
  
  // Show matching sheets
  for (const sh of matchingSheets) {
    const remaining = getRemainingCount(sh);
    if (remaining <= 0) continue; // Skip full sheets
    
    const selected = (wf2SelectedSheet && wf2SelectedSheet.id === sh.id) || (!wf2SelectedSheet && sh.id === preSelectId) ? ' selected' : '';
    const isDedicated = sh.texts && Object.keys(sh.texts).length > 0;
    const daysSince = sh.lastUsedAt ? Math.floor((Date.now() - sh.lastUsedAt) / (1000 * 60 * 60 * 24)) : null;
    
    let meta = remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' available';
    if (daysSince !== null) {
      meta += ' Â· Last used ' + (daysSince === 0 ? 'today' : daysSince + ' day' + (daysSince !== 1 ? 's' : '') + ' ago');
    }
    
    html += '<div class="wf2-content-card' + selected + '" onclick="wf2SelectSheet(\'' + sh.id + '\')">' +
      '<div class="wf2-content-card-icon">ðŸ“„</div>' +
      '<div class="wf2-content-card-info">' +
        '<div class="wf2-content-card-title">' + escapeHtml(sh.name) + '</div>' +
        '<div class="wf2-content-card-meta">' + meta + '</div>' +
      '</div>' +
      (isDedicated ? '<div class="wf2-content-card-badge dedicated">Dedicated</div>' : '') +
      (daysSince !== null && daysSince > 30 ? '<div class="wf2-content-card-badge history">Stale</div>' : '') +
    '</div>';
  }
  
  // "Create new from stock" option
  const inv = inventory[wf2LabelType];
  const stock = inv ? inv.stock : 0;
  if (stock > 0) {
    const newSelected = wf2SelectedSheet && wf2SelectedSheet.isNew ? ' selected' : '';
    html += '<div class="wf2-content-card' + newSelected + '" onclick="wf2SelectSheet(\'__new__\')">' +
      '<div class="wf2-content-card-icon">âž•</div>' +
      '<div class="wf2-content-card-info">' +
        '<div class="wf2-content-card-title">Create new sheet from stock</div>' +
        '<div class="wf2-content-card-meta">' + stock + ' sheet' + (stock !== 1 ? 's' : '') + ' of ' + wf2LabelType + ' available</div>' +
      '</div>' +
    '</div>';
  }
  
  // No sheets at all
  if (matchingSheets.filter(s => getRemainingCount(s) > 0).length === 0 && stock <= 0) {
    html += '<div class="wf2-empty">' +
      '<div class="wf2-empty-icon">ðŸ“­</div>' +
      '<div class="wf2-empty-text">No sheets available for ' + wf2LabelType + '. Add stock in the Inventory tab first.</div>' +
    '</div>';
  }
  
  html += '</div>';
  container.innerHTML = html;
  
  // Auto-select pre-selected sheet if we have one and haven't manually selected yet
  if (!wf2SelectedSheet && preSelectId && sheets[preSelectId] && getRemainingCount(sheets[preSelectId]) > 0) {
    wf2SelectedSheet = { id: preSelectId, isNew: false };
  }
  
  // If only one option and it fits, auto-select it
  const availableSheets = matchingSheets.filter(s => getRemainingCount(s) > 0);
  if (!wf2SelectedSheet && availableSheets.length === 1 && getRemainingCount(availableSheets[0]) >= wf2Quantity) {
    wf2SelectedSheet = { id: availableSheets[0].id, isNew: false };
  }
  
  document.getElementById('wf2SheetNextBtn').disabled = !wf2SelectedSheet;
}

// G3: Print sheet ID label from WF2 sheet check
function wf2PrintIdLabel(sheetId) {
  printSheetLabel(sheetId);
  if (sheets[sheetId]) {
    sheets[sheetId].hasBackLabel = true;
    saveSheets();
  }
  showToast('Sheet ID label sent to printer', 'success');
  wf2RenderSheetCheck();
}

function wf2SelectSheet(idOrNew) {
  if (idOrNew === '__new__') {
    // Create a new sheet from stock
    const spec = LABEL_TYPES[wf2LabelType];
    const typeName = spec ? spec.name : wf2LabelType;
    const sheetName = typeName + ' ' + new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const newId = createSheet(sheetName, wf2LabelType, 1, '');
    wf2SelectedSheet = { id: newId, isNew: true };
  } else {
    wf2SelectedSheet = { id: idOrNew, isNew: false };
  }
  
  // Re-render to show selection
  wf2RenderSheetCheck();
}

// --- Step 4: Preview & Print ---
function wf2ToStep4() {
  if (!wf2SelectedSheet) return;
  wf2Step = 4;
  wf2RenderPreview();
  wf2ShowStep('wf2Step4');
}

function wf2RenderPreview() {
  const container = document.getElementById('wf2PreviewContent');
  const sh = sheets[wf2SelectedSheet.id];
  if (!sh) { container.innerHTML = '<p>Error: sheet not found</p>'; return; }
  
  const spec = LABEL_TYPES[wf2LabelType];
  const typeName = spec ? spec.name : wf2LabelType;
  const lines = wf2ContentLines;
  
  let html = '<div class="wf1-preview-summary">' +
    '<div class="wf1-preview-stat"><span class="wf1-preview-stat-num">' + wf2Quantity + '</span> label' + (wf2Quantity !== 1 ? 's' : '') + '</div>' +
    '<div class="wf1-preview-stat">on <strong>"' + escapeHtml(sh.name) + '"</strong></div>' +
    '<div class="wf1-preview-stat">' + typeName + '</div>' +
  '</div>';
  
  // Get full label config from saved content if available
  let graphics = null;
  let border = null;
  let barcode = null;
  let alignV = 'center';
  
  if (wf2SelectedItem && wf2SelectedItem.textId) {
    const savedText = getSavedText(wf2SelectedItem.textId);
    if (savedText) {
      graphics = savedText.graphics || null;
      border = savedText.border || null;
      barcode = savedText.barcode || null;
      alignV = savedText.alignV || 'center';
    }
  }
  
  // Use unified label preview with full chrome (graphics, border, barcode, alignV)
  if (lines && lines.length > 0) {
    html += '<div class="wf1-preview-frame">';
    html += renderUnifiedLabelPreview({
      lines: lines,
      graphics: graphics,
      border: border,
      barcode: barcode,
      alignV: alignV,
      labelType: wf2LabelType
    }, { showPlaceholder: false });
    html += '</div>';
  }
  
  // Safari print preview warning
  if (isSafari) {
    html += '<div class="safari-print-notice">ðŸŽ Safari\'s print preview may show labels slightly shifted â€” this is a Safari limitation. The actual printed output will be positioned correctly.</div>';
  }
  
  container.innerHTML = html;
}

function wf2ExecutePrint() {
  const sh = sheets[wf2SelectedSheet.id];
  if (!sh) { showToast('Sheet not found', 'error'); return; }
  
  const spec = LABEL_TYPES[wf2LabelType];
  if (!spec) { showToast('Unknown label type', 'error'); return; }
  
  const lines = wf2ContentLines;
  const qty = wf2Quantity;
  const lps = spec.cols * spec.rows;
  
  // Find available positions
  const printed = new Set(sh.printed || []);
  const positions = [];
  for (let i = 0; i < lps && positions.length < qty; i++) {
    if (!printed.has(i)) positions.push(i);
  }
  
  if (positions.length === 0) {
    showToast('No available positions on this sheet', 'error');
    return;
  }
  
  // Resolve full content from saved text if available (for graphics, borders, alignV)
  let graphics = { left: null, right: null };
  let alignV = 'center';
  let border = null;
  let resolvedLines = lines;
  
  if (wf2SelectedItem && wf2SelectedItem.textId) {
    const savedText = getSavedText(wf2SelectedItem.textId);
    if (savedText) {
      resolvedLines = deserializeLines(savedText.text);
      graphics = savedText.graphics || { left: null, right: null };
      alignV = savedText.alignV || 'center';
      border = savedText.border || null;
    }
  }
  
  // Build manifest matching printFromSheet pattern
  const printManifest = positions.map(function(idx) {
    return { idx: idx, lines: resolvedLines, graphics: graphics, alignV: alignV, border: border };
  });
  
  // Use the canonical buildSheetPrintHtml (same as sheets tab print button)
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Print via iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  setTimeout(function() { document.body.removeChild(iframe); }, 1000);
  
  // Store result for post-print
  wf2PrintResult = {
    sheetId: wf2SelectedSheet.id,
    isNewSheet: wf2SelectedSheet.isNew,
    positions: positions,
    totalLabels: positions.length,
    isBatch: false
  };
  
  // Go to post-print step
  wf2Step = 5;
  wf2RenderPostPrint();
  wf2ShowStep('wf2Step5');
}

// --- Step 5: Post-print ---
function wf2RenderPostPrint() {
  const content = document.getElementById('wf2PostPrintContent');
  const result = wf2PrintResult;
  if (!result) { content.innerHTML = '<p>Error: no print result</p>'; return; }
  
  const sh = sheets[result.sheetId];
  const sheetName = sh ? sh.name : 'Unknown';
  
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">ðŸ–¨ï¸</div>' +
    '<div class="wf1-postprint-msg">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' sent to printer</div>' +
    '<div class="wf1-postprint-detail">Printing on "' + escapeHtml(sheetName) + '"</div>' +
    '<div class="wf1-postprint-actions">' +
      '<button class="wf1-postprint-btn primary" onclick="wf2ConfirmPrint(true)">' +
        '<span>âœ…</span><span>Yes, it printed correctly</span>' +
      '</button>' +
      '<button class="wf1-postprint-btn" onclick="wf2ConfirmPrint(false)">' +
        '<span>âŒ</span><span>No, something went wrong â€” don\'t mark as used</span>' +
      '</button>' +
    '</div>' +
  '</div>';
  
  content.innerHTML = html;
  document.getElementById('wf2Step5Actions').style.display = 'none';
}

function wf2ConfirmPrint(success) {
  const result = wf2PrintResult;
  if (!result) return;
  
  const sh = sheets[result.sheetId];
  
  if (success) {
    // Decrement inventory on new sheet
    if (result.isNewSheet && inventory[wf2LabelType] && inventory[wf2LabelType].stock > 0) {
      inventory[wf2LabelType].stock--;
      saveInventory();
      addInventoryEvent(wf2LabelType, 'print', -1, inventory[wf2LabelType].stock);
    }
    
    // Mark positions as printed
    markPositionsPrinted(result.sheetId, result.positions);
    
    // Add to print history (G6 fix: store full lines, G7 fix: store quantity)
    const textName = wf2SelectedItem ? wf2SelectedItem.textName : 'Reprint';
    addPrintHistoryEntry({
      textName: textName,
      count: result.totalLabels,
      labelType: wf2LabelType,
      sheetId: result.sheetId,
      sheetName: sh ? sh.name : 'Unknown',
      lines: wf2ContentLines,
      textId: wf2SelectedItem ? wf2SelectedItem.textId : null
    });
    
    wf2ShowPostPrintOptions();
    
  } else {
    // Cancelled â€” delete new sheet if we created one
    if (result.isNewSheet) {
      delete sheets[result.sheetId];
      saveSheets();
    }
    
    const content = document.getElementById('wf2PostPrintContent');
    content.innerHTML = '<div class="wf1-postprint">' +
      '<div class="wf1-postprint-icon">â†©ï¸</div>' +
      '<div class="wf1-postprint-msg">Print cancelled</div>' +
      '<div class="wf1-postprint-detail">No labels were marked as used.</div>' +
    '</div>';
    
    document.getElementById('wf2Step5Actions').style.display = 'flex';
  }
}

function wf2ShowPostPrintOptions() {
  const result = wf2PrintResult;
  const sh = sheets[result.sheetId];
  const remaining = sh ? getRemainingCount(sh) : 0;
  
  const content = document.getElementById('wf2PostPrintContent');
  let html = '<div class="wf1-postprint">' +
    '<div class="wf1-postprint-icon">âœ…</div>' +
    '<div class="wf1-postprint-msg">Print confirmed!</div>' +
    '<div class="wf1-postprint-detail">' + result.totalLabels + ' label' + (result.totalLabels !== 1 ? 's' : '') + ' printed. "' + escapeHtml(sh ? sh.name : '') + '" has ' + remaining + ' spot' + (remaining !== 1 ? 's' : '') + ' remaining.</div>';
  
  html += '<div class="wf1-postprint-actions">';
  
  // Offer QR back label if sheet doesn't have one
  if (sh && !sh.hasBackLabel) {
    html += '<button class="wf1-postprint-btn" onclick="wf2PrintBackLabel()">' +
      '<span>ðŸ·ï¸</span><span>Print an ID label on the back of this sheet</span>' +
    '</button>';
  }
  
  // Offer split if partially used
  if (remaining > 0 && remaining < (LABEL_TYPES[wf2LabelType].cols * LABEL_TYPES[wf2LabelType].rows)) {
    html += '<button class="wf1-postprint-btn" onclick="wf2SplitRemaining()">' +
      '<span>âœ‚ï¸</span><span>Split remaining ' + remaining + ' labels into a new sheet</span>' +
    '</button>';
  }
  
  html += '</div></div>';
  content.innerHTML = html;
  
  document.getElementById('wf2Step5Actions').style.display = 'flex';
}

function wf2PrintBackLabel() {
  const result = wf2PrintResult;
  if (!result) return;
  
  printSheetLabel(result.sheetId);
  
  if (sheets[result.sheetId]) {
    sheets[result.sheetId].hasBackLabel = true;
    saveSheets();
  }
  
  showToast('Sheet ID label sent to printer', 'success');
}

function wf2SplitRemaining() {
  const result = wf2PrintResult;
  if (!result) return;
  showSplitDialog(result.sheetId);
}


// ========== WORKFLOWS ==========
// ============================================================================
// HISTORY REPRINT â€” Routes through WF2
// ============================================================================

function reprintFromHistory(entryId) {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  const entry = printHistory.find(function(e) { return e.id === entryId; });
  if (!entry) return;
  
  // Route through WF2 â€” start it, then auto-select this history entry
  wf2Start();
  setTimeout(function() {
    wf2SelectItem('hist_' + entry.id, 'history');
  }, 50);
}

// ============================================================================
// WORKFLOW ROUTING
// ============================================================================

function startWorkflow(type) {
  // Block satellite from print-related workflows
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  
  if (type === 'new') {
    wf1Start();
  } else if (type === 'existing') {
    wf2Start();
  } else if (type === 'setup') {
    // Direct to inventory tab for setup
    switchTab('inventory');
  }
}

function showWizard(wizardId) {
  document.getElementById(wizardId).classList.add('visible');
}

function closeWizard(wizardId) {
  document.getElementById(wizardId).classList.remove('visible');
}



// ============================================================================
// BATCH CSV IMPORT (ported from v1.2)
// ============================================================================

function showBatchImportModal(templateId) {
  if (hasActiveJob()) {
    showToast('A batch job is already active. Complete or cancel it before starting a new one.', 'error');
    return;
  }

  const tpl = getBuiltinTemplate(templateId) || savedTexts.find(s => s.id === templateId);
  if (!tpl || tpl.type !== 'template') {
    showToast('Template not found.', 'error');
    return;
  }

  batchTemplateId = templateId;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];

  document.getElementById('batchTemplateName').textContent = tpl.name;
  document.getElementById('batchFileZone').className = 'batch-file-zone';
  document.getElementById('batchFileZone').innerHTML = '<span class="file-icon">ðŸ“„</span><span class="file-prompt">Click to select a CSV file or drag & drop here</span>';
  document.getElementById('batchMappingSection').style.display = 'none';
  document.getElementById('batchCreateBtn').style.display = 'none';
  document.getElementById('batchFileInput').value = '';

  // Set default job name
  const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  document.getElementById('batchJobName').value = tpl.name + ' â€” ' + today;

  document.getElementById('batchImportModal').classList.add('visible');
}

function closeBatchImportModal() {
  document.getElementById('batchImportModal').classList.remove('visible');
  batchTemplateId = null;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];
}

// Handle CSV file selection
function handleBatchFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  processBatchFile(file);
}

function processBatchFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    const parsed = parseCSV(text);
    if (!parsed || !parsed.rows.length) {
      showToast('Could not parse CSV file. Please check the format.', 'error');
      return;
    }
    batchCsvData = parsed;
    batchCsvFileName = file.name;

    // Update file zone
    const zone = document.getElementById('batchFileZone');
    zone.className = 'batch-file-zone has-file';
    zone.innerHTML = '<span class="file-name">âœ… ' + escapeHtml(file.name) + '</span>' +
      '<span class="file-info">' + parsed.rows.length + ' rows Ã— ' + parsed.headers.length + ' columns</span>';

    // Build column mapping
    buildBatchColMapping();
    updateBatchSummary();
    updateBatchPreview();

    document.getElementById('batchMappingSection').style.display = '';
    document.getElementById('batchCreateBtn').style.display = '';
  };
  reader.readAsText(file);
}

// Parse CSV text into { headers: [], rows: [[]] }
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  if (lines.length < 2) return null; // Need header + at least 1 row

  // Simple CSV parse (handles quoted fields)
  function parseLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += ch;
      }
    }
    result.push(current.trim());
    return result;
  }

  const headers = parseLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const row = parseLine(lines[i]);
    if (row.some(c => c)) rows.push(row); // Skip empty rows
  }

  return { headers, rows };
}

// Auto-map CSV columns to template tokens
function autoMapColumns(columns, tokens) {
  const mapping = new Array(columns.length).fill(null);
  const usedTokens = new Set();

  for (let c = 0; c < columns.length; c++) {
    const colLower = (columns[c] || '').toLowerCase().trim();
    // Try exact match first
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      if (colLower === token || colLower === token.replace(/_/g, ' ')) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
    if (mapping[c]) continue;
    // Try alias match
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      const aliases = TOKEN_ALIASES[token] || [];
      if (aliases.some(a => a === colLower)) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
  }
  return mapping;
}

// Build column-to-token mapping UI
function buildBatchColMapping() {
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl || !batchCsvData) return;

  const tokens = tpl.tokens || [];
  const headers = batchCsvData.headers;

  // Auto-map using existing autoMapColumns
  const autoMap = autoMapColumns(headers, tokens);
  batchColTokenMap = autoMap.slice(); // Copy

  let html = '';
  headers.forEach((header, idx) => {
    const autoToken = autoMap[idx] || '';
    html += '<div class="batch-col-row">' +
      '<span class="batch-col-header">' + escapeHtml(header || '(Column ' + (idx + 1) + ')') + '</span>' +
      '<span class="batch-col-arrow">â†’</span>' +
      '<select class="batch-col-token" onchange="updateBatchColMap(' + idx + ',this.value)">' +
        '<option value="">â€” Skip â€”</option>' +
        tokens.map(t => '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>').join('') +
      '</select>' +
    '</div>';
  });

  document.getElementById('batchColMapping').innerHTML = html;
}

function updateBatchColMap(colIdx, tokenName) {
  batchColTokenMap[colIdx] = tokenName || null;
  updateBatchSummary();
  updateBatchPreview();
}

function updateBatchSummary() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  const labelType = tpl?.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const rowCount = batchCsvData.rows.length;
  const sheetsNeeded = Math.ceil(rowCount / lps);
  const remainder = rowCount % lps;
  const unusedOnLast = remainder ? lps - remainder : 0;

  let html = '<div class="batch-summary-row"><span class="label">Records:</span><span class="value">' + rowCount + '</span></div>' +
    '<div class="batch-summary-row"><span class="label">Label type:</span><span class="value">Avery ' + labelType + ' (' + lps + '/sheet)</span></div>' +
    '<div class="batch-summary-row"><span class="label">Sheets needed:</span><span class="value">' + sheetsNeeded + '</span></div>';
  if (unusedOnLast > 0) {
    html += '<div class="batch-summary-row"><span class="label">Unused on last sheet:</span><span class="value">' + unusedOnLast + '</span></div>';
  }
  document.getElementById('batchSummary').innerHTML = html;
}

// Apply a template with record data
function applyTemplate(template, record) {
  const lines = template.text.split('\n');
  return lines.map(line => {
    const colonIdx = line.indexOf(':');
    if (colonIdx === -1) return line;
    const prefix = line.substring(0, colonIdx + 1);
    let content = line.substring(colonIdx + 1);
    // Replace tokens
    content = content.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, tokenName) => {
      const val = record[tokenName.toLowerCase()];
      return val !== undefined && val !== null ? val : '';
    });
    return prefix + content;
  }).join('\n');
}

function updateBatchPreview() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  // Build preview for first 3 records
  const previewRecords = batchCsvData.rows.slice(0, 3);
  const headers = batchCsvData.headers;

  let html = previewRecords.map((row, ridx) => {
    // Build record object
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx]) {
        record[token] = row[cidx];
      }
    });

    // Apply template
    const renderedText = applyTemplate(tpl, record);
    const lines = deserializeLines(renderedText);

    // Render as mini preview
    let previewHtml = lines.map(l => {
      if (!l.text) return '';
      const alignClass = 'align-' + (l.align || 'left');
      return '<div class="preview-line ' + alignClass + '">' + escapeHtml(l.text) + '</div>';
    }).join('');

    return '<div class="batch-preview-card">' + previewHtml + '</div>';
  }).join('');

  if (batchCsvData.rows.length > 3) {
    html += '<div class="batch-preview-more">+' + (batchCsvData.rows.length - 3) + ' more</div>';
  }

  document.getElementById('batchPreviewCards').innerHTML = html;
}

// Create the batch job
async function createBatchJob() {
  if (!batchCsvData || !batchTemplateId) return;

  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  const jobName = document.getElementById('batchJobName').value.trim() || 'Batch Job';
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const headers = batchCsvData.headers;

  // Build list data
  const list = batchCsvData.rows.map(row => {
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx] !== undefined) {
        record[token] = row[cidx];
      }
    });
    return record;
  });

  const sheetsNeeded = Math.ceil(list.length / lps);

  // Create job object
  const jobId = 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  activeJob = {
    id: jobId,
    templateId: batchTemplateId,
    name: jobName,
    csvFileName: batchCsvFileName || 'unknown.csv',
    list: list,
    labelType: labelType,
    sheetIds: [],
    printedRowIndices: [],
    status: 'active',
    createdAt: Date.now()
  };

  // Create job sheets
  for (let i = 0; i < sheetsNeeded; i++) {
    const sheetId = 'sh_job_' + Date.now() + '_' + i + '_' + Math.random().toString(36).substr(2, 4);
    const rowStart = i * lps;
    const rowEnd = Math.min((i + 1) * lps, list.length);

    sheets[sheetId] = {
      id: sheetId,
      name: jobName + ' #' + (i + 1),
      labelType: labelType,
      sheetCount: 1,
      printed: [],
      texts: {},
      // Job-specific properties
      jobId: jobId,
      jobSheetIndex: i,
      jobRowStart: rowStart,
      jobRowEnd: rowEnd
    };

    activeJob.sheetIds.push(sheetId);

    // Inventory: deduct from stock if tracked
    if (inventory[labelType]) {
      recordInventoryUse(labelType, 1, 'batch');
    }
  }

  saveActiveJob();
  saveSheets();
  closeBatchImportModal();

  // Switch to Sheets tab and select first job sheet
  activeSheetId = activeJob.sheetIds[0];
  sheetGridPages = {};
  switchTab('sheets');
  renderCurrentTab();

  showToast('Job created: ' + list.length + ' labels across ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : ''), 'success');
}

// Render active job banner
function renderJobBanner() {
  const container = document.getElementById('jobBannerArea');
  if (!container) return;

  if (!activeJob) {
    container.innerHTML = '';
    return;
  }

  const totalRows = activeJob.list.length;
  const printedRows = activeJob.printedRowIndices.length;
  const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;

  // Count sheets complete vs pending
  let sheetsComplete = 0;
  activeJob.sheetIds.forEach(shId => {
    const sh = sheets[shId];
    if (!sh) return;
    const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
    const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
    if (printedOnSheet >= rowsOnSheet) {
      sheetsComplete++;
    }
  });

  const html = '<div class="job-banner">' +
    '<div class="job-banner-header">' +
      '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
      '<div class="job-banner-actions">' +
        '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
        '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
      '</div>' +
    '</div>' +
    '<div class="job-banner-progress">' +
      '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
      '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
    '</div>' +
    '<div class="job-banner-info">' +
      '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
      '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
    '</div>' +
  '</div>';

  container.innerHTML = html;
}

// Print all job sheets
async function printJobAll() {
  if (settings.deviceRole === 'satellite') {
    showToast('Printing is only available on your primary device', 'info');
    return;
  }
  if (!activeJob) return;

  const tpl = getBuiltinTemplate(activeJob.templateId) || savedTexts.find(s => s.id === activeJob.templateId);
  if (!tpl) {
    showToast('Template not found for this job.', 'error');
    return;
  }

  const labelType = activeJob.labelType;
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;

  // Build print map across all job sheets
  const pageSheets = [];

  activeJob.sheetIds.forEach((shId, shIdx) => {
    const sh = sheets[shId];
    if (!sh) return;

    const pageLabels = [];
    for (let rowIdx = sh.jobRowStart; rowIdx < sh.jobRowEnd; rowIdx++) {
      if (activeJob.printedRowIndices.includes(rowIdx)) continue; // Already printed

      const record = activeJob.list[rowIdx];
      const renderedText = applyTemplate(tpl, record);
      const lines = deserializeLines(renderedText);
      const localIdx = rowIdx - sh.jobRowStart;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;

      pageLabels.push({
        row, col,
        data: { lines, alignV: tpl.alignV || 'center', graphics: tpl.graphics },
        rowIdx: rowIdx
      });
    }

    if (pageLabels.length > 0) {
      pageSheets.push({ sheetId: shId, physicalSheet: shIdx, labels: pageLabels });
    }
  });

  if (!pageSheets.length) {
    showToast('All labels have already been printed.', 'success');
    showJobCompleteModal();
    return;
  }

  const totalLabels = pageSheets.reduce((sum, pg) => sum + pg.labels.length, 0);

  // Build unified print HTML using canonical buildSheetPrintHtml per sheet (G10 fix)
  // Collect all manifests, build HTML once via the canonical path
  const graphics = tpl.graphics || { left: null, right: null };
  const alignV = tpl.alignV || 'center';
  const border = tpl.border || null;

  let fullHtml = '';
  pageSheets.forEach(function(pg) {
    const sh = sheets[pg.sheetId];
    if (!sh) return;
    const manifest = pg.labels.map(function(lbl) {
      const localIdx = lbl.rowIdx - sh.jobRowStart;
      return { idx: localIdx, lines: lbl.data.lines, graphics: graphics, alignV: alignV, border: border };
    });
    // buildSheetPrintHtml returns a full document â€” extract just the body content
    const sheetHtml = buildSheetPrintHtml(sh, manifest);
    fullHtml = sheetHtml; // For single-sheet, use directly
  });

  // For multi-sheet jobs, we need to combine pages â€” rebuild using canonical per-sheet manifests
  if (pageSheets.length > 1) {
    // Build a combined manifest across all sheets
    // Each sheet gets its own buildSheetPrintHtml call, then we combine pages
    let allPagesBody = '';
    pageSheets.forEach(function(pg) {
      const sh = sheets[pg.sheetId];
      if (!sh) return;
      const manifest = pg.labels.map(function(lbl) {
        const localIdx = lbl.rowIdx - sh.jobRowStart;
        return { idx: localIdx, lines: lbl.data.lines, graphics: graphics, alignV: alignV, border: border };
      });
      const sheetHtml = buildSheetPrintHtml(sh, manifest);
      // Extract body content from the full HTML document
      const bodyMatch = sheetHtml.match(/<body>([\s\S]*)<\/body>/);
      if (bodyMatch) {
        allPagesBody += bodyMatch[1];
      }
    });
    // Extract head/CSS from first sheet's HTML for the wrapper
    const firstHtml = buildSheetPrintHtml(sheets[pageSheets[0].sheetId], []);
    const headMatch = firstHtml.match(/<head>([\s\S]*)<\/head>/);
    const headContent = headMatch ? headMatch[1] : '';
    fullHtml = '<!DOCTYPE html><html><head>' + headContent + '</head><body>' + allPagesBody + '</body></html>';
  }

  // Create and print iframe using canonical HTML
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);

  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(fullHtml);
  iframeDoc.close();

  iframe.contentWindow.focus();
  iframe.contentWindow.print();

  // Ask user if print was successful
  setTimeout(async () => {
    const printed = await showConfirmDialog(
      'Did the print complete successfully?',
      'Print ' + totalLabels + ' labels',
      'Yes, printed OK',
      'No, discard'
    );

    if (printed) {
      // Mark all printed rows
      pageSheets.forEach(pg => {
        pg.labels.forEach(lbl => {
          if (!activeJob.printedRowIndices.includes(lbl.rowIdx)) {
            activeJob.printedRowIndices.push(lbl.rowIdx);
          }
          // Mark position on sheet as printed
          const sh = sheets[pg.sheetId];
          if (sh) {
            const localIdx = lbl.rowIdx - sh.jobRowStart;
            if (!sh.printed.includes(localIdx)) {
              sh.printed.push(localIdx);
            }
          }
        });
      });

      saveActiveJob();
      saveSheets();

      // Add to print history
      addPrintHistoryEntry({
        textName: activeJob.name,
        labelType: labelType,
        count: totalLabels,
        type: 'batch'
      });

      renderCurrentTab();
      renderJobBanner();

      // Check if job is complete
      if (activeJob.printedRowIndices.length >= activeJob.list.length) {
        showJobCompleteModal();
      } else {
        showToast('Printed ' + totalLabels + ' labels', 'success');
      }
    }

    document.body.removeChild(iframe);
  }, 500);
}

function showJobCompleteModal() {
  if (!activeJob) return;
  
  const totalPrinted = activeJob.printedRowIndices.length;
  document.getElementById('jobCompleteCount').textContent = totalPrinted;
  
  // Check if there are remainder positions on last sheet
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];
  const spec = LABEL_TYPES[activeJob.labelType];
  const lps = spec.cols * spec.rows;
  const labelsOnLastSheet = lastSheet ? (lastSheet.jobRowEnd - lastSheet.jobRowStart) : lps;
  const hasRemainder = labelsOnLastSheet < lps;
  
  document.getElementById('jobRemainderOptions').style.display = hasRemainder ? '' : 'none';
  document.getElementById('jobCompleteModal').classList.add('visible');
}

function completeJob() {
  if (!activeJob) return;

  const keepRemainder = document.querySelector('input[name="jobRemainder"]:checked')?.value === 'keep';
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];

  // Save to job history
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'completed',
    completedAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  if (jobHistory.length > 50) jobHistory = jobHistory.slice(0, 50);
  saveJobHistory();

  if (keepRemainder && lastSheet) {
    // Convert last job sheet to regular sheet
    delete lastSheet.jobId;
    delete lastSheet.jobSheetIndex;
    delete lastSheet.jobRowStart;
    delete lastSheet.jobRowEnd;
    lastSheet.name = lastSheet.name.replace(/ #\d+$/, ' (partial)');
    // Delete other job sheets
    activeJob.sheetIds.slice(0, -1).forEach(shId => {
      delete sheets[shId];
    });
  } else {
    // Delete all job sheets
    activeJob.sheetIds.forEach(shId => {
      delete sheets[shId];
    });
  }

  // Clear active job
  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Close modal and refresh UI
  document.getElementById('jobCompleteModal').classList.remove('visible');

  // Select a non-job sheet if available
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job completed successfully!', 'success');
}

// Cancel the active job
async function cancelJob() {
  if (!activeJob) return;

  const ok = await showConfirmDialog(
    'Cancel the batch job "' + activeJob.name + '"? This will delete all job sheets and discard the print data.',
    'Cancel Job',
    'Yes, cancel job',
    'Keep job'
  );

  if (!ok) return;

  // Save to history as cancelled
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'cancelled',
    cancelledAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  saveJobHistory();

  // Delete all job sheets
  activeJob.sheetIds.forEach(shId => {
    // Return inventory stock
    const sh = sheets[shId];
    if (sh && inventory[sh.labelType]) {
      adjustInventory(sh.labelType, 1);
    }
    delete sheets[shId];
  });

  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Select a non-job sheet
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job cancelled', 'info');
}

// Drag and drop for file upload
document.addEventListener('DOMContentLoaded', function() {
  // Batch file zone drag/drop
  const batchZone = document.getElementById('batchFileZone');
  if (batchZone) {
    batchZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = 'var(--accent)';
        batchZone.style.background = 'var(--accent-bg)';
      }
    });
    batchZone.addEventListener('dragleave', function() {
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = '';
        batchZone.style.background = '';
      }
    });
    batchZone.addEventListener('drop', function(e) {
      e.preventDefault();
      batchZone.style.borderColor = '';
      batchZone.style.background = '';
      if (e.dataTransfer.files.length > 0 && !batchZone.classList.contains('has-file')) {
        processBatchFile(e.dataTransfer.files[0]);
      }
    });
  }
});

function confirmClearHistory() {
  showConfirm('Clear all print history? This cannot be undone.', 'Clear History', 'Clear', true, (confirmed) => {
    if (confirmed) {
      printHistory = [];
      savePrintHistory();
      showToast('History cleared', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// INVENTORY MANAGEMENT
// ============================================================================

let adjustingInventoryType = null;

function adjustInventory(typeId, delta) {
  if (!inventory[typeId]) return;
  inventory[typeId].stock = Math.max(0, (inventory[typeId].stock || 0) + delta);
  saveInventory();
  addInventoryEvent(typeId, 'adjust', delta, inventory[typeId].stock);
  renderCurrentTab();
}

function showAddInventoryModal() {
  const select = document.getElementById('addInventoryTypeSelect');
  const existingTypes = Object.keys(inventory);
  
  let html = '';
  for (const typeId of TYPE_ORDER) {
    if (existingTypes.includes(typeId)) continue; // Skip types already in inventory
    const spec = LABEL_TYPES[typeId];
    html += '<option value="' + typeId + '">' + typeId + ' â€” ' + spec.desc + ' (' + spec.sizeDisplay + ')</option>';
  }
  
  if (!html) {
    showToast('All label types are already in your inventory', 'info');
    return;
  }
  
  select.innerHTML = html;
  document.getElementById('addInventoryStock').value = 10;
  document.getElementById('addInventoryThreshold').value = DEFAULT_LOW_THRESHOLD;
  document.getElementById('addInventoryModal').classList.add('visible');
}

function closeAddInventoryModal() {
  document.getElementById('addInventoryModal').classList.remove('visible');
}

function saveAddInventory() {
  const typeId = document.getElementById('addInventoryTypeSelect').value;
  const stock = parseInt(document.getElementById('addInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('addInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[typeId] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  addInventoryEvent(typeId, 'add', stock, inventory[typeId].stock);
  
  // Also save as last used type
  settings.lastLabelType = typeId;
  saveSettings();
  
  closeAddInventoryModal();
  showToast('Inventory type added', 'success');
  renderCurrentTab();
}

function showAdjustInventoryModal(typeId) {
  adjustingInventoryType = typeId;
  const inv = inventory[typeId];
  const spec = LABEL_TYPES[typeId];
  
  document.getElementById('adjustInventoryTitle').textContent = 'Adjust Stock â€” ' + typeId;
  document.getElementById('adjustInventoryStock').value = inv ? inv.stock : 0;
  document.getElementById('adjustInventoryThreshold').value = inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD;
  document.getElementById('adjustInventoryModal').classList.add('visible');
}

function closeAdjustInventoryModal() {
  document.getElementById('adjustInventoryModal').classList.remove('visible');
  adjustingInventoryType = null;
}

function saveAdjustInventory() {
  if (!adjustingInventoryType) return;
  
  const oldStock = inventory[adjustingInventoryType] ? inventory[adjustingInventoryType].stock : 0;
  const stock = parseInt(document.getElementById('adjustInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('adjustInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[adjustingInventoryType] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  addInventoryEvent(adjustingInventoryType, 'set', stock - oldStock, inventory[adjustingInventoryType].stock);
  
  closeAdjustInventoryModal();
  showToast('Inventory updated', 'success');
  renderCurrentTab();
}

function confirmRemoveInventory(typeId) {
  const spec = LABEL_TYPES[typeId];
  showConfirm('Remove ' + typeId + ' (' + spec.desc + ') from inventory tracking?', 'Remove from Inventory', 'Remove', true, (confirmed) => {
    if (confirmed) {
      delete inventory[typeId];
      saveInventory();
      showToast('Removed from inventory', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// CONFIRM DIALOG
// ============================================================================

let confirmCallback = null;

function showConfirm(message, title, okText, isDanger, callback, cancelText) {
  document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
  document.getElementById('confirmModalMessage').textContent = message;
  const okBtn = document.getElementById('confirmModalOkBtn');
  okBtn.textContent = okText || 'OK';
  okBtn.className = 'wizard-btn wizard-btn-primary' + (isDanger ? ' danger' : '');
  const cancelBtn = document.getElementById('confirmModalCancelBtn');
  cancelBtn.textContent = cancelText || 'Cancel';
  confirmCallback = callback;
  document.getElementById('confirmModal').classList.add('visible');
}

// Promise-based confirm dialog
function showConfirmDialog(message, title, okText, cancelText) {
  return new Promise(resolve => {
    document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
    document.getElementById('confirmModalMessage').textContent = message;
    const okBtn = document.getElementById('confirmModalOkBtn');
    okBtn.textContent = okText || 'OK';
    okBtn.className = 'wizard-btn wizard-btn-primary';
    confirmCallback = resolve;
    document.getElementById('confirmModal').classList.add('visible');
  });
}

function closeConfirmModal(result) {
  document.getElementById('confirmModal').classList.remove('visible');
  if (confirmCallback) {
    confirmCallback(result);
    confirmCallback = null;
  }
}

// Generic modal for custom content
function showGenericModal(title, contentHtml, modalId, confirmCallback, confirmLabel) {
  let modal = document.getElementById(modalId);
  if (!modal) {
    modal = document.createElement('div');
    modal.id = modalId;
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 520px;">
        <div class="modal-header">
          <div class="modal-title" id="${modalId}Title">${escapeHtml(title)}</div>
          <button class="modal-close" onclick="closeGenericModal('${modalId}')">Ã—</button>
        </div>
        <div class="modal-body" id="${modalId}Body"></div>
        <div class="modal-btns" id="${modalId}Btns" style="display:none;margin-top:12px;padding:0 20px 16px;"></div>
      </div>
    `;
    document.body.appendChild(modal);
  } else {
    document.getElementById(modalId + 'Title').textContent = title;
  }
  
  document.getElementById(modalId + 'Body').innerHTML = contentHtml;
  
  // Optional confirm button
  const btnsEl = document.getElementById(modalId + 'Btns');
  if (confirmCallback && confirmLabel) {
    window['__genericModalConfirm_' + modalId] = confirmCallback;
    btnsEl.innerHTML = '<button class="btn btn-secondary" onclick="closeGenericModal(\'' + modalId + '\')">Cancel</button>' +
      '<button class="btn btn-primary" onclick="window[\'__genericModalConfirm_' + modalId + '\']()">' + escapeHtml(confirmLabel) + '</button>';
    btnsEl.style.display = 'flex';
    btnsEl.style.justifyContent = 'flex-end';
    btnsEl.style.gap = '8px';
  } else {
    btnsEl.style.display = 'none';
  }
  
  modal.classList.add('visible');
}

function closeGenericModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.remove('visible');
  }
}

// Prompt dialog for text input
let promptCallback = null;
function showPrompt(message, title, defaultValue, callback) {
  // Create prompt modal if it doesn't exist
  let modal = document.getElementById('promptModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'promptModal';
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 400px;">
        <div class="modal-header">
          <div class="modal-title" id="promptModalTitle">Enter Value</div>
          <button class="modal-close" onclick="closePromptModal(null)">Ã—</button>
        </div>
        <div class="modal-body">
          <div id="promptModalMessage" style="margin-bottom: 12px;"></div>
          <input type="text" id="promptModalInput" class="modal-input" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--input-bg); color: var(--text); font-size: 14px;">
        </div>
        <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 16px;">
          <button class="wizard-btn wizard-btn-secondary" onclick="closePromptModal(null)">Cancel</button>
          <button class="wizard-btn wizard-btn-primary" onclick="closePromptModal(document.getElementById('promptModalInput').value)">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    // Handle Enter key
    document.getElementById('promptModalInput').addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        closePromptModal(document.getElementById('promptModalInput').value);
      }
    });
  }
  
  document.getElementById('promptModalTitle').textContent = title || 'Enter Value';
  document.getElementById('promptModalMessage').textContent = message;
  document.getElementById('promptModalInput').value = defaultValue || '';
  promptCallback = callback;
  modal.classList.add('visible');
  setTimeout(() => document.getElementById('promptModalInput').focus(), 100);
}

function closePromptModal(result) {
  document.getElementById('promptModal').classList.remove('visible');
  if (promptCallback) {
    promptCallback(result);
    promptCallback = null;
  }
}

// Promise-based prompt dialog
function showPromptDialog(message, title, defaultValue) {
  return new Promise(resolve => {
    showPrompt(message, title, defaultValue, resolve);
  });
}

// ============================================================================
// WELCOME / FIRST RUN
// ============================================================================

function checkFirstRun() {
  const firstRunDone = localStorage.getItem(FIRST_RUN_KEY);
  if (firstRunDone === 'done') {
    return false; // Not first run
  }
  return true;
}

function showWelcome() {
  const stats = getDataStats();
  const hasExistingData = stats.sheets > 0 || stats.savedTexts > 0 || stats.inventory > 0;
  
  // Show data status if there's existing data
  const statusEl = document.getElementById('welcomeDataStatus');
  const itemsEl = document.getElementById('welcomeDataItems');
  const setupBtn = document.getElementById('welcomeSetupBtn');
  
  if (hasExistingData) {
    statusEl.style.display = 'block';
    let html = '';
    if (stats.sheets > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“„ ' + stats.sheets + ' sheet' + (stats.sheets !== 1 ? 's' : '') + '</div>';
    }
    if (stats.savedTexts > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ’¾ ' + stats.savedTexts + ' saved text' + (stats.savedTexts !== 1 ? 's' : '') + '</div>';
    }
    if (stats.templates > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“ ' + stats.templates + ' template' + (stats.templates !== 1 ? 's' : '') + '</div>';
    }
    if (stats.inventory > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“¦ ' + stats.inventory + ' inventory type' + (stats.inventory !== 1 ? 's' : '') + '</div>';
    }
    itemsEl.innerHTML = html;
    setupBtn.style.display = 'none'; // Already has data
  } else {
    statusEl.style.display = 'none';
    setupBtn.style.display = 'block'; // Offer setup wizard
  }
  
  document.getElementById('welcomeModal').classList.add('visible');
}

function closeWelcome(markComplete) {
  document.getElementById('welcomeModal').classList.remove('visible');
  if (markComplete) {
    localStorage.setItem(FIRST_RUN_KEY, 'done');
  }
}

function showSetupWizardFromWelcome() {
  closeWelcome(true);
  setTimeout(() => {
    switchTab('inventory');
    showToast('Add your label types using the button above', 'info');
  }, 100);
}

// Keyboard Shortcuts Modal
function showShortcutsModal() {
  document.getElementById('shortcutsModal').classList.add('visible');
}

function closeShortcutsModal() {
  document.getElementById('shortcutsModal').classList.remove('visible');
}

// Reset welcome screen (for testing)
function resetWelcome() {
  localStorage.removeItem(FIRST_RUN_KEY);
  showWelcome();
}

// ============================================================================
// TOAST NOTIFICATIONS
// ============================================================================

function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  
  const icons = {
    success: 'âœ“',
    error: 'âœ•',
    warning: 'âš ',
    info: 'â„¹'
  };
  
  toast.innerHTML = '<span class="toast-icon">' + (icons[type] || icons.info) + '</span>' +
                    '<span class="toast-message">' + escapeHtml(message) + '</span>';
  
  container.appendChild(toast);
  
  // Auto remove
  setTimeout(() => {
    toast.classList.add('exiting');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, duration);
  
  return toast;
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

function safeExecute(fn, errorMessage) {
  try {
    return fn();
  } catch (e) {
    console.error(errorMessage || 'Error:', e);
    showToast(errorMessage || 'Something went wrong', 'error');
    return null;
  }
}

// Wrap localStorage operations with error handling
function safeSave(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (e) {
    console.error('Failed to save data:', e);
    if (e.name === 'QuotaExceededError') {
      showToast('Storage is full. Some data may not be saved.', 'error', 5000);
    } else {
      showToast('Failed to save data', 'error');
    }
    return false;
  }
}

function safeLoad(key, defaultValue) {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultValue;
  } catch (e) {
    console.error('Failed to load data:', e);
    return defaultValue;
  }
}

// ============================================================================
// DATA EXPORT / IMPORT
// ============================================================================

function exportAllData() {
  const data = {
    version: '3.27.7',
    exportedAt: new Date().toISOString(),
    settings: settings,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    printHistory: printHistory,
    customTokens: customTokens,
    learningData: learningData  // Phase 4
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'labelkeeper-backup-' + new Date().toISOString().slice(0, 10) + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  // Record backup timestamp
  settings.lastBackupAt = Date.now();
  saveSettings();
  updateBackupStatus();
  
  showToast('Data exported successfully', 'success');
}

function importData(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      
      // Validate it's a LabelKeeper backup
      if (!data.version || !data.exportedAt) {
        showToast('Invalid backup file', 'error');
        return;
      }
      
      // Confirm import
      showConfirm(
        'Import will merge with existing data. Continue?',
        'Import Data',
        'Import',
        false,
        (confirmed) => {
          if (confirmed) {
            performImport(data);
          }
        }
      );
    } catch (err) {
      showToast('Failed to read backup file', 'error');
    }
  };
  reader.readAsText(file);
}

function performImport(data) {
  try {
    // Merge sheets
    if (data.sheets) {
      for (const [id, sheet] of Object.entries(data.sheets)) {
        if (!sheets[id]) {
          sheets[id] = sheet;
        }
      }
      saveSheets();
    }
    
    // Merge saved texts (by ID to avoid duplicates)
    if (data.savedTexts) {
      const existingIds = new Set(savedTexts.map(t => t.id));
      for (const text of data.savedTexts) {
        if (!existingIds.has(text.id)) {
          savedTexts.push(text);
        }
      }
      saveSavedTexts();
    }
    
    // Merge inventory
    if (data.inventory) {
      for (const [type, inv] of Object.entries(data.inventory)) {
        if (!inventory[type]) {
          inventory[type] = inv;
        }
      }
      saveInventory();
    }
    
    // Merge print history
    if (data.printHistory) {
      const existingIds = new Set(printHistory.map(p => p.id));
      for (const entry of data.printHistory) {
        if (!existingIds.has(entry.id)) {
          printHistory.push(entry);
        }
      }
      // Sort by timestamp descending
      printHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      savePrintHistory();
    }
    
    // Merge inventory history (G8)
    if (data.inventoryHistory && Array.isArray(data.inventoryHistory)) {
      const existingTs = new Set(inventoryHistory.map(e => e.ts));
      for (const entry of data.inventoryHistory) {
        if (!existingTs.has(entry.ts)) {
          inventoryHistory.push(entry);
        }
      }
      inventoryHistory.sort((a, b) => a.ts - b.ts);
      saveInventoryHistory();
    }
    
    showToast('Data imported successfully', 'success');
    renderCurrentTab();
  } catch (err) {
    console.error('Import error:', err);
    showToast('Failed to import data', 'error');
  }
}

// ============================================================================
// DEVICE SYNC (Firebase-based, no auth required)
// ============================================================================

const FIREBASE_SYNC_URL = 'https://word-boxing-default-rtdb.firebaseio.com/labelkeeper_sync';
const SYNC_CODE_LENGTH = 6;
const SYNC_EXPIRY_MS = 5 * 60 * 1000; // 5 minutes

// Generate a random sync code
function generateSyncCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Avoid confusing chars like 0/O, 1/I
  let code = '';
  for (let i = 0; i < SYNC_CODE_LENGTH; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Show sync modal
function showSyncModal(title, content) {
  document.getElementById('syncModalTitle').textContent = title;
  document.getElementById('syncModalBody').innerHTML = content;
  document.getElementById('syncModal').classList.add('visible');
}

function closeSyncModal() {
  document.getElementById('syncModal').classList.remove('visible');
}

// Start sharing data to another device
async function startSyncShare() {
  const code = generateSyncCode();
  
  // Show loading state
  showSyncModal('Share to Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare data
  const data = {
    version: '3.27.7',
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    customTokens: customTokens
  };
  
  try {
    // Upload to Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    // Show the code
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your other device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your other device:</strong><br>
          Settings â†’ Receive from Another Device â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    // Schedule cleanup after expiry
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Sync share error:', err);
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// Cleanup sync code from Firebase
async function cleanupSyncCode(code) {
  try {
    await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'DELETE'
    });
  } catch (err) {
    console.log('Cleanup failed (may already be deleted):', err);
  }
}

// Start receiving data from another device
function startSyncReceive() {
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your other device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receiveSyncData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receiveSyncData()">Receive Data</button>
    </div>
  `);
  
  // Focus the input
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Receive data using the entered code
async function receiveSyncData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  // Show loading
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data...</div>
    </div>
  `);
  
  try {
    // Fetch from Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    // Check expiry
    if (data.expiresAt && Date.now() > data.expiresAt) {
      // Clean up expired data
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate data structure
    if (!data.version || !data.exportedAt) {
      throw new Error('Invalid sync data');
    }
    
    // Show confirmation with stats
    const sheetCount = data.sheets ? Object.keys(data.sheets).length : 0;
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">ðŸ“¦</div>
        <div style="font-size: 16px; margin-bottom: 16px;">Ready to import:</div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ“„ ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} saved text${textCount !== 1 ? 's' : ''}</div>
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          This will merge with your existing data.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmSyncImport()">Import Data</button>
      </div>
    `);
    
    // Store data temporarily for confirmation
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Sync receive error:', err);
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
          Make sure the code is correct and hasn't expired.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="startSyncReceive()">Try Again</button>
      </div>
    `);
  }
}

// Confirm and perform the sync import
function confirmSyncImport() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  // Use existing import logic
  performImport(data);
  
  // Clean up the sync code from Firebase
  cleanupSyncCode(code);
  
  // Clear temp data
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  showToast('Data synced successfully!', 'success');
}

// ============================================================================
// PRIMARY/SATELLITE SYNC SYSTEM
// ============================================================================

// Set device role (called from settings UI)
function setDeviceRole(role) {
  if (role !== 'primary' && role !== 'satellite') return;
  
  const oldRole = settings.deviceRole;
  
  // Block switching from satellite to primary via toggle
  // Primary role can only be acquired via transfer code
  if (oldRole === 'satellite' && role === 'primary') {
    showToast('Primary role can only be received via Transfer from the current primary device', 'info');
    return;
  }
  
  // Switching from primary to satellite requires confirmation
  if (oldRole === 'primary' && role === 'satellite') {
    showConfirm(
      'Switch this device to satellite mode?\n\nYou will no longer be able to print. To get primary back, you\'ll need a transfer from whatever device holds the primary role.',
      'Switch to Satellite',
      'Switch',
      true,
      (confirmed) => {
        if (confirmed) {
          settings.deviceRole = 'satellite';
          saveSettings();
          updateDeviceRoleUI();
          updateWorkflowsForRole();
          showToast('Satellite mode: Content capture only, printing disabled', 'info');
        }
      }
    );
    return;
  }
}

// Update the device role selector UI
function updateDeviceRoleUI() {
  const role = settings.deviceRole || 'primary';
  
  // Update role selector buttons
  document.querySelectorAll('.device-role-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.role === role);
  });
  
  // Show/hide appropriate sync UI
  const primaryUI = document.getElementById('syncPrimaryUI');
  const satelliteUI = document.getElementById('syncSatelliteUI');
  
  if (primaryUI) primaryUI.style.display = role === 'primary' ? 'block' : 'none';
  if (satelliteUI) satelliteUI.style.display = role === 'satellite' ? 'block' : 'none';
  
  // Update satellite pending list if in satellite mode
  if (role === 'satellite') {
    updateSatellitePendingUI();
  }
}

// Update satellite pending list UI
function updateSatellitePendingUI() {
  const pending = getSatellitePending();
  const countEl = document.getElementById('satellitePendingCount');
  const listEl = document.getElementById('satellitePendingList');
  
  if (countEl) countEl.textContent = pending.length;
  
  if (listEl) {
    if (pending.length === 0) {
      listEl.innerHTML = '<div class="satellite-pending-empty">No pending items to sync</div>';
    } else {
      listEl.innerHTML = pending.map(id => {
        const text = savedTexts.find(t => t.id === id);
        const name = text ? (text.name || text.text.substring(0, 30) + '...') : id;
        return `
          <div class="satellite-pending-item">
            <span class="satellite-pending-name">${escapeHtml(name)}</span>
            <button class="satellite-pending-delete" onclick="deletePendingItem('${id}')" title="Delete">ðŸ—‘ï¸</button>
          </div>
        `;
      }).join('');
    }
  }
}

// Delete a pending item (only in satellite mode, before sync)
function deletePendingItem(id) {
  if (settings.deviceRole !== 'satellite') return;
  
  const pending = getSatellitePending();
  if (!pending.includes(id)) {
    showToast("Can't delete - already synced", 'error');
    return;
  }
  
  showConfirm(
    'Delete this item? It will be removed from the pending queue.',
    'Delete Pending Item',
    'Delete',
    true,
    (confirmed) => {
      if (confirmed) {
        deleteSavedText(id);
        updateSatellitePendingUI();
        renderCurrentTab();
        showToast('Item deleted', 'success');
      }
    }
  );
}

// Update workflows based on device role
function updateWorkflowsForRole() {
  const isSatellite = settings.deviceRole === 'satellite';
  
  // Find and update workflow cards
  const workflowCards = document.querySelectorAll('.workflow-card');
  workflowCards.forEach(card => {
    const onclick = card.getAttribute('onclick') || '';
    
    // Disable print, mailing, reprint, setup in satellite mode
    const isPrimaryOnly = onclick.includes("'print'") || 
                          onclick.includes("'mailing'") || 
                          onclick.includes("'reprint'") ||
                          onclick.includes("'setup'");
    
    if (isPrimaryOnly) {
      card.classList.toggle('disabled', isSatellite);
      
      // Add or update primary-only badge
      let badge = card.querySelector('.primary-only-badge');
      if (!badge && isSatellite) {
        badge = document.createElement('div');
        badge.className = 'primary-only-badge';
        badge.textContent = 'Primary device only';
        card.querySelector('.workflow-content').appendChild(badge);
      }
    }
  });
}

// SATELLITE: Share pending content to primary
async function satelliteShareToPrimary() {
  const pending = getSatellitePending();
  
  if (pending.length === 0) {
    showToast('No pending items to share', 'info');
    return;
  }
  
  const code = generateSyncCode();
  
  // Show loading state
  showSyncModal('Share to Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare data - only pending items
  const pendingTexts = savedTexts.filter(t => pending.includes(t.id));
  
  const data = {
    version: '3.27.7',
    type: 'satellite_contribution',
    storeId: getOrCreateStoreId(),
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    savedTexts: pendingTexts,
    pendingIds: pending
  };
  
  try {
    // Upload to Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    // Show the code
    showSyncModal('Share to Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your primary device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Sharing ${pendingTexts.length} item${pendingTexts.length !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your primary device:</strong><br>
          Settings â†’ Receive from Satellite â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    // Store code for potential clear after confirmed sync
    window._lastSatelliteShareCode = code;
    
    // Schedule cleanup after expiry
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Satellite share error:', err);
    showSyncModal('Share to Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// SATELLITE: Receive full state from primary
function satelliteReceiveFromPrimary() {
  showSyncModal('Receive from Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your primary device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receivePrimaryData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receivePrimaryData()">Receive Data</button>
    </div>
  `);
  
  // Focus the input
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Satellite receives data from primary
async function receivePrimaryData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  // Show loading
  showSyncModal('Receive from Primary', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data from primary...</div>
    </div>
  `);
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    // Check expiry
    if (data.expiresAt && Date.now() > data.expiresAt) {
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate - should be primary share or transfer data
    if (data.type === 'satellite_contribution') {
      throw new Error('This is satellite data. Use "Receive from Satellite" on your primary device.');
    }
    
    // Check if this is a primary transfer
    const isTransfer = data.type === 'primary_transfer';
    
    // Check if this device has existing data that will be overwritten
    const localSheetCount = Object.keys(sheets).length;
    const localTextCount = savedTexts.length;
    const hasLocalData = localSheetCount > 0 || localTextCount > 0;
    
    // Show confirmation
    const sheetCount = data.sheets ? Object.keys(data.sheets).length : 0;
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    const pending = getSatellitePending();
    
    showSyncModal(isTransfer ? 'Receive Primary Transfer' : 'Receive from Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">${isTransfer ? 'ðŸ‘‘' : 'ðŸ“¦'}</div>
        <div style="font-size: 16px; margin-bottom: 16px;">
          ${isTransfer ? 'Ready to become the new primary device:' : 'Ready to import from primary:'}
        </div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ“„ ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} saved text${textCount !== 1 ? 's' : ''}</div>
        </div>
        ${hasLocalData ? `
          <div style="font-size: 13px; color: var(--error-text); background: var(--error-bg); padding: 10px; border-radius: var(--radius-sm); margin-bottom: 12px;">
            âš ï¸ <strong>Warning:</strong> This device has ${localSheetCount} sheet${localSheetCount !== 1 ? 's' : ''} and ${localTextCount} saved text${localTextCount !== 1 ? 's' : ''} that will be <strong>replaced</strong> by the incoming data.
          </div>
        ` : ''}
        ${isTransfer ? `
          <div style="font-size: 13px; color: var(--success-text); background: var(--success-bg); padding: 8px; border-radius: var(--radius-sm);">
            âœ… This device will become the PRIMARY and can print labels
          </div>
        ` : ''}
        ${pending.length > 0 && !isTransfer ? `
          <div style="font-size: 13px; color: var(--warning-text); background: var(--warning-bg); padding: 8px; border-radius: var(--radius-sm);">
            âš ï¸ Your ${pending.length} pending item${pending.length !== 1 ? 's' : ''} will be preserved
          </div>
        ` : ''}
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmSatelliteReceive()">
          ${isTransfer ? 'Accept Primary Role' : (hasLocalData ? 'Replace My Data' : 'Import Data')}
        </button>
      </div>
    `);
    
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Satellite receive error:', err);
    showSyncModal('Receive from Primary', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="satelliteReceiveFromPrimary()">Try Again</button>
      </div>
    `);
  }
}

// Confirm satellite receive - merge primary data while preserving pending
function confirmSatelliteReceive() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  const isTransfer = data.type === 'primary_transfer';
  const pending = getSatellitePending();
  
  // Get pending items BEFORE we overwrite (only relevant if NOT a transfer)
  const pendingItems = isTransfer ? [] : savedTexts.filter(t => pending.includes(t.id));
  
  // Replace with primary data (full state)
  if (data.sheets) {
    sheets = data.sheets;
    saveSheets();
  }
  
  if (data.savedTexts) {
    savedTexts = [...data.savedTexts];
    // Add back pending items that aren't in primary yet (only if not a transfer)
    if (!isTransfer) {
      for (const item of pendingItems) {
        if (!savedTexts.find(t => t.id === item.id)) {
          savedTexts.push(item);
        }
      }
    }
    saveSavedTexts();
  }
  
  if (data.inventory) {
    inventory = data.inventory;
    saveInventory();
  }
  
  if (data.inventoryHistory) {
    inventoryHistory = data.inventoryHistory;
    saveInventoryHistory();
  }
  
  if (data.printHistory) {
    printHistory = data.printHistory;
    savePrintHistory();
  }
  
  if (data.activeSheetId) {
    activeSheetId = data.activeSheetId;
    localStorage.setItem(ACTIVE_KEY, activeSheetId);
  }
  
  // If this is a transfer, become primary and clear pending queue
  if (isTransfer) {
    settings.deviceRole = 'primary';
    saveSettings();
    saveSatellitePending([]); // Clear any pending items
  }
  
  // Cleanup
  cleanupSyncCode(code);
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  updateDeviceRoleUI();
  updateWorkflowsForRole();
  updateSatellitePendingUI();
  renderCurrentTab();
  
  if (isTransfer) {
    showToast('ðŸŽ‰ This device is now the primary! You can print labels.', 'success');
  } else {
    showToast('Data synced from primary!', 'success');
  }
}

// PRIMARY: Receive contributions from satellite
function primaryReceiveFromSatellite() {
  showSyncModal('Receive from Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your satellite device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receiveSatelliteData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receiveSatelliteData()">Receive Data</button>
    </div>
  `);
  
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Primary receives data from satellite
async function receiveSatelliteData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  showSyncModal('Receive from Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data from satellite...</div>
    </div>
  `);
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    if (data.expiresAt && Date.now() > data.expiresAt) {
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate - should be satellite contribution
    if (data.type !== 'satellite_contribution') {
      throw new Error('This is not satellite data. Make sure your satellite device used "Share to Primary".');
    }
    
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    const storeId = data.storeId || 'unknown';
    
    showSyncModal('Receive from Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">ðŸ“±</div>
        <div style="font-size: 16px; margin-bottom: 16px;">Content from satellite:</div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} new item${textCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 12px; color: var(--text-muted); margin-top: 4px;">From: ${storeId}</div>
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          This will add new content to your library.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmPrimaryReceive()">Import Content</button>
      </div>
    `);
    
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Primary receive error:', err);
    showSyncModal('Receive from Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="primaryReceiveFromSatellite()">Try Again</button>
      </div>
    `);
  }
}

// Confirm primary receive from satellite - append new content
function confirmPrimaryReceive() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  // Append satellite texts (don't replace)
  if (data.savedTexts) {
    const existingIds = new Set(savedTexts.map(t => t.id));
    let addedCount = 0;
    for (const text of data.savedTexts) {
      if (!existingIds.has(text.id)) {
        savedTexts.push(text);
        addedCount++;
      }
    }
    saveSavedTexts();
  }
  
  cleanupSyncCode(code);
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  renderCurrentTab();
  showToast('Content imported from satellite!', 'success');
}

// PRIMARY: Share full state to satellite
async function primaryShareToSatellite() {
  const code = generateSyncCode();
  
  showSyncModal('Share to Satellite', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare full state data
  const data = {
    version: '3.27.7',
    type: 'primary_share',
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    inventoryHistory: inventoryHistory,
    customTokens: customTokens
  };
  
  try {
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    const sheetCount = Object.keys(sheets).length;
    const textCount = savedTexts.length;
    
    showSyncModal('Share to Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your satellite device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Sharing ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}, ${textCount} text${textCount !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your satellite device:</strong><br>
          Settings â†’ Receive from Primary â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Primary share error:', err);
    showSyncModal('Share to Satellite', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// Clear satellite pending queue after successful sync confirmation
function clearSatellitePendingAfterSync() {
  saveSatellitePending([]);
  updateSatellitePendingUI();
}

// PRIMARY: Transfer primary role to another device
async function primaryTransferRole() {
  // Show confirmation first
  showConfirm(
    'This will transfer primary status to another device. After the transfer completes, THIS device will become a satellite and will no longer be able to print. Are you sure?',
    'Transfer Primary Role',
    'Transfer',
    true,
    async (confirmed) => {
      if (!confirmed) return;
      
      const code = generateSyncCode();
      
      showSyncModal('Transfer Primary Role', `
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
          <div>Preparing transfer code...</div>
        </div>
      `);
      
      // Prepare transfer data - includes full state + transfer flag
      const data = {
        version: '3.27.7',
        type: 'primary_transfer',
        exportedAt: new Date().toISOString(),
        expiresAt: Date.now() + SYNC_EXPIRY_MS,
        sheets: sheets,
        activeSheetId: activeSheetId,
        savedTexts: savedTexts,
        inventory: inventory,
        customTokens: customTokens,
        printHistory: printHistory
      };
      
      try {
        const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        if (!response.ok) {
          throw new Error('Failed to upload transfer data');
        }
        
        const sheetCount = Object.keys(sheets).length;
        const textCount = savedTexts.length;
        
        showSyncModal('Transfer Primary Role', `
          <div style="text-align: center; padding: 20px;">
            <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
              Enter this code on the device that will become the new primary:
            </div>
            <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
              ${code}
            </div>
            <div style="font-size: 13px; color: var(--text-muted);">
              Transferring ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}, ${textCount} text${textCount !== 1 ? 's' : ''} â€¢ Code expires in 5 minutes
            </div>
            <div style="margin-top: 16px; padding: 12px; background: var(--warning-bg); border-radius: var(--radius-sm);">
              <div style="font-size: 13px; color: var(--warning-text);">
                âš ï¸ After the new device receives this transfer, click "Complete Transfer" below to convert this device to satellite mode.
              </div>
            </div>
          </div>
          <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
            <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
            <button class="wizard-btn wizard-btn-primary" onclick="completeTransferToSatellite()">Complete Transfer</button>
          </div>
        `);
        
        setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
        
      } catch (err) {
        console.error('Primary transfer error:', err);
        showSyncModal('Transfer Primary Role', `
          <div style="text-align: center; padding: 20px;">
            <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
            <div style="color: var(--error-text);">Failed to create transfer code. Please try again.</div>
            <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
          </div>
          <div style="display: flex; justify-content: center; margin-top: 16px;">
            <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
          </div>
        `);
      }
    }
  );
}

// Complete transfer - convert this device to satellite
function completeTransferToSatellite() {
  settings.deviceRole = 'satellite';
  saveSettings();
  
  closeSyncModal();
  updateDeviceRoleUI();
  updateWorkflowsForRole();
  
  showToast('This device is now a satellite. Printing disabled.', 'info');
}

// ============================================================================
// CLEAR ALL DATA
// ============================================================================

function clearAllData() {
  showConfirm(
    'This will delete ALL your data including sheets, saved texts, and history. This cannot be undone.',
    'Clear All Data',
    'Delete Everything',
    true,
    (confirmed) => {
      if (confirmed) {
        // Clear all storage keys
        localStorage.removeItem(SHEETS_KEY);
        localStorage.removeItem(ACTIVE_KEY);
        localStorage.removeItem(TEXTS_KEY);
        localStorage.removeItem(INVENTORY_KEY);
        localStorage.removeItem(INVENTORY_HISTORY_KEY);
        localStorage.removeItem(PRINT_HISTORY_KEY);
        localStorage.removeItem(CUSTOM_TOKENS_KEY);
        localStorage.removeItem(ACTIVE_JOB_KEY);
        localStorage.removeItem(JOB_HISTORY_KEY);
        localStorage.removeItem(FIRST_RUN_KEY);
        localStorage.removeItem(LEARNING_KEY);  // Phase 4
        
        // Reset state
        sheets = {};
        activeSheetId = null;
        savedTexts = [];
        inventory = {};
        inventoryHistory = [];
        printHistory = [];
        customTokens = [];
        if (typeof clearLearningData === 'function') clearLearningData();  // Phase 4
        
        showToast('All data cleared', 'success');
        renderCurrentTab();
      }
    }
  );
}

// ========== EVENT HANDLERS ==========
document.addEventListener('keydown', e => {
  // Don't trigger shortcuts when typing in input fields
  const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement?.tagName);
  
  if (e.key === 'Escape') {
    closeSettings();
    closeShortcutsModal();
    // Close any open workflows on Escape
    const wf1El = document.getElementById('wf1Wizard');
    const wf2El = document.getElementById('wf2Wizard');
    if (wf1El && wf1El.classList.contains('visible')) {
      wf1Close();
    } else if (wf2El && wf2El.classList.contains('visible')) {
      wf2Close();
    }
    // Close modals on Escape
    if (document.getElementById('splitModal').classList.contains('visible')) {
      closeSimpleModal('splitModal');
    }
    if (document.getElementById('importTextModal').classList.contains('visible')) {
      closeModal('importTextModal');
    }
  }
  
  // ? key shows shortcuts help (when not typing)
  if (e.key === '?' && !isTyping) {
    showShortcutsModal();
  }
});

// Split modal Enter key handler
document.getElementById('splitName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeSplit();
});

// Import modal Enter key handler  
document.getElementById('importBaseName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeImport();
});
document.getElementById('importBaseName').addEventListener('input', () => updateImportPreview());

document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', e => {
    if (e.target === overlay) {
      overlay.classList.remove('visible');
    }
  });
});

// ============================================================================
// INITIALIZATION
// ============================================================================

function init() {
  // Load all data
  loadSettings();
  loadSheets();
  loadSavedTexts();
  loadInventory();
  loadInventoryHistory();
  loadActiveJob();
  loadJobHistory();
  loadCustomTokens();
  loadPrintHistory();
  loadSavedLists();
  
  // Apply UI state
  applyTheme();
  
  // Update workflows based on device role (primary/satellite)
  updateWorkflowsForRole();
  
  // Render Quick Actions section (T10-T11)
  renderQuickActions();
  
  // Show AI prompt if key is configured
  updateAIKeyStatusUI();
  
  // Check for URL parameters (deep linking)
  const urlParams = parseUrlParams();
  if (urlParams.hasParams) {
    // Small delay to let UI render
    setTimeout(() => handleUrlDeepLink(urlParams), 150);
  } else {
    // Check for first run only if not deep linking
    if (checkFirstRun()) {
      // Small delay to let the UI render first
      setTimeout(showWelcome, 100);
    }
  }
  
  // Log stats for debugging
  const stats = getDataStats();
  console.log('LabelKeeper v3.20.1 initialized', stats);
}

/**
 * Handle URL deep link parameters
 * Opens print wizard with pre-filled data or navigates to a sheet
 */
function handleUrlDeepLink(params) {
  console.log('Deep link detected:', params);
  
  // Clear URL params to prevent re-triggering on reload
  if (window.history.replaceState) {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
  
  // Handle sheet deep link (from QR code)
  if (params.action === 'openSheet' && params.sheetId) {
    console.log('Opening sheet:', params.sheetId);
    const sh = sheets[params.sheetId];
    if (sh) {
      // Set active sheet first
      activeSheetId = params.sheetId;
      // Switch to sheets tab (this will render the tab)
      switchTab('sheets');
      // Give DOM more time to render, then scroll to the sheet
      setTimeout(() => {
        const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + params.sheetId + '"]');
        console.log('Found sheet card:', sheetCard);
        if (sheetCard) {
          sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add highlight animation
          sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
          setTimeout(() => {
            sheetCard.style.boxShadow = '';
          }, 2000);
        }
        showToast('Opened "' + sh.name + '"', 'success');
      }, 300);
    } else {
      console.log('Sheet not found in sheets object:', Object.keys(sheets));
      showToast('Sheet not found on this device. QR codes only work on the device where the sheet was created.', 'warning', 6000);
    }
    return;
  }
  
  // Handle print deep link â€” route through WF1
  // Set label type if provided
  if (params.type) {
    settings.lastLabelType = params.type;
    saveSettings();
  }
  
  // Start WF1 and let user proceed through the new workflow
  wf1Start();
  
  // If we have content lines from the deep link, populate the editor after WF1 opens
  if (params.lines && params.lines.some(function(l) { return l.trim(); })) {
    setTimeout(function() {
      // Build content lines from params
      const deepLinkLines = [];
      for (let i = 0; i < Math.min(params.lines.length, 4); i++) {
        deepLinkLines.push({
          text: params.lines[i] || '',
          align: 'left',
          fontSize: 11
        });
      }
      wf1PopulateEditorFromLines(deepLinkLines);
      showToast('Content loaded from link', 'success');
    }, 200);
  } else {
    showToast('Deep link opened â€” choose your label type to start', 'info');
  }
}

init();
</script>
</body>
</html>
