<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="gs-app-id" content="labelkeeper">
<meta name="version" content="3.3.22">

<!-- App Meta Tags -->
<meta name="description" content="Print labels without wasting a single position. Track which spots on your label sheets have been used.">
<meta name="theme-color" content="#1a1a1a">

<title>LabelKeeper</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f5f5f0;
  --surface: #ffffff;
  --surface-alt: #fafaf8;
  --text: #1a1a1a;
  --text-secondary: #4a4a4a;
  --text-muted: #777;
  --text-faint: #aaa;
  --border: #e0e0dc;
  --border-light: #eaeae6;
  --input-bg: #ffffff;
  --input-border: #d0d0cc;
  --heading: #0a0a0a;
  --accent: #2563eb;
  --accent-hover: #1d4ed8;
  --accent-bg: #eff4ff;
  --accent-text: #1e52c0;
  --success-bg: #ecfdf5;
  --success-text: #047a56;
  --success-border: #a7f3d0;
  --warning-bg: #fffbeb;
  --warning-text: #b45309;
  --warning-border: #fcd34d;
  --error-bg: #fef2f2;
  --error-text: #dc2626;
  --error-border: #fca5a5;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
  --radius: 12px;
  --radius-sm: 8px;
  --mono: 'JetBrains Mono', monospace;
}

[data-theme="dark"] {
  --bg: #0c0c10;
  --surface: #1a1a22;
  --surface-alt: #141418;
  --text: #eaeaee;
  --text-secondary: #b8b8c0;
  --text-muted: #8888a0;
  --text-faint: #606078;
  --border: #2e2e3a;
  --border-light: #242430;
  --input-bg: #1e1e28;
  --input-border: #3a3a48;
  --heading: #f8f8fc;
  --accent: #6c9eff;
  --accent-hover: #90b8ff;
  --accent-bg: #1c2440;
  --accent-text: #90b8ff;
  --success-bg: #0d2818;
  --success-text: #5cf0c0;
  --success-border: #208868;
  --warning-bg: #2d2006;
  --warning-text: #ffd85c;
  --warning-border: #c07820;
  --error-bg: #2d0a0a;
  --error-text: #ffa0a0;
  --error-border: #dc3838;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow: 0 2px 8px rgba(0,0,0,0.4);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.5);
}

body {
  font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

/* ===== APP SHELL ===== */
.app-shell {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* ===== HEADER ===== */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0 24px;
}

.app-title {
  font-size: 22px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 10px;
  letter-spacing: -0.02em;
}

.app-title .version {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-faint);
  font-family: var(--mono);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-btn {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--text-secondary);
  transition: all 0.15s;
  box-shadow: var(--shadow-sm);
}

.icon-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== WORKFLOW HUB ===== */
.workflow-hub {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.workflow-heading {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.workflow-cards {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.workflow-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: var(--shadow-sm);
}

.workflow-card:hover {
  border-color: var(--accent);
  box-shadow: var(--shadow);
  transform: translateY(-1px);
}

.workflow-card:active {
  transform: translateY(0);
}

.workflow-icon {
  font-size: 32px;
  flex-shrink: 0;
}

.workflow-content {
  flex: 1;
  min-width: 0;
}

.workflow-title {
  font-size: 17px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.workflow-desc {
  font-size: 14px;
  color: var(--text-muted);
  line-height: 1.4;
}

.workflow-arrow {
  font-size: 20px;
  color: var(--text-faint);
  transition: transform 0.2s, color 0.2s;
}

.workflow-card:hover .workflow-arrow {
  color: var(--accent);
  transform: translateX(4px);
}

/* ===== AI WORKFLOW CARD ===== */
.workflow-card-ai {
  background: linear-gradient(135deg, var(--surface) 0%, var(--accent-bg) 100%);
  border-color: var(--accent);
  border-style: dashed;
}

.workflow-card-ai:hover {
  border-style: solid;
  background: linear-gradient(135deg, var(--accent-bg) 0%, var(--surface) 100%);
}

/* ===== AI CATEGORY MODAL ===== */
.ai-category-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
  margin-bottom: 16px;
}

.ai-category-card {
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.ai-category-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: translateY(-2px);
}

.ai-category-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.ai-category-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.ai-category-desc {
  font-size: 11px;
  color: var(--text-muted);
  line-height: 1.3;
}

/* AI Category Form */
.ai-form-section {
  margin-bottom: 16px;
}

.ai-form-label {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: block;
}

.ai-form-input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
}

.ai-form-input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-bg);
}

.ai-form-input::placeholder {
  color: var(--text-faint);
}

.ai-form-textarea {
  min-height: 80px;
  resize: vertical;
}

.ai-form-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-form-row {
  display: flex;
  gap: 12px;
}

.ai-form-row .ai-form-section {
  flex: 1;
}

/* AI Quick suggestions */
.ai-suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}

/* Generic button styles for AI modals */
.btn {
  padding: 12px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border-color: var(--border);
}

.btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ai-suggestion-chip {
  padding: 6px 10px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-size: 12px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-suggestion-chip:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent-text);
}

/* ===== TAB BAR (Power Mode) ===== */
/* Desktop: Top tab bar */
.tab-bar {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--border);
  margin-bottom: 24px;
  overflow-x: auto;
}

/* Mobile: Bottom tab bar */
@media (max-width: 767px) {
  .tab-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-bottom: none;
    border-top: 1px solid var(--border);
    margin-bottom: 0;
    padding: 0;
    padding-bottom: env(safe-area-inset-bottom, 0);
    z-index: 100;
    justify-content: space-around;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
  }
  
  .app-shell {
    padding-bottom: 70px; /* Space for bottom nav */
  }
}

/* Hide workflow hub when not on workflows tab */
.workflow-hub {
  display: none;
}

.workflow-hub.active {
  display: flex;
}

.tab-btn {
  padding: 12px 18px;
  border: none;
  background: none;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  position: relative;
  transition: color 0.2s;
  white-space: nowrap;
}

.tab-btn:hover {
  color: var(--text);
}

.tab-btn.active {
  color: var(--accent);
}

/* Desktop: underline indicator */
.tab-btn.active::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  height: 2px;
  background: var(--accent);
}

/* Mobile: icon-style tabs */
@media (max-width: 767px) {
  .tab-btn {
    flex: 1;
    padding: 10px 8px;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  
  .tab-btn::before {
    font-size: 20px;
  }
  
  .tab-btn[data-tab="workflows"]::before { content: 'ðŸ '; }
  .tab-btn[data-tab="sheets"]::before { content: 'ðŸ“„'; }
  .tab-btn[data-tab="saved"]::before { content: 'ðŸ’¾'; }
  .tab-btn[data-tab="templates"]::before { content: 'ðŸ“'; }
  .tab-btn[data-tab="inventory"]::before { content: 'ðŸ“¦'; }
  .tab-btn[data-tab="history"]::before { content: 'ðŸ“œ'; }
  
  .tab-btn.active::after {
    display: none;
  }
}

/* ===== TAB PANELS ===== */
.tab-panel {
  display: none;
  animation: fadeIn 0.2s ease;
}

.tab-panel.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}

.panel-placeholder {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-muted);
}

.panel-placeholder-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.panel-placeholder-text {
  font-size: 15px;
}

/* ===== TAB CONTENT LIST ===== */
.tab-content-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.list-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 18px;
  cursor: pointer;
  transition: all 0.15s;
}

.list-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.list-card.builtin {
  opacity: 0.8;
}

.list-card.low {
  border-color: var(--warning-border);
  background: var(--warning-bg);
}

.list-card.empty {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.list-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.list-card-meta {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.badge {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--text-faint);
  color: var(--surface);
}

/* ===== TAB HEADERS ===== */
.tab-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 12px;
}

.tab-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.tab-actions {
  display: flex;
  gap: 8px;
}

.tab-action-btn {
  padding: 8px 14px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: background 0.15s;
}

.tab-action-btn:hover {
  background: var(--accent-hover);
}

.tab-action-btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 2px solid var(--border);
}

.tab-action-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

/* ===== SHEET CARDS (Enhanced) ===== */
.sheet-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  transition: all 0.15s;
}

.sheet-card.active {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.sheet-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}

.sheet-card-info {
  flex: 1;
  min-width: 0;
}

.sheet-card-name {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 4px;
}

.sheet-card-type {
  font-size: 13px;
  color: var(--text-muted);
}

.sheet-note-display {
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
  padding: 6px 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin: 8px 12px 0;
}

.sheet-card-actions {
  display: flex;
  gap: 4px;
}

.sheet-card-btn {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.sheet-card-btn:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.sheet-card-btn.danger:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

/* Sheet Grid Preview */
.sheet-grid {
  display: grid;
  gap: 2px;
  background: var(--border);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 2px;
}

.sheet-grid-cell {
  background: var(--surface);
  aspect-ratio: 1;
  min-width: 8px;
  border-radius: 2px;
}

.sheet-grid-cell.printed {
  background: var(--text-faint);
}

.sheet-grid-cell.printed.clickable {
  cursor: pointer;
  transition: all 0.15s;
}

.sheet-grid-cell.printed.clickable:hover {
  background: var(--text-muted);
  transform: scale(1.1);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.sheet-grid-cell.queued {
  background: var(--accent);
}

.sheet-stats {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sheet-stat-value {
  font-weight: 600;
  color: var(--heading);
}

/* ===== ASSIGNED TEXTS (Sheet-Content Relationship) ===== */
.assigned-texts-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.assigned-texts-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.assigned-texts-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
}

.assigned-texts-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.assigned-text-row {
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface-alt);
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.15s;
}

.assigned-text-row:hover {
  border-color: var(--accent);
}

.assigned-text-row.has-error {
  border-color: var(--error-border);
  background: var(--error-bg);
}

.assigned-text-color {
  width: 6px;
  height: 32px;
  border-radius: 3px;
  flex-shrink: 0;
}

.assigned-text-info {
  flex: 1;
  min-width: 0;
}

.assigned-text-name {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.assigned-text-spots {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.assigned-text-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.assigned-text-placement {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 12px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M3 5l3 3 3-3'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 6px center;
  padding-right: 24px;
}

.assigned-text-placement:focus {
  outline: none;
  border-color: var(--accent);
}

.assigned-text-qty {
  display: flex;
  align-items: center;
}

.assigned-text-qty .qty-btn {
  width: 28px;
  height: 28px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

.assigned-text-qty .qty-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.assigned-text-qty .qty-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.assigned-text-qty .qty-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.assigned-text-qty .qty-val {
  min-width: 36px;
  height: 28px;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--heading);
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.assigned-text-remove {
  background: var(--input-bg);
  border: 1px solid var(--border);
  font-size: 14px;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.15s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin-left: 8px;
}

.assigned-text-remove:hover {
  color: var(--error-text);
  background: var(--error-bg);
  border-color: var(--error-border);
}

.assigned-texts-empty {
  padding: 12px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  border: 1px dashed var(--border);
  border-radius: var(--radius-sm);
}

.assigned-add-btn {
  font-size: 12px;
  padding: 4px 10px;
}

/* Sheet Print Actions */
.sheet-print-actions {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sheet-print-actions > div:first-child:not(.sheet-secondary-actions) {
  display: flex;
  align-items: center;
  gap: 12px;
}

.sheet-secondary-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 4px;
}

.sheet-print-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.15s;
}

.sheet-print-btn:hover:not(:disabled) {
  background: var(--accent-hover);
}

.sheet-print-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.sheet-print-summary {
  font-size: 13px;
  color: var(--text-secondary);
}

.sheet-print-error {
  font-size: 12px;
  color: var(--error-text);
  margin-top: 8px;
}

/* Multi-sheet grid container */
.sheet-grids-container {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: flex-start;
}

.sheet-grid-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.sheet-grid-label {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 500;
}

/* Sheet grid pagination (for many sheets) */
.sheet-grid-pagination {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.sheet-grid-page-btn {
  background: var(--input-bg);
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.15s;
}

.sheet-grid-page-btn:hover:not(:disabled) {
  border-color: var(--accent);
  color: var(--accent);
}

.sheet-grid-page-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.sheet-grid-page-info {
  font-size: 12px;
  color: var(--text-muted);
}

/* Text colors for grid visualization */
.text-color-0 { background: #6366f1; }
.text-color-1 { background: #ec4899; }
.text-color-2 { background: #14b8a6; }
.text-color-3 { background: #f59e0b; }
.text-color-4 { background: #8b5cf6; }
.text-color-5 { background: #ef4444; }
.text-color-6 { background: #22c55e; }
.text-color-7 { background: #3b82f6; }

/* Cell colors for grid visualization (match text colors) */
.sheet-grid-cell.cell-color-0 { background: #6366f1; }
.sheet-grid-cell.cell-color-1 { background: #ec4899; }
.sheet-grid-cell.cell-color-2 { background: #14b8a6; }
.sheet-grid-cell.cell-color-3 { background: #f59e0b; }
.sheet-grid-cell.cell-color-4 { background: #8b5cf6; }
.sheet-grid-cell.cell-color-5 { background: #ef4444; }
.sheet-grid-cell.cell-color-6 { background: #22c55e; }
.sheet-grid-cell.cell-color-7 { background: #3b82f6; }

/* ===== SAVED CONTENT CARDS (Enhanced) ===== */
.saved-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  transition: all 0.15s;
  cursor: pointer;
}

.saved-card:hover {
  border-color: var(--accent);
}

.saved-card-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.saved-card-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.saved-card-preview {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.saved-card-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
}

.saved-card:hover .saved-card-actions {
  opacity: 1;
}

/* ===== HISTORY CARDS (Enhanced) ===== */
.history-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 14px;
  transition: all 0.15s;
}

.history-card:hover {
  border-color: var(--accent);
}

.history-card-icon {
  font-size: 24px;
  opacity: 0.6;
}

.history-card-info {
  flex: 1;
  min-width: 0;
}

.history-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 2px;
}

.history-card-meta {
  font-size: 13px;
  color: var(--text-muted);
}

.history-card-action {
  padding: 8px 12px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.history-card-action:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

/* ===== REPRINT LIST ===== */
.reprint-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 400px;
  overflow-y: auto;
  padding: 4px;
}

.reprint-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  display: flex;
  align-items: center;
  gap: 14px;
  cursor: pointer;
  transition: all 0.15s;
}

.reprint-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.reprint-card-icon {
  font-size: 24px;
  opacity: 0.6;
}

.reprint-card-info {
  flex: 1;
  min-width: 0;
}

.reprint-card-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 2px;
}

.reprint-card-meta {
  font-size: 13px;
  color: var(--text-muted);
}

.reprint-card-arrow {
  font-size: 18px;
  color: var(--text-muted);
}

.reprint-empty {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-muted);
}

.reprint-empty-icon {
  font-size: 48px;
  margin-bottom: 12px;
  opacity: 0.5;
}

.reprint-empty-text {
  font-size: 15px;
  margin-bottom: 20px;
}

.reprint-empty-btn {
  display: inline-block;
  padding: 10px 20px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 8px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s;
}

.reprint-empty-btn:hover {
  background: var(--accent-hover);
}

/* ===== SETUP WIZARD ===== */
.setup-hint {
  font-size: 14px;
  color: var(--text-muted);
  margin-bottom: 20px;
}

.setup-stock-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 30px 0;
}

.setup-stock-display {
  display: flex;
  align-items: center;
  gap: 12px;
}

.setup-stock-btn {
  width: 44px;
  height: 44px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface);
  font-size: 18px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.setup-stock-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.setup-stock-value {
  min-width: 80px;
  padding: 12px 20px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 28px;
  font-weight: 700;
  font-family: var(--mono);
  color: var(--heading);
  text-align: center;
}

.setup-stock-info {
  text-align: center;
  font-size: 14px;
  color: var(--text-muted);
}

.setup-stock-info strong {
  color: var(--text);
}

.setup-summary {
  background: var(--success-bg);
  border: 1px solid var(--success-border);
  border-radius: var(--radius-sm);
  padding: 20px;
  margin-bottom: 20px;
}

.setup-summary-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--success-border);
}

.setup-summary-item:last-child {
  border-bottom: none;
}

.setup-summary-label {
  color: var(--text-secondary);
}

.setup-summary-value {
  font-weight: 600;
  color: var(--success-text);
}

.setup-create-sheet {
  margin-bottom: 20px;
}

.setup-checkbox-label {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  font-size: 14px;
  color: var(--text-secondary);
}

.setup-checkbox-label input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: var(--accent);
}

.setup-actions-stack {
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}

/* ===== MAILING WIZARD ===== */
.mailing-upload-area {
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.15s;
}

.mailing-upload-area:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.mailing-upload-area.dragover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.mailing-upload-icon {
  font-size: 48px;
  margin-bottom: 12px;
  opacity: 0.6;
}

.mailing-upload-text {
  font-size: 15px;
  color: var(--text);
}

.mailing-upload-hint {
  font-size: 13px;
  color: var(--text-muted);
}

.mailing-file-info {
  display: flex;
  align-items: center;
  gap: 12px;
  background: var(--success-bg);
  border: 1px solid var(--success-border);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-top: 16px;
}

.mailing-file-name {
  font-weight: 600;
  color: var(--success-text);
}

.mailing-file-meta {
  flex: 1;
  font-size: 13px;
  color: var(--text-muted);
}

.mailing-file-clear {
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 50%;
  background: var(--surface);
  color: var(--text-muted);
  font-size: 18px;
  cursor: pointer;
  transition: all 0.15s;
}

.mailing-file-clear:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.mailing-template-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 300px;
  overflow-y: auto;
}

.mailing-template-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  cursor: pointer;
  transition: all 0.15s;
}

.mailing-template-card:hover {
  border-color: var(--accent);
}

.mailing-template-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 2px var(--accent);
}

.mailing-template-name {
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.mailing-template-tokens {
  font-size: 12px;
  color: var(--text-muted);
  font-family: var(--mono);
}

.mailing-mapping-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 300px;
  overflow-y: auto;
}

.mailing-mapping-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.mailing-mapping-token {
  min-width: 120px;
  font-weight: 600;
  font-size: 14px;
  color: var(--heading);
  font-family: var(--mono);
}

.mailing-mapping-arrow {
  color: var(--text-muted);
}

.mailing-mapping-select {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--input-bg);
  font-family: inherit;
  font-size: 14px;
  color: var(--text);
}

.mailing-mapping-select:focus {
  outline: none;
  border-color: var(--accent);
}

.mailing-summary {
  background: var(--accent-bg);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 16px;
  text-align: center;
}

.mailing-summary-count {
  font-size: 24px;
  font-weight: 700;
  color: var(--accent);
}

.mailing-summary-text {
  font-size: 14px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.mailing-preview-scroll {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding: 8px 4px;
  margin-bottom: 16px;
}

.mailing-preview-label {
  flex: 0 0 auto;
  width: 180px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  font-size: 10px;
  line-height: 1.4;
}

.mailing-preview-more {
  flex: 0 0 auto;
  width: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* ===== INVENTORY CARDS ===== */
.inventory-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 12px;
}

.inventory-card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
}

.inventory-card-type {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.inventory-card-name {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.inventory-card-desc {
  font-size: 13px;
  color: var(--text-muted);
}

.inventory-card-status {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 20px;
}

.inventory-card-status.inv-ok {
  background: var(--success-bg);
  color: var(--success-text);
}

.inventory-card-status.inv-low {
  background: var(--warning-bg);
  color: var(--warning-text);
}

.inventory-card-status.inv-empty {
  background: var(--error-bg);
  color: var(--error-text);
}

.inventory-card-body {
  display: flex;
  gap: 24px;
  margin-bottom: 16px;
}

.inventory-stat {
  text-align: center;
}

.inventory-stat-value {
  font-size: 28px;
  font-weight: 700;
  font-family: var(--mono);
  color: var(--heading);
  line-height: 1;
}

.inventory-stat-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

.inventory-card-actions {
  display: flex;
  gap: 8px;
}

.inventory-adjust-btn {
  padding: 8px 14px;
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: 6px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.inventory-adjust-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.inventory-adjust-btn.wide {
  flex: 1;
}

.inventory-adjust-btn.danger:hover {
  border-color: var(--error-text);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== PRINT INVENTORY WARNING ===== */
.print-inv-warning {
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  font-size: 14px;
  margin-top: 12px;
}

.print-inv-warning.warning {
  background: var(--warning-bg);
  color: var(--warning-text);
  border: 1px solid var(--warning-border);
}

.print-inv-warning.error {
  background: var(--error-bg);
  color: var(--error-text);
  border: 1px solid var(--error-border);
}

/* ===== SIMPLE MODAL (for edit/create) ===== */
.simple-modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.simple-modal-overlay.visible {
  display: flex;
}

.simple-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.simple-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.simple-modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.simple-modal-body {
  padding: 20px 24px;
}

.simple-modal-footer {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  padding: 16px 24px;
  border-top: 1px solid var(--border-light);
}

.form-group {
  margin-bottom: 16px;
}

.form-label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}

.form-input {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

.form-select {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.form-hint {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* ===== WELCOME / FIRST RUN ===== */
.welcome-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.welcome-overlay.visible {
  display: flex;
}

.welcome-modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 480px;
  max-height: 90vh;
  overflow-y: auto;
  text-align: center;
}

.welcome-header {
  padding: 40px 30px 20px;
  background: linear-gradient(135deg, var(--accent-bg), transparent);
  border-bottom: 1px solid var(--border-light);
}

.welcome-icon {
  font-size: 56px;
  margin-bottom: 16px;
}

.welcome-title {
  font-size: 26px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.welcome-version {
  font-size: 13px;
  font-family: var(--mono);
  color: var(--text-muted);
}

.welcome-body {
  padding: 24px 30px;
}

.welcome-tagline {
  font-size: 16px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 24px;
}

.welcome-features {
  display: flex;
  flex-direction: column;
  gap: 12px;
  text-align: left;
  margin-bottom: 24px;
}

.welcome-feature {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.welcome-feature-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.welcome-feature-text {
  font-size: 14px;
  color: var(--text);
  line-height: 1.4;
}

.welcome-feature-text strong {
  color: var(--heading);
}

.welcome-data-status {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-bottom: 20px;
  text-align: left;
}

.welcome-data-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.welcome-data-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.welcome-data-item {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 13px;
  color: var(--text-muted);
  background: var(--surface);
  padding: 4px 10px;
  border-radius: 12px;
  border: 1px solid var(--border-light);
}

.welcome-data-item.has-data {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.welcome-footer {
  padding: 20px 30px 30px;
}

.welcome-btn-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.welcome-btn {
  width: 100%;
  padding: 14px 20px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.welcome-btn-primary {
  background: var(--accent);
  color: #fff;
}

.welcome-btn-primary:hover {
  background: var(--accent-hover);
}

.welcome-btn-secondary {
  background: var(--surface);
  border: 2px solid var(--border);
  color: var(--text-secondary);
}

.welcome-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.welcome-skip {
  margin-top: 8px;
  font-size: 13px;
  color: var(--text-muted);
  cursor: pointer;
  background: none;
  border: none;
  font-family: inherit;
}

.welcome-skip:hover {
  color: var(--accent);
  text-decoration: underline;
}

/* ===== TOAST NOTIFICATIONS ===== */
.toast-container {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 3000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
}

.toast {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px 20px;
  box-shadow: var(--shadow-lg);
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  color: var(--text);
  animation: toastSlideIn 0.3s ease;
  pointer-events: auto;
  max-width: 90vw;
}

.toast.success {
  background: var(--success-bg);
  border-color: var(--success-border);
  color: var(--success-text);
}

.toast.error {
  background: var(--error-bg);
  border-color: var(--error-border);
  color: var(--error-text);
}

.toast.warning {
  background: var(--warning-bg);
  border-color: var(--warning-border);
  color: var(--warning-text);
}

.toast-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.toast.exiting {
  animation: toastSlideOut 0.3s ease forwards;
}

@keyframes toastSlideIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes toastSlideOut {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(20px); }
}

/* ===== MOBILE TOUCH IMPROVEMENTS ===== */
@media (max-width: 600px) {
  .workflow-card {
    padding: 18px;
    min-height: 80px;
  }
  
  .wizard-btn {
    min-height: 48px;
    padding: 14px 20px;
  }
  
  .icon-btn {
    width: 44px;
    height: 44px;
  }
  
  .tab-btn {
    padding: 14px 16px;
  }
  
  .type-card {
    padding: 14px;
  }
  
  .form-input, .form-select {
    padding: 14px 12px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  .secondary-link {
    padding: 12px 16px;
  }
  
  .setup-stock-btn {
    width: 52px;
    height: 52px;
    font-size: 22px;
  }
  
  .welcome-modal {
    max-width: 100%;
    border-radius: var(--radius-sm);
  }
  
  .welcome-header {
    padding: 30px 20px 16px;
  }
  
  .welcome-body {
    padding: 20px;
  }
  
  .welcome-footer {
    padding: 16px 20px 24px;
  }
}

/* ===== SAFE AREA (for notched devices) ===== */
@supports (padding: max(0px)) {
  .app-shell {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
  
  .toast-container {
    bottom: max(24px, calc(env(safe-area-inset-bottom) + 16px));
  }
}

/* ===== MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.visible {
  display: flex;
}

.modal {
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 400px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px 16px;
  border-bottom: 1px solid var(--border-light);
}

.modal-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--heading);
}

.modal-close {
  width: 32px;
  height: 32px;
  border: none;
  background: none;
  font-size: 20px;
  color: var(--text-muted);
  cursor: pointer;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-close:hover {
  background: var(--error-bg);
  color: var(--error-text);
}

.modal-body {
  padding: 20px 24px;
}

/* ===== SETTINGS ===== */
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 0;
  border-bottom: 1px solid var(--border-light);
}

.setting-row:last-child {
  border-bottom: none;
}

.setting-label {
  font-size: 15px;
  font-weight: 500;
  color: var(--text);
}

.setting-desc {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* Toggle Switch */
.toggle {
  width: 48px;
  height: 28px;
  background: var(--border);
  border-radius: 14px;
  position: relative;
  cursor: pointer;
  transition: background 0.2s;
  flex-shrink: 0;
}

.toggle.active {
  background: var(--accent);
}

.toggle-thumb {
  width: 22px;
  height: 22px;
  background: white;
  border-radius: 50%;
  position: absolute;
  top: 3px;
  left: 3px;
  transition: transform 0.2s;
  box-shadow: var(--shadow-sm);
}

.toggle.active .toggle-thumb {
  transform: translateX(20px);
}

.settings-divider {
  height: 1px;
  background: var(--border);
  margin: 20px 0;
}

.settings-section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 16px;
}

.settings-data-stats {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  margin-bottom: 16px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 13px;
  color: var(--text-muted);
}

.settings-data-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.settings-data-stat strong {
  color: var(--text);
  font-weight: 600;
}

.settings-btn-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.settings-action-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.settings-action-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.settings-action-btn.secondary {
  background: var(--surface-alt);
}

.settings-action-btn.danger:hover {
  border-color: var(--error-border);
  background: var(--error-bg);
  color: var(--error-text);
}

/* ===== AI PROMPT MODAL ===== */
.ai-prompt-section {
  margin-bottom: 4px;
}

.ai-prompt-box {
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-family: var(--mono);
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  color: var(--text-secondary);
  max-height: 200px;
  overflow-y: auto;
  margin-bottom: 12px;
}

.ai-prompt-copy-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  border: 2px solid var(--accent);
  border-radius: var(--radius-sm);
  background: var(--accent-bg);
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: var(--accent-text);
  cursor: pointer;
  transition: all 0.15s;
}

.ai-prompt-copy-btn:hover {
  background: var(--accent);
  color: white;
}

.ai-prompt-divider {
  height: 1px;
  background: var(--border-light);
  margin: 20px 0;
}

.ai-prompt-steps {
  margin: 0;
  padding-left: 20px;
  color: var(--text-secondary);
  font-size: 13px;
  line-height: 1.8;
}

.ai-prompt-steps li {
  margin-bottom: 4px;
}

.ai-prompt-example {
  user-select: all;
}

/* Keyboard Shortcuts Modal */
.shortcuts-section {
  margin-bottom: 20px;
}

.shortcuts-section:last-child {
  margin-bottom: 0;
}

.shortcuts-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.shortcut-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--border-light);
}

.shortcut-row:last-child {
  border-bottom: none;
}

.shortcut-key {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
}

.shortcut-desc {
  font-size: 13px;
  color: var(--text-secondary);
}

/* ===== FULL EDITOR MODAL (ported from v1.2.0) ===== */
.full-editor-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 1000;
  overflow-y: auto;
}

.full-editor-overlay.visible {
  display: block;
}

.full-editor-container {
  max-width: 700px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

.full-editor-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 24px;
}

.full-editor-back {
  width: 40px;
  height: 40px;
  border: 2px solid var(--border);
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.full-editor-back:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.full-editor-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.full-editor-subtitle {
  font-size: 13px;
  color: var(--text-muted);
}

.full-editor-panel {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 16px;
}

.full-editor-section-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}

/* Line input rows */
.fe-line-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}

.fe-line-num {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-faint);
  width: 16px;
  text-align: center;
  flex-shrink: 0;
  font-family: var(--mono);
}

.fe-line-input {
  flex: 1;
  padding: 10px 12px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 15px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.2s;
  min-width: 0;
}

.fe-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-line-input::placeholder {
  color: var(--text-faint);
  font-size: 13px;
}

.fe-align-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
}

.fe-align-btn:hover {
  border-color: var(--accent);
}

.fe-align-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-size-stepper {
  display: flex;
  align-items: center;
  flex-shrink: 0;
}

.fe-size-btn {
  width: 26px;
  height: 36px;
  border: 2px solid var(--border);
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-size-btn:first-child {
  border-radius: 6px 0 0 6px;
}

.fe-size-btn:last-child {
  border-radius: 0 6px 6px 0;
}

.fe-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-size-val {
  width: 32px;
  height: 36px;
  border-top: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--mono);
}

.fe-style-btn {
  width: 32px;
  height: 36px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  flex-shrink: 0;
  position: relative;
}

.fe-style-btn:hover {
  border-color: var(--accent);
}

.fe-style-btn.has-styles {
  color: var(--accent);
  border-color: var(--accent);
}

.fe-style-btn.popover-open {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Style popover */
.fe-style-popover {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  z-index: 100;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  margin-top: 6px;
  box-shadow: var(--shadow-lg);
  min-width: 220px;
}

.fe-style-popover.open {
  display: block;
}

.fe-popover-section {
  margin-bottom: 10px;
}

.fe-popover-section:last-child {
  margin-bottom: 0;
}

.fe-popover-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 6px;
}

.fe-style-toggles {
  display: flex;
  gap: 6px;
}

.fe-style-toggle {
  width: 36px;
  height: 34px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-style-toggle:hover {
  border-color: var(--accent);
}

.fe-style-toggle.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.fe-style-toggle .lbl-b { font-weight: 800; }
.fe-style-toggle .lbl-i { font-style: italic; font-family: Georgia, serif; }
.fe-style-toggle .lbl-u { text-decoration: underline; }
.fe-style-toggle .lbl-s { text-decoration: line-through; }

.fe-color-palette {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.fe-color-swatch {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid var(--border);
  transition: all 0.15s;
}

.fe-color-swatch:hover {
  border-color: var(--accent);
  transform: scale(1.1);
}

.fe-color-swatch.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent);
}

.fe-color-swatch.swatch-none {
  background: var(--surface);
  position: relative;
}

.fe-color-swatch.swatch-none::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 50%;
  width: 2px;
  height: calc(100% - 6px);
  background: var(--error-text);
  transform: rotate(45deg);
}

/* Line hint */
.fe-line-hint {
  font-size: 12px;
  color: var(--text-faint);
  margin-top: 4px;
  padding-left: 22px;
}

.fe-line-hint code {
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 1px 4px;
  font-size: 11px;
  font-family: var(--mono);
}

/* Token Panel */
.fe-token-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  padding-left: 22px;
}

.fe-token-toggle {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

.fe-token-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-toggle.active {
  background: var(--accent-bg);
  border-color: var(--accent);
  color: var(--accent);
}

.fe-token-panel {
  display: none;
  margin-top: 12px;
  padding: 12px;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}

.fe-token-panel.visible {
  display: block;
}

.fe-token-category {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 10px;
  margin-bottom: 6px;
}

.fe-token-category:first-child {
  margin-top: 0;
}

.fe-token-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 4px;
}

.fe-token-chip {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  font-size: 12px;
  font-family: var(--mono);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-chip:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-token-custom-row {
  display: flex;
  gap: 6px;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}

.fe-token-custom-row input {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 12px;
  font-family: var(--mono);
}

.fe-token-custom-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.fe-token-custom-row button {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-secondary);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-token-custom-row button:hover {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

/* Vertical alignment */
.fe-valign-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-valign-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
}

.fe-valign-btn {
  min-width: 38px;
  height: 34px;
  padding: 0 8px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface-alt);
  color: var(--text-muted);
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.fe-valign-btn:hover {
  border-color: var(--accent);
}

.fe-valign-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Graphics panel */
.fe-graphics-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-graphics-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.fe-graphics-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  min-width: 45px;
}

.fe-graphic-add {
  padding: 6px 14px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-muted);
  cursor: pointer;
  font-family: inherit;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-graphic-add:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-graphic-thumb {
  width: 44px;
  height: 44px;
  border-radius: 6px;
  border: 2px solid var(--border);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  cursor: pointer;
}

.fe-graphic-thumb:hover {
  border-color: var(--accent);
}

.fe-graphic-thumb img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.fe-graphic-size-pills {
  display: flex;
  gap: 4px;
}

.fe-graphic-size-pill {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
}

.fe-graphic-size-pill:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-graphic-size-pill.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-graphic-remove {
  padding: 4px 10px;
  border: 2px solid var(--border);
  border-radius: 5px;
  background: transparent;
  color: var(--text-faint);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  transition: all 0.15s;
}

.fe-graphic-remove:hover {
  border-color: var(--error-border);
  color: var(--error-text);
  background: var(--error-bg);
}

/* Preview */
.fe-preview-container {
  background: repeating-conic-gradient(#d8d8d2 0% 25%, #e4e4de 0% 50%) 50% / 12px 12px;
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100px;
}

[data-theme="dark"] .fe-preview-container {
  background: repeating-conic-gradient(#2a2a32 0% 25%, #1e1e26 0% 50%) 50% / 12px 12px;
}

.fe-preview-label {
  background: white;
  border: 2px solid #888;
  border-radius: 4px;
  padding: 8px 10px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  transition: all 0.15s;
}

.fe-preview-label .preview-line {
  width: 100%;
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  line-height: 1.3;
}

.fe-preview-label .preview-line.align-left { justify-content: flex-start; }
.fe-preview-label .preview-line.align-center { justify-content: center; }
.fe-preview-label .preview-line.align-right { justify-content: flex-end; }

.fe-preview-label.empty-preview {
  align-items: center;
  justify-content: center;
  color: #bbb;
  font-size: 12px;
  font-style: italic;
}

.fe-preview-dimensions {
  text-align: center;
  font-size: 11px;
  color: var(--text-faint);
  margin-top: 8px;
  font-family: var(--mono);
}

/* Preview type selector */
.fe-preview-type-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-top: 8px;
}

.fe-preview-type-label {
  font-size: 11px;
  color: var(--text-muted);
}

.fe-preview-type-select {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 11px;
  font-family: var(--mono);
  cursor: pointer;
}

.fe-preview-type-select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Border controls */
.fe-border-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-light);
}

.fe-border-row {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.fe-border-toggles {
  display: flex;
  gap: 4px;
}

.fe-border-toggle {
  width: 32px;
  height: 32px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--surface);
  color: var(--text-muted);
  cursor: pointer;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.fe-border-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-border-toggle.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

.fe-border-color {
  display: flex;
  align-items: center;
  gap: 4px;
}

.fe-border-color-swatch {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
}

.fe-border-color-swatch:hover {
  border-color: var(--accent);
}

/* Global style controls */
.fe-global-style-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px 12px;
  background: var(--surface-alt);
  border-radius: 8px;
}

.fe-global-style-label {
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  white-space: nowrap;
}

.fe-global-style-btn {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 11px;
  font-family: inherit;
  transition: all 0.15s;
}

.fe-global-style-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.fe-global-style-btn.active {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent-text);
}

/* Unsaved changes indicator */
.fe-dirty-indicator {
  display: none;
  color: var(--warning-text);
  font-size: 11px;
  margin-left: 8px;
}

.fe-dirty-indicator.visible {
  display: inline;
}

/* Actions */
.fe-actions {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.fe-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid transparent;
  border-radius: 10px;
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.fe-btn-primary {
  background: var(--accent);
  color: white;
}

.fe-btn-primary:hover {
  background: var(--accent-hover);
}

.fe-btn-secondary {
  background: var(--surface);
  border-color: var(--border);
  color: var(--text);
}

.fe-btn-secondary:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Name input for save */
.fe-name-row {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.fe-name-input {
  flex: 1;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.fe-name-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Graphic picker modal */
.fe-graphic-picker {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1100;
  align-items: center;
  justify-content: center;
}

.fe-graphic-picker.visible {
  display: flex;
}

.fe-graphic-picker-modal {
  background: var(--surface);
  border-radius: var(--radius);
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.fe-gp-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-light);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.fe-gp-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
}

.fe-gp-close {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-size: 20px;
  cursor: pointer;
  border-radius: 6px;
}

.fe-gp-close:hover {
  background: var(--surface-alt);
  color: var(--text);
}

.fe-gp-tabs {
  display: flex;
  border-bottom: 1px solid var(--border-light);
}

.fe-gp-tab {
  flex: 1;
  padding: 10px;
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  border-bottom: 2px solid transparent;
}

.fe-gp-tab:hover {
  color: var(--text);
  background: var(--surface-alt);
}

.fe-gp-tab.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

.fe-gp-body {
  padding: 16px;
  overflow-y: auto;
  flex: 1;
}

.fe-gp-upload-area {
  text-align: center;
  padding: 30px;
}

.fe-gp-upload-btn {
  padding: 12px 24px;
  border: 2px dashed var(--border);
  border-radius: 8px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}

.fe-gp-upload-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-bg);
}

.fe-gp-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.fe-gp-icon {
  width: 48px;
  height: 48px;
  border: 2px solid var(--border-light);
  border-radius: 8px;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px;
  transition: all 0.15s;
}

.fe-gp-icon:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  transform: scale(1.05);
}

.fe-gp-icon svg {
  width: 100%;
  height: 100%;
}

/* ===== WIZARD (for workflows) ===== */
.wizard-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 900;
  overflow-y: auto;
}

.wizard-overlay.visible {
  display: block;
}

.wizard-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.wizard-header {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 32px;
}

.wizard-back {
  width: 40px;
  height: 40px;
  border: none;
  background: var(--surface);
  border-radius: var(--radius-sm);
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  box-shadow: var(--shadow-sm);
}

.wizard-back:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.wizard-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--heading);
}

.wizard-step {
  flex: 1;
  display: none;
  flex-direction: column;
}

.wizard-step.active {
  display: flex;
}

.wizard-question {
  font-size: 22px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 24px;
  line-height: 1.3;
}

.wizard-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.wizard-option {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  padding: 18px 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 14px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 500;
  color: var(--text);
  text-align: left;
}

.wizard-option:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-option-icon {
  font-size: 24px;
}

/* ===== WIZARD TEXT EDITOR ===== */
.wizard-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.editor-lines {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.editor-line {
  display: flex;
  gap: 8px;
  align-items: stretch;
}

.editor-line-input {
  flex: 1;
  padding: 12px 14px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
  transition: border-color 0.15s;
}

.editor-line-input:focus {
  outline: none;
  border-color: var(--accent);
}

.editor-line-input::placeholder {
  color: var(--text-faint);
}

.editor-controls {
  display: flex;
  gap: 4px;
}

.editor-align-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-align-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-align-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.editor-size-btn {
  width: 36px;
  height: 100%;
  min-height: 44px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  color: var(--text-muted);
  transition: all 0.15s;
}

.editor-size-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.editor-size-btn.size-s { font-size: 11px; }
.editor-size-btn.size-m { font-size: 14px; }
.editor-size-btn.size-l { font-size: 17px; }

.editor-size-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Preview */
.editor-preview-section {
  margin-top: 8px;
}

.editor-preview-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.editor-preview-frame {
  background: white;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  min-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.editor-preview-label-box {
  background: #fff;
  border: 1px solid #ccc;
  width: 100%;
  max-width: 263px;
  height: 96px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 8px 12px;
  font-family: Arial, sans-serif;
  color: #000;
  overflow: hidden;
}

.preview-line {
  line-height: 1.3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-line.align-left { text-align: left; }
.preview-line.align-center { text-align: center; }
.preview-line.align-right { text-align: right; }

/* Actions */
.wizard-actions {
  display: flex;
  gap: 12px;
  margin-top: auto;
  padding-top: 24px;
}

.wizard-btn {
  flex: 1;
  padding: 14px 20px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.wizard-btn-secondary {
  background: var(--surface);
  color: var(--text);
}

.wizard-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.wizard-btn-primary {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.wizard-btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.wizard-btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.wizard-btn-primary.danger {
  background: var(--error-text);
  border-color: var(--error-text);
}

.wizard-btn-primary.danger:hover {
  background: #b91c1c;
  border-color: #b91c1c;
}

/* ===== WIZARD SAVED PICKER ===== */
.saved-picker {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.saved-picker-search {
  position: relative;
}

.saved-picker-search input {
  width: 100%;
  padding: 12px 14px 12px 40px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  background: var(--input-bg);
  color: var(--text);
}

.saved-picker-search input:focus {
  outline: none;
  border-color: var(--accent);
}

.saved-picker-search-icon {
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 16px;
  color: var(--text-muted);
}

.saved-picker-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.saved-picker-item {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  cursor: pointer;
  transition: all 0.15s;
}

.saved-picker-item:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.saved-picker-item-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 4px;
}

.saved-picker-item-preview {
  font-size: 13px;
  color: var(--text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.saved-picker-empty {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-muted);
}

.saved-picker-empty-icon {
  font-size: 40px;
  margin-bottom: 12px;
  opacity: 0.5;
}

.saved-picker-empty-text {
  font-size: 15px;
  margin-bottom: 16px;
}

.saved-picker-empty-btn {
  padding: 10px 20px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
}

.saved-picker-empty-btn:hover {
  background: var(--accent-hover);
}

/* ===== WIZARD QUANTITY SELECTOR ===== */
.quantity-selector {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 24px;
  padding: 20px 0;
}

.quantity-controls {
  display: flex;
  align-items: center;
  gap: 16px;
}

.quantity-btn {
  width: 56px;
  height: 56px;
  border: 2px solid var(--border);
  background: var(--surface);
  border-radius: var(--radius);
  font-size: 28px;
  font-weight: 600;
  color: var(--text);
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.quantity-btn:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
  color: var(--accent);
}

.quantity-btn:active {
  transform: scale(0.95);
}

.quantity-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.quantity-value {
  font-size: 48px;
  font-weight: 700;
  color: var(--heading);
  min-width: 100px;
  text-align: center;
  font-family: var(--mono);
}

.quantity-hint {
  font-size: 14px;
  color: var(--text-muted);
  text-align: center;
}

/* ===== WIZARD TYPE PICKER ===== */
.type-picker {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.type-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
}

.type-card {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
}

.type-card:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.type-card.selected {
  border-color: var(--accent);
  background: var(--accent-bg);
  box-shadow: 0 0 0 2px var(--accent);
}

.type-card-name {
  font-size: 15px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 4px;
}

.type-card-desc {
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.type-card-details {
  font-size: 11px;
  color: var(--text-secondary);
  font-family: var(--mono);
}

.type-card.already-tracked {
  opacity: 0.7;
  border-style: dashed;
}

.type-card-tracked {
  font-size: 10px;
  color: var(--success-border);
  margin-top: 4px;
  font-weight: 600;
}

.type-category-badge {
  display: inline-block;
  margin-left: 6px;
  font-size: 10px;
  font-weight: 600;
  color: var(--accent-text);
  background: var(--accent-bg);
  padding: 2px 6px;
  border-radius: 4px;
  vertical-align: middle;
}

/* ===== WIZARD PRINT PREVIEW ===== */
.print-preview-section {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.print-summary {
  background: var(--success-bg);
  border: 2px solid var(--success-border);
  border-radius: var(--radius-sm);
  padding: 16px 20px;
  text-align: center;
}

.print-summary-text {
  font-size: 16px;
  font-weight: 600;
  color: var(--success-text);
}

.print-preview-box {
  background: white;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 24px;
  display: flex;
  justify-content: center;
}

.print-preview-label {
  background: #fff;
  border: 1px solid #999;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 12px 16px;
  font-family: Arial, sans-serif;
  color: #000;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.print-preview-label .preview-line {
  line-height: 1.4;
  white-space: nowrap;
  overflow: hidden;
}

.print-sheet-info {
  background: var(--surface-alt);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 18px;
}

.print-sheet-info-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.print-sheet-info-text {
  font-size: 15px;
  color: var(--text);
}

.print-sheet-info-detail {
  font-size: 13px;
  color: var(--text-secondary);
  margin-top: 4px;
}

/* Print success overlay */
.print-success-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 1100;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.print-success-overlay.visible {
  display: flex;
}

.print-success-modal {
  background: var(--surface);
  border-radius: var(--radius);
  padding: 32px;
  text-align: center;
  max-width: 400px;
  box-shadow: var(--shadow-lg);
}

.print-success-icon {
  font-size: 64px;
  margin-bottom: 16px;
}

.print-success-title {
  font-size: 22px;
  font-weight: 700;
  color: var(--heading);
  margin-bottom: 8px;
}

.print-success-text {
  font-size: 15px;
  color: var(--text-secondary);
  margin-bottom: 24px;
}

.print-success-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
}

.print-success-btn {
  padding: 12px 24px;
  border-radius: var(--radius-sm);
  font-family: inherit;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.print-success-btn-secondary {
  background: var(--surface);
  border: 2px solid var(--border);
  color: var(--text);
}

.print-success-btn-secondary:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.print-success-btn-primary {
  background: var(--accent);
  border: 2px solid var(--accent);
  color: white;
}

.print-success-btn-primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

/* ===== RESPONSIVE ===== */
@media (max-width: 600px) {
  .app-shell {
    padding: 16px;
  }
  
  .workflow-card {
    padding: 16px 18px;
  }
  
  .workflow-icon {
    font-size: 28px;
  }
  
  .workflow-title {
    font-size: 16px;
  }
  
  .secondary-links {
    gap: 6px;
  }
  
  .secondary-link {
    padding: 6px 12px;
    font-size: 12px;
  }
}

/* ===== BATCH IMPORT ===== */
.batch-import-modal { max-width: 560px; }

.batch-file-zone {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 100px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: all 0.15s;
}

.batch-file-zone:hover {
  border-color: var(--accent);
  background: var(--accent-bg);
}

.batch-file-zone.has-file {
  border-style: solid;
  border-color: var(--success-border);
  background: var(--success-bg);
  cursor: default;
}

.batch-file-zone .file-icon {
  font-size: 28px;
  margin-bottom: 8px;
}

.batch-file-zone .file-prompt {
  font-size: 13px;
  color: var(--text-muted);
}

.batch-file-zone .file-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 6px;
}

.batch-file-zone .file-info {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.batch-col-mapping {
  margin-bottom: 16px;
  max-height: 180px;
  overflow-y: auto;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px;
}

.batch-col-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  border-bottom: 1px solid var(--border-light);
}

.batch-col-row:last-child {
  border-bottom: none;
}

.batch-col-header {
  flex: 1;
  font-size: 12px;
  font-weight: 600;
  color: var(--heading);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.batch-col-arrow {
  color: var(--text-muted);
  font-size: 12px;
}

.batch-col-token {
  min-width: 120px;
  padding: 4px 8px;
  border: 1px solid var(--input-border);
  border-radius: 4px;
  font-size: 11px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
}

.batch-col-token:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-summary {
  padding: 12px;
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  background: var(--accent-bg);
  border: 1px solid var(--border);
  font-size: 13px;
  color: var(--accent-text);
}

.batch-summary-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
}

.batch-summary-row .label {
  color: var(--text-secondary);
}

.batch-summary-row .value {
  font-weight: 700;
  font-family: var(--mono);
}

.batch-job-name-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 16px;
}

.batch-job-name-row label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  white-space: nowrap;
}

.batch-job-name-row input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}

.batch-job-name-row input:focus {
  outline: none;
  border-color: var(--accent);
}

.batch-preview-section {
  margin-bottom: 16px;
}

.batch-preview-title {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

.batch-preview-cards {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 4px 0;
}

.batch-preview-card {
  flex-shrink: 0;
  width: 150px;
  padding: 10px 12px;
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--surface);
  font-size: 10px;
  line-height: 1.4;
  color: var(--text);
  font-family: Arial, sans-serif;
}

.batch-preview-card .preview-line {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
}

.batch-preview-card .preview-line.align-left { justify-content: flex-start; }
.batch-preview-card .preview-line.align-center { justify-content: center; }
.batch-preview-card .preview-line.align-right { justify-content: flex-end; }

.batch-preview-more {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--text-muted);
  font-weight: 600;
  padding: 0 12px;
}

/* Job Banner */
.job-banner {
  background: var(--accent-bg);
  border: 2px solid var(--accent);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 20px;
}

.job-banner-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.job-banner-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--heading);
  display: flex;
  align-items: center;
  gap: 8px;
}

.job-banner-title .job-icon {
  font-size: 18px;
}

.job-banner-actions {
  display: flex;
  gap: 8px;
}

.job-banner-progress {
  margin-bottom: 12px;
}

.job-progress-bar {
  height: 8px;
  background: var(--border);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 6px;
}

.job-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s;
}

.job-progress-text {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  text-align: center;
}

.job-banner-info {
  display: flex;
  gap: 16px;
  font-size: 13px;
  color: var(--text-secondary);
}

/* Job Complete Modal */
.job-complete-modal { max-width: 400px; }

.job-complete-summary {
  text-align: center;
  padding: 20px 0;
}

.job-complete-icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.job-complete-count {
  font-size: 36px;
  font-weight: 700;
  color: var(--heading);
}

.job-complete-label {
  font-size: 14px;
  color: var(--text-secondary);
}

.job-remainder-options {
  padding: 16px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  margin-top: 16px;
}

.job-remainder-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--heading);
  margin-bottom: 12px;
}

.job-remainder-option {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 8px 0;
  cursor: pointer;
}

.job-remainder-option input {
  margin-top: 2px;
}

.job-remainder-option-label {
  font-size: 13px;
  color: var(--text);
}

.job-remainder-option-desc {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

/* ===== SPLIT SHEET MODAL ===== */
.split-modal { max-width: 460px; }
.split-summary {
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 14px;
  color: var(--text);
  margin-bottom: 16px;
  text-align: center;
}
.split-form { display: flex; flex-direction: column; gap: 14px; }
.split-form-group { display: flex; flex-direction: column; gap: 6px; }
.split-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
.split-form label {
  font-size: 14px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.split-form label input[type="radio"] {
  margin: 0;
  accent-color: var(--accent);
}
.split-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.split-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}

/* ===== CLIPBOARD IMPORT MODAL ===== */
.import-modal { max-width: 560px; }
.import-summary {
  padding: 10px 14px;
  background: var(--accent-bg);
  border-radius: 8px;
  font-size: 13px;
  color: var(--text);
  margin-bottom: 14px;
  text-align: center;
}
.import-form { display: flex; flex-direction: column; gap: 14px; }
.import-form-title { font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 4px; }
.import-form select, .import-form input[type="text"] {
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  width: 100%;
}
.import-form select:focus, .import-form input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
}
.import-stepper {
  display: inline-flex;
  align-items: center;
  gap: 0;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  overflow: hidden;
}
.import-stepper button {
  width: 32px;
  height: 32px;
  border: none;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.import-stepper button:hover { background: var(--accent-bg); color: var(--accent); }
.import-stepper span {
  min-width: 36px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  background: var(--input-bg);
  padding: 6px 8px;
}
.import-col-mapping { display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; }
.import-col-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 10px;
  background: var(--surface-alt);
  border-radius: 6px;
}
.import-col-row .col-sample {
  flex: 1;
  font-size: 12px;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.import-col-row select {
  width: auto;
  min-width: 100px;
  padding: 4px 8px;
  font-size: 12px;
}
.import-preview-area {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  padding: 10px;
  background: var(--surface-alt);
  border-radius: 6px;
  min-height: 60px;
}
.import-preview-label {
  padding: 6px 10px;
  background: var(--preview-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: Arial, sans-serif;
  font-size: 10px;
  color: var(--preview-text);
  line-height: 1.3;
}
.import-name-preview { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

/* ===== PRINT CSS ===== */
@media print {
  @page { size: letter; margin: 0; }
  html, body { 
    height: 11in !important; 
    width: 8.5in !important; 
    margin: 0 !important; 
    padding: 0 !important; 
    overflow: hidden !important; 
    background: #fff !important; 
    color: #000 !important; 
  }
  body > *:not(.print-sheet) { 
    display: none !important; 
    height: 0 !important; 
    width: 0 !important; 
    overflow: hidden !important; 
    position: absolute !important; 
    visibility: hidden !important; 
  }
  .print-sheet { 
    display: block !important; 
    visibility: visible !important; 
    position: relative !important; 
    width: 8.5in; 
    height: 11in; 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    box-sizing: border-box; 
  }
  .print-label {
    position: absolute; 
    overflow: hidden; 
    font-family: Arial, sans-serif;
    line-height: 1.3; 
    color: #000; 
    display: flex; 
    flex-direction: column;
    box-sizing: border-box;
  }
  .print-label .print-line { 
    width: 100%; 
    display: flex; 
    white-space: nowrap; 
    overflow: hidden; 
  }
  .print-label .print-line.align-left { justify-content: flex-start; text-align: left; }
  .print-label .print-line.align-center { justify-content: center; text-align: center; }
  .print-label .print-line.align-right { justify-content: flex-end; text-align: right; }
  .print-label .print-line.align-split { justify-content: space-between; text-align: left; }
  .print-label .print-line.fill-line { display: flex; align-items: flex-end; gap: 3px; }
  .print-label .print-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .print-label .print-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid #000; min-width: 0.25in; margin-bottom: 1px; }
  .print-label.empty { color: transparent; }
  /* Tent card printing styles */
  .print-label.tent-card { position: relative; }
  .print-label .fold-line { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px dashed #bbb; z-index: 1; }
  .print-label .tent-top, .print-label .tent-bottom { position: absolute; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; padding: 0.1in; box-sizing: border-box; }
  .print-label .tent-top { top: 0; height: 50%; }
  .print-label .tent-bottom { bottom: 0; height: 50%; transform: rotate(180deg); }
}

.print-sheet { display: none; }

/* ===== BYOAI - AI Assistant Styles ===== */
.ai-key-modal {
  max-width: 420px;
}

.ai-key-modal h3 {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}

.ai-key-input-wrapper {
  margin: 16px 0;
}

.ai-key-input {
  width: 100%;
  padding: 12px;
  font-family: var(--mono);
  font-size: 13px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
}

.ai-key-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-key-hint {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 8px;
}

.ai-key-providers {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 12px;
  font-size: 12px;
  color: var(--text-secondary);
}

.ai-key-providers a {
  color: var(--accent);
  text-decoration: none;
}

.ai-key-providers a:hover {
  text-decoration: underline;
}

.ai-key-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px;
  border-radius: var(--radius-sm);
  background: var(--success-bg);
  color: var(--success-text);
  margin-bottom: 16px;
}

.ai-key-status.no-key {
  background: var(--surface-alt);
  color: var(--text-secondary);
}

.ai-ask-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
}

.ai-ask-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

.ai-ask-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.ai-prompt-input-wrapper {
  margin: 16px 0;
}

.ai-prompt-input {
  width: 100%;
  padding: 12px;
  font-size: 14px;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 80px;
}

.ai-prompt-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-prompt-input::placeholder {
  color: var(--text-muted);
}

.ai-generating {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  font-size: 13px;
}

.ai-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: ai-spin 0.8s linear infinite;
}

@keyframes ai-spin {
  to { transform: rotate(360deg); }
}

.ai-error {
  padding: 12px;
  background: var(--error-bg);
  color: var(--error-text);
  border-radius: var(--radius-sm);
  font-size: 13px;
  margin-top: 12px;
}

.ai-settings-section {
  border-top: 1px solid var(--border);
  padding-top: 16px;
  margin-top: 16px;
}

.ai-settings-section h4 {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* ===== AI Preview Modal ===== */
.ai-preview-modal {
  max-width: 540px;
}

.ai-preview-section {
  margin-bottom: 16px;
}

.ai-preview-section-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-understanding {
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
  padding: 12px;
  font-size: 14px;
  color: var(--text);
  border-left: 3px solid var(--accent);
}

.ai-preview-labels {
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  overflow: hidden;
  max-height: 280px;
  overflow-y: auto;
}

.ai-preview-label-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
}

.ai-preview-label-item:last-child {
  border-bottom: none;
}

.ai-preview-label-item:hover {
  background: var(--surface-alt);
}

.ai-preview-label-num {
  min-width: 24px;
  height: 24px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 600;
  flex-shrink: 0;
}

.ai-preview-label-content {
  flex: 1;
  min-width: 0;
}

.ai-preview-label-text {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  word-break: break-word;
}

.ai-preview-label-meta {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
}

.ai-preview-label-edit {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 14px;
  transition: all 0.15s;
  flex-shrink: 0;
}

.ai-preview-label-edit:hover {
  background: var(--accent-bg);
  color: var(--accent);
}

.ai-preview-settings {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  font-size: 13px;
  color: var(--text-secondary);
  padding: 12px;
  background: var(--surface-alt);
  border-radius: var(--radius-sm);
}

.ai-preview-setting {
  display: flex;
  align-items: center;
  gap: 6px;
}

.ai-preview-setting strong {
  color: var(--text);
}

.ai-preview-skip-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 8px 0;
}

.ai-preview-skip-label input {
  cursor: pointer;
}

.ai-preview-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview inline edit mode */
.ai-preview-label-item.editing {
  background: var(--accent-bg);
}

.ai-preview-label-item.editing .ai-preview-label-text {
  display: none;
}

.ai-preview-edit-input {
  width: 100%;
  padding: 8px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--accent);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
}

.ai-preview-edit-input:focus {
  outline: none;
}

.ai-preview-edit-actions {
  display: flex;
  gap: 6px;
  margin-top: 6px;
}

.ai-preview-edit-actions button {
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  border: none;
}

.ai-preview-edit-save {
  background: var(--accent);
  color: white;
}

.ai-preview-edit-cancel {
  background: var(--surface-alt);
  color: var(--text-secondary);
  border: 1px solid var(--border) !important;
}

/* Refine panel */
.ai-refine-panel {
  display: none;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* AI Preview error state */
.ai-preview-error {
  padding: 24px;
  text-align: center;
  background: var(--warning-bg);
  border: 1px solid var(--warning-border);
  border-radius: var(--radius-sm);
}

.ai-preview-error-icon {
  font-size: 32px;
  margin-bottom: 12px;
}

.ai-preview-error-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--warning-text);
  margin-bottom: 8px;
}

.ai-preview-error-message {
  font-size: 14px;
  color: var(--text);
  line-height: 1.5;
  margin-bottom: 12px;
}

.ai-preview-error-hint {
  font-size: 13px;
  color: var(--text-muted);
  font-style: italic;
}

.ai-refine-panel.visible {
  display: block;
}

.ai-refine-original {
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.ai-refine-original strong {
  color: var(--text-secondary);
}

.ai-refine-input {
  width: 100%;
  padding: 10px;
  font-size: 14px;
  font-family: inherit;
  border: 2px solid var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--text);
  resize: vertical;
  min-height: 60px;
}

.ai-refine-input:focus {
  outline: none;
  border-color: var(--accent);
}

.ai-refine-input::placeholder {
  color: var(--text-muted);
}

.ai-refine-actions {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

/* ===== EMOJI PICKER (Full Editor) ===== */
.fe-emoji-toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}
.fe-emoji-toggle {
  padding: 6px 12px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.fe-emoji-toggle:hover { border-color: var(--accent); }
.fe-emoji-toggle.active { border-color: var(--accent); background: var(--accent-bg); }
.fe-emoji-panel {
  display: none;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-lg);
  padding: 10px;
  margin-bottom: 12px;
}
.fe-emoji-panel.visible { display: block; }
.fe-emoji-search {
  width: 100%;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text);
  font-size: 13px;
  font-family: inherit;
  margin-bottom: 8px;
}
.fe-emoji-search:focus { outline: none; border-color: var(--accent); }
.fe-emoji-search::placeholder { color: var(--text-faint); }
.fe-emoji-scroll { max-height: 220px; overflow-y: auto; }
.fe-emoji-category { margin-bottom: 8px; }
.fe-emoji-category-label {
  font-size: 10px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 4px;
}
.fe-emoji-grid { display: flex; flex-wrap: wrap; gap: 2px; }
.fe-emoji-btn {
  width: 34px;
  height: 34px;
  border: none;
  border-radius: 6px;
  background: transparent;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.1s;
}
.fe-emoji-btn:hover { background: var(--accent-bg); }

/* ===== OCR SCAN MODAL ===== */
.ocr-image-area {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 8px;
  border: 2px dashed var(--border);
  border-radius: var(--radius-sm);
  min-height: 140px;
  padding: 20px;
  margin-bottom: 16px;
  background: var(--surface-alt);
  cursor: pointer;
  transition: border-color 0.15s;
}
.ocr-image-area:hover { border-color: var(--accent); }
.ocr-image-area.has-image { cursor: default; border-style: solid; padding: 12px; }
.ocr-image-area img {
  max-width: 100%;
  max-height: 220px;
  border-radius: 4px;
  object-fit: contain;
}
.ocr-placeholder {
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  line-height: 1.5;
}
.ocr-rotation-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 12px;
}
.ocr-rotate-btn {
  padding: 6px 14px;
  border: 2px solid var(--border);
  border-radius: 8px;
  background: var(--surface-alt);
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
  transition: all 0.15s;
}
.ocr-rotate-btn:hover { border-color: var(--accent); background: var(--accent-bg); }
.ocr-rotation-label {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
  text-align: center;
}
.ocr-progress {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 0;
}
.ocr-progress-bar {
  flex: 1;
  height: 8px;
  background: var(--surface-alt);
  border-radius: 4px;
  overflow: hidden;
}
.ocr-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 4px;
  transition: width 0.3s ease;
}
.ocr-progress-text {
  font-size: 12px;
  color: var(--text-secondary);
  min-width: 90px;
  text-align: right;
  font-family: var(--mono);
}
.ocr-results-area {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}
.ocr-results-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.ocr-result-line {
  display: flex;
  align-items: center;
  gap: 8px;
}
.ocr-result-line input {
  flex: 1;
  padding: 8px 12px;
  border: 2px solid var(--input-border);
  border-radius: 6px;
  font-size: 13px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.ocr-result-line input:focus { outline: none; border-color: var(--accent); }
.ocr-result-line input.low-confidence { border-color: var(--warning-text); background: var(--warning-bg); }
.ocr-result-line .ocr-conf {
  font-size: 10px;
  font-family: var(--mono);
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
}
.ocr-result-line .ocr-conf.low { color: var(--warning-text); font-weight: 700; }
.ocr-result-line .ocr-line-remove {
  width: 28px;
  height: 28px;
  border: none;
  background: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  flex-shrink: 0;
}
.ocr-result-line .ocr-line-remove:hover { background: var(--error-bg); color: var(--error-text); }
.ocr-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 4px;
  font-style: italic;
}

/* ===== INVENTORY BREAKDOWN BAR ===== */
.inventory-breakdown {
  margin-bottom: 16px;
}
.inventory-breakdown-bar {
  display: flex;
  height: 12px;
  border-radius: 6px;
  overflow: hidden;
  background: var(--surface-alt);
  margin-bottom: 8px;
}
.inventory-breakdown-segment {
  height: 100%;
  min-width: 2px;
  transition: width 0.3s ease;
}
.inventory-breakdown-segment.shelf { background: var(--success-text); }
.inventory-breakdown-segment.assigned { background: var(--accent); }
.inventory-breakdown-segment.partial { background: var(--warning-text); }
.inventory-breakdown-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  font-size: 12px;
}
.inventory-breakdown-item {
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--text-secondary);
}
.inventory-breakdown-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}
.inventory-breakdown-dot.shelf { background: var(--success-text); }
.inventory-breakdown-dot.assigned { background: var(--accent); }
.inventory-breakdown-dot.partial { background: var(--warning-text); }
.inventory-breakdown-value {
  font-weight: 600;
  font-family: var(--mono);
}

/* ===== HISTORY TAB IMPROVEMENTS ===== */
.history-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}
.history-search {
  flex: 1;
  min-width: 200px;
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
}
.history-search:focus { outline: none; border-color: var(--accent); }
.history-search::placeholder { color: var(--text-faint); }
.history-filter-select {
  padding: 10px 14px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  background: var(--input-bg);
  color: var(--text);
  cursor: pointer;
  min-width: 140px;
}
.history-filter-select:focus { outline: none; border-color: var(--accent); }
.history-date-group {
  margin-bottom: 20px;
}
.history-date-header {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border-light);
}
.history-group-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.history-card-checkbox {
  width: 20px;
  height: 20px;
  margin-right: 4px;
  cursor: pointer;
}
.history-bulk-actions {
  display: flex;
  gap: 10px;
  padding: 12px 16px;
  background: var(--accent-bg);
  border-radius: var(--radius-sm);
  margin-bottom: 16px;
  align-items: center;
}
.history-bulk-count {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent-text);
  margin-right: auto;
}
.history-bulk-btn {
  padding: 8px 14px;
  background: var(--accent);
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 600;
  color: #fff;
  cursor: pointer;
  transition: all 0.15s;
}
.history-bulk-btn:hover { background: var(--accent-hover); }
.history-bulk-btn.secondary {
  background: transparent;
  border: 2px solid var(--accent);
  color: var(--accent);
}
.history-bulk-btn.secondary:hover {
  background: var(--accent-bg);
}
.history-no-results {
  text-align: center;
  padding: 32px;
  color: var(--text-muted);
  font-size: 14px;
}
</style>
</head>
<body>

<div class="app-shell" id="appShell">
  <!-- Header -->
  <header class="app-header">
    <div class="app-title">
      ðŸ·ï¸ LabelKeeper
      <span class="version">v3.3.22</span>
    </div>
    <div class="header-actions">
      <button class="icon-btn" onclick="openSettings()" title="Settings">âš™ï¸</button>
    </div>
  </header>

  <!-- Tab Bar -->
  <nav class="tab-bar" id="tabBar">
    <button class="tab-btn active" data-tab="workflows" onclick="switchTab('workflows')">Workflows</button>
    <button class="tab-btn" data-tab="sheets" onclick="switchTab('sheets')">Sheets</button>
    <button class="tab-btn" data-tab="saved" onclick="switchTab('saved')">Content</button>
    <button class="tab-btn" data-tab="templates" onclick="switchTab('templates')">Templates</button>
    <button class="tab-btn" data-tab="inventory" onclick="switchTab('inventory')">Inventory</button>
    <button class="tab-btn" data-tab="history" onclick="switchTab('history')">History</button>
  </nav>

  <!-- Workflow Hub (Workflows Tab) -->
  <main class="workflow-hub active" id="workflowHub">
    <div>
      <h2 class="workflow-heading">What would you like to do?</h2>
    </div>
    
    <div class="workflow-cards">
      <div class="workflow-card" onclick="startWorkflow('print')">
        <div class="workflow-icon">ðŸ–¨ï¸</div>
        <div class="workflow-content">
          <div class="workflow-title">Print Labels</div>
          <div class="workflow-desc">Type something new or pick from your saved content</div>
        </div>
        <div class="workflow-arrow">â†’</div>
      </div>
      
      <div class="workflow-card" onclick="startWorkflow('mailing')">
        <div class="workflow-icon">ðŸ“‹</div>
        <div class="workflow-content">
          <div class="workflow-title">Print a Mailing List</div>
          <div class="workflow-desc">Upload a spreadsheet of addresses and print them all at once</div>
        </div>
        <div class="workflow-arrow">â†’</div>
      </div>
      
      <div class="workflow-card" onclick="startWorkflow('reprint')">
        <div class="workflow-icon">ðŸ”„</div>
        <div class="workflow-content">
          <div class="workflow-title">Reprint Recent Labels</div>
          <div class="workflow-desc">Find something you printed before and print it again</div>
        </div>
        <div class="workflow-arrow">â†’</div>
      </div>
      
      <div class="workflow-card" onclick="startWorkflow('setup')">
        <div class="workflow-icon">ðŸ“¦</div>
        <div class="workflow-content">
          <div class="workflow-title">Set Up Label Sheets</div>
          <div class="workflow-desc">Track which label sheets you own and how many you have left</div>
        </div>
        <div class="workflow-arrow">â†’</div>
      </div>
      
      <div class="workflow-card workflow-card-ai" onclick="openAICategoryModal()">
        <div class="workflow-icon">âœ¨</div>
        <div class="workflow-content">
          <div class="workflow-title">Ask AI</div>
          <div class="workflow-desc">Describe what you need and AI creates the labels</div>
        </div>
        <div class="workflow-arrow">â†’</div>
      </div>
    </div>
  </main>

  <!-- Tab Panels (Power Mode) -->
  <div id="tabPanels">
    <div class="tab-panel" id="panel-sheets">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“„</div>
        <div class="panel-placeholder-text">Your label sheets will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-saved">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ’¾</div>
        <div class="panel-placeholder-text">Saved content will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-templates">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“</div>
        <div class="panel-placeholder-text">Templates will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-inventory">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“¦</div>
        <div class="panel-placeholder-text">Inventory tracking will appear here</div>
      </div>
    </div>
    
    <div class="tab-panel" id="panel-history">
      <div class="panel-placeholder">
        <div class="panel-placeholder-icon">ðŸ“œ</div>
        <div class="panel-placeholder-text">Print history will appear here</div>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" style="max-width: 440px;">
    <div class="modal-header">
      <div class="modal-title">Settings</div>
      <button class="modal-close" onclick="closeSettings()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="setting-row">
        <div>
          <div class="setting-label">Dark Mode</div>
          <div class="setting-desc">Use dark color theme</div>
        </div>
        <div class="toggle" id="darkModeToggle" onclick="toggleDarkMode()">
          <div class="toggle-thumb"></div>
        </div>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Advanced</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Print calibration settings. Safari requires an automatic offset correction due to a browser limitation.
      </div>
      
      <div class="setting-row" style="margin-bottom: 12px;">
        <div style="flex: 1;">
          <div class="setting-label">Safari Print Offset</div>
          <div class="setting-desc" style="font-size: 11px;">Auto-applied when printing from Safari</div>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="safariPrintOffset" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
          <span style="color: var(--text-muted); font-size: 13px;">in</span>
        </div>
      </div>
      
      <div class="setting-row" style="gap: 16px;">
        <div style="flex: 1;">
          <div class="setting-label">Manual Vertical Offset</div>
          <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
            <input type="number" id="printOffsetTop" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
            <span style="color: var(--text-muted); font-size: 13px;">in</span>
          </div>
        </div>
        <div style="flex: 1;">
          <div class="setting-label">Manual Horizontal Offset</div>
          <div style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
            <input type="number" id="printOffsetLeft" step="0.05" style="width: 70px; padding: 8px; border: 2px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--text); font-size: 14px;" onchange="updatePrintOffset()">
            <span style="color: var(--text-muted); font-size: 13px;">in</span>
          </div>
        </div>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Data Management</div>
      
      <div class="settings-data-stats" id="settingsDataStats">
        <!-- Populated by JS -->
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Device Sync</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Sync your sheets and content between devices without signing in.
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="startSyncShare()">
          <span>ðŸ“¤</span> Share to Another Device
        </button>
        <button class="settings-action-btn" onclick="startSyncReceive()">
          <span>ðŸ“¥</span> Receive from Another Device
        </button>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Backup &amp; Restore</div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="exportAllData()">
          <span>ðŸ“¤</span> Export Backup
        </button>
        <label class="settings-action-btn">
          <span>ðŸ“¥</span> Import Backup
          <input type="file" accept=".json" style="display:none;" onchange="importData(this.files[0])">
        </label>
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn secondary" onclick="showWelcome()">
          <span>ðŸ‘‹</span> Show Welcome Screen
        </button>
        <button class="settings-action-btn danger" onclick="clearAllData()">
          <span>ðŸ—‘ï¸</span> Clear All Data
        </button>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">AI Integration</div>
      
      <!-- BYOAI Status -->
      <div id="aiKeyStatus" class="ai-key-status no-key">
        <span>ðŸ”‘</span>
        <span id="aiKeyStatusText">No API key configured</span>
      </div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" id="aiKeyConfigBtn" onclick="showAIKeyModal()">
          <span>ðŸ”‘</span> <span id="aiKeyConfigBtnText">Add API Key</span>
        </button>
        <button class="settings-action-btn secondary" id="aiKeyClearBtn" onclick="clearAIKey()" style="display: none;">
          <span>ðŸ—‘ï¸</span> Remove Key
        </button>
      </div>
      
      <div class="setting-desc" style="margin: 12px 0;">
        Add your own API key to enable "âœ¨ Ask AI" in the editor. Your key stays on this device only.
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">External AI (Copy/Paste)</div>
      <div class="setting-desc" style="margin-bottom: 12px;">
        Use any AI (Claude, ChatGPT, etc.) to generate labels. Copy the prompt below and paste AI-generated labels directly into the editor.
      </div>
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showAIPromptModal()">
          <span>ðŸ¤–</span> View AI Prompt
        </button>
        <button class="settings-action-btn secondary" onclick="copyDeepLinkExample()">
          <span>ðŸ”—</span> Copy Link Format
        </button>
      </div>
      
      <div class="settings-divider"></div>
      <div class="settings-section-title">Help</div>
      
      <div class="settings-btn-row">
        <button class="settings-action-btn" onclick="showShortcutsModal()">
          <span>âŒ¨ï¸</span> Keyboard Shortcuts
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Modal -->
<div class="modal-overlay" id="shortcutsModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <div class="modal-title">Keyboard Shortcuts</div>
      <button class="modal-close" onclick="closeShortcutsModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="shortcuts-section">
        <div class="shortcuts-title">Global</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Esc</span>
          <span class="shortcut-desc">Close modal or wizard</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">?</span>
          <span class="shortcut-desc">Show this help (when not typing)</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Text Editor / OCR</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Ctrl+V</span>
          <span class="shortcut-desc">Paste text or image</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Enter</span>
          <span class="shortcut-desc">Confirm dialog / Submit form</span>
        </div>
      </div>
      
      <div class="shortcuts-section">
        <div class="shortcuts-title">Navigation</div>
        <div class="shortcut-row">
          <span class="shortcut-key">Tab</span>
          <span class="shortcut-desc">Move between fields</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Prompt Modal -->
<div class="modal-overlay" id="aiPromptModal">
  <div class="modal" style="max-width: 560px;">
    <div class="modal-header">
      <div class="modal-title">AI Integration</div>
      <button class="modal-close" onclick="closeAIPromptModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ“‹ Copy this prompt to your AI assistant:</h3>
        <div class="ai-prompt-box" id="aiPromptBox">
          <!-- Populated by JS -->
        </div>
        <button class="ai-prompt-copy-btn" onclick="copyAIPrompt()">
          <span>ðŸ“‹</span> Copy Prompt
        </button>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ¤– How it works:</h3>
        <ol class="ai-prompt-steps">
          <li>Copy the prompt above and paste it into Claude, ChatGPT, or any AI</li>
          <li>Ask the AI to generate labels (e.g., "Create address labels for John Smith at 123 Main St")</li>
          <li>Copy the AI's output</li>
          <li>Paste into LabelKeeper's text editor â€” it auto-detects the format!</li>
        </ol>
      </div>
      
      <div class="ai-prompt-divider"></div>
      
      <div class="ai-prompt-section">
        <h3 style="margin: 0 0 8px; font-size: 14px; color: var(--heading);">ðŸ”— Deep Link Format:</h3>
        <div class="ai-prompt-example" style="font-family: var(--mono); font-size: 12px; background: var(--surface-alt); padding: 12px; border-radius: 8px; word-break: break-all;">
          labelkeeper.html?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1
        </div>
        <div class="setting-desc" style="margin-top: 8px;">
          Use pipe (|) to separate lines. URL-encode special characters.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Key Setup Modal (BYOAI) -->
<div class="modal-overlay" id="aiKeyModal">
  <div class="modal ai-key-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Enable AI Assistant</div>
      <button class="modal-close" onclick="closeAIKeyModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <p style="color: var(--text-secondary); margin-bottom: 16px;">
        Paste your API key to use AI features. Your key stays on this device only â€” it's never sent anywhere except directly to your chosen AI provider.
      </p>
      
      <div class="ai-key-input-wrapper">
        <input type="password" class="ai-key-input" id="aiKeyInput" placeholder="sk-ant-... or sk-..." autocomplete="off">
        <div class="ai-key-hint">
          Works with: <strong>Claude</strong> â€¢ <strong>OpenAI</strong> â€¢ <strong>Gemini</strong>
        </div>
      </div>
      
      <div class="ai-key-providers">
        <span>Get a key:</span>
        <a href="https://console.anthropic.com/settings/keys" target="_blank">Claude â†’</a>
        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI â†’</a>
        <a href="https://aistudio.google.com/app/apikey" target="_blank">Gemini â†’</a>
      </div>
      
      <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIKeyModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveAIKey()">Save & Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Modal -->
<div class="modal-overlay" id="aiCategoryModal">
  <div class="modal" style="max-width: 500px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ What kind of labels?</div>
      <button class="modal-close" onclick="closeAICategoryModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-category-grid">
        <div class="ai-category-card" onclick="selectAICategory('address')">
          <div class="ai-category-icon">ðŸ“¬</div>
          <div class="ai-category-title">Address</div>
          <div class="ai-category-desc">Return address or shipping labels</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('gift')">
          <div class="ai-category-icon">ðŸŽ</div>
          <div class="ai-category-title">Gift</div>
          <div class="ai-category-desc">Gift tags for any occasion</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('organize')">
          <div class="ai-category-icon">ðŸ·ï¸</div>
          <div class="ai-category-title">Organize</div>
          <div class="ai-category-desc">Pantry, files, bins, storage</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('moving')">
          <div class="ai-category-icon">ðŸ“¦</div>
          <div class="ai-category-title">Moving</div>
          <div class="ai-category-desc">Box labels with room & contents</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('nametag')">
          <div class="ai-category-icon">ðŸ‘‹</div>
          <div class="ai-category-title">Name Tag</div>
          <div class="ai-category-desc">Name badges for events</div>
        </div>
        <div class="ai-category-card" onclick="selectAICategory('custom')">
          <div class="ai-category-icon">âœï¸</div>
          <div class="ai-category-title">Custom</div>
          <div class="ai-category-desc">Describe anything you need</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Category Form Modal -->
<div class="modal-overlay" id="aiFormModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <button class="modal-back" onclick="backToAICategories()" style="background:none;border:none;font-size:20px;cursor:pointer;color:var(--text-secondary);margin-right:8px;">â†</button>
      <div class="modal-title" id="aiFormTitle">âœ¨ Address Labels</div>
      <button class="modal-close" onclick="closeAIFormModal()">Ã—</button>
    </div>
    <div class="modal-body" id="aiFormBody">
      <!-- Form content injected by JS -->
    </div>
  </div>
</div>

<!-- AI Generate Modal (BYOAI) -->
<div class="modal-overlay" id="aiGenerateModal">
  <div class="modal" style="max-width: 480px;">
    <div class="modal-header">
      <div class="modal-title">âœ¨ Ask AI</div>
      <button class="modal-close" onclick="closeAIGenerateModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="ai-prompt-input-wrapper">
        <textarea class="ai-prompt-input" id="aiPromptTextarea" placeholder="Describe the label you want to create...

Examples:
â€¢ Return address label for John Smith at 123 Main St, Boston MA 02101
â€¢ Shipping label for Acme Corp, 456 Business Ave, Suite 100, Chicago IL 60601
â€¢ Make a label that says &quot;Happy Birthday&quot; with confetti vibes"></textarea>
      </div>
      
      <div id="aiGenerateStatus" style="display: none;">
        <div class="ai-generating">
          <div class="ai-spinner"></div>
          <span>Generating...</span>
        </div>
      </div>
      
      <div id="aiGenerateError" class="ai-error" style="display: none;"></div>
      
      <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeAIGenerateModal()">Cancel</button>
        <button class="btn btn-primary" id="aiGenerateBtn" onclick="generateWithAI()">
          âœ¨ Generate
        </button>
      </div>
    </div>
  </div>
</div>

<!-- AI Preview Modal -->
<div class="modal-overlay" id="aiPreviewModal">
  <div class="modal ai-preview-modal">
    <div class="modal-header">
      <div class="modal-title">âœ¨ AI Preview</div>
      <button class="modal-close" onclick="closeAIPreviewModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Understanding section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“ What I understood</div>
        <div class="ai-preview-understanding" id="aiPreviewUnderstanding">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Labels section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ·ï¸ Labels I'll create (<span id="aiPreviewLabelCount">0</span>)</div>
        <div class="ai-preview-labels" id="aiPreviewLabels">
          <!-- Populated by JS -->
        </div>
      </div>
      
      <!-- Settings section -->
      <div class="ai-preview-section">
        <div class="ai-preview-section-title">ðŸ“‹ Settings</div>
        <div class="ai-preview-settings">
          <div class="ai-preview-setting">
            <span>Type:</span>
            <strong id="aiPreviewType">5160 Address Labels</strong>
          </div>
          <div class="ai-preview-setting">
            <span>Quantity:</span>
            <strong id="aiPreviewQty">1</strong>
          </div>
        </div>
      </div>
      
      <!-- Skip preview checkbox -->
      <label class="ai-preview-skip-label">
        <input type="checkbox" id="aiPreviewSkip" onchange="toggleAIPreviewSkip()">
        <span>Don't show preview (trust AI output)</span>
      </label>
      
      <!-- Refine panel (hidden by default) -->
      <div class="ai-refine-panel" id="aiRefinePanel">
        <div class="ai-refine-original">
          <strong>Original request:</strong> <span id="aiRefineOriginal"></span>
        </div>
        <textarea class="ai-refine-input" id="aiRefineInput" placeholder="Add more detail or corrections..."></textarea>
        <div class="ai-refine-actions">
          <button class="btn btn-secondary" onclick="hideRefinePanel()">Cancel</button>
          <button class="btn btn-primary" onclick="regenerateWithRefinement()">âœ¨ Regenerate</button>
        </div>
      </div>
      
      <!-- Action buttons -->
      <div class="ai-preview-actions" id="aiPreviewActions">
        <button class="btn btn-secondary" onclick="closeAIPreviewModal()">Cancel</button>
        <button class="btn btn-secondary" onclick="showRefinePanel()">ðŸ”„ Refine</button>
        <button class="btn btn-primary" onclick="acceptAIPreview()">âœ“ Accept</button>
      </div>
    </div>
  </div>
</div>

<!-- OCR Scan Modal -->
<div class="modal-overlay" id="ocrModal" style="z-index: 1100;">
  <div class="modal" style="max-width: 520px;">
    <div class="modal-header">
      <div class="modal-title">ðŸ“· Scan Image</div>
      <button class="modal-close" onclick="closeOcrModal()">Ã—</button>
    </div>
    <div class="modal-body">
      <!-- Image area: shows preview, click to pick file -->
      <div class="ocr-image-area" id="ocrImageArea" onclick="ocrImageAreaClick()">
        <div class="ocr-placeholder" id="ocrPlaceholder">
          <div style="font-size: 32px; margin-bottom: 6px;">ðŸ“·</div>
          <div>Click to select an image, or drag & drop</div>
          <div style="font-size: 11px; margin-top: 6px; color: var(--text-faint);">or paste a screenshot (Ctrl+V / âŒ˜V)</div>
        </div>
        <img id="ocrPreviewImg" style="display: none;" alt="Scanned image">
      </div>
      <input type="file" id="ocrFileInput" accept="image/*" style="display: none;" onchange="handleOcrFile(event)">
      
      <!-- Rotation controls -->
      <div class="ocr-rotation-bar" id="ocrRotationBar" style="display: none;">
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(-90)" title="Rotate left">â†¶</button>
        <span class="ocr-rotation-label" id="ocrRotationLabel"></span>
        <button class="ocr-rotate-btn" onclick="rotateOcrImage(90)" title="Rotate right">â†·</button>
      </div>
      
      <!-- Progress bar -->
      <div id="ocrProgressArea" style="display: none;">
        <div class="ocr-progress">
          <div class="ocr-progress-bar"><div class="ocr-progress-fill" id="ocrProgressFill"></div></div>
          <div class="ocr-progress-text" id="ocrProgressText">Loadingâ€¦</div>
        </div>
      </div>
      
      <!-- Editable results -->
      <div id="ocrResultsArea" style="display: none;">
        <div class="ocr-results-label">Extracted text â€” edit as needed:</div>
        <div class="ocr-results-area" id="ocrResultLines"></div>
        <div class="ocr-hint" id="ocrHint"></div>
      </div>
      
      <div class="modal-btns" style="margin-top: 16px;">
        <button class="btn btn-secondary" onclick="closeOcrModal()">Cancel</button>
        <button class="btn btn-secondary" id="ocrNewImageBtn" style="display: none;" onclick="ocrNewImage()">ðŸ“· New</button>
        <button class="btn btn-secondary" id="ocrRescanBtn" style="display: none;" onclick="ocrRescan()">ðŸ”„ Rescan</button>
        <button class="btn btn-primary" id="ocrConfirmBtn" style="display: none;" onclick="confirmOcr()">Use Text</button>
      </div>
    </div>
  </div>
</div>

<!-- Full Editor (ported from v1.2.0) -->
<div class="full-editor-overlay" id="fullEditorOverlay">
  <div class="full-editor-container">
    <div class="full-editor-header">
      <button class="full-editor-back" onclick="closeFullEditor()">â†</button>
      <div>
        <div class="full-editor-title" id="fullEditorTitle">Edit Label</div>
        <div class="full-editor-subtitle" id="fullEditorSubtitle">Full formatting options</div>
      </div>
    </div>
    
    <!-- Name input (for new/rename) -->
    <div class="fe-name-row" id="feNameRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feName" placeholder="Name this label (e.g., Return Address, Aria's Labels)">
    </div>
    
    <!-- Name display for existing (editable) -->
    <div class="fe-name-row" id="feNameEditRow" style="display:none;">
      <input type="text" class="fe-name-input" id="feNameEdit" placeholder="Label name">
      <span class="fe-dirty-indicator" id="feDirtyIndicator">â— unsaved</span>
    </div>
    
    <!-- Text Input Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Label Text</div>
      
      <!-- Global Style Controls -->
      <div class="fe-global-style-row">
        <span class="fe-global-style-label">All lines:</span>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('bold')" id="feGlobalBold" title="Bold all"><b>B</b></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('italic')" id="feGlobalItalic" title="Italic all"><i>I</i></button>
        <button class="fe-global-style-btn" onclick="toggleGlobalStyle('underline')" id="feGlobalUnderline" title="Underline all"><u>U</u></button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('left')" title="Align all left">â†</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('center')" title="Align all center">â€¢</button>
        <button class="fe-global-style-btn" onclick="setGlobalAlign('right')" title="Align all right">â†’</button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 4px;"></span>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(11)" title="Size 11 all">11</button>
        <button class="fe-global-style-btn" onclick="setGlobalFontSize(14)" title="Size 14 all">14</button>
      </div>
      
      <div id="feLineInputs">
        <!-- Line 1 -->
        <div class="fe-line-row">
          <span class="fe-line-num">1</span>
          <input type="text" class="fe-line-input" id="feLine1" placeholder="Line 1 â€” use || to split, __ for fill line" maxlength="80" oninput="updateFullEditorPreview()" onfocus="feLastFocusedLine=1">
          <button class="fe-align-btn active" data-line="1" data-align="left" onclick="setFeAlign(1,'left')">â†</button>
          <button class="fe-align-btn" data-line="1" data-align="center" onclick="setFeAlign(1,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="1" data-align="right" onclick="setFeAlign(1,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(1,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize1">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(1,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn1" onclick="toggleFeStylePopover(1)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover1"></div>
          </div>
        </div>
        
        <!-- Line 2 -->
        <div class="fe-line-row">
          <span class="fe-line-num">2</span>
          <input type="text" class="fe-line-input" id="feLine2" placeholder="Line 2" maxlength="80" oninput="updateFullEditorPreview()" onfocus="feLastFocusedLine=2">
          <button class="fe-align-btn active" data-line="2" data-align="left" onclick="setFeAlign(2,'left')">â†</button>
          <button class="fe-align-btn" data-line="2" data-align="center" onclick="setFeAlign(2,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="2" data-align="right" onclick="setFeAlign(2,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(2,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize2">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(2,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn2" onclick="toggleFeStylePopover(2)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover2"></div>
          </div>
        </div>
        
        <!-- Line 3 -->
        <div class="fe-line-row">
          <span class="fe-line-num">3</span>
          <input type="text" class="fe-line-input" id="feLine3" placeholder="Line 3" maxlength="80" oninput="updateFullEditorPreview()" onfocus="feLastFocusedLine=3">
          <button class="fe-align-btn active" data-line="3" data-align="left" onclick="setFeAlign(3,'left')">â†</button>
          <button class="fe-align-btn" data-line="3" data-align="center" onclick="setFeAlign(3,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="3" data-align="right" onclick="setFeAlign(3,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(3,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize3">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(3,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn3" onclick="toggleFeStylePopover(3)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover3"></div>
          </div>
        </div>
        
        <!-- Line 4 -->
        <div class="fe-line-row">
          <span class="fe-line-num">4</span>
          <input type="text" class="fe-line-input" id="feLine4" placeholder="Line 4" maxlength="80" oninput="updateFullEditorPreview()" onfocus="feLastFocusedLine=4">
          <button class="fe-align-btn active" data-line="4" data-align="left" onclick="setFeAlign(4,'left')">â†</button>
          <button class="fe-align-btn" data-line="4" data-align="center" onclick="setFeAlign(4,'center')">â€¢</button>
          <button class="fe-align-btn" data-line="4" data-align="right" onclick="setFeAlign(4,'right')">â†’</button>
          <div class="fe-size-stepper">
            <button class="fe-size-btn" onclick="stepFeSize(4,-1)">âˆ’</button>
            <span class="fe-size-val" id="feSize4">11</span>
            <button class="fe-size-btn" onclick="stepFeSize(4,1)">+</button>
          </div>
          <div style="position:relative">
            <button class="fe-style-btn" id="feStyleBtn4" onclick="toggleFeStylePopover(4)">â‹¯</button>
            <div class="fe-style-popover" id="feStylePopover4"></div>
          </div>
        </div>
      </div>
      
      <div class="fe-line-hint">Use <code>||</code> to split a line Â· Use <code>__</code> for a fill line, e.g. <code>Name__</code></div>
      
      <!-- Token Panel (for templates) -->
      <div class="fe-token-toggle-row" id="feTokenToggleRow" style="display:none;">
        <button class="fe-token-toggle" id="feTokenToggle" onclick="toggleFeTokenPanel()">{T} Insert Token</button>
      </div>
      <div class="fe-token-panel" id="feTokenPanel"></div>
      
      <!-- Emoji Panel -->
      <div class="fe-emoji-toggle-row">
        <button class="fe-emoji-toggle" id="feClearToggle" onclick="clearEditorLines()" title="Clear text lines">ðŸ§¹ Clear</button>
        <button class="fe-emoji-toggle" id="fePasteToggle" onclick="pasteToEditor()" title="Paste from clipboard">ðŸ“‹ Paste</button>
        <button class="fe-emoji-toggle" id="feEmojiToggle" onclick="toggleFeEmojiPanel()">ðŸ˜€ Emoji</button>
        <button class="fe-emoji-toggle" id="feOcrToggle" onclick="openOcrModal()">ðŸ“· Scan</button>
      </div>
      <div class="fe-emoji-panel" id="feEmojiPanel">
        <input type="text" class="fe-emoji-search" id="feEmojiSearch" placeholder="Search emojiâ€¦" oninput="filterFeEmojis()">
        <div class="fe-emoji-scroll" id="feEmojiScroll"></div>
      </div>
      
      <!-- Vertical Alignment -->
      <div class="fe-valign-row">
        <span class="fe-valign-label">Vertical:</span>
        <button class="fe-valign-btn" data-valign="top" onclick="setFeValign('top')">â†‘</button>
        <button class="fe-valign-btn active" data-valign="center" onclick="setFeValign('center')">â€”</button>
        <button class="fe-valign-btn" data-valign="bottom" onclick="setFeValign('bottom')">â†“</button>
        <button class="fe-valign-btn" data-valign="spread" onclick="setFeValign('spread')">â†•</button>
      </div>
      
      <!-- Graphics -->
      <div class="fe-graphics-section">
        <div class="full-editor-section-title">Graphics</div>
        <div class="fe-graphics-row" id="feGraphicsLeft">
          <span class="fe-graphics-label">Left:</span>
          <span id="feGraphicLeftContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('left')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
        <div class="fe-graphics-row" id="feGraphicsRight">
          <span class="fe-graphics-label">Right:</span>
          <span id="feGraphicRightContent">
            <button class="fe-graphic-add" onclick="openFeGraphicPicker('right')">ðŸ–¼ Add Graphic</button>
          </span>
        </div>
      </div>
      
      <!-- Border Controls -->
      <div class="fe-border-section">
        <div class="full-editor-section-title">Label Border</div>
        <div class="fe-border-row">
          <div class="fe-border-toggles">
            <button class="fe-border-toggle" id="feBorderTop" onclick="toggleFeBorder('top')" title="Top border">T</button>
            <button class="fe-border-toggle" id="feBorderBottom" onclick="toggleFeBorder('bottom')" title="Bottom border">B</button>
            <button class="fe-border-toggle" id="feBorderLeft" onclick="toggleFeBorder('left')" title="Left border">L</button>
            <button class="fe-border-toggle" id="feBorderRight" onclick="toggleFeBorder('right')" title="Right border">R</button>
          </div>
          <button class="fe-global-style-btn" onclick="toggleAllBorders()" id="feBorderAll" title="Toggle all borders">All</button>
          <div class="fe-border-color">
            <input type="color" class="fe-border-color-swatch" id="feBorderColor" value="#000000" onchange="updateFeBorderColor(this.value)" title="Border color">
          </div>
        </div>
      </div>
    </div>
    
    <!-- Preview Panel -->
    <div class="full-editor-panel">
      <div class="full-editor-section-title">Preview</div>
      <div class="fe-preview-container">
        <div class="fe-preview-label empty-preview" id="fePreviewLabel">
          <span>Type above to preview</span>
        </div>
      </div>
      <div class="fe-preview-dimensions" id="fePreviewDimensions"></div>
      <div class="fe-preview-type-row">
        <span class="fe-preview-type-label">Preview as:</span>
        <select class="fe-preview-type-select" id="fePreviewType" onchange="changeFePreviewType(this.value)">
          <option value="5160">5160 (1Ã—2â…)</option>
          <option value="5163">5163 (2Ã—4)</option>
          <option value="5164">5164 (3â…“Ã—4)</option>
          <option value="8163">8163 (2Ã—4)</option>
        </select>
      </div>
    </div>
    
    <!-- Actions -->
    <div class="fe-actions">
      <button class="fe-btn fe-btn-secondary" onclick="closeFullEditor()">Cancel</button>
      <button class="fe-btn fe-btn-secondary" id="feBackToWizardBtn" onclick="closeFullEditorToWizard()" style="display:none;">â† Back to Wizard</button>
      <button class="fe-btn fe-btn-primary" id="feSaveBtn" onclick="saveFromFullEditor()">Save</button>
    </div>
  </div>
</div>

<!-- Graphic Picker Modal -->
<div class="fe-graphic-picker" id="feGraphicPicker">
  <div class="fe-graphic-picker-modal">
    <div class="fe-gp-header">
      <span class="fe-gp-title">Add Graphic</span>
      <button class="fe-gp-close" onclick="closeFeGraphicPicker()">Ã—</button>
    </div>
    <div class="fe-gp-tabs">
      <button class="fe-gp-tab active" data-tab="library" onclick="switchFeGpTab('library')">Library</button>
      <button class="fe-gp-tab" data-tab="upload" onclick="switchFeGpTab('upload')">Upload</button>
    </div>
    <div class="fe-gp-body" id="feGpBody">
      <!-- Populated by JS -->
    </div>
  </div>
  <input type="file" id="feGraphicFileInput" accept="image/*" style="display:none" onchange="handleFeGraphicUpload(event)">
</div>

<!-- Print Wizard -->
<div class="wizard-overlay" id="printWizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="wizardBack()">â†</button>
      <div class="wizard-title">Print Labels</div>
    </div>
    
    <!-- Step 1: What to print -->
    <div class="wizard-step active" id="printStep1">
      <div class="wizard-question">What would you like to print?</div>
      <div class="wizard-options">
        <button class="wizard-option" onclick="printWizardChoice('new')">
          <span class="wizard-option-icon">âœï¸</span>
          <span>Type new text</span>
        </button>
        <button class="wizard-option" onclick="printWizardChoice('saved')">
          <span class="wizard-option-icon">ðŸ’¾</span>
          <span>Use something I've saved</span>
        </button>
      </div>
    </div>
    
    <!-- Step 2a: Text Editor -->
    <div class="wizard-step" id="printStep2a">
      <div class="wizard-question">What should the label say?</div>
      
      <!-- Ask AI Button -->
      <div style="margin-bottom: 12px; text-align: right;">
        <button class="ai-ask-btn" onclick="openAIGenerate()">
          âœ¨ Ask AI
        </button>
      </div>
      
      <div class="wizard-editor">
        <div class="editor-lines">
          <div class="editor-line">
            <input type="text" class="editor-line-input" id="wizLine1" placeholder="Line 1" maxlength="100" oninput="updateWizardPreview()">
            <div class="editor-controls">
              <button class="editor-align-btn active" data-line="1" data-align="left" onclick="setWizardAlign(1,'left')" title="Left">â—€</button>
              <button class="editor-align-btn" data-line="1" data-align="center" onclick="setWizardAlign(1,'center')" title="Center">â—†</button>
              <button class="editor-align-btn" data-line="1" data-align="right" onclick="setWizardAlign(1,'right')" title="Right">â–¶</button>
              <button class="editor-size-btn size-s" data-line="1" data-size="9" onclick="setWizardSize(1,9)" title="Small">A</button>
              <button class="editor-size-btn size-m active" data-line="1" data-size="11" onclick="setWizardSize(1,11)" title="Medium">A</button>
              <button class="editor-size-btn size-l" data-line="1" data-size="14" onclick="setWizardSize(1,14)" title="Large">A</button>
            </div>
          </div>
          <div class="editor-line">
            <input type="text" class="editor-line-input" id="wizLine2" placeholder="Line 2 (optional)" maxlength="100" oninput="updateWizardPreview()">
            <div class="editor-controls">
              <button class="editor-align-btn active" data-line="2" data-align="left" onclick="setWizardAlign(2,'left')" title="Left">â—€</button>
              <button class="editor-align-btn" data-line="2" data-align="center" onclick="setWizardAlign(2,'center')" title="Center">â—†</button>
              <button class="editor-align-btn" data-line="2" data-align="right" onclick="setWizardAlign(2,'right')" title="Right">â–¶</button>
              <button class="editor-size-btn size-s" data-line="2" data-size="9" onclick="setWizardSize(2,9)" title="Small">A</button>
              <button class="editor-size-btn size-m active" data-line="2" data-size="11" onclick="setWizardSize(2,11)" title="Medium">A</button>
              <button class="editor-size-btn size-l" data-line="2" data-size="14" onclick="setWizardSize(2,14)" title="Large">A</button>
            </div>
          </div>
          <div class="editor-line">
            <input type="text" class="editor-line-input" id="wizLine3" placeholder="Line 3 (optional)" maxlength="100" oninput="updateWizardPreview()">
            <div class="editor-controls">
              <button class="editor-align-btn active" data-line="3" data-align="left" onclick="setWizardAlign(3,'left')" title="Left">â—€</button>
              <button class="editor-align-btn" data-line="3" data-align="center" onclick="setWizardAlign(3,'center')" title="Center">â—†</button>
              <button class="editor-align-btn" data-line="3" data-align="right" onclick="setWizardAlign(3,'right')" title="Right">â–¶</button>
              <button class="editor-size-btn size-s" data-line="3" data-size="9" onclick="setWizardSize(3,9)" title="Small">A</button>
              <button class="editor-size-btn size-m active" data-line="3" data-size="11" onclick="setWizardSize(3,11)" title="Medium">A</button>
              <button class="editor-size-btn size-l" data-line="3" data-size="14" onclick="setWizardSize(3,14)" title="Large">A</button>
            </div>
          </div>
          <div class="editor-line">
            <input type="text" class="editor-line-input" id="wizLine4" placeholder="Line 4 (optional)" maxlength="100" oninput="updateWizardPreview()">
            <div class="editor-controls">
              <button class="editor-align-btn active" data-line="4" data-align="left" onclick="setWizardAlign(4,'left')" title="Left">â—€</button>
              <button class="editor-align-btn" data-line="4" data-align="center" onclick="setWizardAlign(4,'center')" title="Center">â—†</button>
              <button class="editor-align-btn" data-line="4" data-align="right" onclick="setWizardAlign(4,'right')" title="Right">â–¶</button>
              <button class="editor-size-btn size-s" data-line="4" data-size="9" onclick="setWizardSize(4,9)" title="Small">A</button>
              <button class="editor-size-btn size-m active" data-line="4" data-size="11" onclick="setWizardSize(4,11)" title="Medium">A</button>
              <button class="editor-size-btn size-l" data-line="4" data-size="14" onclick="setWizardSize(4,14)" title="Large">A</button>
            </div>
          </div>
        </div>
        
        <div class="editor-preview-section">
          <div class="editor-preview-label">Preview</div>
          <div class="editor-preview-frame">
            <div class="editor-preview-label-box" id="wizardPreviewBox">
              <div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>
            </div>
          </div>
        </div>
        
        <div style="text-align:center; margin: 12px 0;">
          <button onclick="openFullEditorFromWizard()" style="background:none; border:none; color:var(--accent); font-size:13px; cursor:pointer; text-decoration:underline;">
            Need colors, graphics, or more formatting? Open Full Editor â†’
          </button>
        </div>
        
        <div class="wizard-actions">
          <button class="wizard-btn wizard-btn-secondary" onclick="wizardBack()">Back</button>
          <button class="wizard-btn wizard-btn-primary" id="wizardNextBtn" onclick="wizardToStep3()" disabled>Next â†’</button>
        </div>
      </div>
    </div>
    
    <!-- Step 2b: Saved Content Picker -->
    <div class="wizard-step" id="printStep2b">
      <div class="wizard-question">Choose saved content</div>
      <div class="saved-picker">
        <div class="saved-picker-search">
          <span class="saved-picker-search-icon">ðŸ”</span>
          <input type="text" id="savedPickerSearch" placeholder="Search saved texts..." oninput="filterSavedPicker()">
        </div>
        <div class="saved-picker-list" id="savedPickerList">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>
    
    <!-- Step 3: Quantity -->
    <div class="wizard-step" id="printStep3">
      <div class="wizard-question">How many labels do you need?</div>
      <div class="quantity-selector">
        <div class="quantity-controls">
          <button class="quantity-btn" onclick="adjustQuantity(-1)" id="qtyMinusBtn">âˆ’</button>
          <div class="quantity-value" id="qtyValue">1</div>
          <button class="quantity-btn" onclick="adjustQuantity(1)" id="qtyPlusBtn">+</button>
        </div>
        <div class="quantity-hint" id="qtyHint">You can print up to 30 labels per sheet</div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wizardToStep4()">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 4: Label Type -->
    <div class="wizard-step" id="printStep4">
      <div class="wizard-question">Which label type?</div>
      <div class="type-picker">
        <div class="type-grid" id="typeGrid">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="wizardToStep5()" id="typeNextBtn">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 5: Preview & Print -->
    <div class="wizard-step" id="printStep5">
      <div class="wizard-question">Ready to print?</div>
      <div class="print-preview-section">
        <div class="print-summary" id="printSummary">
          <div class="print-summary-text">Print 1 label on Avery 5160</div>
        </div>
        
        <div class="print-preview-box">
          <div class="print-preview-label" id="printPreviewLabel">
            <!-- Preview rendered by JS -->
          </div>
        </div>
        
        <div class="print-sheet-info" id="printSheetInfo">
          <div class="print-sheet-info-title">Sheet</div>
          <div class="print-sheet-info-text" id="sheetInfoText">Creating new sheet...</div>
          <div class="print-sheet-info-detail" id="sheetInfoDetail"></div>
        </div>
        
        <div id="printInventoryWarning" style="display:none;"></div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="wizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="executePrint()">ðŸ–¨ï¸ Print</button>
      </div>
    </div>
  </div>
</div>

<!-- Print Success Modal -->
<div class="print-success-overlay" id="printSuccessOverlay">
  <div class="print-success-modal">
    <div class="print-success-icon">âœ…</div>
    <div class="print-success-title">Labels Printed!</div>
    <div class="print-success-text" id="printSuccessText">1 label printed on "My Sheet"</div>
    <div class="print-success-actions">
      <button class="print-success-btn print-success-btn-secondary" onclick="printMore()">Print More</button>
      <button class="print-success-btn print-success-btn-primary" onclick="finishPrint()">Done</button>
    </div>
  </div>
</div>

<!-- Reprint Recent Wizard -->
<div class="wizard-overlay" id="reprintWizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="closeWizard('reprintWizard')">â†</button>
      <div class="wizard-title">Reprint Recent Labels</div>
    </div>
    
    <div class="wizard-step active" id="reprintStep1">
      <div class="wizard-question">Select a past print to reprint</div>
      <div class="reprint-list" id="reprintHistoryList">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<!-- Setup Label Sheets Wizard -->
<div class="wizard-overlay" id="setupWizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="setupWizardBack()">â†</button>
      <div class="wizard-title">Set Up Label Sheets</div>
    </div>
    
    <!-- Step 1: Select Label Type -->
    <div class="wizard-step active" id="setupStep1">
      <div class="wizard-question">What type of labels do you have?</div>
      <div class="setup-hint">Look for the Avery number on your label packaging (e.g., 5160, 5163)</div>
      <div class="type-picker">
        <div class="type-grid" id="setupTypeGrid">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeWizard('setupWizard')">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="setupToStep2()">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 2: Stock Count -->
    <div class="wizard-step" id="setupStep2">
      <div class="wizard-question">How many blank sheets do you have?</div>
      <div class="setup-hint">Count the unused label sheets in your stack</div>
      <div class="setup-stock-section">
        <div class="setup-stock-display">
          <button class="setup-stock-btn" onclick="adjustSetupStock(-10)">âˆ’10</button>
          <button class="setup-stock-btn" onclick="adjustSetupStock(-1)">âˆ’</button>
          <div class="setup-stock-value" id="setupStockValue">10</div>
          <button class="setup-stock-btn" onclick="adjustSetupStock(1)">+</button>
          <button class="setup-stock-btn" onclick="adjustSetupStock(10)">+10</button>
        </div>
        <div class="setup-stock-info" id="setupStockInfo">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="setupWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="setupToStep3()">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 3: Confirmation -->
    <div class="wizard-step" id="setupStep3">
      <div class="wizard-question">Label type added!</div>
      <div class="setup-summary" id="setupSummary">
        <!-- Populated by JS -->
      </div>
      <div class="setup-create-sheet">
        <label class="setup-checkbox-label">
          <input type="checkbox" id="setupCreateSheet" checked>
          <span>Create a sheet so I can start printing right away</span>
        </label>
      </div>
      <div class="wizard-actions setup-actions-stack">
        <button class="wizard-btn wizard-btn-secondary" onclick="setupWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-secondary" onclick="setupAddAnother()">+ Add Another Type</button>
        <button class="wizard-btn wizard-btn-primary" onclick="finishSetup()">Done âœ“</button>
      </div>
    </div>
  </div>
</div>

<!-- Mailing List Wizard -->
<div class="wizard-overlay" id="mailingWizard">
  <div class="wizard-container">
    <div class="wizard-header">
      <button class="wizard-back" onclick="mailingWizardBack()">â†</button>
      <div class="wizard-title">Print Mailing List</div>
    </div>
    
    <!-- Step 1: Upload CSV -->
    <div class="wizard-step active" id="mailingStep1">
      <div class="wizard-question">Upload your mailing list</div>
      <div class="setup-hint">CSV or tab-separated file with a header row</div>
      <div class="mailing-upload-area" id="mailingUploadArea" onclick="document.getElementById('mailingFileInput').click()">
        <div class="mailing-upload-icon">ðŸ“„</div>
        <div class="mailing-upload-text">Click to select a file<br><span class="mailing-upload-hint">or drag and drop here</span></div>
        <input type="file" id="mailingFileInput" accept=".csv,.tsv,.txt" style="display:none" onchange="handleMailingFile(this.files[0])">
      </div>
      <div class="mailing-file-info" id="mailingFileInfo" style="display:none">
        <div class="mailing-file-name" id="mailingFileName"></div>
        <div class="mailing-file-meta" id="mailingFileMeta"></div>
        <button class="mailing-file-clear" onclick="clearMailingFile()">Ã—</button>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeWizard('mailingWizard')">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" id="mailingStep1Next" onclick="mailingToStep2()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- Step 2: Select Template -->
    <div class="wizard-step" id="mailingStep2">
      <div class="wizard-question">Choose a template</div>
      <div class="setup-hint">Templates have placeholders like {first_name} that get filled from your data</div>
      <div class="mailing-template-list" id="mailingTemplateList">
        <!-- Populated by JS -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="mailingWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" id="mailingStep2Next" onclick="mailingToStep3()" disabled>Next â†’</button>
      </div>
    </div>
    
    <!-- Step 3: Map Columns -->
    <div class="wizard-step" id="mailingStep3">
      <div class="wizard-question">Match your columns</div>
      <div class="setup-hint">We tried to auto-match. Adjust if needed.</div>
      <div class="mailing-mapping-list" id="mailingMappingList">
        <!-- Populated by JS -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="mailingWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="mailingToStep4()">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 4: Label Type -->
    <div class="wizard-step" id="mailingStep4">
      <div class="wizard-question">Select label type</div>
      <div class="type-picker">
        <div class="type-grid" id="mailingTypeGrid">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="mailingWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="mailingToStep5()">Next â†’</button>
      </div>
    </div>
    
    <!-- Step 5: Preview & Print -->
    <div class="wizard-step" id="mailingStep5">
      <div class="wizard-question">Ready to print</div>
      <div class="mailing-summary" id="mailingSummary">
        <!-- Populated by JS -->
      </div>
      <div class="mailing-preview-scroll" id="mailingPreviewScroll">
        <!-- Populated by JS -->
      </div>
      <div class="wizard-actions">
        <button class="wizard-btn wizard-btn-secondary" onclick="mailingWizardBack()">Back</button>
        <button class="wizard-btn wizard-btn-primary" onclick="executeMailingPrint()">ðŸ–¨ï¸ Print All</button>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Sheet Modal -->
<div class="simple-modal-overlay" id="sheetModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="sheetModalTitle">New Sheet</div>
      <button class="modal-close" onclick="closeSheetModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheet Name</label>
        <input type="text" class="form-input" id="sheetNameInput" placeholder="e.g., Holiday Cards" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="sheetTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group" id="sheetCountGroup">
        <label class="form-label">Number of Physical Sheets</label>
        <input type="number" class="form-input" id="sheetCountInput" value="1" min="1" max="20">
        <div class="form-hint">Pool multiple sheets together for large jobs</div>
      </div>
      <div class="form-group">
        <label class="form-label">Note <span style="color:var(--text-faint);font-weight:normal">(optional)</span></label>
        <input type="text" class="form-input" id="sheetNoteInput" placeholder="e.g., For client mailings" maxlength="80">
        <div class="form-hint">Brief description of what this sheet is for</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSheetModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSheetModal()">Save</button>
    </div>
  </div>
</div>

<!-- Create/Edit Saved Text Modal -->
<div class="simple-modal-overlay" id="savedTextModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="savedTextModalTitle">New Saved Text</div>
      <button class="modal-close" onclick="closeSavedTextModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Name</label>
        <input type="text" class="form-input" id="savedTextNameInput" placeholder="e.g., Return Address" maxlength="40">
      </div>
      <div class="form-group">
        <label class="form-label">Line 1</label>
        <input type="text" class="form-input" id="savedTextLine1" placeholder="First line" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 2</label>
        <input type="text" class="form-input" id="savedTextLine2" placeholder="Second line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 3</label>
        <input type="text" class="form-input" id="savedTextLine3" placeholder="Third line (optional)" maxlength="100">
      </div>
      <div class="form-group">
        <label class="form-label">Line 4</label>
        <input type="text" class="form-input" id="savedTextLine4" placeholder="Fourth line (optional)" maxlength="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSavedTextModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveSavedTextModal()">Save</button>
    </div>
  </div>
</div>

<!-- Confirm Dialog -->
<div class="simple-modal-overlay" id="confirmModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="confirmModalTitle">Confirm</div>
      <button class="modal-close" onclick="closeConfirmModal(false)">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p id="confirmModalMessage">Are you sure?</p>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" id="confirmModalCancelBtn" onclick="closeConfirmModal(false)">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" id="confirmModalOkBtn" onclick="closeConfirmModal(true)">OK</button>
    </div>
  </div>
</div>

<!-- Add Text to Sheet Picker Modal -->
<div class="simple-modal-overlay" id="addTextPickerModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="addTextPickerTitle">Add Content</div>
      <button class="modal-close" onclick="closeAddTextPickerModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <p style="margin-bottom: 12px; color: var(--text-secondary); font-size: 13px;">Select content to add:</p>
      <div class="tab-content-list" style="max-height: 280px; overflow-y: auto;" id="addTextPickerContent">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<!-- Add Inventory Modal -->
<div class="simple-modal-overlay" id="addInventoryModal">
  <div class="simple-modal">
    <div class="simple-modal-header">
      <div class="simple-modal-title">Add Label Type to Inventory</div>
      <button class="modal-close" onclick="closeAddInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Label Type</label>
        <select class="form-select" id="addInventoryTypeSelect">
          <!-- Populated by JS -->
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="addInventoryStock" value="10" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="addInventoryThreshold" value="5" min="0" max="100">
        <div class="form-hint">You'll see a warning when stock drops to this level</div>
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAddInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAddInventory()">Add</button>
    </div>
  </div>
</div>

<!-- Adjust Inventory Modal -->
<div class="simple-modal-overlay" id="adjustInventoryModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="adjustInventoryTitle">Adjust Stock</div>
      <button class="modal-close" onclick="closeAdjustInventoryModal()">Ã—</button>
    </div>
    <div class="simple-modal-body">
      <div class="form-group">
        <label class="form-label">Sheets in Stock</label>
        <input type="number" class="form-input" id="adjustInventoryStock" value="0" min="0" max="999">
      </div>
      <div class="form-group">
        <label class="form-label">Low Stock Warning At</label>
        <input type="number" class="form-input" id="adjustInventoryThreshold" value="5" min="0" max="100">
      </div>
    </div>
    <div class="simple-modal-footer">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeAdjustInventoryModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="saveAdjustInventory()">Save</button>
    </div>
  </div>
</div>

<!-- Batch Import Modal -->
<div class="modal-overlay" id="batchImportModal">
  <div class="modal batch-import-modal">
    <h3>ðŸ“¦ Create Batch Print Job</h3>
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
      Import a CSV file and print labels using template: <strong id="batchTemplateName"></strong>
    </div>

    <!-- File drop zone -->
    <div class="batch-file-zone" id="batchFileZone" onclick="document.getElementById('batchFileInput').click()">
      <span class="file-icon">ðŸ“„</span>
      <span class="file-prompt">Click to select a CSV file or drag & drop here</span>
    </div>
    <input type="file" id="batchFileInput" accept=".csv,.txt" style="display:none" onchange="handleBatchFile(event)">

    <!-- Column mapping (shown after file loaded) -->
    <div id="batchMappingSection" style="display:none">
      <div style="font-size:12px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px">
        Map CSV columns to template tokens:
      </div>
      <div class="batch-col-mapping" id="batchColMapping"></div>

      <!-- Summary -->
      <div class="batch-summary" id="batchSummary"></div>

      <!-- Job name -->
      <div class="batch-job-name-row">
        <label for="batchJobName">Job name:</label>
        <input type="text" id="batchJobName" placeholder="e.g., Holiday Mailing 2024">
      </div>

      <!-- Preview cards -->
      <div class="batch-preview-section">
        <div class="batch-preview-title">Preview (first 3 labels)</div>
        <div class="batch-preview-cards" id="batchPreviewCards"></div>
      </div>
    </div>

    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeBatchImportModal()">Cancel</button>
      <button class="btn btn-primary" id="batchCreateBtn" style="display:none" onclick="createBatchJob()">ðŸ“¦ Create Print Job</button>
    </div>
  </div>
</div>

<!-- Job Complete Modal -->
<div class="modal-overlay" id="jobCompleteModal">
  <div class="modal job-complete-modal">
    <div class="job-complete-summary">
      <div class="job-complete-icon">âœ…</div>
      <div class="job-complete-count" id="jobCompleteCount">0</div>
      <div class="job-complete-label">labels printed successfully</div>
    </div>
    
    <div class="job-remainder-options" id="jobRemainderOptions" style="display:none">
      <div class="job-remainder-title">What would you like to do with the remaining positions on the last sheet?</div>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="keep" checked>
        <div>
          <div class="job-remainder-option-label">Keep as partial sheet</div>
          <div class="job-remainder-option-desc">Save the sheet for future printing</div>
        </div>
      </label>
      <label class="job-remainder-option">
        <input type="radio" name="jobRemainder" value="discard">
        <div>
          <div class="job-remainder-option-label">Discard remaining positions</div>
          <div class="job-remainder-option-desc">Delete all job sheets (saves space)</div>
        </div>
      </label>
    </div>
    
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-primary" onclick="completeJob()">Done</button>
    </div>
  </div>
</div>

<!-- Split Remaining Modal (ported from v1.2) -->
<div class="simple-modal-overlay" id="splitModal">
  <div class="simple-modal split-modal">
    <h3>âœ‚ï¸ Split Remaining Labels</h3>
    <div class="split-summary" id="splitSummary"></div>
    <div class="split-form">
      <div class="split-form-group">
        <label for="splitName" class="split-form-title">New sheet name:</label>
        <input type="text" id="splitName" placeholder="Leftover 5160 - Feb" maxlength="40">
      </div>
      <div class="split-form-group" id="splitModeGroup">
        <div class="split-form-title">Physical sheets:</div>
        <label><input type="radio" name="splitMode" value="separate" checked> Split into separate sheets</label>
        <label><input type="radio" name="splitMode" value="together"> Keep together as one pool</label>
      </div>
      <div class="split-form-group">
        <div class="split-form-title">Text associations:</div>
        <label><input type="radio" name="splitTexts" value="remove" checked> Remove texts (clean slate)</label>
        <label><input type="radio" name="splitTexts" value="keep"> Keep texts (qty set to 0)</label>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeSimpleModal('splitModal')">Cancel</button>
      <button class="btn btn-primary" onclick="executeSplit()">âœ‚ï¸ Split</button>
    </div>
  </div>
</div>

<!-- Clipboard Import Modal (ported from v1.2) -->
<div class="modal-overlay" id="importTextModal">
  <div class="modal import-modal">
    <h3>ðŸ“‹ Import from Clipboard</h3>
    <div class="import-summary" id="importSummary"></div>
    <div class="import-form">
      <!-- Template selection -->
      <div id="importTemplateRow">
        <label for="importTemplateSelect" class="import-form-title">Apply template:</label>
        <select id="importTemplateSelect" onchange="onImportTemplateChange()">
          <option value="">No Template (manual)</option>
        </select>
      </div>
      <!-- Plain list mode: lines per label -->
      <div id="importPlainControls" style="display:none">
        <div class="import-form-title">Lines per label:</div>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="import-stepper">
            <button onclick="stepLinesPerLabel(-1)">âˆ’</button>
            <span id="linesPerLabelVal">1</span>
            <button onclick="stepLinesPerLabel(1)">+</button>
          </div>
          <span style="font-size:13px;color:var(--text-secondary)" id="importRecordCount"></span>
        </div>
      </div>
      <!-- Tabular mode: column mapping -->
      <div id="importTabularControls" style="display:none">
        <div class="import-form-title" id="importColMappingTitle">Map columns to label lines:</div>
        <div class="import-col-mapping" id="importColMapping"></div>
      </div>
      <!-- Preview -->
      <div>
        <div class="import-form-title">Preview:</div>
        <div class="import-preview-area" id="importPreviewArea"></div>
      </div>
      <!-- Base name -->
      <div>
        <label for="importBaseName" class="import-form-title">Base name:</label>
        <input type="text" id="importBaseName" placeholder="e.g. Student" maxlength="40">
        <div class="import-name-preview" id="importNamePreview"></div>
      </div>
      <!-- Sheet assignment -->
      <div>
        <label for="importSheetAssign" class="import-form-title">Assign to sheet (optional):</label>
        <select id="importSheetAssign">
          <option value="">â€” Don't assign â€”</option>
        </select>
      </div>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-secondary" onclick="closeModal('importTextModal')">Cancel</button>
      <button class="btn btn-primary" id="importExecuteBtn" onclick="executeImport()">Import</button>
    </div>
  </div>
</div>

<!-- Welcome / First Run Modal -->
<div class="welcome-overlay" id="welcomeModal">
  <div class="welcome-modal">
    <div class="welcome-header">
      <div class="welcome-icon">ðŸ·ï¸</div>
      <div class="welcome-title">Welcome to LabelKeeper</div>
      <div class="welcome-version">v3.3.22</div>
    </div>
    <div class="welcome-body">
      <div class="welcome-tagline">
        Print labels without wasting a single position. LabelKeeper tracks which spots on your label sheets have been used, so you can print one label at a time or hundredsâ€”and never lose track.
      </div>
      
      <div class="welcome-features">
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“‹</div>
          <div class="welcome-feature-text">
            <strong>Track Sheet Usage</strong><br>
            Never wonder which positions are already printedâ€”the app remembers for you.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¦</div>
          <div class="welcome-feature-text">
            <strong>Manage Inventory</strong><br>
            Know when you're running low on label sheets before you need them.
          </div>
        </div>
        <div class="welcome-feature">
          <div class="welcome-feature-icon">ðŸ“¬</div>
          <div class="welcome-feature-text">
            <strong>Batch Printing</strong><br>
            Import a mailing list and print dozens of labels in one go.
          </div>
        </div>
      </div>
      
      <div class="welcome-data-status" id="welcomeDataStatus" style="display:none;">
        <div class="welcome-data-title">ðŸ“ Found Existing Data</div>
        <div class="welcome-data-items" id="welcomeDataItems">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>
    <div class="welcome-footer">
      <div class="welcome-btn-group">
        <button class="welcome-btn welcome-btn-primary" onclick="closeWelcome(true)">Get Started</button>
        <button class="welcome-btn welcome-btn-secondary" onclick="showSetupWizardFromWelcome()" id="welcomeSetupBtn" style="display:none;">Set Up Label Sheets First</button>
      </div>
      <button class="welcome-skip" onclick="closeWelcome(false)">Don't show again</button>
    </div>
  </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Device Sync Modal -->
<div class="simple-modal-overlay" id="syncModal">
  <div class="simple-modal" style="max-width: 400px;">
    <div class="simple-modal-header">
      <div class="simple-modal-title" id="syncModalTitle">Device Sync</div>
      <button class="modal-close" onclick="closeSyncModal()">Ã—</button>
    </div>
    <div class="simple-modal-body" id="syncModalBody">
      <!-- Content populated by JS -->
    </div>
  </div>
</div>

<div class="print-sheet" id="printSheet"></div>

<script>
// ============================================================================
// LABELKEEPER v2.5.0 â€” DATA LAYER
// ============================================================================

// ========== LABEL TYPES (from v1.x) ==========
const LABEL_TYPES = {
  '5160': { name: '5160 / 8160', desc: 'Standard Address', labelW: 2.625, labelH: 1, cols: 3, rows: 10, topMargin: 0.5, leftMargin: 0.1875, hGutter: 0.125, vGutter: 0, sizeDisplay: '1â€³ Ã— 2â…â€³', layoutDisplay: '3 Ã— 10' },
  '5161': { name: '5161 / 8161', desc: 'Address + Logo', labelW: 4, labelH: 1, cols: 2, rows: 10, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 10' },
  '5162': { name: '5162 / 8162', desc: 'Large Address', labelW: 4, labelH: 1.333, cols: 2, rows: 7, topMargin: 0.8335, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 7' },
  '5163': { name: '5163 / 8163', desc: 'Shipping', labelW: 4, labelH: 2, cols: 2, rows: 5, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '2â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 5' },
  '5164': { name: '5164 / 8164', desc: 'Large Shipping', labelW: 4, labelH: 3.333, cols: 2, rows: 3, topMargin: 0.5005, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '3â…“â€³ Ã— 4â€³', layoutDisplay: '2 Ã— 3' },
  '5167': { name: '5167 / 8167', desc: 'Return Address (tiny)', labelW: 1.75, labelH: 0.5, cols: 4, rows: 20, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'Â½â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 20' },
  '5168': { name: '5168 / 8168', desc: 'Extra Large Shipping', labelW: 3.5, labelH: 5, cols: 2, rows: 2, topMargin: 0.5, leftMargin: 0.5, hGutter: 0.5, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 5â€³', layoutDisplay: '2 Ã— 2' },
  '5195': { name: '5195 / 8195', desc: 'Small Return Address', labelW: 1.75, labelH: 0.667, cols: 4, rows: 15, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: 'â…”â€³ Ã— 1Â¾â€³', layoutDisplay: '4 Ã— 15' },
  '5165': { name: '5165', desc: 'Full Sheet', labelW: 8.5, labelH: 11, cols: 1, rows: 1, topMargin: 0, leftMargin: 0, hGutter: 0, vGutter: 0, sizeDisplay: '8Â½â€³ Ã— 11â€³', layoutDisplay: '1 Ã— 1' },
  // Name Badges & Tent Cards (Session 21)
  '5395': { name: '5395', desc: 'Name Badge', labelW: 3.375, labelH: 2.333, cols: 2, rows: 4, topMargin: 0.55, leftMargin: 0.6875, hGutter: 0.375, vGutter: 0.19, sizeDisplay: '2â…“â€³ Ã— 3â…œâ€³', layoutDisplay: '2 Ã— 4', category: 'badge' },
  '5302': { name: '5302', desc: 'Tent Card (Small)', labelW: 3.5, labelH: 4, cols: 2, rows: 2, topMargin: 0.75, leftMargin: 0.75, hGutter: 0, vGutter: 0, sizeDisplay: '3Â½â€³ Ã— 2â€³ (folded)', layoutDisplay: '2 Ã— 2', category: 'tent', foldLine: 2 }
};
const TYPE_ORDER = ['5160', '5163', '5164', '5161', '5162', '5167', '5195', '5168', '5165', '5395', '5302'];

// ========== LOCALSTORAGE KEYS ==========
// v1.x compatible keys (preserved for data migration)
const SHEETS_KEY = 'avery_sheets_v6';
const ACTIVE_KEY = 'avery_active_v6';
const TEXTS_KEY = 'avery5160_saved_texts';
const THEME_KEY = 'avery5160_theme';
const INVENTORY_KEY = 'avery_inventory';
const ACTIVE_JOB_KEY = 'avery_active_job';
const JOB_HISTORY_KEY = 'avery_job_history';
const CUSTOM_TOKENS_KEY = 'avery5160_custom_tokens';

// v2.0 keys
const SETTINGS_KEY = 'lk_settings';
const PRINT_HISTORY_KEY = 'lk_print_history';
const FIRST_RUN_KEY = 'lk_first_run';

// ========== APP STATE ==========
let settings = {
  darkMode: false,
  lastLabelType: '5160',
  printOffsetTop: 0,       // Manual offset - inches to shift print vertically
  printOffsetLeft: 0,      // Manual offset - inches to shift print horizontally  
  safariPrintOffset: 0.5   // Safari auto-compensation (adjustable)
};

let sheets = {};
let activeSheetId = null;
let savedTexts = [];
let inventory = {};
let activeJob = null;
let jobHistory = [];
let customTokens = [];
let printHistory = [];
let lastPrintJob = null; // For undo last print (from v1.2)

// Safari detection for print offset compensation
// Safari doesn't properly respect @page { margin: 0 } in iframes
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// Helper to get Safari offset (uses settings value, defaults to 0.5)
function getSafariPrintOffset() {
  return isSafari ? (settings.safariPrintOffset ?? 0.5) : 0;
}

// Batch job state (for CSV import)
let batchTemplateId = null;
let batchCsvData = null;
let batchCsvFileName = null;
let batchColTokenMap = [];

// UI state
let currentTab = 'workflows';
let currentWizard = null;
let wizardStep = 1;
let sheetGridPages = {}; // Tracks current page for multi-sheet grids

// ========== BUILT-IN TEMPLATES ==========
const BUILTIN_TEMPLATES = [
  { id: '__builtin_mailing', name: 'Mailing Address', text: 'left,11:{first_name} {last_name}\nleft,11:{street}\nleft,11:{city}, {state} {zip}\nleft,10:{country}', alignV: 'center', type: 'template', tokens: ['first_name','last_name','street','city','state','zip','country'], builtin: true, labelType: '5160' },
  { id: '__builtin_return', name: 'Return Address', text: 'left,9:{name}\nleft,9:{street}\nleft,9:{city}, {state} {zip}', alignV: 'center', type: 'template', tokens: ['name','street','city','state','zip'], builtin: true, labelType: '5167' },
  { id: '__builtin_classroom', name: 'Classroom Label', text: 'left,14:{student_name}\ncenter,11:Room {room} || {teacher}\ncenter,10:Level: {level}', alignV: 'center', type: 'template', tokens: ['student_name','room','teacher','level'], builtin: true, labelType: '5160' },
  { id: '__builtin_namebadge', name: 'Name Badge', text: 'center,16:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5163' },
  // Name Badge templates for 5395
  { id: '__builtin_badge_simple', name: 'Name Badge (Simple)', text: 'center,24:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_company', name: 'Name Badge (Company)', text: 'center,10:HELLO my name is\ncenter,20:{name}\ncenter,12:{company}', alignV: 'center', type: 'template', tokens: ['name','company'], builtin: true, labelType: '5395' },
  { id: '__builtin_badge_event', name: 'Name Badge (Event)', text: 'center,18:{name}\ncenter,12:{title}\ncenter,10:{company}', alignV: 'center', type: 'template', tokens: ['name','title','company'], builtin: true, labelType: '5395' },
  // Tent Card templates for 5302
  { id: '__builtin_tent_name', name: 'Tent Card (Name)', text: 'center,28:{name}', alignV: 'center', type: 'template', tokens: ['name'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_table', name: 'Tent Card (Table)', text: 'center,14:Table\ncenter,36:{table_number}', alignV: 'center', type: 'template', tokens: ['table_number'], builtin: true, labelType: '5302' },
  { id: '__builtin_tent_food', name: 'Tent Card (Food Label)', text: 'center,18:{dish_name}\ncenter,11:{description}', alignV: 'center', type: 'template', tokens: ['dish_name','description'], builtin: true, labelType: '5302' }
];

// Built-in tokens for template editing (categorized)
const BUILTIN_TOKENS = {
  'Name': ['name', 'first_name', 'last_name', 'prefix', 'suffix'],
  'Address': ['street', 'street2', 'city', 'state', 'zip', 'country'],
  'School': ['student_name', 'room', 'teacher', 'grade', 'level', 'student_id'],
  'General': ['title', 'company', 'department', 'phone', 'email'],
  'Events': ['table_number', 'dish_name', 'description', 'event_name', 'date']
};

// Token alias map for auto-mapping columns during CSV import
const TOKEN_ALIASES = {
  'first_name': ['first name', 'first', 'fname', 'given name', 'given_name'],
  'last_name': ['last name', 'last', 'lname', 'surname', 'family name', 'family_name'],
  'name': ['full name', 'fullname', 'full_name', 'student name', 'student_name', 'guest', 'guest name'],
  'student_name': ['student name', 'student', 'pupil', 'child name'],
  'street': ['street address', 'address', 'address1', 'address_1', 'street_address', 'addr'],
  'street2': ['address 2', 'address2', 'address_2', 'apt', 'suite', 'unit'],
  'city': ['town', 'municipality'],
  'state': ['province', 'region', 'st'],
  'zip': ['zip code', 'zipcode', 'postal', 'postal code', 'postal_code', 'postcode'],
  'country': ['nation'],
  'room': ['room number', 'classroom'],
  'teacher': ['teacher name', 'instructor'],
  'grade': ['year', 'class year'],
  'title': ['job title', 'position'],
  'company': ['organization', 'org', 'employer'],
  'phone': ['telephone', 'tel', 'mobile', 'cell'],
  'email': ['email address', 'e-mail'],
  'table_number': ['table', 'table no', 'table #', 'seating'],
  'dish_name': ['dish', 'food', 'item', 'menu item'],
  'description': ['desc', 'details', 'notes', 'info', 'ingredients', 'allergens']
};

// ========== EMOJI DATA ==========
const EMOJI_DATA = [
  { cat: 'Common', emojis: [
    { e: 'â­', n: 'star' }, { e: 'â¤ï¸', n: 'heart love' }, { e: 'âœ…', n: 'check done' }, { e: 'âŒ', n: 'x cross no' },
    { e: 'âš ï¸', n: 'warning caution' }, { e: 'ðŸ“Œ', n: 'pin pushpin' }, { e: 'ðŸ”´', n: 'red circle' }, { e: 'ðŸŸ¢', n: 'green circle' },
    { e: 'ðŸ”µ', n: 'blue circle' }, { e: 'ðŸŸ¡', n: 'yellow circle' }, { e: 'â¬›', n: 'black square' }, { e: 'â¬œ', n: 'white square' },
    { e: 'â–¶ï¸', n: 'play arrow right' }, { e: 'â—€ï¸', n: 'left arrow' }, { e: 'ðŸ”¹', n: 'diamond blue' }, { e: 'ðŸ”¸', n: 'diamond orange' },
  ]},
  { cat: 'School', emojis: [
    { e: 'ðŸ“š', n: 'books reading' }, { e: 'ðŸ“–', n: 'open book reading' }, { e: 'ðŸŽ’', n: 'backpack school bag' }, { e: 'âœ‚ï¸', n: 'scissors craft' },
    { e: 'ðŸ“', n: 'triangle ruler math' }, { e: 'ðŸ“', n: 'ruler measure' }, { e: 'ðŸ–ï¸', n: 'crayon color draw' }, { e: 'ðŸ–Œï¸', n: 'paintbrush art' },
    { e: 'ðŸŽ¨', n: 'art palette paint color' }, { e: 'ðŸ”¬', n: 'microscope science' }, { e: 'ðŸ§ª', n: 'test tube science lab' }, { e: 'ðŸ§®', n: 'abacus math count' },
    { e: 'ðŸŽµ', n: 'music note' }, { e: 'ðŸŽ¶', n: 'music notes' }, { e: 'ðŸ…', n: 'medal award' }, { e: 'ðŸ†', n: 'trophy winner award' },
    { e: 'ðŸ““', n: 'notebook journal' }, { e: 'ðŸ–Šï¸', n: 'pen write' }, { e: 'âœï¸', n: 'pencil write' }, { e: 'ðŸ“', n: 'memo note write' },
    { e: 'ðŸ§©', n: 'puzzle piece' }, { e: 'ðŸŽ²', n: 'dice game' }, { e: 'ðŸ§¸', n: 'teddy bear toy' }, { e: 'ðŸª', n: 'kite play' },
    { e: 'ðŸŽ', n: 'apple teacher' }, { e: 'ðŸ›', n: 'caterpillar bug insect' }, { e: 'ðŸ¸', n: 'frog animal' }, { e: 'ðŸ¢', n: 'turtle animal slow' },
    { e: 'ðŸ¦•', n: 'dinosaur dino' }, { e: 'ðŸ', n: 'bee honeybee insect' }, { e: 'ðŸž', n: 'ladybug insect' }, { e: 'ðŸ¦', n: 'lion animal' },
  ]},
  { cat: 'People', emojis: [
    { e: 'ðŸ˜€', n: 'smile happy' }, { e: 'ðŸ˜Š', n: 'blush smile' }, { e: 'ðŸ‘‹', n: 'wave hello' }, { e: 'ðŸ‘', n: 'thumbs up' },
    { e: 'ðŸ‘Ž', n: 'thumbs down' }, { e: 'ðŸ‘', n: 'clap hands' }, { e: 'ðŸ™', n: 'pray thanks' }, { e: 'ðŸ’ª', n: 'strong muscle' },
    { e: 'ðŸŽ‰', n: 'party celebrate' }, { e: 'ðŸŽ‚', n: 'birthday cake' }, { e: 'ðŸ‘¤', n: 'person silhouette' }, { e: 'ðŸ‘¥', n: 'people group' },
  ]},
  { cat: 'Office', emojis: [
    { e: 'ðŸ“', n: 'folder file' }, { e: 'ðŸ“‚', n: 'open folder' }, { e: 'ðŸ“‹', n: 'clipboard' }, { e: 'ðŸ“Ž', n: 'paperclip' },
    { e: 'âœï¸', n: 'pencil edit' }, { e: 'ðŸ–Šï¸', n: 'pen' }, { e: 'ðŸ“', n: 'memo note' }, { e: 'ðŸ“Š', n: 'chart graph' },
    { e: 'ðŸ“…', n: 'calendar date' }, { e: 'ðŸ—“ï¸', n: 'calendar spiral' }, { e: 'ðŸ“‡', n: 'card index' }, { e: 'ðŸ·ï¸', n: 'label tag' },
    { e: 'ðŸ“¦', n: 'box package' }, { e: 'ðŸ—‚ï¸', n: 'dividers tabs' }, { e: 'ðŸ”‘', n: 'key' }, { e: 'ðŸ”’', n: 'lock' },
  ]},
  { cat: 'Places', emojis: [
    { e: 'ðŸ ', n: 'home house' }, { e: 'ðŸ¢', n: 'office building' }, { e: 'ðŸ«', n: 'school' }, { e: 'ðŸ¥', n: 'hospital' },
    { e: 'â›ª', n: 'church' }, { e: 'ðŸ›ï¸', n: 'classical building' }, { e: 'ðŸ“', n: 'location pin' }, { e: 'ðŸš—', n: 'car' },
    { e: 'âœˆï¸', n: 'airplane travel' }, { e: 'ðŸŒŽ', n: 'earth globe' }, { e: 'ðŸª', n: 'store shop' }, { e: 'ðŸ…¿ï¸', n: 'parking' },
  ]},
  { cat: 'Nature', emojis: [
    { e: 'ðŸŒŸ', n: 'glowing star' }, { e: 'â˜€ï¸', n: 'sun' }, { e: 'ðŸŒ™', n: 'moon' }, { e: 'ðŸŒˆ', n: 'rainbow' },
    { e: 'ðŸ”¥', n: 'fire hot' }, { e: 'ðŸ’§', n: 'water drop' }, { e: 'â„ï¸', n: 'snowflake cold' }, { e: 'ðŸŒº', n: 'flower' },
    { e: 'ðŸŒ²', n: 'tree pine' }, { e: 'ðŸ€', n: 'clover luck' }, { e: 'ðŸ¾', n: 'paw prints animal' }, { e: 'ðŸ¦‹', n: 'butterfly' },
  ]},
  { cat: 'Arrows & Numbers', emojis: [
    { e: 'âž¡ï¸', n: 'right arrow' }, { e: 'â¬…ï¸', n: 'left arrow' }, { e: 'â¬†ï¸', n: 'up arrow' }, { e: 'â¬‡ï¸', n: 'down arrow' },
    { e: 'â†©ï¸', n: 'return back' }, { e: 'ðŸ”„', n: 'refresh cycle' }, { e: 'â‘ ', n: 'one 1' }, { e: 'â‘¡', n: 'two 2' },
    { e: 'â‘¢', n: 'three 3' }, { e: 'â‘£', n: 'four 4' }, { e: 'â‘¤', n: 'five 5' }, { e: 'â’¶', n: 'letter a' },
    { e: 'â’·', n: 'letter b' }, { e: 'â’¸', n: 'letter c' }, { e: 'â„¢', n: 'trademark' }, { e: 'Â©', n: 'copyright' },
  ]},
];

// ========== OCR STATE ==========
let ocrImageBlob = null;
let ocrResults = [];
let ocrRotation = 0;

// ========== HISTORY FILTER STATE ==========
let historySearchQuery = '';
let historyTypeFilter = 'all';
let historySelectedIds = new Set();

const DEFAULT_LOW_THRESHOLD = 5;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function escapeHtml(t) {
  const d = document.createElement('div');
  d.textContent = t;
  return d.innerHTML;
}

function escapeAttr(t) {
  return t.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' ');
}

function generateId(prefix) {
  return (prefix || 'id') + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
}

// ========== LABEL TYPE HELPERS ==========
function getSpec(typeId) {
  return LABEL_TYPES[typeId || '5160'];
}

function getLabelsPerSheet(typeId) {
  const spec = getSpec(typeId);
  return spec.cols * spec.rows;
}

// ========== SHEET HELPERS ==========
function getSheet(id) {
  return sheets[id] || null;
}

function getActiveSheet() {
  return sheets[activeSheetId] || null;
}

function getPoolSize(sh) {
  const spec = getSpec(sh.labelType);
  return spec.cols * spec.rows * (sh.sheetCount || 1);
}

function getPrintedCount(sh) {
  return (sh.printed || []).length;
}

function getRemainingCount(sh) {
  return getPoolSize(sh) - getPrintedCount(sh);
}

function getAssignedCount(sh) {
  if (!sh.texts) return 0;
  return Object.values(sh.texts).reduce((sum, t) => sum + (t.qty || 0), 0);
}

function getAvailableSpots(sh) {
  return Math.max(0, getRemainingCount(sh) - getAssignedCount(sh));
}

// Get physical sheet info for a position index
function getPhysicalSheet(index, sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const physicalSheet = Math.floor(index / lps);
  const localIndex = index % lps;
  const localRow = Math.floor(localIndex / spec.cols);
  const localCol = localIndex % spec.cols;
  return { physicalSheet, localIndex, row: localRow, col: localCol };
}

// Build position assignments for a sheet
function buildAssignments(sh) {
  const spec = getSpec(sh.labelType);
  const lps = spec.cols * spec.rows;
  const total = lps * (sh.sheetCount || 1);
  const printed = new Set(sh.printed || []);
  const assignments = {};
  const errors = [];
  const used = new Set();

  if (!sh.texts) return { assignments, errors };

  const textIds = Object.keys(sh.texts);

  // First pass: place column-specific texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0 || placement === 'next') continue;

    const colNum = parseInt(placement.split(':')[1]) - 1;
    if (colNum < 0 || colNum >= spec.cols) {
      assignments[textId] = [];
      errors.push({ textId, message: 'Column ' + (colNum+1) + ' does not exist' });
      continue;
    }
    const indices = [];
    for (let p = 0; p < (sh.sheetCount || 1) && indices.length < qty; p++) {
      for (let r = 0; r < spec.rows && indices.length < qty; r++) {
        const idx = p * lps + r * spec.cols + colNum;
        if (!printed.has(idx) && !used.has(idx)) {
          indices.push(idx);
          used.add(idx);
        }
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' in Column ' + (colNum+1) + ' but only ' + indices.length + ' available' });
    }
  }

  // Second pass: place "next available" texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0) { assignments[textId] = assignments[textId] || []; continue; }
    if (placement !== 'next') continue;

    const indices = [];
    for (let i = 0; i < total && indices.length < qty; i++) {
      if (!printed.has(i) && !used.has(i)) {
        indices.push(i);
        used.add(i);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' spots but only ' + indices.length + ' available' });
    }
  }

  // Ensure all textIds have an entry
  for (const textId of textIds) {
    if (!assignments[textId]) assignments[textId] = [];
  }

  return { assignments, errors };
}

// ========== SAVED TEXT HELPERS ==========
function getSavedText(id) {
  // Check user texts first
  const found = savedTexts.find(t => t.id === id);
  if (found) return found;
  // Check built-in templates
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

function getTexts() {
  return savedTexts.filter(t => t.type !== 'template');
}

function getTemplates() {
  return [...BUILTIN_TEMPLATES, ...savedTexts.filter(t => t.type === 'template')];
}

// ========== LINE SERIALIZATION ==========
function serializeLines(lines) {
  return lines.map(l => {
    let meta = l.align + ',' + (l.fontSize || 11);
    const flags = (l.bold ? 'b' : '') + (l.italic ? 'i' : '') + (l.underline ? 'u' : '') + (l.strikethrough ? 's' : '');
    const color = l.color || '';
    const fill = l.fillColor || '';
    const borders = l.borders || '';
    if (flags || color || fill || borders) {
      meta += ',' + flags + ',' + color + ',' + fill + ',' + borders;
    }
    return meta + ':' + l.text;
  }).join('\n');
}

function deserializeLines(str) {
  if (!str) return [];
  return str.split('\n').filter(s => s.trim()).map(s => {
    // Extended format: align,fontSize,flags,color,fillColor,borders:text
    const m3 = s.match(/^(left|center|right),(\d+),([\s\S]*?):(.*)$/);
    if (m3) {
      const parts = m3[3].split(',');
      const flags = parts[0] || '';
      const color = parts[1] || '';
      const fill = parts[2] || '';
      const borders = parts[3] || '';
      const line = { text: m3[4], align: m3[1], fontSize: parseInt(m3[2]) || 11 };
      if (flags.includes('b')) line.bold = true;
      if (flags.includes('i')) line.italic = true;
      if (flags.includes('u')) line.underline = true;
      if (flags.includes('s')) line.strikethrough = true;
      if (color) line.color = color;
      if (fill) line.fillColor = fill;
      if (borders) line.borders = borders;
      return line;
    }
    // Legacy format: align,fontSize:text
    const m2 = s.match(/^(left|center|right),(\d+):(.*)$/);
    if (m2) return { text: m2[3], align: m2[1], fontSize: parseInt(m2[2]) || 11 };
    const m = s.match(/^(left|center|right):(.*)$/);
    if (m) return { text: m[2], align: m[1], fontSize: 11 };
    return { text: s, align: 'left', fontSize: 11 };
  });
}

function getFlatText(lines) {
  return lines.map(l => l.text).join(' / ');
}

// Parse line for split (||) and fill (__) syntax
function parseLine(text) {
  if (text.includes('||')) {
    const parts = text.split('||').map(s => s.trim());
    return { type: 'split', left: parts[0], right: parts.slice(1).join(' ').trim() };
  }
  if (text.includes('__')) {
    const idx = text.indexOf('__');
    return { type: 'fill', label: text.substring(0, idx), trailing: text.substring(idx + 2).trim() };
  }
  return { type: 'normal', text };
}

// ========== TOKEN SYSTEM ==========
function extractTokens(text) {
  const re = /\{([a-z][a-z0-9_]*)\}/gi;
  const tokens = [];
  let m;
  while ((m = re.exec(text)) !== null) {
    const token = m[1].toLowerCase();
    if (!tokens.includes(token)) tokens.push(token);
  }
  return tokens;
}

function replaceTokens(text, record) {
  return text.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, token) => {
    const key = token.toLowerCase();
    return record[key] !== undefined ? record[key] : match;
  });
}

// ========== AI INTEGRATION (v2.0 - Session 9) ==========

/**
 * Parse #LABELKEEPER format from clipboard/text
 * Format:
 *   #LABELKEEPER
 *   type: 5160
 *   qty: 3
 *   ---
 *   Line 1 content
 *   Line 2 content
 *   Line 3 content
 *   Line 4 content
 * 
 * Returns: { valid: true, type, qty, lines[] } or { valid: false }
 */
function parseLabelKeeperFormat(text) {
  if (!text || typeof text !== 'string') {
    return { valid: false };
  }
  
  const trimmed = text.trim();
  
  // Must start with #LABELKEEPER (case insensitive)
  if (!trimmed.toUpperCase().startsWith('#LABELKEEPER')) {
    return { valid: false };
  }
  
  // Split into header and content
  const separatorIndex = trimmed.indexOf('---');
  if (separatorIndex === -1) {
    return { valid: false };
  }
  
  const headerSection = trimmed.substring(0, separatorIndex);
  const contentSection = trimmed.substring(separatorIndex + 3).trim();
  
  // Parse header fields
  const headerLines = headerSection.split('\n').map(l => l.trim()).filter(l => l && l !== '#LABELKEEPER');
  
  let type = null;
  let qty = 1;
  
  for (const line of headerLines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) continue;
    
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    
    if (key === 'type') {
      // Accept formats: "5160", "avery5160", "avery 5160"
      const typeMatch = value.match(/\d{4}/);
      if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
        type = typeMatch[0];
      }
    } else if (key === 'qty' || key === 'quantity' || key === 'count') {
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
        qty = parsed;
      }
    }
  }
  
  // Parse content lines (up to 4)
  const contentLines = contentSection.split('\n').map(l => l.trim());
  const lines = contentLines.slice(0, 4);
  
  // Pad to 4 lines if needed
  while (lines.length < 4) {
    lines.push('');
  }
  
  // Must have at least one non-empty line
  if (lines.every(l => !l)) {
    return { valid: false };
  }
  
  return {
    valid: true,
    type: type,  // null means use default/last-used
    qty: qty,
    lines: lines
  };
}

/**
 * Parse URL query parameters for deep linking
 * Supported params:
 *   ?text=Line1|Line2|Line3|Line4  (pipe-separated)
 *   ?type=5160
 *   ?qty=3
 *   ?action=print  (goes directly to print wizard)
 * 
 * Returns: { hasParams: true, text, type, qty, action } or { hasParams: false }
 */
function parseUrlParams() {
  const params = new URLSearchParams(window.location.search);
  
  // Check for sheet deep link (QR code scan)
  if (params.has('sheet')) {
    return { 
      hasParams: true,
      action: 'openSheet',
      sheetId: params.get('sheet')
    };
  }
  
  if (!params.has('text') && !params.has('action')) {
    return { hasParams: false };
  }
  
  const result = {
    hasParams: true,
    text: null,
    lines: ['', '', '', ''],
    type: null,
    qty: 1,
    action: params.get('action') || 'print'
  };
  
  // Parse text (pipe-separated lines)
  if (params.has('text')) {
    const textParam = params.get('text');
    const lines = textParam.split('|').map(l => l.trim());
    result.lines = lines.slice(0, 4);
    while (result.lines.length < 4) {
      result.lines.push('');
    }
    result.text = textParam;
  }
  
  // Parse type
  if (params.has('type')) {
    const typeMatch = params.get('type').match(/\d{4}/);
    if (typeMatch && LABEL_TYPES[typeMatch[0]]) {
      result.type = typeMatch[0];
    }
  }
  
  // Parse quantity
  if (params.has('qty')) {
    const parsed = parseInt(params.get('qty'), 10);
    if (!isNaN(parsed) && parsed >= 1 && parsed <= 999) {
      result.qty = parsed;
    }
  }
  
  return result;
}

/**
 * Generate shareable prompt for AI assistants
 */
function getAIPromptTemplate() {
  return `When generating labels for LabelKeeper, format your output like this:

#LABELKEEPER
type: 5160
qty: 1
---
Line 1 (name or main text)
Line 2 (address line 1 or subtitle)
Line 3 (address line 2 or additional info)
Line 4 (city, state zip or footer)

Supported label types:
- 5160: Address labels (1" x 2.625", 30/sheet)
- 5163: Shipping labels (2" x 4", 10/sheet)
- 5167: Return address (0.5" x 1.75", 80/sheet)
- 5161: Address (1" x 4", 20/sheet)
- 5162: Address (1.33" x 4", 14/sheet)
- 5164: Shipping (3.33" x 4", 6/sheet)
- 8463: Shipping (2" x 4", 10/sheet)
- 18163: Shipping (2" x 4", 10/sheet)
- 5267: Return address (0.5" x 1.75", 80/sheet)

The user can paste this format directly into LabelKeeper for instant preview and printing.`;
}

// ============================================================================
// DATA PERSISTENCE
// ============================================================================

// ========== SETTINGS ==========
function loadSettings() {
  try {
    const saved = localStorage.getItem(SETTINGS_KEY);
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
    } else {
      // No saved settings - check system preference for dark mode
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        settings.darkMode = true;
      }
    }
    // Check legacy theme key
    const legacyTheme = localStorage.getItem(THEME_KEY);
    if (legacyTheme === 'dark') {
      settings.darkMode = true;
    }
  } catch(e) {}
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    localStorage.setItem(THEME_KEY, settings.darkMode ? 'dark' : 'light');
  } catch(e) {}
}

// ========== SHEETS ==========
function loadSheets() {
  try {
    const s = localStorage.getItem(SHEETS_KEY);
    if (s) sheets = JSON.parse(s);
    activeSheetId = localStorage.getItem(ACTIVE_KEY);
  } catch(e) {}
  
  // Try legacy migration
  if (!Object.keys(sheets).length) {
    try {
      const old = localStorage.getItem('avery5160_sheets');
      if (old) {
        const oldSheets = JSON.parse(old);
        for (const [id, sh] of Object.entries(oldSheets)) {
          sheets[id] = { ...sh, id, labelType: '5160' };
        }
        activeSheetId = localStorage.getItem('avery5160_active');
      }
    } catch(e) {}
  }
  
  // Ensure data consistency
  for (const [id, sh] of Object.entries(sheets)) {
    if (!sh.id) sh.id = id;  // Ensure id property exists
    if (!sh.labelType) sh.labelType = '5160';
    if (!sh.texts) sh.texts = {};
    if (!sh.sheetCount) sh.sheetCount = 1;
    if (!sh.printed) sh.printed = [];
    for (const entry of Object.values(sh.texts)) {
      if (!entry.placement) entry.placement = 'next';
    }
  }
  
  // Set active sheet if none
  if (!activeSheetId || !sheets[activeSheetId]) {
    if (Object.keys(sheets).length) {
      activeSheetId = Object.keys(sheets)[0];
    }
  }
}

function saveSheets() {
  try {
    localStorage.setItem(SHEETS_KEY, JSON.stringify(sheets));
    localStorage.setItem(ACTIVE_KEY, activeSheetId || '');
  } catch(e) {}
}

// ========== SAVED TEXTS ==========
function loadSavedTexts() {
  try {
    const s = localStorage.getItem(TEXTS_KEY);
    if (s) savedTexts = JSON.parse(s);
  } catch(e) {}
}

function saveSavedTexts() {
  try {
    localStorage.setItem(TEXTS_KEY, JSON.stringify(savedTexts));
  } catch(e) {}
}

// ========== INVENTORY ==========
function loadInventory() {
  try {
    const s = localStorage.getItem(INVENTORY_KEY);
    if (s) inventory = JSON.parse(s);
  } catch(e) {}
}

function saveInventory() {
  try {
    localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory));
  } catch(e) {}
}

function getInventoryForType(labelType) {
  return inventory[labelType] || null;
}

function getInventorySummary(labelType) {
  const inv = inventory[labelType];
  const spec = LABEL_TYPES[labelType];
  if (!spec) return null;
  const lps = spec.cols * spec.rows;
  const stock = inv ? inv.stock : 0;

  let activeSheets = 0, partialSheets = 0, partialLabels = 0, fullyConsumed = 0;
  let assignedUnusedSheets = 0; // Sheets assigned to content but fully available
  let assignedPartialSheets = 0; // Sheets assigned with some printed
  
  for (const sh of Object.values(sheets)) {
    if (sh.labelType !== labelType) continue;
    const count = sh.sheetCount || 1;
    const printed = new Set(sh.printed || []);
    for (let p = 0; p < count; p++) {
      activeSheets++;
      let open = 0;
      for (let i = p * lps; i < (p + 1) * lps; i++) {
        if (!printed.has(i)) open++;
      }
      if (open === lps) {
        // All positions available
        assignedUnusedSheets++;
        partialSheets++; // Still count toward partial for legacy
        partialLabels += open;
      } else if (open > 0) {
        assignedPartialSheets++;
        partialSheets++;
        partialLabels += open;
      } else {
        fullyConsumed++;
      }
    }
  }

  return {
    stock, lps,
    stockLabels: stock * lps,
    activeSheets, partialSheets, partialLabels, fullyConsumed,
    assignedUnusedSheets,
    assignedPartialSheets,
    totalSheets: stock + partialSheets,
    totalLabels: (stock * lps) + partialLabels,
    isLow: inv ? stock <= inv.lowThreshold : false,
    lowThreshold: inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD
  };
}

// ========== BATCH JOBS ==========
function loadActiveJob() {
  try {
    const stored = localStorage.getItem(ACTIVE_JOB_KEY);
    activeJob = stored ? JSON.parse(stored) : null;
  } catch(e) { activeJob = null; }
}

function saveActiveJob() {
  try {
    if (activeJob) {
      localStorage.setItem(ACTIVE_JOB_KEY, JSON.stringify(activeJob));
    } else {
      localStorage.removeItem(ACTIVE_JOB_KEY);
    }
  } catch(e) {}
}

function hasActiveJob() {
  return activeJob !== null;
}

function getActiveJob() {
  return activeJob;
}

function loadJobHistory() {
  try {
    const stored = localStorage.getItem(JOB_HISTORY_KEY);
    jobHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { jobHistory = []; }
}

function saveJobHistory() {
  try {
    localStorage.setItem(JOB_HISTORY_KEY, JSON.stringify(jobHistory));
  } catch(e) {}
}

// ========== PRINT HISTORY (v2 new) ==========
function loadPrintHistory() {
  try {
    const stored = localStorage.getItem(PRINT_HISTORY_KEY);
    printHistory = stored ? JSON.parse(stored) : [];
  } catch(e) { printHistory = []; }
}

function savePrintHistory() {
  try {
    localStorage.setItem(PRINT_HISTORY_KEY, JSON.stringify(printHistory));
  } catch(e) {}
}

function addPrintHistoryEntry(entry) {
  printHistory.unshift({
    id: generateId('ph'),
    timestamp: Date.now(),
    ...entry
  });
  // Keep last 100 entries
  if (printHistory.length > 100) {
    printHistory = printHistory.slice(0, 100);
  }
  savePrintHistory();
}

// ========== CUSTOM TOKENS ==========
function loadCustomTokens() {
  try {
    const s = localStorage.getItem(CUSTOM_TOKENS_KEY);
    if (s) customTokens = JSON.parse(s);
  } catch(e) {}
}

function saveCustomTokens() {
  try {
    localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(customTokens));
  } catch(e) {}
}

// ============================================================================
// SHEET OPERATIONS
// ============================================================================

function createSheet(name, labelType, sheetCount = 1, note = '') {
  const id = generateId('sh');
  sheets[id] = {
    id,
    name,
    labelType,
    sheetCount,
    note: note || '',
    printed: [],
    texts: {},
    createdAt: Date.now()
  };
  activeSheetId = id;
  saveSheets();
  return id;
}

function deleteSheet(id) {
  if (!sheets[id]) return false;
  delete sheets[id];
  if (activeSheetId === id) {
    activeSheetId = Object.keys(sheets)[0] || null;
  }
  saveSheets();
  return true;
}

function renameSheet(id, newName) {
  if (!sheets[id]) return false;
  sheets[id].name = newName;
  saveSheets();
  return true;
}

function setActiveSheet(id) {
  if (sheets[id]) {
    activeSheetId = id;
    saveSheets();
  }
}

function markPositionsPrinted(sheetId, positions) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const printed = new Set(sh.printed || []);
  for (const pos of positions) {
    printed.add(pos);
  }
  sh.printed = Array.from(printed).sort((a, b) => a - b);
  saveSheets();
}

// ============================================================================
// SAVED TEXT OPERATIONS
// ============================================================================

function createSavedText(name, lines, opts = {}) {
  const id = generateId('st');
  const entry = {
    id,
    name,
    text: serializeLines(lines),
    alignV: opts.alignV || 'center',
    createdAt: Date.now()
  };
  if (opts.graphics) entry.graphics = opts.graphics;
  if (opts.isTemplate) {
    entry.type = 'template';
    entry.tokens = extractTokens(entry.text);
    entry.labelType = opts.labelType || '5160';
  }
  savedTexts.push(entry);
  saveSavedTexts();
  return id;
}

function updateSavedText(id, updates) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  savedTexts[idx] = { ...savedTexts[idx], ...updates };
  if (updates.text && savedTexts[idx].type === 'template') {
    savedTexts[idx].tokens = extractTokens(updates.text);
  }
  saveSavedTexts();
  return true;
}

function deleteSavedText(id) {
  const idx = savedTexts.findIndex(t => t.id === id);
  if (idx === -1) return false;
  savedTexts.splice(idx, 1);
  // Remove from all sheets
  for (const sh of Object.values(sheets)) {
    if (sh.texts && sh.texts[id]) {
      delete sh.texts[id];
    }
  }
  saveSavedTexts();
  saveSheets();
  return true;
}

function cloneSavedText(id, newName) {
  const original = getSavedText(id);
  if (!original) return null;
  const clone = {
    id: generateId('st'),
    name: newName,
    text: original.text,
    alignV: original.alignV || 'center',
    createdAt: Date.now()
  };
  if (original.graphics) clone.graphics = JSON.parse(JSON.stringify(original.graphics));
  if (original.type === 'template') {
    clone.type = 'template';
    clone.tokens = [...(original.tokens || [])];
    clone.labelType = original.labelType || '5160';
  }
  savedTexts.push(clone);
  saveSavedTexts();
  return clone.id;
}

// ============================================================================
// DATA EXPORT/IMPORT
// ============================================================================

function exportAllDataJSON() {
  const data = {
    version: '3.0.0',
    exportedAt: new Date().toISOString(),
    sheets,
    savedTexts,
    inventory,
    activeJob,
    jobHistory,
    customTokens,
    printHistory,
    settings,
    theme: settings.darkMode ? 'dark' : 'light'
  };
  return JSON.stringify(data, null, 2);
}

function importAllData(json) {
  try {
    const data = JSON.parse(json);
    
    // Validate
    if (!data.sheets && !data.savedTexts) {
      throw new Error('Invalid backup file');
    }
    
    // Import sheets
    if (data.sheets) {
      sheets = data.sheets;
      // Ensure consistency
      for (const sh of Object.values(sheets)) {
        if (!sh.labelType) sh.labelType = '5160';
        if (!sh.texts) sh.texts = {};
        if (!sh.sheetCount) sh.sheetCount = 1;
        if (!sh.printed) sh.printed = [];
      }
      activeSheetId = Object.keys(sheets)[0] || null;
      saveSheets();
    }
    
    // Import texts
    if (data.savedTexts) {
      savedTexts = data.savedTexts;
      saveSavedTexts();
    }
    
    // Import inventory
    if (data.inventory) {
      inventory = data.inventory;
      saveInventory();
    }
    
    // Import jobs
    if (data.activeJob !== undefined) {
      activeJob = data.activeJob;
      saveActiveJob();
    }
    if (data.jobHistory) {
      jobHistory = data.jobHistory;
      saveJobHistory();
    }
    
    // Import custom tokens
    if (data.customTokens) {
      customTokens = data.customTokens;
      saveCustomTokens();
    }
    
    // Import print history
    if (data.printHistory) {
      printHistory = data.printHistory;
      savePrintHistory();
    }
    
    // Import theme
    if (data.theme) {
      settings.darkMode = data.theme === 'dark';
      saveSettings();
    }
    
    return { success: true };
  } catch(e) {
    return { success: false, error: e.message };
  }
}

// ============================================================================
// DATA STATS (for UI)
// ============================================================================

function getDataStats() {
  const sheetCount = Object.keys(sheets).length;
  const textCount = savedTexts.filter(t => t.type !== 'template').length;
  const templateCount = savedTexts.filter(t => t.type === 'template').length + BUILTIN_TEMPLATES.length;
  const inventoryTypes = Object.keys(inventory).length;
  
  let totalAvailable = 0;
  let totalPrinted = 0;
  for (const sh of Object.values(sheets)) {
    totalAvailable += getRemainingCount(sh);
    totalPrinted += getPrintedCount(sh);
  }
  
  return {
    sheetCount,
    textCount,
    templateCount,
    inventoryTypes,
    totalAvailable,
    totalPrinted,
    printHistoryCount: printHistory.length,
    hasData: sheetCount > 0 || textCount > 0
  };
}

// ============================================================================
// UI STATE & NAVIGATION
// ============================================================================

function applyTheme() {
  document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light');
  updateToggle('darkModeToggle', settings.darkMode);
}

function toggleDarkMode() {
  settings.darkMode = !settings.darkMode;
  saveSettings();
  applyTheme();
}

function updateToggle(id, active) {
  const toggle = document.getElementById(id);
  if (toggle) {
    toggle.classList.toggle('active', active);
  }
}

function openSettings() {
  // Populate data stats
  const stats = getDataStats();
  const statsEl = document.getElementById('settingsDataStats');
  statsEl.innerHTML = 
    '<div class="settings-data-stat">ðŸ“„ <strong>' + stats.sheets + '</strong> sheet' + (stats.sheets !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ’¾ <strong>' + stats.savedTexts + '</strong> saved text' + (stats.savedTexts !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“¦ <strong>' + stats.inventory + '</strong> inventory type' + (stats.inventory !== 1 ? 's' : '') + '</div>' +
    '<div class="settings-data-stat">ðŸ“œ <strong>' + stats.printHistory + '</strong> history item' + (stats.printHistory !== 1 ? 's' : '') + '</div>';
  
  // Populate print offset fields
  document.getElementById('safariPrintOffset').value = settings.safariPrintOffset ?? 0.5;
  document.getElementById('printOffsetTop').value = settings.printOffsetTop || 0;
  document.getElementById('printOffsetLeft').value = settings.printOffsetLeft || 0;
  
  // Update AI key status
  updateAIKeyStatusUI();
  
  document.getElementById('settingsModal').classList.add('visible');
}

function updatePrintOffset() {
  settings.safariPrintOffset = parseFloat(document.getElementById('safariPrintOffset').value) ?? 0.5;
  settings.printOffsetTop = parseFloat(document.getElementById('printOffsetTop').value) || 0;
  settings.printOffsetLeft = parseFloat(document.getElementById('printOffsetLeft').value) || 0;
  saveSettings();
  showToast('Print settings saved', 'success');
}

function closeSettings() {
  document.getElementById('settingsModal').classList.remove('visible');
}

// ========== AI PROMPT MODAL ==========
function showAIPromptModal() {
  const promptBox = document.getElementById('aiPromptBox');
  if (promptBox) {
    promptBox.textContent = getAIPromptTemplate();
  }
  document.getElementById('aiPromptModal').classList.add('visible');
}

function closeAIPromptModal() {
  document.getElementById('aiPromptModal').classList.remove('visible');
}

function copyAIPrompt() {
  const prompt = getAIPromptTemplate();
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(prompt).then(() => {
      showToast('Prompt copied to clipboard!', 'success');
    }).catch(() => {
      fallbackCopyToClipboard(prompt);
    });
  } else {
    fallbackCopyToClipboard(prompt);
  }
}

function fallbackCopyToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    document.execCommand('copy');
    showToast('Prompt copied!', 'success');
  } catch (e) {
    showToast('Failed to copy. Please select and copy manually.', 'warning');
  }
  document.body.removeChild(textarea);
}

function copyDeepLinkExample() {
  const baseUrl = window.location.href.split('?')[0];
  const example = baseUrl + '?text=John%20Smith|123%20Main%20St|Boston,%20MA%2002101&type=5160&qty=1';
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(example).then(() => {
      showToast('Link format copied!', 'success');
    }).catch(() => {
      showToast('Copy failed', 'error');
    });
  }
}

// ========== BYOAI - Bring Your Own AI ==========
const AI_KEY_STORAGE = 'lk_ai_key';
const AI_PROVIDER_STORAGE = 'lk_ai_provider';

// Detect provider from API key format
function detectAIProvider(key) {
  if (!key) return null;
  key = key.trim();
  if (key.startsWith('sk-ant-')) return 'claude';
  if (key.startsWith('sk-')) return 'openai';
  // Gemini keys are typically 39 chars and alphanumeric
  if (/^[A-Za-z0-9_-]{39}$/.test(key)) return 'gemini';
  return null;
}

// Get stored AI key
function getAIKey() {
  try {
    return localStorage.getItem(AI_KEY_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Get stored provider
function getAIProvider() {
  try {
    return localStorage.getItem(AI_PROVIDER_STORAGE) || '';
  } catch (e) {
    return '';
  }
}

// Save AI key
function saveAIKeyToStorage(key, provider) {
  try {
    localStorage.setItem(AI_KEY_STORAGE, key);
    localStorage.setItem(AI_PROVIDER_STORAGE, provider);
    return true;
  } catch (e) {
    return false;
  }
}

// Clear AI key
function clearAIKeyFromStorage() {
  try {
    localStorage.removeItem(AI_KEY_STORAGE);
    localStorage.removeItem(AI_PROVIDER_STORAGE);
    return true;
  } catch (e) {
    return false;
  }
}

// Update Settings UI to reflect AI key status
function updateAIKeyStatusUI() {
  const hasKey = !!getAIKey();
  const provider = getAIProvider();
  
  const statusEl = document.getElementById('aiKeyStatus');
  const statusTextEl = document.getElementById('aiKeyStatusText');
  const configBtn = document.getElementById('aiKeyConfigBtn');
  const configBtnText = document.getElementById('aiKeyConfigBtnText');
  const clearBtn = document.getElementById('aiKeyClearBtn');
  
  if (!statusEl) return;
  
  if (hasKey && provider) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    statusEl.classList.remove('no-key');
    statusTextEl.textContent = `Connected to ${providerNames[provider] || provider}`;
    configBtnText.textContent = 'Change Key';
    clearBtn.style.display = 'inline-flex';
  } else {
    statusEl.classList.add('no-key');
    statusTextEl.textContent = 'No API key configured';
    configBtnText.textContent = 'Add API Key';
    clearBtn.style.display = 'none';
  }
}

// Show AI Key modal
function showAIKeyModal() {
  const input = document.getElementById('aiKeyInput');
  if (input) {
    input.value = getAIKey();
  }
  document.getElementById('aiKeyModal').classList.add('visible');
}

// Close AI Key modal
function closeAIKeyModal() {
  document.getElementById('aiKeyModal').classList.remove('visible');
}

// Save AI key from modal
function saveAIKey() {
  const input = document.getElementById('aiKeyInput');
  const key = input ? input.value.trim() : '';
  
  if (!key) {
    showToast('Please enter an API key', 'warning');
    return;
  }
  
  const provider = detectAIProvider(key);
  if (!provider) {
    showToast('Unrecognized key format. Please use a Claude, OpenAI, or Gemini key.', 'error');
    return;
  }
  
  if (saveAIKeyToStorage(key, provider)) {
    const providerNames = { claude: 'Claude', openai: 'OpenAI', gemini: 'Gemini' };
    showToast(`${providerNames[provider]} API key saved!`, 'success');
    closeAIKeyModal();
    updateAIKeyStatusUI();
  } else {
    showToast('Failed to save key', 'error');
  }
}

// Clear AI key
function clearAIKey() {
  if (confirm('Remove your API key? You can add it again anytime.')) {
    clearAIKeyFromStorage();
    showToast('API key removed', 'info');
    updateAIKeyStatusUI();
  }
}

// ===== AI CATEGORY FLOW =====
let currentAICategory = null;

function openAICategoryModal() {
  // Check if AI key is configured first
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  document.getElementById('aiCategoryModal').classList.add('visible');
}

function closeAICategoryModal() {
  document.getElementById('aiCategoryModal').classList.remove('visible');
}

function selectAICategory(category) {
  currentAICategory = category;
  closeAICategoryModal();
  showAICategoryForm(category);
}

function showAICategoryForm(category) {
  const titleEl = document.getElementById('aiFormTitle');
  const bodyEl = document.getElementById('aiFormBody');
  
  const forms = {
    address: {
      title: 'ðŸ“¬ Address Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Full Address</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiAddressInput" placeholder="Paste or type the full address...

Example:
John Smith
123 Main Street
Boston, MA 02101"></textarea>
          <div class="ai-form-hint">Include name, street, city, state, and zip</div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    gift: {
      title: 'ðŸŽ Gift Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Who is it for?</label>
          <input type="text" class="ai-form-input" id="aiGiftTo" placeholder="Sarah, Mom, The Johnsons...">
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">What's the occasion?</label>
          <input type="text" class="ai-form-input" id="aiGiftOccasion" placeholder="Birthday, Christmas, Thank you...">
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Birthday')">Birthday</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Christmas')">Christmas</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Thank You')">Thank You</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Wedding')">Wedding</span>
            <span class="ai-suggestion-chip" onclick="fillGiftOccasion('Baby Shower')">Baby Shower</span>
          </div>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">From (optional)</label>
          <input type="text" class="ai-form-input" id="aiGiftFrom" placeholder="With love from...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Label</button>
        </div>
      `
    },
    organize: {
      title: 'ðŸ·ï¸ Organization Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What are you labeling?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiOrganizeItems" placeholder="List items (one per line or comma separated)...

Examples:
â€¢ Flour, Sugar, Rice, Pasta
â€¢ Q1 Reports, Tax Documents, Receipts
â€¢ Kids Toys, Winter Clothes, Holiday Decor"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('pantry')">ðŸ¥« Pantry</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('files')">ðŸ“ Files</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('bins')">ðŸ“¦ Storage Bins</span>
            <span class="ai-suggestion-chip" onclick="fillOrganizeType('kids')">ðŸ§¸ Kids Stuff</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    moving: {
      title: 'ðŸ“¦ Moving Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">What rooms/boxes do you need?</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiMovingRooms" placeholder="List rooms or box contents...

Example:
Kitchen - Pots & Pans
Kitchen - Fragile Dishes
Bedroom - Clothes
Garage - Tools"></textarea>
          <div class="ai-suggestions">
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Kitchen')">Kitchen</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bedroom')">Bedroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Bathroom')">Bathroom</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Living Room')">Living Room</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('Garage')">Garage</span>
            <span class="ai-suggestion-chip" onclick="fillMovingRoom('FRAGILE')">âš ï¸ Fragile</span>
          </div>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Labels</button>
        </div>
      `
    },
    nametag: {
      title: 'ðŸ‘‹ Name Tags',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Names</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiNametagNames" placeholder="Enter names (one per line or comma separated)...

Example:
John Smith
Sarah Johnson
Mike Williams"></textarea>
        </div>
        <div class="ai-form-section">
          <label class="ai-form-label">Event or company (optional)</label>
          <input type="text" class="ai-form-input" id="aiNametagEvent" placeholder="Team Meeting, Book Club, Acme Corp...">
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Create Name Tags</button>
        </div>
      `
    },
    custom: {
      title: 'âœï¸ Custom Labels',
      html: `
        <div class="ai-form-section">
          <label class="ai-form-label">Describe what you need</label>
          <textarea class="ai-form-input ai-form-textarea" id="aiCustomPrompt" placeholder="Tell the AI what kind of labels you want...

Examples:
â€¢ Warning labels for homemade hot sauce bottles
â€¢ Return address with a fun gardening theme
â€¢ Labels for my handmade candle business"></textarea>
        </div>
        <div id="aiFormStatus" style="display: none;">
          <div class="ai-generating"><div class="ai-spinner"></div><span>Generating...</span></div>
        </div>
        <div id="aiFormError" class="ai-error" style="display: none;"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeAIFormModal()">Cancel</button>
          <button class="btn btn-primary" id="aiFormSubmit" onclick="generateFromCategory()">âœ¨ Generate</button>
        </div>
      `
    }
  };
  
  const form = forms[category];
  titleEl.textContent = form.title;
  bodyEl.innerHTML = form.html;
  
  document.getElementById('aiFormModal').classList.add('visible');
}

function closeAIFormModal() {
  document.getElementById('aiFormModal').classList.remove('visible');
  currentAICategory = null;
}

function backToAICategories() {
  closeAIFormModal();
  openAICategoryModal();
}

// Helper functions for suggestion chips
function fillGiftOccasion(value) {
  document.getElementById('aiGiftOccasion').value = value;
}

function fillOrganizeType(type) {
  const examples = {
    pantry: 'Flour, Sugar, Rice, Pasta, Cereal, Oats',
    files: 'Tax Documents, Medical Records, Insurance, Receipts',
    bins: 'Holiday Decor, Winter Clothes, Sports Equipment',
    kids: 'Toys, Art Supplies, Books, Games'
  };
  document.getElementById('aiOrganizeItems').value = examples[type] || '';
}

function fillMovingRoom(room) {
  const input = document.getElementById('aiMovingRooms');
  const current = input.value.trim();
  if (current) {
    input.value = current + '\n' + room;
  } else {
    input.value = room;
  }
}

// Build prompt from category form and generate
async function generateFromCategory() {
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  const statusEl = document.getElementById('aiFormStatus');
  const errorEl = document.getElementById('aiFormError');
  const btn = document.getElementById('aiFormSubmit');
  
  // Build the prompt based on category
  let prompt = '';
  
  switch (currentAICategory) {
    case 'address':
      const address = document.getElementById('aiAddressInput').value.trim();
      if (!address) {
        showToast('Please enter an address', 'warning');
        return;
      }
      prompt = `Format this as a clean address label:\n${address}`;
      break;
      
    case 'gift':
      const to = document.getElementById('aiGiftTo').value.trim();
      const occasion = document.getElementById('aiGiftOccasion').value.trim();
      const from = document.getElementById('aiGiftFrom').value.trim();
      if (!to) {
        showToast('Please enter who the gift is for', 'warning');
        return;
      }
      prompt = `Create a gift tag label for ${to}`;
      if (occasion) prompt += ` for ${occasion}`;
      if (from) prompt += `, from ${from}`;
      break;
      
    case 'organize':
      const items = document.getElementById('aiOrganizeItems').value.trim();
      if (!items) {
        showToast('Please enter items to label', 'warning');
        return;
      }
      prompt = `Create organization labels for these items (one label per item, keep text short and clear):\n${items}`;
      break;
      
    case 'moving':
      const rooms = document.getElementById('aiMovingRooms').value.trim();
      if (!rooms) {
        showToast('Please enter rooms or contents', 'warning');
        return;
      }
      prompt = `Create moving box labels for these (include room name prominently, add relevant icon if possible with text):\n${rooms}`;
      break;
      
    case 'nametag':
      const names = document.getElementById('aiNametagNames').value.trim();
      const event = document.getElementById('aiNametagEvent').value.trim();
      if (!names) {
        showToast('Please enter names', 'warning');
        return;
      }
      prompt = `Create name tag labels for these people`;
      if (event) prompt += ` (for: ${event})`;
      prompt += `:\n${names}`;
      break;
      
    case 'custom':
      const customPrompt = document.getElementById('aiCustomPrompt').value.trim();
      if (!customPrompt) {
        showToast('Please describe what you need', 'warning');
        return;
      }
      prompt = customPrompt;
      break;
      
    default:
      showToast('Unknown category', 'error');
      return;
  }
  
  // Show loading
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, prompt);
    
    closeAIFormModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: prompt,
        category: currentAICategory,
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, prompt, currentAICategory);
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Open AI Generate modal (or key modal if no key)
function openAIGenerate() {
  const key = getAIKey();
  if (!key) {
    showAIKeyModal();
    return;
  }
  
  // Clear previous state
  const textarea = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  if (textarea) textarea.value = '';
  if (statusEl) statusEl.style.display = 'none';
  if (errorEl) errorEl.style.display = 'none';
  if (btn) btn.disabled = false;
  
  document.getElementById('aiGenerateModal').classList.add('visible');
}

// Close AI Generate modal
function closeAIGenerateModal() {
  document.getElementById('aiGenerateModal').classList.remove('visible');
}

// Generate label content with AI
async function generateWithAI() {
  const key = getAIKey();
  const provider = getAIProvider();
  const promptInput = document.getElementById('aiPromptTextarea');
  const statusEl = document.getElementById('aiGenerateStatus');
  const errorEl = document.getElementById('aiGenerateError');
  const btn = document.getElementById('aiGenerateBtn');
  
  const userPrompt = promptInput ? promptInput.value.trim() : '';
  
  if (!userPrompt) {
    showToast('Please describe the label you want', 'warning');
    return;
  }
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Show loading state
  statusEl.style.display = 'block';
  errorEl.style.display = 'none';
  btn.disabled = true;
  
  try {
    // Use new preview system
    const previewData = await callAIProviderForPreview(provider, key, userPrompt);
    
    closeAIGenerateModal();
    
    // Show preview or apply directly based on user preference
    if (shouldSkipAIPreview()) {
      aiPreviewState = {
        originalPrompt: userPrompt,
        category: 'custom',
        understanding: previewData.understanding || 'Generated labels',
        labels: previewData.labels || [],
        suggestedType: previewData.suggestedType || '5160',
        quantity: previewData.quantity || 1,
        svgLeft: null,
        svgRight: null
      };
      // Extract SVG if present
      if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
        const svg = aiPreviewState.labels[0].svg;
        if (svg.startsWith('SVG_LEFT:')) {
          aiPreviewState.svgLeft = svg.substring(9).trim();
        } else if (svg.startsWith('SVG_RIGHT:')) {
          aiPreviewState.svgRight = svg.substring(10).trim();
        }
      }
      applyAIPreviewToWizard();
      showToast('Label generated! Review and edit as needed.', 'success');
    } else {
      showAIPreviewModal(previewData, userPrompt, 'custom');
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    errorEl.textContent = error.message || 'Failed to generate. Check your API key and try again.';
    errorEl.style.display = 'block';
  } finally {
    statusEl.style.display = 'none';
    btn.disabled = false;
  }
}

// Call the appropriate AI provider API
async function callAIProvider(provider, key, userPrompt) {
  const systemPrompt = `You are a label content generator for LabelKeeper. Output label content in LabelKeeper format.

OUTPUT FORMAT:
Return up to 4 lines of label text, optionally with formatting and graphics instructions.

LINE FORMAT:
alignment,size:text

ALIGNMENT: left | center | right (default: left)
SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left-aligned and right-aligned parts
  Example: "left,11:Teacher: Smith || Room: 101" 
  This renders "Teacher: Smith" on the left and "Room: 101" on the right of the same line

â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) to create a blank line for writing
  Example: "left,11:Name: __" renders as "Name: _______________" (a long line for writing)
  
â€¢ DECORATIVE LINES: For visual separators, use Unicode characters:
  - Solid line: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (use â”€ character, NOT dashes)
  - Dotted: Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· (use Â· middle dot)
  - Stars: â˜… â˜… â˜… â˜… â˜… or â˜† â˜† â˜† â˜† â˜†
  - Hearts: â™¥ â™¥ â™¥ â™¥ â™¥
  - Arrows: â†’ â† â†‘ â†“
  
DO NOT use ASCII dashes (---) for decorative lines. Use proper Unicode box-drawing characters.

EXAMPLES:
"center,14:FRAGILE" - Large centered text
"left,11:From: || To:" - Split line with labels on each side
"center,11:â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" - Decorative separator line
"left,11:Signature: __" - Fill-in line for signature

GRAPHICS:
You CAN generate custom SVG graphics! If the user wants an icon, logo, or image:
1. Output the label text lines first
2. Then add a line starting with SVG_LEFT: or SVG_RIGHT: followed by valid SVG code
3. SVG should use viewBox="0 0 64 64" and be self-contained with solid fills (not just strokes)

Example with graphic:
left,14:Warning
center,11:Hot Surface
SVG_LEFT:<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><text x="32" y="42" text-anchor="middle" fill="white" font-size="32" font-weight="bold">!</text></svg>

COMMON ICON SVGs YOU CAN USE:
- Warning triangle: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4L4 56h56L32 4z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>
- Checkmark: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32L28 40L44 24" stroke="#fff" stroke-width="4" fill="none"/></svg>
- X/Stop: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#ef4444"/><path d="M20 20L44 44M44 20L20 44" stroke="#fff" stroke-width="4"/></svg>
- Heart: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56C16 44 4 32 4 20c0-10 8-16 18-16 6 0 10 4 10 4s4-4 10-4c10 0 18 6 18 16 0 12-12 24-28 36z" fill="#ef4444"/></svg>
- Star: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#fbbf24"/></svg>
- Arrow right: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32h32M36 20l12 12-12 12" stroke="#333" stroke-width="4" fill="none" stroke-linecap="round"/></svg>
- Box/Package: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/></svg>
- Fragile glass: <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8L44 8L44 28Q44 48 32 56Q20 48 20 28Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20L32 32L28 32L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>

Feel free to create custom SVGs for specific requests (logos, symbols, simple illustrations). Keep SVGs simple with solid fills for good print quality.

QR CODES / BARCODES:
You cannot generate functional QR codes or barcodes. If requested, explain they need to use Full Editor and upload a QR code image.

OUTPUT ONLY THE FORMATTED LINES AND OPTIONAL SVG. NO EXPLANATIONS OR MARKDOWN.`;

  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 200,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 200,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 200
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
}

// Populate wizard fields from AI-generated content
function populateWizardFromAI(content) {
  if (!content) return;
  
  // Parse AI output - separate text lines from SVG instructions
  const allLines = content.trim().split('\n').filter(l => l.trim());
  const textLines = [];
  let svgLeft = null;
  let svgRight = null;
  
  for (const line of allLines) {
    if (line.startsWith('SVG_LEFT:')) {
      svgLeft = line.substring(9).trim();
    } else if (line.startsWith('SVG_RIGHT:')) {
      svgRight = line.substring(10).trim();
    } else if (textLines.length < 4) {
      textLines.push(line);
    }
  }
  
  // Start the print workflow if not already open
  currentWizard = 'print';
  wizardStep = 2;
  wizardSelectedTextId = null;
  
  // Reset and show wizard at step 2a (new text editor)
  resetWizardEditor();
  showWizard('printWizard');
  showWizardStep('printStep2a');
  
  // Parse and populate wizard line inputs
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById(`wizLine${i + 1}`);
    if (!input) continue;
    
    const rawLine = textLines[i] || '';
    
    // Parse format: "alignment,size:text" or just "text"
    let text = rawLine;
    let align = 'left';
    let fontSize = 11;
    
    const colonIndex = rawLine.indexOf(':');
    if (colonIndex > 0 && colonIndex < 15) {
      // Check if there's a format prefix
      const prefix = rawLine.substring(0, colonIndex);
      const parts = prefix.split(',');
      
      if (parts.length >= 1 && ['left', 'center', 'right'].includes(parts[0])) {
        align = parts[0];
        text = rawLine.substring(colonIndex + 1);
        
        if (parts.length >= 2) {
          const size = parseInt(parts[1]);
          if ([9, 11, 14].includes(size)) {
            fontSize = size;
          }
        }
      }
    }
    
    // Set input value
    input.value = text;
    
    // Update wizardLines state
    wizardLines[i].text = text;
    wizardLines[i].align = align;
    wizardLines[i].fontSize = fontSize;
    
    // Update alignment button states
    document.querySelectorAll(`.editor-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === align);
    });
    
    // Update size button states
    document.querySelectorAll(`.editor-size-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', parseInt(btn.dataset.size) === fontSize);
    });
  }
  
  // Handle SVG graphics - if present, show message and open full editor
  if (svgLeft || svgRight) {
    showToast('AI generated graphics! Opening Full Editor to apply them.', 'info');
    
    // Store SVGs for full editor
    window._aiGeneratedSvgLeft = svgLeft;
    window._aiGeneratedSvgRight = svgRight;
    
    // Small delay then open full editor
    setTimeout(() => {
      openFullEditorFromWizard();
      
      // Apply SVGs after editor opens
      setTimeout(() => {
        if (window._aiGeneratedSvgLeft) {
          const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgLeft);
          feGraphics.left = { data: svgDataUrl, size: 'M' };
        }
        if (window._aiGeneratedSvgRight) {
          const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgRight);
          feGraphics.right = { data: svgDataUrl, size: 'M' };
        }
        updateFullEditorPreview();
        renderFeGraphics();
        window._aiGeneratedSvgLeft = null;
        window._aiGeneratedSvgRight = null;
      }, 100);
    }, 500);
  } else {
    // Update the preview
    if (typeof updateWizardPreview === 'function') {
      updateWizardPreview();
    }
  }
}

// ============================================================================
// AI PREVIEW SYSTEM - Shows what AI understood before applying
// ============================================================================

const AI_SKIP_PREVIEW_KEY = 'lk_ai_skip_preview';

// State for current AI preview
let aiPreviewState = {
  originalPrompt: '',
  category: null,
  understanding: '',
  labels: [],
  suggestedType: '5160',
  quantity: 1,
  svgLeft: null,
  svgRight: null
};

// Check if user wants to skip preview
function shouldSkipAIPreview() {
  try {
    return localStorage.getItem(AI_SKIP_PREVIEW_KEY) === 'true';
  } catch (e) {
    return false;
  }
}

// Toggle skip preview preference
function toggleAIPreviewSkip() {
  const checkbox = document.getElementById('aiPreviewSkip');
  try {
    if (checkbox && checkbox.checked) {
      localStorage.setItem(AI_SKIP_PREVIEW_KEY, 'true');
    } else {
      localStorage.removeItem(AI_SKIP_PREVIEW_KEY);
    }
  } catch (e) {}
}

// New system prompt that returns JSON with understanding
function getAISystemPromptWithPreview() {
  return `You are a label content generator for LabelKeeper. You MUST respond with valid JSON only.

RESPONSE FORMAT (strict JSON, no markdown):
{
  "understanding": "Brief summary of what the user wants (1-2 sentences)",
  "labels": [
    {
      "preview": "Human-readable preview text for this label",
      "lines": ["alignment,size:text", ...],
      "svg": null or "SVG_LEFT:..." or "SVG_RIGHT:..."
    }
  ],
  "suggestedType": "5160",
  "quantity": 1,
  "error": null
}

HANDLING IMPOSSIBLE REQUESTS:
If you cannot fulfill the request (e.g., user asks you to access files, browse the web, read emails, or do something outside label generation), respond with:
{
  "understanding": "What the user asked for",
  "labels": [],
  "suggestedType": "5160",
  "quantity": 0,
  "error": "Brief explanation of why this can't be done and what the user could do instead"
}
Example error: "I cannot access local files or Excel documents. To create labels from your contacts, please copy the contact information from Excel and paste it here, or use the CSV Import feature in the main menu."

IMPORTANT: Always respond with JSON. Never write conversational text or instructions as label content.

LABEL LINE FORMAT:
alignment,size:text
- ALIGNMENT: left | center | right (default: left)
- SIZE: 9 (small) | 11 (medium, default) | 14 (large)

SPECIAL TEXT FEATURES:
â€¢ SPLIT LINE: Use || to split a line into left and right parts
  Example: "left,11:Teacher: Smith || Room: 101"
â€¢ FILL-IN-THE-BLANK: Use __ (two underscores) for a blank line
  Example: "left,11:Name: __"
â€¢ DECORATIVE LINES: Use Unicode: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (not dashes)

LABEL TYPES:
- "5160": Address labels (30/sheet) - most common
- "5163": Shipping labels (10/sheet) - larger
- "5167": Return address (80/sheet) - small
- "5395": Name badges (8/sheet)

GRAPHICS (optional):
For icons/images, add svg field with "SVG_LEFT:<svg...>" or "SVG_RIGHT:<svg...>"
SVG should use viewBox="0 0 64 64" with solid fills.

MULTIPLE LABELS:
If user wants multiple different labels (e.g., "labels for Flour, Sugar, Rice"), create separate label objects in the array.
If user wants multiple copies of the SAME label, use quantity field instead.

EXAMPLES:

Request: "Address label for John Smith, 123 Main St, Boston MA"
{
  "understanding": "Creating an address label for John Smith in Boston",
  "labels": [{"preview": "John Smith\\n123 Main St\\nBoston, MA", "lines": ["left,11:John Smith", "left,11:123 Main St", "left,11:Boston, MA"], "svg": null}],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Pantry labels for Flour, Sugar, and Rice"
{
  "understanding": "Creating 3 pantry organization labels",
  "labels": [
    {"preview": "FLOUR", "lines": ["center,14:FLOUR"], "svg": null},
    {"preview": "SUGAR", "lines": ["center,14:SUGAR"], "svg": null},
    {"preview": "RICE", "lines": ["center,14:RICE"], "svg": null}
  ],
  "suggestedType": "5160",
  "quantity": 1
}

Request: "Warning label with exclamation icon"
{
  "understanding": "Creating a warning label with an icon",
  "labels": [{"preview": "âš ï¸ WARNING\\nHot Surface", "lines": ["center,14:WARNING", "center,11:Hot Surface"], "svg": "SVG_LEFT:<svg viewBox=\\"0 0 64 64\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M32 4L4 56h56L32 4z\\" fill=\\"#fbbf24\\"/><rect x=\\"29\\" y=\\"20\\" width=\\"6\\" height=\\"20\\" fill=\\"#1f2937\\"/><circle cx=\\"32\\" cy=\\"48\\" r=\\"4\\" fill=\\"#1f2937\\"/></svg>"}],
  "suggestedType": "5163",
  "quantity": 1
}

RESPOND WITH VALID JSON ONLY. NO MARKDOWN, NO EXPLANATION, NO CODE BLOCKS.`;
}

// Call AI provider and get structured preview data
async function callAIProviderForPreview(provider, key, userPrompt) {
  const systemPrompt = getAISystemPromptWithPreview();
  
  let responseText = '';
  
  if (provider === 'claude') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        messages: [
          { role: 'user', content: systemPrompt + '\n\nRequest: ' + userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.content?.[0]?.text || '';
    
  } else if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        max_tokens: 1000,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ]
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.choices?.[0]?.message?.content || '';
    
  } else if (provider === 'gemini') {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: systemPrompt + '\n\nRequest: ' + userPrompt }]
        }],
        generationConfig: {
          maxOutputTokens: 1000
        }
      })
    });
    
    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Gemini API error: ${response.status}`);
    }
    
    const data = await response.json();
    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
  } else {
    throw new Error('Unknown AI provider');
  }
  
  // Parse JSON response
  try {
    // Clean up response - remove markdown code blocks if present
    let cleanJson = responseText.trim();
    if (cleanJson.startsWith('```json')) {
      cleanJson = cleanJson.slice(7);
    } else if (cleanJson.startsWith('```')) {
      cleanJson = cleanJson.slice(3);
    }
    if (cleanJson.endsWith('```')) {
      cleanJson = cleanJson.slice(0, -3);
    }
    cleanJson = cleanJson.trim();
    
    const parsed = JSON.parse(cleanJson);
    return parsed;
  } catch (e) {
    console.error('Failed to parse AI response as JSON:', responseText);
    
    // Detect if this looks like a conversational refusal/explanation rather than label content
    const lowerResponse = responseText.toLowerCase();
    const refusalPatterns = [
      'i cannot', 'i can\'t', 'i\'m unable', 'i am unable',
      'i don\'t have access', 'i do not have access',
      'unfortunately', 'i\'m sorry', 'i apologize',
      'not able to', 'unable to access', 'cannot access',
      'please provide', 'you\'ll need to', 'you will need to',
      'copy and paste', 'copy the', 'paste the',
      'however,', 'instead,', 'alternatively,'
    ];
    
    const looksLikeRefusal = refusalPatterns.some(pattern => lowerResponse.includes(pattern));
    
    if (looksLikeRefusal) {
      // This is an explanation/refusal - return as error, not label content
      return {
        understanding: 'Unable to complete this request',
        labels: [],
        suggestedType: '5160',
        quantity: 0,
        error: responseText.split('\n').slice(0, 4).join(' ').substring(0, 300) + (responseText.length > 300 ? '...' : '')
      };
    }
    
    // Fallback: try to create a basic response from raw text (only if it looks like actual content)
    return {
      understanding: 'Generated label content',
      labels: [{
        preview: responseText.split('\n')[0] || 'Label',
        lines: responseText.split('\n').filter(l => l.trim()).slice(0, 4),
        svg: null
      }],
      suggestedType: '5160',
      quantity: 1,
      error: null
    };
  }
}

// Show AI Preview modal with results
function showAIPreviewModal(previewData, originalPrompt, category) {
  // Store state
  aiPreviewState = {
    originalPrompt: originalPrompt,
    category: category,
    understanding: previewData.understanding || 'Generated labels',
    labels: previewData.labels || [],
    suggestedType: previewData.suggestedType || '5160',
    quantity: previewData.quantity || 1,
    error: previewData.error || null,
    svgLeft: null,
    svgRight: null
  };
  
  // Extract SVG from first label if present
  if (aiPreviewState.labels.length > 0 && aiPreviewState.labels[0].svg) {
    const svg = aiPreviewState.labels[0].svg;
    if (svg.startsWith('SVG_LEFT:')) {
      aiPreviewState.svgLeft = svg.substring(9).trim();
    } else if (svg.startsWith('SVG_RIGHT:')) {
      aiPreviewState.svgRight = svg.substring(10).trim();
    }
  }
  
  // Populate understanding
  document.getElementById('aiPreviewUnderstanding').textContent = aiPreviewState.understanding;
  
  // Handle error state
  const labelsContainer = document.getElementById('aiPreviewLabels');
  const labelCountEl = document.getElementById('aiPreviewLabelCount');
  const acceptBtn = document.getElementById('aiPreviewAcceptBtn');
  
  if (aiPreviewState.error) {
    // Show error message instead of labels
    labelCountEl.textContent = '0';
    labelsContainer.innerHTML = `
      <div class="ai-preview-error">
        <div class="ai-preview-error-icon">âš ï¸</div>
        <div class="ai-preview-error-title">Unable to generate labels</div>
        <div class="ai-preview-error-message">${escapeHtml(aiPreviewState.error)}</div>
        <div class="ai-preview-error-hint">Use the "Refine" button below to provide different information or rephrase your request.</div>
      </div>
    `;
    // Disable accept button when there's an error
    if (acceptBtn) {
      acceptBtn.disabled = true;
      acceptBtn.style.opacity = '0.5';
    }
  } else {
    // Normal flow - populate labels list
    labelCountEl.textContent = aiPreviewState.labels.length;
    labelsContainer.innerHTML = '';
    
    if (acceptBtn) {
      acceptBtn.disabled = false;
      acceptBtn.style.opacity = '1';
    }
  
    aiPreviewState.labels.forEach((label, index) => {
      const item = document.createElement('div');
      item.className = 'ai-preview-label-item';
      item.dataset.index = index;
      
      // Format preview text for display
      const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
      const displayText = previewText.replace(/\\n/g, '\n');
      
      // Build meta info
      let metaInfo = [];
      if (label.lines && label.lines.length > 0) {
        const firstLine = label.lines[0];
        if (firstLine.includes(',')) {
          const parts = firstLine.split(':')[0].split(',');
          if (parts[0]) metaInfo.push(parts[0]);
          if (parts[1]) metaInfo.push('size ' + parts[1]);
        }
      }
      if (label.svg) metaInfo.push('has graphic');
      
      item.innerHTML = `
        <div class="ai-preview-label-num">${index + 1}</div>
        <div class="ai-preview-label-content">
          <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
          ${metaInfo.length ? `<div class="ai-preview-label-meta">${metaInfo.join(' â€¢ ')}</div>` : ''}
        </div>
        <button class="ai-preview-label-edit" onclick="editPreviewLabel(${index})" title="Edit this label">âœï¸</button>
      `;
      
      labelsContainer.appendChild(item);
    });
  }
  
  // Populate settings
  const typeSpec = LABEL_TYPES[aiPreviewState.suggestedType];
  const typeDisplay = typeSpec ? `${aiPreviewState.suggestedType} ${typeSpec.desc}` : aiPreviewState.suggestedType;
  document.getElementById('aiPreviewType').textContent = typeDisplay;
  document.getElementById('aiPreviewQty').textContent = aiPreviewState.labels.length > 1 
    ? aiPreviewState.labels.length + ' labels' 
    : aiPreviewState.quantity;
  
  // Set skip checkbox state
  const skipCheckbox = document.getElementById('aiPreviewSkip');
  if (skipCheckbox) {
    skipCheckbox.checked = shouldSkipAIPreview();
  }
  
  // Hide refine panel
  hideRefinePanel();
  
  // Show modal
  document.getElementById('aiPreviewModal').classList.add('visible');
}

// Close AI Preview modal
function closeAIPreviewModal() {
  document.getElementById('aiPreviewModal').classList.remove('visible');
  hideRefinePanel();
}

// Edit a specific label in preview
function editPreviewLabel(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item || item.classList.contains('editing')) return;
  
  const label = aiPreviewState.labels[index];
  const textEl = item.querySelector('.ai-preview-label-text');
  const currentText = label.preview || label.lines?.join('\n') || '';
  
  // Switch to edit mode
  item.classList.add('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  const originalHTML = contentDiv.innerHTML;
  
  contentDiv.innerHTML = `
    <textarea class="ai-preview-edit-input" rows="3">${escapeHtml(currentText.replace(/\\n/g, '\n'))}</textarea>
    <div class="ai-preview-edit-actions">
      <button class="ai-preview-edit-save" onclick="savePreviewLabelEdit(${index})">Save</button>
      <button class="ai-preview-edit-cancel" onclick="cancelPreviewLabelEdit(${index})">Cancel</button>
    </div>
  `;
  
  // Store original HTML for cancel
  item.dataset.originalHtml = originalHTML;
  
  // Focus input
  const input = contentDiv.querySelector('.ai-preview-edit-input');
  if (input) input.focus();
}

// Save edited label
function savePreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const input = item.querySelector('.ai-preview-edit-input');
  const newText = input ? input.value.trim() : '';
  
  if (newText) {
    // Update state
    const lines = newText.split('\n').filter(l => l.trim()).slice(0, 4);
    aiPreviewState.labels[index].preview = newText.replace(/\n/g, '\\n');
    aiPreviewState.labels[index].lines = lines.map(l => 'left,11:' + l);
    
    // Rebuild item
    rebuildPreviewLabelItem(index);
  } else {
    cancelPreviewLabelEdit(index);
  }
}

// Cancel label edit
function cancelPreviewLabelEdit(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  item.classList.remove('editing');
  const contentDiv = item.querySelector('.ai-preview-label-content');
  if (contentDiv && item.dataset.originalHtml) {
    contentDiv.innerHTML = item.dataset.originalHtml;
  }
}

// Rebuild label item after edit
function rebuildPreviewLabelItem(index) {
  const item = document.querySelector(`.ai-preview-label-item[data-index="${index}"]`);
  if (!item) return;
  
  const label = aiPreviewState.labels[index];
  const previewText = label.preview || label.lines?.join(' / ') || 'Label ' + (index + 1);
  const displayText = previewText.replace(/\\n/g, '\n');
  
  item.classList.remove('editing');
  
  const contentDiv = item.querySelector('.ai-preview-label-content');
  contentDiv.innerHTML = `
    <div class="ai-preview-label-text">${escapeHtml(displayText).replace(/\n/g, '<br>')}</div>
  `;
}

// Show refine panel
function showRefinePanel() {
  document.getElementById('aiRefineOriginal').textContent = aiPreviewState.originalPrompt;
  document.getElementById('aiRefineInput').value = '';
  document.getElementById('aiRefinePanel').classList.add('visible');
  document.getElementById('aiPreviewActions').style.display = 'none';
  document.getElementById('aiRefineInput').focus();
}

// Hide refine panel
function hideRefinePanel() {
  document.getElementById('aiRefinePanel').classList.remove('visible');
  document.getElementById('aiPreviewActions').style.display = 'flex';
}

// Regenerate with refinement
async function regenerateWithRefinement() {
  const refinement = document.getElementById('aiRefineInput').value.trim();
  if (!refinement) {
    showToast('Please add some refinement details', 'warning');
    return;
  }
  
  const key = getAIKey();
  const provider = getAIProvider();
  
  if (!key || !provider) {
    showAIKeyModal();
    return;
  }
  
  // Build combined prompt
  const combinedPrompt = `Original request: ${aiPreviewState.originalPrompt}\n\nRefinement: ${refinement}`;
  
  // Close preview and show loading
  closeAIPreviewModal();
  
  // Re-trigger the appropriate flow
  try {
    showToast('Regenerating with your refinements...', 'info');
    
    const previewData = await callAIProviderForPreview(provider, key, combinedPrompt);
    
    if (shouldSkipAIPreview()) {
      applyAIPreviewToWizard();
    } else {
      showAIPreviewModal(previewData, combinedPrompt, aiPreviewState.category);
    }
  } catch (error) {
    console.error('AI regeneration error:', error);
    showToast(error.message || 'Failed to regenerate. Try again.', 'error');
  }
}

// Accept and apply the AI preview
function acceptAIPreview() {
  applyAIPreviewToWizard();
  closeAIPreviewModal();
  showToast('Labels created! Review and print.', 'success');
}

// Apply AI preview state to the wizard
function applyAIPreviewToWizard() {
  if (aiPreviewState.labels.length === 0) return;
  
  // If multiple labels, create each as separate content
  if (aiPreviewState.labels.length > 1) {
    // Save each label as content
    aiPreviewState.labels.forEach((label, i) => {
      const lines = label.lines || [];
      const parsedLines = lines.map(parseLabelLine);
      
      // Create content item
      const id = 'text_' + Date.now() + '_' + i;
      const textContent = parsedLines.map(l => l.text).join('\n');
      
      // Save to storage (simplified - just text for now)
      const savedTexts = loadSavedTexts();
      savedTexts[id] = {
        text: textContent,
        lines: parsedLines,
        isTemplate: false,
        createdAt: Date.now()
      };
      saveSavedTexts(savedTexts);
    });
    
    showToast(`${aiPreviewState.labels.length} labels saved to Content!`, 'success');
    showTab('content');
    renderContentTab();
    return;
  }
  
  // Single label - populate wizard
  const label = aiPreviewState.labels[0];
  const lines = label.lines || [];
  
  // Start wizard at step 2a
  currentWizard = 'print';
  wizardStep = 2;
  wizardSelectedTextId = null;
  
  resetWizardEditor();
  showWizard('printWizard');
  showWizardStep('printStep2a');
  
  // Parse and populate each line
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById(`wizLine${i + 1}`);
    if (!input) continue;
    
    const rawLine = lines[i] || '';
    const parsed = parseLabelLine(rawLine);
    
    input.value = parsed.text;
    wizardLines[i].text = parsed.text;
    wizardLines[i].align = parsed.align;
    wizardLines[i].fontSize = parsed.fontSize;
    
    // Update button states
    document.querySelectorAll(`.editor-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === parsed.align);
    });
    document.querySelectorAll(`.editor-size-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', parseInt(btn.dataset.size) === parsed.fontSize);
    });
  }
  
  // Handle SVG graphics
  if (aiPreviewState.svgLeft || aiPreviewState.svgRight) {
    showToast('Opening Full Editor to apply graphics...', 'info');
    
    window._aiGeneratedSvgLeft = aiPreviewState.svgLeft;
    window._aiGeneratedSvgRight = aiPreviewState.svgRight;
    
    setTimeout(() => {
      openFullEditorFromWizard();
      setTimeout(() => {
        if (window._aiGeneratedSvgLeft) {
          const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgLeft);
          feGraphics.left = { data: svgDataUrl, size: 'M' };
        }
        if (window._aiGeneratedSvgRight) {
          const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(window._aiGeneratedSvgRight);
          feGraphics.right = { data: svgDataUrl, size: 'M' };
        }
        updateFullEditorPreview();
        renderFeGraphics();
        window._aiGeneratedSvgLeft = null;
        window._aiGeneratedSvgRight = null;
      }, 100);
    }, 300);
  } else {
    if (typeof updateWizardPreview === 'function') {
      updateWizardPreview();
    }
  }
}

// Parse a label line format "alignment,size:text"
function parseLabelLine(rawLine) {
  let text = rawLine;
  let align = 'left';
  let fontSize = 11;
  
  if (!rawLine) return { text: '', align, fontSize };
  
  const colonIndex = rawLine.indexOf(':');
  if (colonIndex > 0 && colonIndex < 15) {
    const prefix = rawLine.substring(0, colonIndex);
    const parts = prefix.split(',');
    
    if (parts.length >= 1 && ['left', 'center', 'right'].includes(parts[0])) {
      align = parts[0];
      text = rawLine.substring(colonIndex + 1);
      
      if (parts.length >= 2) {
        const size = parseInt(parts[1]);
        if ([9, 11, 14].includes(size)) {
          fontSize = size;
        }
      }
    }
  }
  
  return { text, align, fontSize };
}

// ============================================================================
// FULL EDITOR (ported from v1.2.0)
// ============================================================================

// Full editor state
let feEditingId = null;  // ID of text being edited (null = new)
let feIsTemplate = false;
let feLines = [
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
  { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
];
let feAlignV = 'center';
let feGraphics = { left: null, right: null };
let feActiveStylePopover = null;
let feGraphicPickerSide = null;

// New: Dirty tracking
let feDirty = false;
let feOriginalState = null;

// New: Border state
let feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };

// New: Preview label type
let fePreviewLabelType = '5160';

// Color palette
const FE_COLORS = ['#000000', '#dc2626', '#2563eb', '#16a34a', '#ea580c', '#9333ea', '#78350f', '#6b7280'];

// Built-in graphics library (full 83-icon library from v1.8.0)
const FE_GRAPHICS_CATEGORIES = {
  school: { label: 'ðŸ“š School', order: 1 },
  mailing: { label: 'âœ‰ï¸ Mailing', order: 2 },
  winter: { label: 'â„ï¸ Winter', order: 3 },
  spring: { label: 'ðŸŒ· Spring', order: 4 },
  summer: { label: 'â˜€ï¸ Summer/Fall', order: 5 },
  occasion: { label: 'ðŸŽ‰ Occasions', order: 6 },
  symbol: { label: 'âš¡ Symbols', order: 7 }
};

const FE_GRAPHICS_LIBRARY = [
  // School & Education (~15)
  {id:'apple',cat:'school',name:'Apple',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="38" rx="20" ry="22" fill="#ef4444"/><path d="M32 16 Q36 8 42 10" stroke="#16a34a" stroke-width="3" fill="none"/><ellipse cx="34" cy="12" rx="6" ry="4" fill="#22c55e"/></svg>'},
  {id:'book',cat:'school',name:'Book',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 h20 v48 h-20 a4 4 0 0 1 -4 -4 v-40 a4 4 0 0 1 4 -4z" fill="#3b82f6"/><path d="M28 8 h20 a4 4 0 0 1 4 4 v40 a4 4 0 0 1 -4 4 h-20 v-48z" fill="#2563eb"/><line x1="28" y1="8" x2="28" y2="56" stroke="#1d4ed8" stroke-width="2"/><line x1="14" y1="20" x2="24" y2="20" stroke="#93c5fd" stroke-width="2"/><line x1="14" y1="28" x2="22" y2="28" stroke="#93c5fd" stroke-width="2"/></svg>'},
  {id:'pencil',cat:'school',name:'Pencil',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="12,52 8,60 16,56 52,20 48,16" fill="#fbbf24"/><polygon points="52,20 56,16 52,8 48,12 48,16" fill="#f472b6"/><polygon points="8,60 12,52 16,56" fill="#1f2937"/></svg>'},
  {id:'ruler',cat:'school',name:'Ruler',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="16" rx="2" fill="#fbbf24"/><g stroke="#92400e" stroke-width="1.5"><line x1="16" y1="24" x2="16" y2="32"/><line x1="24" y1="24" x2="24" y2="28"/><line x1="32" y1="24" x2="32" y2="32"/><line x1="40" y1="24" x2="40" y2="28"/><line x1="48" y1="24" x2="48" y2="32"/></g></svg>'},
  {id:'scissors',cat:'school',name:'Scissors',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="48" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><circle cx="18" cy="16" r="8" fill="none" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="42" x2="56" y2="28" stroke="#6b7280" stroke-width="4"/><line x1="24" y1="22" x2="56" y2="36" stroke="#6b7280" stroke-width="4"/></svg>'},
  {id:'crayon',cat:'school',name:'Crayon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="40" rx="4" fill="#ef4444"/><polygon points="12,16 32,4 52,16" fill="#fca5a5"/><rect x="20" y="24" width="24" height="8" fill="#fef2f2"/></svg>'},
  {id:'globe',cat:'school',name:'Globe',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="28" r="24" fill="#3b82f6"/><ellipse cx="32" cy="28" rx="10" ry="24" fill="none" stroke="#1d4ed8" stroke-width="2"/><line x1="8" y1="28" x2="56" y2="28" stroke="#1d4ed8" stroke-width="2"/><path d="M12 18 Q32 24 52 18" fill="none" stroke="#1d4ed8" stroke-width="2"/><path d="M12 38 Q32 32 52 38" fill="none" stroke="#1d4ed8" stroke-width="2"/><rect x="28" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'backpack',cat:'school',name:'Backpack',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="16" width="40" height="44" rx="6" fill="#8b5cf6"/><rect x="20" y="32" width="24" height="16" rx="2" fill="#c4b5fd"/><path d="M20 16 Q20 4 32 4 Q44 4 44 16" fill="none" stroke="#6d28d9" stroke-width="4"/></svg>'},
  {id:'bus',cat:'school',name:'School Bus',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="56" height="28" rx="4" fill="#fbbf24"/><rect x="8" y="24" width="12" height="12" fill="#fef3c7"/><rect x="24" y="24" width="12" height="12" fill="#fef3c7"/><rect x="40" y="24" width="12" height="12" fill="#fef3c7"/><circle cx="16" cy="52" r="6" fill="#1f2937"/><circle cx="48" cy="52" r="6" fill="#1f2937"/><rect x="4" y="14" width="56" height="6" fill="#f59e0b"/></svg>'},
  {id:'gradcap',cat:'school',name:'Graduation Cap',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,8 4,24 32,40 60,24" fill="#1f2937"/><rect x="28" y="24" width="8" height="24" fill="#1f2937"/><path d="M16 28 v16 Q32 56 48 44 v-16" fill="#374151"/><circle cx="56" cy="44" r="4" fill="#fbbf24"/><line x1="56" y1="24" x2="56" y2="44" stroke="#fbbf24" stroke-width="2"/></svg>'},
  {id:'abc',cat:'school',name:'ABC Blocks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="32" width="24" height="24" fill="#ef4444"/><rect x="20" y="20" width="24" height="24" fill="#22c55e"/><rect x="36" y="8" width="24" height="24" fill="#3b82f6"/><text x="16" y="50" text-anchor="middle" fill="white" font-size="14" font-weight="bold">A</text><text x="32" y="38" text-anchor="middle" fill="white" font-size="14" font-weight="bold">B</text><text x="48" y="26" text-anchor="middle" fill="white" font-size="14" font-weight="bold">C</text></svg>'},
  {id:'star',cat:'school',name:'Star',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 40,24 62,26 46,42 50,62 32,52 14,62 18,42 2,26 24,24" fill="#f59e0b"/></svg>'},
  {id:'microscope',cat:'school',name:'Microscope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="48" width="24" height="8" rx="2" fill="#6b7280"/><rect x="36" y="12" width="8" height="36" fill="#9ca3af"/><circle cx="40" cy="12" r="8" fill="#3b82f6"/><rect x="16" y="52" width="8" height="8" fill="#6b7280"/></svg>'},
  {id:'music',cat:'school',name:'Music Note',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="48" rx="10" ry="8" fill="#1f2937"/><rect x="28" y="12" width="4" height="36" fill="#1f2937"/><path d="M32 12 Q48 8 48 20 Q48 28 32 24" fill="#1f2937"/></svg>'},
  {id:'owl',cat:'school',name:'Owl',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="24" fill="#92400e"/><circle cx="22" cy="28" r="10" fill="white"/><circle cx="42" cy="28" r="10" fill="white"/><circle cx="22" cy="28" r="5" fill="#1f2937"/><circle cx="42" cy="28" r="5" fill="#1f2937"/><polygon points="32,34 28,42 36,42" fill="#f59e0b"/><path d="M16 12 Q22 20 32 16 Q42 20 48 12" fill="#78350f"/></svg>'},
  
  // Mailing & Address (~12)
  {id:'mail',cat:'mailing',name:'Envelope',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="56" height="36" rx="4" fill="#3b82f6"/><path d="M4 18 L32 36 L60 18" stroke="#1d4ed8" stroke-width="3" fill="none"/></svg>'},
  {id:'mailbox',cat:'mailing',name:'Mailbox',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 24 h48 v24 a8 8 0 0 1 -8 8 h-32 a8 8 0 0 1 -8 -8 z" fill="#3b82f6"/><path d="M8 24 a24 24 0 0 1 48 0" fill="#2563eb"/><rect x="28" y="56" width="8" height="8" fill="#6b7280"/><rect x="44" y="20" width="8" height="16" fill="#ef4444"/></svg>'},
  {id:'stamp',cat:'mailing',name:'Stamp',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="48" height="48" fill="#f5f5f4"/><rect x="12" y="12" width="40" height="40" fill="#3b82f6"/><circle cx="32" cy="32" r="12" fill="#1d4ed8"/><text x="32" y="37" text-anchor="middle" fill="white" font-size="12" font-weight="bold">USA</text></svg>'},
  {id:'home',cat:'mailing',name:'House',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 8 L4 32 L12 32 L12 56 L52 56 L52 32 L60 32 Z" fill="#78716c"/><rect x="26" y="38" width="12" height="18" fill="#292524"/><rect x="18" y="32" width="8" height="8" fill="#7dd3fc"/><rect x="38" y="32" width="8" height="8" fill="#7dd3fc"/></svg>'},
  {id:'pin',cat:'mailing',name:'Location Pin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 58 Q8 34 8 24 A24 24 0 1 1 56 24 Q56 34 32 58z" fill="#ef4444"/><circle cx="32" cy="24" r="10" fill="white"/></svg>'},
  {id:'airplane',cat:'mailing',name:'Airplane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 20 L58 28 L36 32 L36 52 L44 58 L36 56 L32 62 L28 56 L20 58 L28 52 L28 32 L6 28 L28 20 Z" fill="#6b7280"/></svg>'},
  {id:'package',cat:'mailing',name:'Package',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="40" fill="#d4a574"/><line x1="8" y1="28" x2="56" y2="28" stroke="#92400e" stroke-width="2"/><line x1="32" y1="28" x2="32" y2="56" stroke="#92400e" stroke-width="2"/><rect x="24" y="32" width="16" height="8" fill="white"/></svg>'},
  {id:'fragile',cat:'mailing',name:'Fragile',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 8 L44 8 L44 28 Q44 48 32 56 Q20 48 20 28 Z" fill="none" stroke="#ef4444" stroke-width="4"/><path d="M28 20 L32 32 L28 32 L32 44" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'heart',cat:'mailing',name:'Heart',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 56 C16 44 4 32 4 20 C4 10 12 4 22 4 C28 4 32 8 32 8 C32 8 36 4 42 4 C52 4 60 10 60 20 C60 32 48 44 32 56Z" fill="#ef4444"/></svg>'},
  {id:'paw',cat:'mailing',name:'Paw Print',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="16" ry="14" fill="#78350f"/><ellipse cx="18" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="46" cy="24" rx="8" ry="6" fill="#78350f"/><ellipse cx="12" cy="36" rx="6" ry="8" fill="#78350f"/><ellipse cx="52" cy="36" rx="6" ry="8" fill="#78350f"/></svg>'},
  {id:'certified',cat:'mailing',name:'Certified',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'priority',cat:'mailing',name:'Priority',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="32" fill="#ef4444"/><text x="32" y="38" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PRIORITY</text></svg>'},
  
  // Winter Holidays (~12)
  {id:'snowflake',cat:'winter',name:'Snowflake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g stroke="#3b82f6" stroke-width="3" fill="none"><line x1="32" y1="4" x2="32" y2="60"/><line x1="8" y1="18" x2="56" y2="46"/><line x1="8" y1="46" x2="56" y2="18"/><line x1="32" y1="12" x2="26" y2="6"/><line x1="32" y1="12" x2="38" y2="6"/><line x1="32" y1="52" x2="26" y2="58"/><line x1="32" y1="52" x2="38" y2="58"/></g></svg>'},
  {id:'tree',cat:'winter',name:'Christmas Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="26" y="50" width="12" height="10" fill="#78350f"/><polygon points="32,4 8,50 56,50" fill="#16a34a"/><polygon points="32,14 14,42 50,42" fill="#22c55e"/><circle cx="32" cy="8" r="4" fill="#fbbf24"/><circle cx="24" cy="32" r="3" fill="#ef4444"/><circle cx="40" cy="36" r="3" fill="#3b82f6"/><circle cx="32" cy="44" r="3" fill="#fbbf24"/></svg>'},
  {id:'candycane',cat:'winter',name:'Candy Cane',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="#ef4444" stroke-width="8" stroke-linecap="round"/><path d="M40 8 Q56 8 56 24 Q56 32 48 32 L48 60" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" stroke-dasharray="8 8"/></svg>'},
  {id:'gift',cat:'winter',name:'Gift Box',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="24" width="48" height="8" fill="#ef4444"/><rect x="12" y="32" width="40" height="24" fill="#fca5a5"/><rect x="28" y="24" width="8" height="32" fill="#dc2626"/><ellipse cx="24" cy="20" rx="8" ry="6" fill="#fbbf24"/><ellipse cx="40" cy="20" rx="8" ry="6" fill="#fbbf24"/></svg>'},
  {id:'ornament',cat:'winter',name:'Ornament',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="36" r="24" fill="#ef4444"/><rect x="28" y="8" width="8" height="8" fill="#fbbf24"/><circle cx="32" cy="12" r="4" fill="#fbbf24" fill-opacity="0.5"/><path d="M20 28 Q32 44 44 28" stroke="#fca5a5" stroke-width="3" fill="none"/></svg>'},
  {id:'stocking',cat:'winter',name:'Stocking',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M20 4 L44 4 L44 32 Q44 52 28 56 Q12 52 12 40 L12 32 L20 32 Z" fill="#ef4444"/><rect x="16" y="4" width="32" height="8" fill="white"/></svg>'},
  {id:'gingerbread',cat:'winter',name:'Gingerbread',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="14" r="10" fill="#d4a574"/><rect x="22" y="22" width="20" height="20" fill="#d4a574"/><rect x="8" y="26" width="16" height="8" fill="#d4a574"/><rect x="40" y="26" width="16" height="8" fill="#d4a574"/><rect x="24" y="42" width="6" height="16" fill="#d4a574"/><rect x="34" y="42" width="6" height="16" fill="#d4a574"/><circle cx="28" cy="12" r="2" fill="#1f2937"/><circle cx="36" cy="12" r="2" fill="#1f2937"/><path d="M28 18 Q32 22 36 18" stroke="#ef4444" stroke-width="2" fill="none"/></svg>'},
  {id:'menorah',cat:'winter',name:'Menorah',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="24" width="8" height="32" fill="#fbbf24"/><g fill="#fbbf24"><rect x="8" y="32" width="4" height="16"/><rect x="16" y="32" width="4" height="16"/><rect x="24" y="32" width="4" height="16"/><rect x="36" y="32" width="4" height="16"/><rect x="44" y="32" width="4" height="16"/><rect x="52" y="32" width="4" height="16"/></g><rect x="4" y="48" width="56" height="4" fill="#fbbf24"/><g fill="#f97316"><ellipse cx="10" cy="28" rx="3" ry="5"/><ellipse cx="18" cy="28" rx="3" ry="5"/><ellipse cx="26" cy="28" rx="3" ry="5"/><ellipse cx="32" cy="20" rx="3" ry="5"/><ellipse cx="38" cy="28" rx="3" ry="5"/><ellipse cx="46" cy="28" rx="3" ry="5"/><ellipse cx="54" cy="28" rx="3" ry="5"/></g></svg>'},
  {id:'snowman',cat:'winter',name:'Snowman',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="48" r="16" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="26" r="12" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="32" cy="10" r="8" fill="white" stroke="#d1d5db" stroke-width="2"/><circle cx="29" cy="8" r="2" fill="#1f2937"/><circle cx="35" cy="8" r="2" fill="#1f2937"/><polygon points="32,10 40,14 32,14" fill="#f97316"/><rect x="24" y="2" width="16" height="4" fill="#1f2937"/><rect x="28" y="0" width="8" height="4" fill="#1f2937"/></svg>'},
  {id:'wreath',cat:'winter',name:'Wreath',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="24" fill="none" stroke="#16a34a" stroke-width="12"/><circle cx="32" cy="8" r="6" fill="#ef4444"/><path d="M28 6 Q32 2 36 6" stroke="#ef4444" stroke-width="3" fill="none"/></svg>'},
  {id:'santahat',cat:'winter',name:'Santa Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 52 Q32 32 56 52 L32 8 Z" fill="#ef4444"/><ellipse cx="32" cy="54" rx="28" ry="6" fill="white"/><circle cx="32" cy="10" r="6" fill="white"/></svg>'},
  {id:'mittens',cat:'winter',name:'Mittens',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 24 L12 52 a8 8 0 0 0 8 8 h8 a8 8 0 0 0 8 -8 v-28" fill="#3b82f6"/><path d="M12 32 L4 28 L4 40 L12 40" fill="#3b82f6"/><rect x="12" y="20" width="24" height="8" fill="#93c5fd"/></svg>'},
  
  // Spring (~10)
  {id:'egg',cat:'spring',name:'Easter Egg',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="20" ry="26" fill="#c4b5fd"/><path d="M12 32 Q22 40 32 32 Q42 24 52 32" stroke="#8b5cf6" stroke-width="3" fill="none"/><path d="M12 42 Q22 50 32 42 Q42 34 52 42" stroke="#a78bfa" stroke-width="3" fill="none"/></svg>'},
  {id:'bunny',cat:'spring',name:'Bunny',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="20" ry="18" fill="#fdf4ff"/><circle cx="32" cy="28" r="14" fill="#fdf4ff"/><ellipse cx="22" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="42" cy="10" rx="6" ry="16" fill="#fdf4ff"/><ellipse cx="22" cy="8" rx="3" ry="10" fill="#fbcfe8"/><ellipse cx="42" cy="8" rx="3" ry="10" fill="#fbcfe8"/><circle cx="26" cy="26" r="3" fill="#1f2937"/><circle cx="38" cy="26" r="3" fill="#1f2937"/><ellipse cx="32" cy="34" rx="4" ry="3" fill="#fbcfe8"/></svg>'},
  {id:'flower',cat:'spring',name:'Flower',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><line x1="32" y1="32" x2="32" y2="60" stroke="#22c55e" stroke-width="4"/><circle cx="32" cy="20" r="8" fill="#fbbf24"/><circle cx="20" cy="20" r="8" fill="#f472b6"/><circle cx="44" cy="20" r="8" fill="#f472b6"/><circle cx="24" cy="30" r="8" fill="#f472b6"/><circle cx="40" cy="30" r="8" fill="#f472b6"/><circle cx="32" cy="8" r="8" fill="#f472b6"/></svg>'},
  {id:'butterfly',cat:'spring',name:'Butterfly',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="18" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="46" cy="24" rx="14" ry="18" fill="#c4b5fd"/><ellipse cx="18" cy="44" rx="10" ry="14" fill="#a78bfa"/><ellipse cx="46" cy="44" rx="10" ry="14" fill="#a78bfa"/><rect x="30" y="12" width="4" height="44" fill="#1f2937"/><path d="M30 12 Q24 4 20 8" stroke="#1f2937" stroke-width="2" fill="none"/><path d="M34 12 Q40 4 44 8" stroke="#1f2937" stroke-width="2" fill="none"/></svg>'},
  {id:'chick',cat:'spring',name:'Chick',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="20" ry="20" fill="#fbbf24"/><circle cx="32" cy="24" r="14" fill="#fbbf24"/><circle cx="26" cy="22" r="3" fill="#1f2937"/><circle cx="38" cy="22" r="3" fill="#1f2937"/><polygon points="32,26 28,32 36,32" fill="#f97316"/><path d="M24 10 Q32 4 40 10" stroke="#fbbf24" stroke-width="4" fill="none"/></svg>'},
  {id:'basket',cat:'spring',name:'Basket',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 28 Q8 56 32 56 Q56 56 56 28" fill="#d4a574"/><path d="M8 28 L56 28" stroke="#92400e" stroke-width="2"/><path d="M8 36 L56 36" stroke="#92400e" stroke-width="2"/><path d="M16 28 Q16 8 32 8 Q48 8 48 28" fill="none" stroke="#d4a574" stroke-width="6"/></svg>'},
  {id:'shamrock',cat:'spring',name:'Shamrock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="18" r="12" fill="#22c55e"/><circle cx="20" cy="30" r="12" fill="#22c55e"/><circle cx="44" cy="30" r="12" fill="#22c55e"/><rect x="30" y="38" width="4" height="22" fill="#16a34a"/></svg>'},
  {id:'rainbow',cat:'spring',name:'Rainbow',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 56 Q4 8 60 56" fill="none" stroke="#ef4444" stroke-width="6"/><path d="M10 56 Q10 18 54 56" fill="none" stroke="#f97316" stroke-width="5"/><path d="M16 56 Q16 26 48 56" fill="none" stroke="#fbbf24" stroke-width="5"/><path d="M22 56 Q22 34 42 56" fill="none" stroke="#22c55e" stroke-width="5"/><path d="M28 56 Q28 42 36 56" fill="none" stroke="#3b82f6" stroke-width="5"/></svg>'},
  {id:'umbrella',cat:'spring',name:'Umbrella',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4 32 Q4 8 60 32" fill="#ef4444"/><line x1="32" y1="8" x2="32" y2="56" stroke="#78350f" stroke-width="4"/><path d="M32 56 Q24 56 24 48" fill="none" stroke="#78350f" stroke-width="4"/></svg>'},
  {id:'ladybug',cat:'spring',name:'Ladybug',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="36" rx="24" ry="22" fill="#ef4444"/><line x1="32" y1="14" x2="32" y2="58" stroke="#1f2937" stroke-width="2"/><circle cx="20" cy="28" r="4" fill="#1f2937"/><circle cx="44" cy="28" r="4" fill="#1f2937"/><circle cx="24" cy="44" r="4" fill="#1f2937"/><circle cx="40" cy="44" r="4" fill="#1f2937"/><circle cx="32" cy="12" r="8" fill="#1f2937"/></svg>'},
  
  // Summer/Fall (~10)
  {id:'sun',cat:'summer',name:'Sun',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="14" fill="#fbbf24"/><g stroke="#fbbf24" stroke-width="3"><line x1="32" y1="4" x2="32" y2="12"/><line x1="32" y1="52" x2="32" y2="60"/><line x1="4" y1="32" x2="12" y2="32"/><line x1="52" y1="32" x2="60" y2="32"/><line x1="12" y1="12" x2="18" y2="18"/><line x1="46" y1="46" x2="52" y2="52"/><line x1="12" y1="52" x2="18" y2="46"/><line x1="46" y1="18" x2="52" y2="12"/></g></svg>'},
  {id:'palm',cat:'summer',name:'Palm Tree',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="28" y="28" width="8" height="32" fill="#92400e"/><path d="M32 28 Q16 8 8 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q48 8 56 16" stroke="#22c55e" stroke-width="6" fill="none"/><path d="M32 28 Q24 4 32 8 Q40 4 32 28" fill="#16a34a"/></svg>'},
  {id:'fireworks',cat:'summer',name:'Fireworks',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="4" fill="#ef4444"/><g stroke="#ef4444" stroke-width="2"><line x1="32" y1="24" x2="32" y2="8"/><line x1="32" y1="24" x2="32" y2="40"/><line x1="32" y1="24" x2="16" y2="24"/><line x1="32" y1="24" x2="48" y2="24"/><line x1="32" y1="24" x2="20" y2="12"/><line x1="32" y1="24" x2="44" y2="36"/><line x1="32" y1="24" x2="44" y2="12"/><line x1="32" y1="24" x2="20" y2="36"/></g><circle cx="16" cy="44" r="3" fill="#3b82f6"/><g stroke="#3b82f6" stroke-width="1.5"><line x1="16" y1="44" x2="16" y2="36"/><line x1="16" y1="44" x2="8" y2="44"/><line x1="16" y1="44" x2="24" y2="44"/><line x1="16" y1="44" x2="10" y2="38"/><line x1="16" y1="44" x2="22" y2="50"/></g></svg>'},
  {id:'flag',cat:'summer',name:'Flag',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="4" height="48" fill="#78350f"/><rect x="14" y="8" width="42" height="8" fill="#ef4444"/><rect x="14" y="24" width="42" height="8" fill="#ef4444"/><rect x="14" y="16" width="42" height="8" fill="white"/><rect x="14" y="8" width="16" height="16" fill="#1e40af"/></svg>'},
  {id:'pumpkin',cat:'summer',name:'Pumpkin',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="40" rx="28" ry="20" fill="#f97316"/><ellipse cx="20" cy="40" rx="12" ry="20" fill="#ea580c"/><ellipse cx="44" cy="40" rx="12" ry="20" fill="#ea580c"/><rect x="28" y="8" width="8" height="12" fill="#16a34a"/><path d="M32 8 Q40 4 44 12" stroke="#22c55e" stroke-width="3" fill="none"/></svg>'},
  {id:'ghost',cat:'summer',name:'Ghost',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 32 A20 20 0 1 1 52 32 L52 56 L44 48 L36 56 L28 48 L20 56 L12 48 Z" fill="white"/><circle cx="24" cy="28" r="4" fill="#1f2937"/><circle cx="40" cy="28" r="4" fill="#1f2937"/><ellipse cx="32" cy="40" rx="6" ry="4" fill="#1f2937"/></svg>'},
  {id:'bat',cat:'summer',name:'Bat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 24 Q8 16 4 40 Q12 32 20 40 Q16 28 32 32 Q48 28 44 40 Q52 32 60 40 Q56 16 32 24" fill="#1f2937"/><circle cx="28" cy="28" r="2" fill="#ef4444"/><circle cx="36" cy="28" r="2" fill="#ef4444"/></svg>'},
  {id:'witch',cat:'summer',name:'Witch Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,48 56,48" fill="#1f2937"/><ellipse cx="32" cy="48" rx="28" ry="8" fill="#1f2937"/><rect x="20" y="36" width="24" height="6" fill="#f97316"/></svg>'},
  {id:'turkey',cat:'summer',name:'Turkey',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="44" rx="16" ry="14" fill="#92400e"/><circle cx="24" cy="36" r="10" fill="#78350f"/><circle cx="20" cy="34" r="2" fill="#1f2937"/><polygon points="16,38 8,36 16,34" fill="#f97316"/><path d="M40 12 Q60 8 56 32 Q52 12 40 16" fill="#ef4444"/><path d="M44 12 Q60 12 52 28 Q48 16 44 16" fill="#f97316"/><path d="M48 16 Q56 16 48 28" fill="#fbbf24"/></svg>'},
  {id:'leaf',cat:'summer',name:'Maple Leaf',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L36 16 L48 12 L40 24 L56 28 L40 36 L48 52 L32 44 L16 52 L24 36 L8 28 L24 24 L16 12 L28 16 Z" fill="#ef4444"/><line x1="32" y1="44" x2="32" y2="60" stroke="#78350f" stroke-width="3"/></svg>'},
  
  // Occasions (~10)
  {id:'cake',cat:'occasion',name:'Birthday Cake',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="28" width="48" height="28" rx="4" fill="#f472b6"/><rect x="8" y="28" width="48" height="8" fill="#ec4899"/><rect x="12" y="36" width="40" height="4" fill="#fbbf24"/><rect x="30" y="16" width="4" height="12" fill="#fbbf24"/><ellipse cx="32" cy="12" rx="4" ry="6" fill="#f97316"/></svg>'},
  {id:'balloon',cat:'occasion',name:'Balloon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><ellipse cx="32" cy="24" rx="18" ry="22" fill="#ef4444"/><polygon points="32,44 28,50 36,50" fill="#ef4444"/><path d="M32 50 Q28 56 32 60 Q36 56 32 50" fill="none" stroke="#6b7280" stroke-width="2"/></svg>'},
  {id:'party',cat:'occasion',name:'Party Hat',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="32,4 8,56 56,56" fill="#8b5cf6"/><circle cx="32" cy="8" r="6" fill="#fbbf24"/><circle cx="24" cy="32" r="4" fill="#22c55e"/><circle cx="40" cy="40" r="4" fill="#f472b6"/><circle cx="28" cy="48" r="4" fill="#3b82f6"/></svg>'},
  {id:'ribbon',cat:'occasion',name:'Ribbon',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="24" r="16" fill="#3b82f6"/><path d="M24 38 L16 60 L32 50 L48 60 L40 38" fill="#2563eb"/><circle cx="32" cy="24" r="8" fill="#1d4ed8"/></svg>'},
  {id:'trophy',cat:'occasion',name:'Trophy',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="20" y="8" width="24" height="28" rx="4" fill="#fbbf24"/><path d="M20 16 Q8 16 8 28 Q8 36 20 36" fill="#f59e0b"/><path d="M44 16 Q56 16 56 28 Q56 36 44 36" fill="#f59e0b"/><rect x="28" y="36" width="8" height="12" fill="#fbbf24"/><rect x="20" y="48" width="24" height="8" fill="#92400e"/></svg>'},
  {id:'medal',cat:'occasion',name:'Medal',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M24 4 L24 28 L32 20 L40 28 L40 4" fill="#3b82f6"/><circle cx="32" cy="40" r="18" fill="#fbbf24"/><circle cx="32" cy="40" r="12" fill="#f59e0b"/><text x="32" y="46" text-anchor="middle" fill="white" font-size="16" font-weight="bold">1</text></svg>'},
  {id:'rattle',cat:'occasion',name:'Baby Rattle',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="20" r="16" fill="#f472b6"/><rect x="28" y="36" width="8" height="20" rx="4" fill="#fbbf24"/><circle cx="26" cy="16" r="4" fill="#fdf4ff"/><circle cx="38" cy="16" r="4" fill="#fdf4ff"/><circle cx="32" cy="24" r="4" fill="#fdf4ff"/></svg>'},
  {id:'rings',cat:'occasion',name:'Wedding Rings',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="32" r="16" fill="none" stroke="#fbbf24" stroke-width="6"/><circle cx="40" cy="32" r="16" fill="none" stroke="#d1d5db" stroke-width="6"/></svg>'},
  {id:'diploma',cat:'occasion',name:'Diploma',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="48" height="32" fill="#fef3c7"/><rect x="8" y="16" width="48" height="6" fill="#fcd34d"/><line x1="16" y1="28" x2="48" y2="28" stroke="#92400e" stroke-width="2"/><line x1="16" y1="36" x2="40" y2="36" stroke="#92400e" stroke-width="2"/><circle cx="44" cy="44" r="8" fill="#ef4444"/></svg>'},
  {id:'confetti',cat:'occasion',name:'Confetti',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="8" height="8" fill="#ef4444" transform="rotate(15 12 12)"/><rect x="28" y="4" width="8" height="8" fill="#3b82f6" transform="rotate(-20 32 8)"/><rect x="48" y="12" width="8" height="8" fill="#22c55e" transform="rotate(30 52 16)"/><rect x="4" y="32" width="8" height="8" fill="#f472b6" transform="rotate(-15 8 36)"/><rect x="20" y="28" width="8" height="8" fill="#fbbf24" transform="rotate(25 24 32)"/><rect x="44" y="36" width="8" height="8" fill="#8b5cf6" transform="rotate(-30 48 40)"/><rect x="12" y="48" width="8" height="8" fill="#14b8a6" transform="rotate(10 16 52)"/><rect x="32" y="52" width="8" height="8" fill="#f97316" transform="rotate(-25 36 56)"/></svg>'},
  
  // Symbols & Decorative (~12)
  {id:'arrow',cat:'symbol',name:'Arrow Right',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L48 32 M36 20 L48 32 L36 44" stroke="#1f2937" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'check',cat:'symbol',name:'Checkmark',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#22c55e"/><path d="M20 32 L28 40 L44 24" stroke="#fff" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>'},
  {id:'warning',cat:'symbol',name:'Warning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M32 4 L4 56 L60 56 Z" fill="#fbbf24"/><rect x="29" y="20" width="6" height="20" fill="#1f2937"/><circle cx="32" cy="48" r="4" fill="#1f2937"/></svg>'},
  {id:'info',cat:'symbol',name:'Info',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="#3b82f6"/><circle cx="32" cy="18" r="4" fill="white"/><rect x="28" y="26" width="8" height="24" fill="white"/></svg>'},
  {id:'phone',cat:'symbol',name:'Phone',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M12 4 L24 4 L28 16 L20 24 Q28 40 40 48 L48 40 L60 44 L60 56 Q60 60 56 60 Q12 56 8 12 Q8 8 12 4" fill="#22c55e"/></svg>'},
  {id:'at',cat:'symbol',name:'Email @',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="8" fill="none" stroke="#3b82f6" stroke-width="4"/><path d="M40 32 Q40 44 48 44 A20 20 0 1 1 48 20" fill="none" stroke="#3b82f6" stroke-width="4"/></svg>'},
  {id:'web',cat:'symbol',name:'Globe/Web',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="26" fill="none" stroke="#3b82f6" stroke-width="3"/><ellipse cx="32" cy="32" rx="10" ry="26" fill="none" stroke="#3b82f6" stroke-width="3"/><line x1="6" y1="32" x2="58" y2="32" stroke="#3b82f6" stroke-width="3"/><path d="M10 18 Q32 24 54 18" fill="none" stroke="#3b82f6" stroke-width="2"/><path d="M10 46 Q32 40 54 46" fill="none" stroke="#3b82f6" stroke-width="2"/></svg>'},
  {id:'clock',cat:'symbol',name:'Clock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="32" cy="32" r="28" fill="white" stroke="#1f2937" stroke-width="4"/><line x1="32" y1="32" x2="32" y2="16" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><line x1="32" y1="32" x2="44" y2="32" stroke="#1f2937" stroke-width="3" stroke-linecap="round"/><circle cx="32" cy="32" r="3" fill="#ef4444"/></svg>'},
  {id:'camera',cat:'symbol',name:'Camera',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="56" height="40" rx="4" fill="#1f2937"/><circle cx="32" cy="36" r="14" fill="#374151"/><circle cx="32" cy="36" r="10" fill="#3b82f6"/><rect x="24" y="8" width="16" height="8" fill="#1f2937"/></svg>'},
  {id:'key',cat:'symbol',name:'Key',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="14" fill="none" stroke="#fbbf24" stroke-width="4"/><line x1="30" y1="26" x2="56" y2="52" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="48" y1="44" x2="56" y2="44" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/><line x1="40" y1="36" x2="48" y2="36" stroke="#fbbf24" stroke-width="4" stroke-linecap="round"/></svg>'},
  {id:'lock',cat:'symbol',name:'Lock',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="28" width="40" height="32" rx="4" fill="#6b7280"/><path d="M20 28 v-8 a12 12 0 1 1 24 0 v8" fill="none" stroke="#6b7280" stroke-width="6"/><circle cx="32" cy="44" r="6" fill="#1f2937"/></svg>'},
  {id:'bolt',cat:'symbol',name:'Lightning',svg:'<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><polygon points="36,4 16,32 28,32 24,60 48,28 36,28" fill="#fbbf24"/></svg>'}
];

// Show a read-only preview modal for built-in templates
function showBuiltinTemplatePreview(templateId) {
  const tpl = getBuiltinTemplate(templateId);
  if (!tpl) {
    showToast('Template not found', 'error');
    return;
  }
  
  const lines = deserializeLines(tpl.text);
  const tokens = tpl.tokens || [];
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  
  // Build preview lines with sample data
  const sampleData = {
    name: 'John Smith',
    first_name: 'John',
    last_name: 'Smith',
    street: '123 Main St',
    city: 'Anytown',
    state: 'CA',
    zip: '12345',
    country: 'USA',
    student_name: 'Emma Johnson',
    room: '101',
    teacher: 'Ms. Wilson',
    level: 'Grade 3',
    company: 'Acme Corp',
    title: 'Software Engineer',
    table_number: '5',
    dish_name: 'Caesar Salad',
    description: 'Contains dairy'
  };
  
  // Replace tokens with sample values for preview
  const previewLines = lines.map(line => {
    let text = line.text;
    tokens.forEach(token => {
      const regex = new RegExp('\\{' + token + '\\}', 'gi');
      text = text.replace(regex, sampleData[token] || '{' + token + '}');
    });
    return { ...line, text };
  });
  
  // Build simple preview HTML
  const previewLinesHtml = previewLines.filter(l => l.text.trim()).map(line => {
    const align = line.align || 'left';
    const fontSize = line.fontSize || 11;
    return `<div style="text-align:${align};font-size:${fontSize}px;line-height:1.3;margin:2px 0;">${escapeHtml(line.text)}</div>`;
  }).join('');
  
  // Calculate preview dimensions
  const aspectRatio = spec.labelW / spec.labelH;
  const previewWidth = Math.min(280, spec.labelW * 72);
  const previewHeight = previewWidth / aspectRatio;
  
  // Build modal content
  const modalContent = `
    <div style="text-align: center; padding: 10px 0 20px;">
      <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px;">${escapeHtml(tpl.name)}</div>
      <div style="font-size: 12px; color: var(--text-muted);">Built-in Template Â· ${spec?.name || labelType}</div>
    </div>
    
    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
      <div style="width:${previewWidth}px;min-height:${previewHeight}px;background:#fff;border:2px solid #888;border-radius:4px;padding:8px 12px;display:flex;flex-direction:column;justify-content:center;color:#000;">
        ${previewLinesHtml || '<div style="color:#888;font-style:italic;">Empty template</div>'}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Template Structure</div>
      <div style="font-family: var(--mono); font-size: 12px; color: var(--text-muted); line-height: 1.6;">
        ${lines.map((l, i) => `<div>Line ${i + 1}: ${escapeHtml(l.text) || '<em style="opacity:0.5">(empty)</em>'}</div>`).join('')}
      </div>
    </div>
    
    <div style="background: var(--surface-alt); border-radius: var(--radius-sm); padding: 12px; margin-bottom: 20px;">
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">Tokens (${tokens.length})</div>
      <div style="display: flex; flex-wrap: wrap; gap: 6px;">
        ${tokens.map(tk => `<span style="background: var(--accent-bg); color: var(--accent-text); padding: 3px 8px; border-radius: 4px; font-size: 12px; font-family: var(--mono);">{${tk}}</span>`).join('')}
      </div>
    </div>
    
    <div style="display: flex; justify-content: center; gap: 12px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeBuiltinPreviewModal()">Close</button>
      <button class="wizard-btn wizard-btn-primary" onclick="closeBuiltinPreviewModal(); showBatchImportModal('${templateId}')">ðŸ“Š Use for Batch Print</button>
    </div>
  `;
  
  showGenericModal('Template Preview', modalContent, 'builtinPreviewModal');
}

function closeBuiltinPreviewModal() {
  closeGenericModal('builtinPreviewModal');
}

function openFullEditor(textId, isTemplate = false) {
  feEditingId = textId;
  feIsTemplate = isTemplate;
  
  // Reset state
  resetFullEditorState();
  
  // Determine preview label type (from source sheet or settings)
  if (window._editorSourceSheetId && sheets[window._editorSourceSheetId]) {
    fePreviewLabelType = sheets[window._editorSourceSheetId].labelType;
  } else {
    fePreviewLabelType = settings.lastLabelType || '5160';
  }
  document.getElementById('fePreviewType').value = fePreviewLabelType;
  
  if (textId) {
    // Load existing text
    const text = getSavedText(textId);
    if (text) {
      document.getElementById('fullEditorTitle').textContent = 'Edit Label';
      document.getElementById('feNameRow').style.display = 'none';
      document.getElementById('feNameEditRow').style.display = 'flex';
      document.getElementById('feNameEdit').value = text.name;
      loadTextIntoFullEditor(text);
      
      // Store original state for dirty tracking
      feOriginalState = captureEditorState();
    }
  } else {
    // New text
    document.getElementById('fullEditorTitle').textContent = isTemplate ? 'New Template' : 'New Label';
    document.getElementById('feNameRow').style.display = 'flex';
    document.getElementById('feNameEditRow').style.display = 'none';
    document.getElementById('feName').value = '';
    feOriginalState = null;
  }
  
  // Reset dirty state
  feDirty = false;
  updateDirtyIndicator();
  
  // Show/hide Back to Wizard button
  const backToWizardBtn = document.getElementById('feBackToWizardBtn');
  if (backToWizardBtn) {
    backToWizardBtn.style.display = feOpenedFromWizard ? 'inline-flex' : 'none';
  }
  
  document.getElementById('fullEditorSubtitle').textContent = isTemplate ? 'Template with tokens' : 'Full formatting options';
  document.getElementById('fullEditorOverlay').classList.add('visible');
  updateTokenToggleVisibility(); // Show/hide token panel toggle for templates
  updateFullEditorPreview();
}

// Track if editor was opened from wizard (for return navigation)
let feOpenedFromWizard = false;

// Capture current editor state for dirty comparison
function captureEditorState() {
  return JSON.stringify({
    lines: feLines,
    alignV: feAlignV,
    graphics: feGraphics,
    border: feBorder,
    name: document.getElementById('feNameEdit')?.value || ''
  });
}

// Check if editor is dirty and update indicator
function checkEditorDirty() {
  if (!feOriginalState) {
    // New text - dirty if any content
    const hasContent = feLines.some(l => l.text.trim());
    feDirty = hasContent;
  } else {
    // Existing - compare to original
    feDirty = captureEditorState() !== feOriginalState;
  }
  updateDirtyIndicator();
}

function updateDirtyIndicator() {
  const indicator = document.getElementById('feDirtyIndicator');
  if (indicator) {
    indicator.classList.toggle('visible', feDirty);
  }
}

function closeFullEditor() {
  // Check for unsaved changes
  if (feDirty) {
    if (!confirm('You have unsaved changes. Discard them?')) {
      return;
    }
  }
  
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  feDirty = false;
  feOriginalState = null;
  closeFeStylePopovers();
  
  // Clear editor source sheet reference
  window._editorSourceSheetId = null;
  
  // Refresh current tab to ensure data is current (especially for sheet print)
  renderCurrentTab();
}

// Close full editor and return to wizard with content
function closeFullEditorToWizard() {
  // Transfer content back to wizard
  for (let i = 1; i <= 4; i++) {
    const feInput = document.getElementById('feLine' + i);
    const wizInput = document.getElementById('wizLine' + i);
    if (feInput && wizInput) {
      wizInput.value = feInput.value;
      wizardLines[i - 1].text = feInput.value;
      wizardLines[i - 1].align = feLines[i - 1].align || 'left';
      wizardLines[i - 1].fontSize = feLines[i - 1].fontSize || 11;
    }
  }
  
  // Update wizard align button states
  for (let i = 1; i <= 4; i++) {
    document.querySelectorAll(`.editor-align-btn[data-line="${i}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === wizardLines[i - 1].align);
    });
    document.querySelectorAll(`.editor-size-btn[data-line="${i}"]`).forEach(btn => {
      btn.classList.toggle('active', parseInt(btn.dataset.size) === wizardLines[i - 1].fontSize);
    });
  }
  
  // Close full editor
  document.getElementById('fullEditorOverlay').classList.remove('visible');
  feEditingId = null;
  feOpenedFromWizard = false;
  closeFeStylePopovers();
  
  // Re-open print wizard at step 2a
  currentWizard = 'print';
  wizardStep = 2;
  showWizard('printWizard');
  showWizardStep('printStep2a');
  updateWizardPreview();
  showToast('Returned to print wizard', 'info');
}

// ========== TOKEN PANEL FOR TEMPLATES ==========
let feLastFocusedLine = null; // Track which line input was last focused

function toggleFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  const toggle = document.getElementById('feTokenToggle');
  
  if (panel.classList.contains('visible')) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  } else {
    renderFeTokenPanel();
    panel.classList.add('visible');
    toggle.classList.add('active');
  }
}

function renderFeTokenPanel() {
  const panel = document.getElementById('feTokenPanel');
  let html = '';
  
  // Built-in categories
  for (const [category, tokens] of Object.entries(BUILTIN_TOKENS)) {
    html += '<div class="fe-token-category">' + escapeHtml(category) + '</div>';
    html += '<div class="fe-token-grid">';
    tokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Custom tokens
  if (customTokens.length) {
    html += '<div class="fe-token-category">Custom</div>';
    html += '<div class="fe-token-grid">';
    customTokens.forEach(t => {
      html += '<span class="fe-token-chip" onclick="insertFeToken(\'' + escapeAttr(t) + '\')">{' + escapeHtml(t) + '}</span>';
    });
    html += '</div>';
  }
  
  // Add custom token row
  html += '<div class="fe-token-custom-row">';
  html += '<input type="text" id="feCustomTokenInput" placeholder="custom_field" maxlength="30" onkeydown="if(event.key===\'Enter\')addFeCustomToken()">';
  html += '<button onclick="addFeCustomToken()">+ Add</button>';
  html += '</div>';
  
  panel.innerHTML = html;
}

function insertFeToken(tokenName) {
  // Find which line input to insert into
  let input = null;
  
  // Use last focused line, or default to line 1
  if (feLastFocusedLine) {
    input = document.getElementById('feLine' + feLastFocusedLine);
  }
  if (!input) {
    input = document.getElementById('feLine1');
  }
  
  if (!input) return;
  
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const val = input.value;
  const insert = '{' + tokenName + '}';
  
  input.value = val.substring(0, start) + insert + val.substring(end);
  input.selectionStart = input.selectionEnd = start + insert.length;
  input.focus();
  
  // Update feLines state
  const lineNum = parseInt(input.id.replace('feLine', ''));
  if (lineNum >= 1 && lineNum <= 4) {
    feLines[lineNum - 1].text = input.value;
  }
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function addFeCustomToken() {
  const inp = document.getElementById('feCustomTokenInput');
  if (!inp) return;
  
  // Clean the token name: lowercase, underscores for spaces, alphanumeric only
  let name = inp.value.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/^_+|_+$/g, '');
  
  if (!name || !/^[a-z]/.test(name)) {
    inp.style.borderColor = 'var(--error-border)';
    showToast('Token must start with a letter', 'error');
    return;
  }
  
  // Check for duplicates across builtins and custom
  const allBuiltin = Object.values(BUILTIN_TOKENS).flat();
  if (allBuiltin.includes(name) || customTokens.includes(name)) {
    // Already exists - just insert it
    insertFeToken(name);
    inp.value = '';
    inp.style.borderColor = '';
    return;
  }
  
  // Add new custom token
  customTokens.push(name);
  saveCustomTokens();
  renderFeTokenPanel();
  insertFeToken(name);
  inp.value = '';
  inp.style.borderColor = '';
  showToast('Custom token {' + name + '} added', 'success');
}

// Show/hide token toggle based on template mode
function updateTokenToggleVisibility() {
  const tokenToggleRow = document.getElementById('feTokenToggleRow');
  if (tokenToggleRow) {
    tokenToggleRow.style.display = feIsTemplate ? 'flex' : 'none';
  }
  // Close token panel when switching away from template mode
  if (!feIsTemplate) {
    const panel = document.getElementById('feTokenPanel');
    const toggle = document.getElementById('feTokenToggle');
    if (panel) panel.classList.remove('visible');
    if (toggle) toggle.classList.remove('active');
  }
}

// ========== EMOJI PANEL (Full Editor) ==========
function toggleFeEmojiPanel() {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  
  const show = !panel.classList.contains('visible');
  panel.classList.toggle('visible', show);
  toggle.classList.toggle('active', show);
  
  if (show) {
    renderFeEmojiPanel();
    const search = document.getElementById('feEmojiSearch');
    if (search) {
      search.value = '';
      search.focus();
    }
  }
}

function renderFeEmojiPanel(filter) {
  const scroll = document.getElementById('feEmojiScroll');
  const q = (filter || '').toLowerCase().trim();
  let html = '';
  
  EMOJI_DATA.forEach(cat => {
    const filtered = q ? cat.emojis.filter(em => em.n.includes(q) || em.e === q) : cat.emojis;
    if (!filtered.length) return;
    html += '<div class="fe-emoji-category"><div class="fe-emoji-category-label">' + escapeHtml(cat.cat) + '</div><div class="fe-emoji-grid">';
    filtered.forEach(em => {
      html += '<button class="fe-emoji-btn" onclick="insertFeEmoji(\'' + em.e + '\')" title="' + escapeAttr(em.n) + '">' + em.e + '</button>';
    });
    html += '</div></div>';
  });
  
  if (!html) html = '<div style="padding: 16px; text-align: center; font-size: 12px; color: var(--text-muted);">No matches</div>';
  scroll.innerHTML = html;
}

function filterFeEmojis() {
  const search = document.getElementById('feEmojiSearch');
  renderFeEmojiPanel(search ? search.value : '');
}

function insertFeEmoji(emoji) {
  // Determine which input to insert into
  const lineNum = feLastFocusedLine || 1;
  const input = document.getElementById('feLine' + lineNum);
  if (!input) return;
  
  const start = input.selectionStart || input.value.length;
  const end = input.selectionEnd || start;
  input.value = input.value.slice(0, start) + emoji + input.value.slice(end);
  input.focus();
  const pos = start + emoji.length;
  input.setSelectionRange(pos, pos);
  updateFullEditorPreview();
}

// Close emoji panel on click outside
document.addEventListener('click', e => {
  const panel = document.getElementById('feEmojiPanel');
  const toggle = document.getElementById('feEmojiToggle');
  if (panel && panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== toggle && !toggle.contains(e.target)) {
    panel.classList.remove('visible');
    toggle.classList.remove('active');
  }
});

// ========== OCR SCANNING ==========
async function loadTesseract() {
  if (window.Tesseract) return;
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load Tesseract.js'));
    document.head.appendChild(script);
  });
}

function openOcrModal() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  
  // Reset UI
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loadingâ€¦';
  document.getElementById('ocrResultLines').innerHTML = '';
  document.getElementById('ocrHint').textContent = '';
  document.getElementById('ocrModal').classList.add('visible');
}

function closeOcrModal() {
  document.getElementById('ocrModal').classList.remove('visible');
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
}

// Paste clipboard text directly into editor line inputs (like v1.2)
async function pasteToEditor() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // Route based on content:
  // - Tabular data (Excel-style with tabs+newlines): always import modal
  // - 8+ plain lines: import modal for bulk processing
  // - 1-7 plain lines: paste first 4 into editor
  if (isTabular || rows.length > 7) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // Paste into editor lines (up to 4 lines)
  const maxLines = Math.min(rows.length, 4);
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('feLine' + (i + 1));
    if (input) {
      input.value = i < maxLines ? rows[i] : '';
    }
  }
  
  updateFePreview();
  markFeDirty();
  
  if (rows.length > 4) {
    showToast('Pasted first 4 of ' + rows.length + ' lines (label limit)', 'success');
  } else {
    showToast('Pasted ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard', 'success');
  }
}

// Clear text lines in the editor
// If a specific line is focused, clear only that line
// If no line is focused, clear all lines
function clearEditorLines() {
  const focusedLine = feLastFocusedLine;
  
  if (focusedLine && focusedLine >= 1 && focusedLine <= 4) {
    // Clear only the focused line
    const input = document.getElementById('feLine' + focusedLine);
    if (input) {
      input.value = '';
      input.focus();
      showToast('Line ' + focusedLine + ' cleared', 'info');
    }
  } else {
    // Clear all lines
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('feLine' + i);
      if (input) {
        input.value = '';
      }
    }
    showToast('All lines cleared', 'info');
  }
  
  updateFePreview();
  markFeDirty();
}

function ocrImageAreaClick() {
  if (!ocrImageBlob) {
    document.getElementById('ocrFileInput').click();
  }
}

function handleOcrFile(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  event.target.value = '';
  processOcrImage(file);
}

// Handle paste events for screenshot paste in OCR modal
document.addEventListener('paste', e => {
  const modal = document.getElementById('ocrModal');
  if (!modal || !modal.classList.contains('visible')) return;
  const items = e.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      if (blob) processOcrImage(blob);
      return;
    }
  }
});

function processOcrImage(fileOrBlob) {
  ocrImageBlob = fileOrBlob;
  ocrRotation = 0;
  
  const img = document.getElementById('ocrPreviewImg');
  const url = URL.createObjectURL(fileOrBlob);
  img.onload = () => URL.revokeObjectURL(url);
  img.src = url;
  img.style.display = '';
  img.style.transform = '';
  document.getElementById('ocrPlaceholder').style.display = 'none';
  document.getElementById('ocrImageArea').classList.add('has-image');
  
  document.getElementById('ocrRotationBar').style.display = 'flex';
  document.getElementById('ocrRotationLabel').textContent = '';
  
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  
  runOcr(fileOrBlob);
}

function rotateOcrImage(delta) {
  ocrRotation = ((ocrRotation || 0) + delta + 360) % 360;
  const img = document.getElementById('ocrPreviewImg');
  img.style.transform = 'rotate(' + ocrRotation + 'deg)';
  document.getElementById('ocrRotationLabel').textContent = ocrRotation ? ocrRotation + 'Â°' : '';
}

async function runOcr(imageBlob) {
  document.getElementById('ocrProgressArea').style.display = '';
  document.getElementById('ocrProgressFill').style.width = '0%';
  document.getElementById('ocrProgressText').textContent = 'Loading OCR engineâ€¦';
  
  try {
    await loadTesseract();
    document.getElementById('ocrProgressText').textContent = 'Preprocessingâ€¦';
    document.getElementById('ocrProgressFill').style.width = '15%';
    
    const processed = await preprocessOcrImage(imageBlob, ocrRotation);
    
    document.getElementById('ocrProgressText').textContent = 'Scanningâ€¦';
    document.getElementById('ocrProgressFill').style.width = '30%';
    
    const result = await Tesseract.recognize(processed, 'eng', {
      logger: m => {
        if (m.status === 'recognizing text' && m.progress) {
          const pct = 30 + Math.round(m.progress * 65);
          document.getElementById('ocrProgressFill').style.width = pct + '%';
          document.getElementById('ocrProgressText').textContent = Math.round(m.progress * 100) + '%';
        }
      }
    });
    
    document.getElementById('ocrProgressFill').style.width = '100%';
    document.getElementById('ocrProgressText').textContent = 'Done!';
    
    parseOcrResult(result);
    
  } catch (err) {
    document.getElementById('ocrProgressText').textContent = 'Error: ' + err.message;
    document.getElementById('ocrProgressFill').style.background = 'var(--error-text)';
    console.error('OCR error:', err);
  }
}

function preprocessOcrImage(imageBlob, rotation) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(imageBlob);
    img.onload = () => {
      URL.revokeObjectURL(url);
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let w = img.naturalWidth;
        let h = img.naturalHeight;
        const rot = ((rotation || 0) % 360 + 360) % 360;
        const swapDims = (rot === 90 || rot === 270);
        
        // Scale up small images for better OCR
        const minDim = 1500;
        if (w < minDim && h < minDim) {
          const scale = minDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        // Cap very large images
        const maxDim = 4000;
        if (w > maxDim || h > maxDim) {
          const scale = maxDim / Math.max(w, h);
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }
        
        canvas.width = swapDims ? h : w;
        canvas.height = swapDims ? w : h;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rot * Math.PI / 180);
        ctx.translate(-w / 2, -h / 2);
        ctx.drawImage(img, 0, 0, w, h);
        
        canvas.toBlob(blob => {
          if (blob) resolve(blob);
          else reject(new Error('Failed to preprocess image'));
        }, 'image/png');
        
      } catch (e) {
        reject(e);
      }
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };
    img.src = url;
  });
}

function parseOcrResult(result) {
  ocrResults = [];
  
  if (!result?.data?.lines) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
    renderOcrResults();
    return;
  }
  
  const lines = result.data.lines;
  let totalConf = 0;
  
  for (const line of lines) {
    const text = (line.text || '').trim();
    if (!text) continue;
    const conf = Math.round(line.confidence || 0);
    totalConf += conf;
    ocrResults.push({ text, confidence: conf });
  }
  
  // Show hint based on line count
  if (ocrResults.length === 0) {
    document.getElementById('ocrHint').textContent = 'No text detected. Try a clearer image.';
  } else if (ocrResults.length > 7) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. Will open import modal for bulk processing.';
  } else if (ocrResults.length > 4) {
    document.getElementById('ocrHint').textContent = ocrResults.length + ' lines detected. First 4 will be used (label limit).';
  } else {
    const avgConf = totalConf / ocrResults.length;
    if (avgConf < 70) {
      document.getElementById('ocrHint').textContent = 'Low confidence results. Check for errors.';
    } else {
      document.getElementById('ocrHint').textContent = '';
    }
  }
  
  renderOcrResults();
}

function renderOcrResults() {
  const container = document.getElementById('ocrResultLines');
  let html = '';
  
  ocrResults.forEach((r, idx) => {
    const isLow = r.confidence < 70;
    html += '<div class="ocr-result-line">' +
      '<input type="text" value="' + escapeAttr(r.text) + '" ' +
        'class="' + (isLow ? 'low-confidence' : '') + '" ' +
        'oninput="updateOcrLine(' + idx + ', this.value)">' +
      '<span class="ocr-conf ' + (isLow ? 'low' : '') + '">' + r.confidence + '%</span>' +
      '<button class="ocr-line-remove" onclick="removeOcrLine(' + idx + ')" title="Remove line">Ã—</button>' +
    '</div>';
  });
  
  container.innerHTML = html;
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = '';
  document.getElementById('ocrConfirmBtn').style.display = ocrResults.length > 0 ? '' : 'none';
  document.getElementById('ocrRescanBtn').style.display = '';
  document.getElementById('ocrNewImageBtn').style.display = '';
}

function updateOcrLine(idx, value) {
  if (ocrResults[idx]) ocrResults[idx].text = value;
}

function removeOcrLine(idx) {
  ocrResults.splice(idx, 1);
  renderOcrResults();
}

function ocrRescan() {
  if (ocrImageBlob) runOcr(ocrImageBlob);
}

function ocrNewImage() {
  ocrImageBlob = null;
  ocrResults = [];
  ocrRotation = 0;
  document.getElementById('ocrPreviewImg').style.display = 'none';
  document.getElementById('ocrPlaceholder').style.display = '';
  document.getElementById('ocrImageArea').classList.remove('has-image');
  document.getElementById('ocrRotationBar').style.display = 'none';
  document.getElementById('ocrProgressArea').style.display = 'none';
  document.getElementById('ocrResultsArea').style.display = 'none';
  document.getElementById('ocrConfirmBtn').style.display = 'none';
  document.getElementById('ocrRescanBtn').style.display = 'none';
  document.getElementById('ocrNewImageBtn').style.display = 'none';
  document.getElementById('ocrFileInput').click();
}

function confirmOcr() {
  // Get text from editable OCR result inputs
  const rows = [];
  document.querySelectorAll('#ocrResultLines input').forEach(input => {
    const text = input.value.trim();
    if (text) rows.push(text);
  });
  
  if (rows.length === 0) {
    showToast('No text to import', 'warning');
    return;
  }
  
  closeOcrModal();
  
  // Route based on line count (same rules as paste)
  if (rows.length > 7) {
    // 8+ lines: open import modal for bulk processing
    showImportModal(rows, false);
  } else {
    // 1-7 lines: paste first 4 into editor
    const maxLines = Math.min(rows.length, 4);
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById('feLine' + (i + 1));
      if (input) {
        input.value = i < maxLines ? rows[i] : '';
      }
    }
    updateFePreview();
    markFeDirty();
    
    if (rows.length > 4) {
      showToast('Imported first 4 of ' + rows.length + ' lines (label limit)', 'success');
    } else {
      showToast('Imported ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' to editor', 'success');
    }
  }
}

function resetFullEditorState() {
  feLines = [
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' },
    { text: '', align: 'left', fontSize: 11, bold: false, italic: false, underline: false, strikethrough: false, color: '', fillColor: '', borders: '' }
  ];
  feAlignV = 'center';
  feGraphics = { left: null, right: null };
  feLastFocusedLine = null; // Reset token insertion target
  
  // Close token panel if open
  const tokenPanel = document.getElementById('feTokenPanel');
  const tokenToggle = document.getElementById('feTokenToggle');
  if (tokenPanel) tokenPanel.classList.remove('visible');
  if (tokenToggle) tokenToggle.classList.remove('active');
  
  // Close emoji panel if open
  const emojiPanel = document.getElementById('feEmojiPanel');
  const emojiToggle = document.getElementById('feEmojiToggle');
  if (emojiPanel) emojiPanel.classList.remove('visible');
  if (emojiToggle) emojiToggle.classList.remove('active');
  
  // Reset inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) input.value = '';
    document.getElementById('feSize' + i).textContent = '11';
    
    // Reset align buttons
    document.querySelectorAll(`.fe-align-btn[data-line="${i}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === 'left');
    });
    
    // Reset style button
    const styleBtn = document.getElementById('feStyleBtn' + i);
    if (styleBtn) styleBtn.classList.remove('has-styles');
  }
  
  // Reset valign buttons
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === 'center');
  });
  
  // Reset border state
  feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  document.getElementById('feBorderTop').classList.remove('active');
  document.getElementById('feBorderBottom').classList.remove('active');
  document.getElementById('feBorderLeft').classList.remove('active');
  document.getElementById('feBorderRight').classList.remove('active');
  document.getElementById('feBorderAll').classList.remove('active');
  document.getElementById('feBorderColor').value = '#000000';
  
  // Reset graphics display
  renderFeGraphics();
}

function loadTextIntoFullEditor(text) {
  const lines = deserializeLines(text.text);
  
  for (let i = 0; i < 4; i++) {
    const line = lines[i] || { text: '', align: 'left', fontSize: 11 };
    feLines[i] = {
      text: line.text || '',
      align: line.align || 'left',
      fontSize: line.fontSize || 11,
      bold: line.bold || false,
      italic: line.italic || false,
      underline: line.underline || false,
      strikethrough: line.strikethrough || false,
      color: line.color || '',
      fillColor: line.fillColor || '',
      borders: line.borders || ''
    };
    
    // Update inputs
    const input = document.getElementById('feLine' + (i + 1));
    if (input) input.value = feLines[i].text;
    document.getElementById('feSize' + (i + 1)).textContent = feLines[i].fontSize;
    
    // Update align buttons
    document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === feLines[i].align);
    });
    
    // Update style button indicator
    updateFeStyleButtonIndicator(i + 1);
  }
  
  // Load vertical alignment
  feAlignV = text.alignV || 'center';
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === feAlignV);
  });
  
  // Load graphics
  feGraphics = text.graphics ? { ...text.graphics } : { left: null, right: null };
  renderFeGraphics();
  
  // Load border state
  if (text.border) {
    feBorder = { ...text.border };
  } else {
    feBorder = { top: false, bottom: false, left: false, right: false, color: '#000000' };
  }
  updateBorderUI();
}

function updateBorderUI() {
  document.getElementById('feBorderTop').classList.toggle('active', feBorder.top);
  document.getElementById('feBorderBottom').classList.toggle('active', feBorder.bottom);
  document.getElementById('feBorderLeft').classList.toggle('active', feBorder.left);
  document.getElementById('feBorderRight').classList.toggle('active', feBorder.right);
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  document.getElementById('feBorderAll').classList.toggle('active', allActive);
  document.getElementById('feBorderColor').value = feBorder.color || '#000000';
}

function updateFeStyleButtonIndicator(lineNum) {
  const s = feLines[lineNum - 1];
  const hasStyles = s.bold || s.italic || s.underline || s.strikethrough || s.color || s.fillColor;
  const btn = document.getElementById('feStyleBtn' + lineNum);
  if (btn) btn.classList.toggle('has-styles', hasStyles);
}

// Alignment
function setFeAlign(lineNum, align) {
  feLines[lineNum - 1].align = align;
  document.querySelectorAll(`.fe-align-btn[data-line="${lineNum}"]`).forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// Font size
function stepFeSize(lineNum, delta) {
  const sizes = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24];
  const current = feLines[lineNum - 1].fontSize;
  const idx = sizes.indexOf(current);
  const newIdx = Math.max(0, Math.min(sizes.length - 1, idx + delta));
  feLines[lineNum - 1].fontSize = sizes[newIdx];
  document.getElementById('feSize' + lineNum).textContent = sizes[newIdx];
  updateFullEditorPreview();
  checkEditorDirty();
}

// Vertical alignment
function setFeValign(valign) {
  feAlignV = valign;
  document.querySelectorAll('.fe-valign-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.valign === valign);
  });
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== GLOBAL STYLE CONTROLS ==========

function toggleGlobalStyle(styleProp) {
  // Check if all lines have this style
  const allHaveStyle = feLines.every(l => l[styleProp]);
  const newValue = !allHaveStyle;
  
  // Apply to all lines
  for (let i = 0; i < 4; i++) {
    feLines[i][styleProp] = newValue;
    updateFeStyleButtonIndicator(i + 1);
  }
  
  // Update global button
  const btn = document.getElementById('feGlobal' + styleProp.charAt(0).toUpperCase() + styleProp.slice(1));
  if (btn) btn.classList.toggle('active', newValue);
  
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalAlign(align) {
  for (let i = 0; i < 4; i++) {
    feLines[i].align = align;
    document.querySelectorAll(`.fe-align-btn[data-line="${i + 1}"]`).forEach(btn => {
      btn.classList.toggle('active', btn.dataset.align === align);
    });
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

function setGlobalFontSize(size) {
  for (let i = 0; i < 4; i++) {
    feLines[i].fontSize = size;
    document.getElementById('feSize' + (i + 1)).textContent = size;
  }
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== BORDER CONTROLS ==========

function toggleFeBorder(side) {
  feBorder[side] = !feBorder[side];
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function toggleAllBorders() {
  const allActive = feBorder.top && feBorder.bottom && feBorder.left && feBorder.right;
  const newValue = !allActive;
  feBorder.top = newValue;
  feBorder.bottom = newValue;
  feBorder.left = newValue;
  feBorder.right = newValue;
  updateBorderUI();
  updateFullEditorPreview();
  checkEditorDirty();
}

function updateFeBorderColor(color) {
  feBorder.color = color;
  updateFullEditorPreview();
  checkEditorDirty();
}

// ========== PREVIEW TYPE SELECTOR ==========

function changeFePreviewType(labelType) {
  fePreviewLabelType = labelType;
  updateFullEditorPreview();
}

// Style popover
function toggleFeStylePopover(lineNum) {
  const popover = document.getElementById('feStylePopover' + lineNum);
  const btn = document.getElementById('feStyleBtn' + lineNum);
  
  if (popover.classList.contains('open')) {
    closeFeStylePopovers();
  } else {
    closeFeStylePopovers();
    renderFeStylePopover(lineNum);
    popover.classList.add('open');
    btn.classList.add('popover-open');
    feActiveStylePopover = lineNum;
  }
}

function closeFeStylePopovers() {
  for (let i = 1; i <= 4; i++) {
    const popover = document.getElementById('feStylePopover' + i);
    const btn = document.getElementById('feStyleBtn' + i);
    if (popover) popover.classList.remove('open');
    if (btn) btn.classList.remove('popover-open');
  }
  feActiveStylePopover = null;
}

function renderFeStylePopover(lineNum) {
  const s = feLines[lineNum - 1];
  const popover = document.getElementById('feStylePopover' + lineNum);
  
  let html = '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Style</div>';
  html += '<div class="fe-style-toggles">';
  html += `<button class="fe-style-toggle${s.bold ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'bold')"><span class="lbl-b">B</span></button>`;
  html += `<button class="fe-style-toggle${s.italic ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'italic')"><span class="lbl-i">I</span></button>`;
  html += `<button class="fe-style-toggle${s.underline ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'underline')"><span class="lbl-u">U</span></button>`;
  html += `<button class="fe-style-toggle${s.strikethrough ? ' active' : ''}" onclick="toggleFeStyle(${lineNum},'strikethrough')"><span class="lbl-s">S</span></button>`;
  html += '</div></div>';
  
  // Text color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Text Color</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.color ? ' active' : ''}" onclick="setFeColor(${lineNum},'color','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.color === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'color','${c}')"></div>`;
  }
  html += '</div></div>';
  
  // Fill color
  html += '<div class="fe-popover-section">';
  html += '<div class="fe-popover-label">Background</div>';
  html += '<div class="fe-color-palette">';
  html += `<div class="fe-color-swatch swatch-none${!s.fillColor ? ' active' : ''}" onclick="setFeColor(${lineNum},'fillColor','')"></div>`;
  for (const c of FE_COLORS) {
    html += `<div class="fe-color-swatch${s.fillColor === c ? ' active' : ''}" style="background:${c}" onclick="setFeColor(${lineNum},'fillColor','${c}')"></div>`;
  }
  html += '</div></div>';
  
  popover.innerHTML = html;
}

function toggleFeStyle(lineNum, prop) {
  const s = feLines[lineNum - 1];
  s[prop] = !s[prop];
  
  // Underline and strikethrough are mutually exclusive
  if (prop === 'underline' && s.underline) s.strikethrough = false;
  if (prop === 'strikethrough' && s.strikethrough) s.underline = false;
  
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

function setFeColor(lineNum, prop, color) {
  feLines[lineNum - 1][prop] = color;
  renderFeStylePopover(lineNum);
  updateFeStyleButtonIndicator(lineNum);
  updateFullEditorPreview();
  checkEditorDirty();
}

// Graphics
function renderFeGraphics() {
  renderFeGraphicSide('left');
  renderFeGraphicSide('right');
}

function renderFeGraphicSide(side) {
  const container = document.getElementById('feGraphic' + (side === 'left' ? 'Left' : 'Right') + 'Content');
  const g = feGraphics[side];
  
  if (!g || !g.data) {
    container.innerHTML = `<button class="fe-graphic-add" onclick="openFeGraphicPicker('${side}')">ðŸ–¼ Add Graphic</button>`;
  } else {
    let html = `<div class="fe-graphic-thumb" onclick="openFeGraphicPicker('${side}')"><img src="${g.data}"></div>`;
    html += '<div class="fe-graphic-size-pills">';
    for (const size of ['S', 'M', 'L']) {
      html += `<button class="fe-graphic-size-pill${g.size === size ? ' active' : ''}" onclick="setFeGraphicSize('${side}','${size}')">${size}</button>`;
    }
    html += '</div>';
    html += `<button class="fe-graphic-remove" onclick="removeFeGraphic('${side}')">âœ•</button>`;
    container.innerHTML = html;
  }
}

function setFeGraphicSize(side, size) {
  if (feGraphics[side]) {
    feGraphics[side].size = size;
    renderFeGraphicSide(side);
    updateFullEditorPreview();
  }
}

function removeFeGraphic(side) {
  feGraphics[side] = null;
  renderFeGraphicSide(side);
  updateFullEditorPreview();
}

// Graphic picker
function openFeGraphicPicker(side) {
  feGraphicPickerSide = side;
  document.getElementById('feGraphicPicker').classList.add('visible');
  switchFeGpTab('library');
}

function closeFeGraphicPicker() {
  document.getElementById('feGraphicPicker').classList.remove('visible');
  feGraphicPickerSide = null;
}

function switchFeGpTab(tab) {
  document.querySelectorAll('.fe-gp-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  
  const body = document.getElementById('feGpBody');
  
  if (tab === 'library') {
    // Build category filter
    let html = '<div style="margin-bottom:12px;"><select id="feGpCategoryFilter" onchange="renderFeGpLibrary()" style="width:100%;padding:8px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--input-bg);color:var(--text);font-size:14px;">';
    html += '<option value="all">All Categories</option>';
    Object.entries(FE_GRAPHICS_CATEGORIES).sort((a,b) => a[1].order - b[1].order).forEach(([key, cat]) => {
      html += `<option value="${key}">${cat.label}</option>`;
    });
    html += '</select></div>';
    html += '<div id="feGpIconGrid" class="fe-gp-grid"></div>';
    body.innerHTML = html;
    renderFeGpLibrary();
  } else {
    body.innerHTML = `
      <div class="fe-gp-upload-area">
        <button class="fe-gp-upload-btn" onclick="document.getElementById('feGraphicFileInput').click()">
          ðŸ“ Choose Image File
        </button>
        <div style="margin-top:12px;font-size:12px;color:var(--text-muted)">PNG, JPG, or SVG</div>
      </div>
    `;
  }
}

function renderFeGpLibrary() {
  const filter = document.getElementById('feGpCategoryFilter')?.value || 'all';
  const grid = document.getElementById('feGpIconGrid');
  if (!grid) return;
  
  let icons = FE_GRAPHICS_LIBRARY;
  if (filter !== 'all') {
    icons = icons.filter(i => i.cat === filter);
  }
  
  let html = '';
  for (const icon of icons) {
    html += `<div class="fe-gp-icon" onclick="selectFeLibraryGraphic('${icon.id}')" title="${icon.name}">${icon.svg}</div>`;
  }
  grid.innerHTML = html || '<div style="padding:20px;text-align:center;color:var(--text-muted)">No icons in this category</div>';
}

function selectFeLibraryGraphic(iconId) {
  const icon = FE_GRAPHICS_LIBRARY.find(i => i.id === iconId);
  if (icon && feGraphicPickerSide) {
    const dataUrl = 'data:image/svg+xml;base64,' + btoa(icon.svg);
    feGraphics[feGraphicPickerSide] = { data: dataUrl, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  }
}

function handleFeGraphicUpload(event) {
  const file = event.target.files[0];
  if (!file || !feGraphicPickerSide) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    feGraphics[feGraphicPickerSide] = { data: e.target.result, size: 'M' };
    renderFeGraphicSide(feGraphicPickerSide);
    updateFullEditorPreview();
    closeFeGraphicPicker();
  };
  reader.readAsDataURL(file);
  event.target.value = '';
}

// Preview
function updateFullEditorPreview() {
  // Get current text from inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('feLine' + i);
    if (input) feLines[i - 1].text = input.value;
  }
  
  // Also check for dirty state on text input
  checkEditorDirty();
  
  const previewLabel = document.getElementById('fePreviewLabel');
  const nonEmptyLines = feLines.filter(l => l.text.trim());
  
  if (nonEmptyLines.length === 0 && !feGraphics.left && !feGraphics.right) {
    previewLabel.className = 'fe-preview-label empty-preview';
    previewLabel.innerHTML = '<span>Type above to preview</span>';
    previewLabel.style.borderTop = '';
    previewLabel.style.borderBottom = '';
    previewLabel.style.borderLeft = '';
    previewLabel.style.borderRight = '';
    return;
  }
  
  previewLabel.className = 'fe-preview-label';
  
  // Calculate dimensions based on selected preview label type
  const labelType = fePreviewLabelType || settings.lastLabelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const aspectRatio = spec.labelW / spec.labelH;
  const maxWidth = 300;
  const width = Math.min(maxWidth, spec.labelW * 72);
  const height = width / aspectRatio;
  
  previewLabel.style.width = width + 'px';
  previewLabel.style.minHeight = height + 'px';
  
  // Apply border styles
  const borderStyle = '2px solid ' + (feBorder.color || '#000000');
  const noBorder = '2px solid #888';
  previewLabel.style.borderTop = feBorder.top ? borderStyle : noBorder;
  previewLabel.style.borderBottom = feBorder.bottom ? borderStyle : noBorder;
  previewLabel.style.borderLeft = feBorder.left ? borderStyle : noBorder;
  previewLabel.style.borderRight = feBorder.right ? borderStyle : noBorder;
  
  // Set vertical alignment
  if (feAlignV === 'top') {
    previewLabel.style.justifyContent = 'flex-start';
  } else if (feAlignV === 'bottom') {
    previewLabel.style.justifyContent = 'flex-end';
  } else if (feAlignV === 'spread') {
    previewLabel.style.justifyContent = 'space-between';
  } else {
    previewLabel.style.justifyContent = 'center';
  }
  
  // Build preview HTML
  let html = '';
  
  // Add graphics wrapper if needed
  const hasGraphics = feGraphics.left || feGraphics.right;
  if (hasGraphics) {
    html += '<div style="display:flex;align-items:center;width:100%;height:100%;">';
    
    // Left graphic
    if (feGraphics.left) {
      const size = feGraphics.left.size === 'S' ? 24 : feGraphics.left.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-right:6px;"><img src="${feGraphics.left.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '<div style="flex:1;min-width:0;">';
  }
  
  // Render lines
  for (const line of feLines) {
    if (!line.text.trim()) continue;
    
    const style = buildLineStyleStr(line);
    const align = line.align === 'center' ? 'center' : line.align === 'right' ? 'right' : 'left';
    const parsed = parseLine(line.text);
    
    if (parsed.type === 'split') {
      html += `<div class="preview-line" style="display:flex;justify-content:space-between;${style}"><span>${escapeHtml(parsed.left)}</span><span>${escapeHtml(parsed.right)}</span></div>`;
    } else if (parsed.type === 'fill') {
      html += `<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;${style}"><span>${escapeHtml(parsed.label)}</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>${parsed.trailing ? '<span>' + escapeHtml(parsed.trailing) + '</span>' : ''}</div>`;
    } else {
      html += `<div class="preview-line align-${align}" style="${style}">${escapeHtml(parsed.text)}</div>`;
    }
  }
  
  if (hasGraphics) {
    html += '</div>';
    
    // Right graphic
    if (feGraphics.right) {
      const size = feGraphics.right.size === 'S' ? 24 : feGraphics.right.size === 'L' ? 48 : 36;
      html += `<div style="flex-shrink:0;margin-left:6px;"><img src="${feGraphics.right.data}" style="width:${size}px;height:${size}px;object-fit:contain;"></div>`;
    }
    
    html += '</div>';
  }
  
  previewLabel.innerHTML = html;
  
  // Update dimensions text
  document.getElementById('fePreviewDimensions').textContent = `Avery ${labelType} Â· ${spec.sizeDisplay}`;
}

// Save
function saveFromFullEditor() {
  // Get lines from state
  const lines = feLines.filter(l => l.text.trim());
  
  if (lines.length === 0) {
    showToast('Enter some text first', 'warning');
    return;
  }
  
  // Serialize lines
  const serialized = serializeLines(feLines.filter(l => l.text.trim()));
  
  // Check if any border is enabled
  const hasBorder = feBorder.top || feBorder.bottom || feBorder.left || feBorder.right;
  
  if (feEditingId) {
    // Update existing
    const text = getSavedText(feEditingId);
    if (text) {
      // Update name if changed
      const newName = document.getElementById('feNameEdit').value.trim();
      if (newName) {
        text.name = newName;
      }
      
      text.text = serialized;
      text.alignV = feAlignV;
      text.graphics = feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined;
      text.border = hasBorder ? { ...feBorder } : undefined;
      saveSavedTexts();
      showToast('Saved changes', 'success');
      renderCurrentTab();
    }
  } else {
    // Create new
    const name = document.getElementById('feName').value.trim();
    if (!name) {
      document.getElementById('feName').style.borderColor = 'var(--error-border)';
      document.getElementById('feName').focus();
      return;
    }
    
    const newText = {
      id: generateId('st'),
      name: name,
      text: serialized,
      isTemplate: feIsTemplate,
      alignV: feAlignV,
      graphics: feGraphics.left || feGraphics.right ? { ...feGraphics } : undefined,
      border: hasBorder ? { ...feBorder } : undefined,
      tokens: feIsTemplate ? extractTokens(serialized) : []
    };
    
    savedTexts.push(newText);
    saveSavedTexts();
    showToast('Created "' + name + '"', 'success');
    renderCurrentTab();
  }
  
  // Reset dirty state before closing
  feDirty = false;
  feOriginalState = null;
  
  closeFullEditor();
}

// Close popover on click outside
document.addEventListener('click', function(e) {
  if (feActiveStylePopover && !e.target.closest('.fe-style-popover') && !e.target.closest('.fe-style-btn')) {
    closeFeStylePopovers();
  }
});

// Open full editor from wizard (transfers current wizard content)
function openFullEditorFromWizard() {
  // Close wizard
  closeWizard('printWizard');
  
  // Mark that we came from wizard
  feOpenedFromWizard = true;
  
  // Open full editor with empty state (new text)
  openFullEditor(null, false);
  
  // Transfer any text from wizard inputs
  for (let i = 1; i <= 4; i++) {
    const wizInput = document.getElementById('wizLine' + i);
    const feInput = document.getElementById('feLine' + i);
    if (wizInput && feInput && wizInput.value) {
      feInput.value = wizInput.value;
      feLines[i - 1].text = wizInput.value;
      feLines[i - 1].align = wizardLines[i - 1]?.align || 'left';
      feLines[i - 1].fontSize = wizardLines[i - 1]?.fontSize || 11;
    }
  }
  
  updateFullEditorPreview();
  showToast('Switched to full editor. Use "Back to Wizard" when done.', 'info');
}

// ========== TAB NAVIGATION ==========
function switchTab(tabId) {
  currentTab = tabId;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabId);
  });
  
  // Handle workflows tab (workflow hub) vs other tabs (panels)
  const workflowHub = document.getElementById('workflowHub');
  if (tabId === 'workflows') {
    workflowHub.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.remove('active');
    });
  } else {
    workflowHub.classList.remove('active');
    document.querySelectorAll('.tab-panel').forEach(panel => {
      panel.classList.toggle('active', panel.id === 'panel-' + tabId);
    });
    renderCurrentTab();
  }
}

function goToTab(tabId) {
  switchTab(tabId);
}

// Navigate to Sheets tab and expand a specific sheet card
function navigateToSheet(sheetId) {
  switchTab('sheets');
  // Give DOM time to render, then scroll to and highlight the sheet
  setTimeout(() => {
    const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + sheetId + '"]');
    if (sheetCard) {
      sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Add highlight animation
      sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
      setTimeout(() => {
        sheetCard.style.boxShadow = '';
      }, 2000);
    }
  }, 100);
}

function renderCurrentTab() {
  // Placeholder â€” each tab will have its own render function
  const stats = getDataStats();
  
  switch(currentTab) {
    case 'sheets':
      renderSheetsTab(stats);
      break;
    case 'saved':
      renderSavedTab(stats);
      break;
    case 'templates':
      renderTemplatesTab(stats);
      break;
    case 'inventory':
      renderInventoryTab(stats);
      break;
    case 'history':
      renderHistoryTab(stats);
      break;
  }
}

// Placeholder render functions â€” will be expanded in future sessions
function renderSheetsTab(stats) {
  const panel = document.getElementById('panel-sheets');
  const sheetList = Object.values(sheets).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
  
  // Separate job sheets from regular sheets
  const regularSheets = sheetList.filter(s => !s.jobId);
  const jobSheets = sheetList.filter(s => s.jobId && activeJob && s.jobId === activeJob.id);
  
  let html = '';
  
  // Job banner if active job exists
  if (activeJob) {
    const totalRows = activeJob.list.length;
    const printedRows = activeJob.printedRowIndices.length;
    const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;
    let sheetsComplete = 0;
    activeJob.sheetIds.forEach(shId => {
      const sh = sheets[shId];
      if (!sh) return;
      const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
      const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
      if (printedOnSheet >= rowsOnSheet) sheetsComplete++;
    });
    
    html += '<div class="job-banner">' +
      '<div class="job-banner-header">' +
        '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
        '<div class="job-banner-actions">' +
          '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
          '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
        '</div>' +
      '</div>' +
      '<div class="job-banner-progress">' +
        '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
        '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
      '</div>' +
      '<div class="job-banner-info">' +
        '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
        '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
      '</div>' +
    '</div>';
  }
  
  html += '<div class="tab-header">' +
    '<div class="tab-title">Sheets (' + sheetList.length + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openNewSheetModal()">+ New Sheet</button>' +
    '</div>' +
  '</div>';
  
  if (sheetList.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“„</div><div class="panel-placeholder-text">No sheets yet. Create one to start tracking labels.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const sh of sheetList) {
    const spec = LABEL_TYPES[sh.labelType];
    const lps = spec.cols * spec.rows;
    const total = getPoolSize(sh);
    const printed = getPrintedCount(sh);
    const remaining = total - printed;
    const isActive = sh.id === activeSheetId;
    const sheetCount = sh.sheetCount || 1;
    
    // Get assignments for color-coded grid
    const { assignments, errors } = buildAssignments(sh);
    
    // Build index map for quick lookup: index -> { textId, colorIdx }
    const indexMap = {};
    const textIds = sh.texts ? Object.keys(sh.texts) : [];
    textIds.forEach((textId, colorIdx) => {
      const indices = assignments[textId] || [];
      indices.forEach(idx => { 
        indexMap[idx] = { textId, colorIdx: colorIdx % 8 }; 
      });
    });
    
    // Build grid(s) - show multiple grids for pooled sheets
    let gridHtml = '';
    const printedSet = new Set(sh.printed || []);
    
    if (sheetCount <= 3) {
      // Show all grids side by side
      gridHtml = '<div class="sheet-grids-container">';
      for (let p = 0; p < sheetCount; p++) {
        gridHtml += '<div class="sheet-grid-wrapper">';
        if (sheetCount > 1) {
          gridHtml += '<div class="sheet-grid-label">Sheet ' + (p + 1) + '</div>';
        }
        gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
        for (let i = 0; i < lps; i++) {
          const poolIdx = p * lps + i;
          let cellClass = '';
          let cellAttrs = '';
          if (printedSet.has(poolIdx)) {
            cellClass = 'printed clickable';
            cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="Click to mark as available"';
          } else if (indexMap[poolIdx]) {
            cellClass = 'cell-color-' + indexMap[poolIdx].colorIdx;
          }
          gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
        }
        gridHtml += '</div></div>';
      }
      gridHtml += '</div>';
    } else {
      // Show first grid with page controls
      const currentPage = sheetGridPages[sh.id] || 0;
      gridHtml = '<div class="sheet-grids-container">';
      gridHtml += '<div class="sheet-grid-wrapper">';
      gridHtml += '<div class="sheet-grid-label">Sheet ' + (currentPage + 1) + ' of ' + sheetCount + '</div>';
      gridHtml += '<div class="sheet-grid" style="grid-template-columns: repeat(' + spec.cols + ', 1fr); max-width: ' + (spec.cols * 12) + 'px;">';
      for (let i = 0; i < lps; i++) {
        const poolIdx = currentPage * lps + i;
        let cellClass = '';
        let cellAttrs = '';
        if (printedSet.has(poolIdx)) {
          cellClass = 'printed clickable';
          cellAttrs = ' onclick="event.stopPropagation(); toggleCellPrinted(\'' + sh.id + '\', ' + poolIdx + ')" title="Click to mark as available"';
        } else if (indexMap[poolIdx]) {
          cellClass = 'cell-color-' + indexMap[poolIdx].colorIdx;
        }
        gridHtml += '<div class="sheet-grid-cell ' + cellClass + '"' + cellAttrs + '></div>';
      }
      gridHtml += '</div>';
      gridHtml += '<div class="sheet-grid-pagination">' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', -1)"' + (currentPage === 0 ? ' disabled' : '') + '>â†</button>' +
        '<span class="sheet-grid-page-info">' + (currentPage + 1) + ' / ' + sheetCount + '</span>' +
        '<button class="sheet-grid-page-btn" onclick="event.stopPropagation(); changeSheetPage(\'' + sh.id + '\', 1)"' + (currentPage >= sheetCount - 1 ? ' disabled' : '') + '>â†’</button>' +
      '</div>';
      gridHtml += '</div></div>';
    }
    
    // Build assigned texts section (only for active sheet)
    let assignedHtml = '';
    let printActionsHtml = '';
    if (isActive) {
      assignedHtml = buildAssignedTextsHtml(sh, assignments, errors);
      printActionsHtml = buildPrintActionsHtml(sh, assignments, errors);
    }
    
    // Build note display if present
    const noteHtml = sh.note ? '<div class="sheet-note-display">' + escapeHtml(sh.note) + '</div>' : '';
    
    html += '<div class="sheet-card' + (isActive ? ' active' : '') + '" data-sheet-id="' + sh.id + '" onclick="selectSheet(\'' + sh.id + '\')">' +
      '<div class="sheet-card-header">' +
        '<div class="sheet-card-info">' +
          '<div class="sheet-card-name">' + escapeHtml(sh.name) + '</div>' +
          '<div class="sheet-card-type">' + spec.name + ' Â· ' + spec.sizeDisplay + '</div>' +
        '</div>' +
        '<div class="sheet-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); printSheetLabel(\'' + sh.id + '\')" title="Print sheet label on back">ðŸ·ï¸</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSheet(\'' + sh.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); openEditSheetModal(\'' + sh.id + '\')" title="Edit">âœï¸</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSheet(\'' + sh.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
      noteHtml +
      gridHtml +
      '<div class="sheet-stats">' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + remaining + '</span> available</div>' +
        '<div class="sheet-stat"><span class="sheet-stat-value">' + printed + '</span> printed</div>' +
        (sheetCount > 1 ? '<div class="sheet-stat"><span class="sheet-stat-value">' + sheetCount + '</span> sheets pooled</div>' : '') +
      '</div>' +
      assignedHtml +
      printActionsHtml +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

// Build HTML for assigned texts section
function buildAssignedTextsHtml(sh, assignments, errors) {
  if (!sh.texts) sh.texts = {};
  const textIds = Object.keys(sh.texts);
  const spec = LABEL_TYPES[sh.labelType];
  
  // Build error lookup
  const errorMap = {};
  if (errors) {
    errors.forEach(e => { errorMap[e.textId] = e.message; });
  }
  
  let html = '<div class="assigned-texts-section">' +
    '<div class="assigned-texts-header">' +
      '<span class="assigned-texts-title">Assigned Content</span>' +
      '<button class="btn btn-primary assigned-add-btn" onclick="event.stopPropagation(); showAddTextToSheetModal(\'' + sh.id + '\')">+ Add</button>' +
    '</div>' +
    '<div class="assigned-texts-list">';
  
  if (textIds.length === 0) {
    html += '<div class="assigned-texts-empty">No content assigned. Click "+ Add" to assign content to this sheet.</div>';
  } else {
    textIds.forEach((textId, idx) => {
      const st = getSavedText(textId);
      if (!st) return;
      
      const entry = sh.texts[textId];
      const qty = entry.qty || 0;
      const placement = entry.placement || 'next';
      const colorIdx = idx % 8;
      const assignedCount = assignments && assignments[textId] ? assignments[textId].length : 0;
      const error = errorMap[textId];
      
      // Build placement options
      let placementHtml = '<select class="assigned-text-placement" onclick="event.stopPropagation()" onchange="setTextPlacement(\'' + sh.id + '\', \'' + textId + '\', this.value)">';
      placementHtml += '<option value="next"' + (placement === 'next' ? ' selected' : '') + '>Next Avail</option>';
      for (let c = 1; c <= spec.cols; c++) {
        const val = 'col:' + c;
        placementHtml += '<option value="' + val + '"' + (placement === val ? ' selected' : '') + '>Col ' + c + '</option>';
      }
      placementHtml += '</select>';
      
      const rowClass = error ? 'assigned-text-row has-error' : 'assigned-text-row';
      
      html += '<div class="' + rowClass + '" ondblclick="event.stopPropagation(); openContentEditorFromSheet(\'' + textId + '\', \'' + sh.id + '\')">' +
        '<div class="assigned-text-color text-color-' + colorIdx + '"></div>' +
        '<div class="assigned-text-info">' +
          '<div class="assigned-text-name">' + escapeHtml(st.name) + '</div>' +
          '<div class="assigned-text-spots">' + (error ? '<span style="color:var(--error-text)">' + error + '</span>' : assignedCount + ' label' + (assignedCount !== 1 ? 's' : '')) + '</div>' +
        '</div>' +
        '<div class="assigned-text-controls" ondblclick="event.stopPropagation()">' +
          placementHtml +
          '<div class="assigned-text-qty">' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', -1)">âˆ’</button>' +
            '<span class="qty-val">' + qty + '</span>' +
            '<button class="qty-btn" onclick="event.stopPropagation(); adjustAssignedQty(\'' + sh.id + '\', \'' + textId + '\', 1)">+</button>' +
          '</div>' +
        '</div>' +
        '<button class="assigned-text-remove" onclick="event.stopPropagation(); removeTextFromSheet(\'' + sh.id + '\', \'' + textId + '\')" ondblclick="event.stopPropagation()" title="Remove">âœ•</button>' +
      '</div>';
    });
  }
  
  html += '</div></div>';
  return html;
}

// Build print actions HTML for sheet
function buildPrintActionsHtml(sh, assignments, errors) {
  // Count total labels to print
  let totalToPrint = 0;
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  textIds.forEach(textId => {
    if (assignments && assignments[textId]) {
      totalToPrint += assignments[textId].length;
    }
  });
  
  const hasErrors = errors && errors.length > 0;
  const canPrint = totalToPrint > 0 && !hasErrors;
  const printedCount = (sh.printed || []).length;
  const hasUndo = lastPrintJob && lastPrintJob.sheetId === sh.id;
  
  if (textIds.length === 0 && printedCount === 0 && !hasUndo) {
    return ''; // No print section if no content and nothing to reset/undo
  }
  
  let html = '<div class="sheet-print-actions">';
  
  // Print button (only if content is assigned)
  if (textIds.length > 0) {
    html += '<button class="sheet-print-btn" onclick="event.stopPropagation(); printFromSheet(\'' + sh.id + '\')"' + (canPrint ? '' : ' disabled') + '>ðŸ–¨ï¸ Print ' + totalToPrint + ' Label' + (totalToPrint !== 1 ? 's' : '') + '</button>';
    
    if (hasErrors) {
      html += '<span class="sheet-print-summary" style="color:var(--error-text)">Fix placement errors first</span>';
    } else if (totalToPrint === 0) {
      html += '<span class="sheet-print-summary">Set quantities to print</span>';
    }
  }
  
  // Calculate remaining for split button
  const spec = LABEL_TYPES[sh.labelType];
  const poolSize = spec.cols * spec.rows * (sh.sheetCount || 1);
  const remainingCount = poolSize - printedCount;
  const canSplit = printedCount > 0 && remainingCount > 0;
  
  // Secondary actions row (Reset, Undo, Split)
  if (printedCount > 0 || hasUndo) {
    html += '<div class="sheet-secondary-actions">';
    
    // Reset button (if there are printed positions)
    if (printedCount > 0) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); resetSheet(\'' + sh.id + '\')" title="Reset all labels to available">ðŸ”„ Reset Sheet</button>';
    }
    
    // Undo button (if last print was on this sheet)
    if (hasUndo) {
      const undoCount = lastPrintJob.indices.length;
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); undoLastPrint()" title="Undo last print">â†©ï¸ Undo (' + undoCount + ' label' + (undoCount !== 1 ? 's' : '') + ')</button>';
    }
    
    // Split button (if there are both printed and remaining positions)
    if (canSplit) {
      html += '<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); showSplitDialog(\'' + sh.id + '\')" title="Split remaining labels into new sheet">âœ‚ï¸ Split (' + remainingCount + ')</button>';
    }
    
    html += '</div>';
  }
  
  html += '</div>';
  return html;
}

// Select a sheet (make it active)
function selectSheet(sheetId) {
  if (activeSheetId === sheetId) return; // Already selected
  activeSheetId = sheetId;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Set text placement on a sheet
function setTextPlacement(sheetId, textId, value) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  sh.texts[textId].placement = value;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Adjust assigned quantity
function adjustAssignedQty(sheetId, textId, delta) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts || !sh.texts[textId]) return;
  const current = sh.texts[textId].qty || 0;
  const newQty = Math.max(0, current + delta);
  sh.texts[textId].qty = newQty;
  saveSheets();
  renderSheetsTab(getDataStats());
}

// Remove text from sheet
function removeTextFromSheet(sheetId, textId) {
  const sh = sheets[sheetId];
  if (!sh || !sh.texts) return;
  delete sh.texts[textId];
  saveSheets();
  showToast('Content removed from sheet', 'info');
  renderSheetsTab(getDataStats());
}

// Add text to sheet modal
function showAddTextToSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const texts = getTexts();
  const existingIds = new Set(Object.keys(sh.texts || {}));
  const available = texts.filter(t => !existingIds.has(t.id));
  
  if (available.length === 0) {
    showToast('No content available to add. Create new content first.', 'warning');
    return;
  }
  
  // Store sheetId for use in addTextToSheetFromPicker
  window._addTextSheetId = sheetId;
  
  // Build picker content
  const modal = document.getElementById('addTextPickerModal');
  const content = document.getElementById('addTextPickerContent');
  document.getElementById('addTextPickerTitle').textContent = 'Add to "' + sh.name + '"';
  
  let html = '';
  for (const t of available) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 40);
    html += '<div class="saved-card" style="cursor: pointer;" onclick="addTextToSheetFromPicker(\'' + t.id + '\')">' +
      '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="saved-card-preview">' + escapeHtml(preview) + '</div>' +
    '</div>';
  }
  
  content.innerHTML = html;
  modal.classList.add('visible');
}

function closeAddTextPickerModal() {
  document.getElementById('addTextPickerModal').classList.remove('visible');
  window._addTextSheetId = null;
}

// Add text to sheet from picker
function addTextToSheetFromPicker(textId) {
  const sheetId = window._addTextSheetId;
  if (!sheetId) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  if (!sh.texts) sh.texts = {};
  
  if (sh.texts[textId]) {
    showToast('Content already assigned to this sheet', 'warning');
    return;
  }
  
  sh.texts[textId] = { qty: 0, placement: 'next' }; // Default to 0, user sets qty
  saveSheets();
  closeAddTextPickerModal();
  showToast('Content added. Set quantity to see it on the grid.', 'success');
  renderSheetsTab(getDataStats());
}

// Change sheet grid page (for multi-sheet pools)
function changeSheetPage(sheetId, delta) {
  const sh = sheets[sheetId];
  if (!sh) return;
  const sheetCount = sh.sheetCount || 1;
  const current = sheetGridPages[sheetId] || 0;
  const newPage = Math.max(0, Math.min(sheetCount - 1, current + delta));
  sheetGridPages[sheetId] = newPage;
  renderSheetsTab(getDataStats());
}

// Open content editor from sheet (double-click)
function openContentEditorFromSheet(textId, sheetId) {
  const st = getSavedText(textId);
  if (!st) return;
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  // Store the source sheet so we can set the preview label type
  window._editorSourceSheetId = sheetId;
  
  // Open the full editor with this content
  openFullEditor(textId, st.type === 'template');
}

// Print from sheet - the main print flow
function printFromSheet(sheetId) {
  // Reload sheets from localStorage to ensure fresh data
  loadSheets();
  
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const { assignments, errors } = buildAssignments(sh);
  
  if (errors && errors.length > 0) {
    showToast('Fix placement errors before printing', 'error');
    return;
  }
  
  // Collect all positions and their content
  const printManifest = [];
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  
  textIds.forEach(textId => {
    const indices = assignments[textId] || [];
    const st = getSavedText(textId);
    if (!st || indices.length === 0) return;
    
    const lines = deserializeLines(st.text);
    const graphics = st.graphics || { left: null, right: null };
    const alignV = st.alignV || 'center';
    const border = st.border || null;
    
    indices.forEach(idx => {
      printManifest.push({ idx, lines, graphics, alignV, border, textId });
    });
  });
  
  if (printManifest.length === 0) {
    showToast('Nothing to print. Set quantities first.', 'warning');
    return;
  }
  
  // Sort by position
  printManifest.sort((a, b) => a.idx - b.idx);
  
  // Build print HTML
  const printHtml = buildSheetPrintHtml(sh, printManifest);
  
  // Use iframe for printing (like v1.2)
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  
  // Wait for iframe to render, then print
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  // After print dialog closes, ask user to confirm
  const totalLabels = printManifest.length;
  showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer.\n\nDid the print complete successfully?',
    'ðŸ–¨ï¸ Confirm Print',
    'Yes, printed OK',
    false,
    (confirmed) => {
      if (confirmed) {
        // Mark positions as printed
        const positionsPrinted = printManifest.map(m => m.idx);
        markPositionsPrinted(sheetId, positionsPrinted);
        
        // Store quantities before resetting (for undo)
        const prevQtys = {};
        textIds.forEach(textId => {
          if (sh.texts[textId]) {
            prevQtys[textId] = sh.texts[textId].qty || 0;
            sh.texts[textId].qty = 0;
          }
        });
        saveSheets();
        
        // Stash for undo (from v1.2)
        lastPrintJob = {
          sheetId: sheetId,
          indices: positionsPrinted,
          textQtys: prevQtys
        };
        
        // Add to print history
        // Build a name from the texts being printed
        const textNames = textIds.map(tid => {
          const t = getSavedText(tid);
          return t ? t.name : 'Unknown';
        }).join(', ');
        addPrintHistoryEntry({
          textName: textNames || 'Mixed labels',
          sheetId: sh.id,
          sheetName: sh.name,
          labelType: sh.labelType,
          count: totalLabels,
          textIds: textIds
        });
        
        // Show success and refresh
        const remaining = getRemainingCount(sh);
        if (remaining > 0) {
          showToast('Printed! ' + remaining + ' spots left on "' + sh.name + '"', 'success');
        } else {
          showToast('"' + sh.name + '" is now full. Select or create another sheet.', 'success');
        }
        renderSheetsTab(getDataStats());
      } else {
        // User cancelled - no changes
        showToast('Print cancelled â€” no labels marked as used', 'warning');
        renderSheetsTab(getDataStats());
      }
    }
  );
}

// ========== UNDO/RESET FUNCTIONS (ported from v1.2) ==========

// Undo the last print job - restores printed positions and quantities
function undoLastPrint() {
  if (!lastPrintJob) {
    showToast('Nothing to undo', 'warning');
    return;
  }
  
  const sh = sheets[lastPrintJob.sheetId];
  if (!sh) {
    lastPrintJob = null;
    showToast('Sheet no longer exists', 'error');
    return;
  }
  
  const count = lastPrintJob.indices.length;
  showConfirm(
    'Undo the last print on "' + sh.name + '"?\n\nThis will unmark ' + count + ' position' + (count !== 1 ? 's' : '') + ' as used and restore the quantities.',
    'â†©ï¸ Undo Last Print',
    'Undo',
    false,
    (confirmed) => {
      if (!confirmed) return;
      
      // Remove printed indices
      const undoSet = new Set(lastPrintJob.indices);
      sh.printed = (sh.printed || []).filter(i => !undoSet.has(i));
      
      // Restore text quantities
      if (lastPrintJob.textQtys && sh.texts) {
        for (const [textId, qty] of Object.entries(lastPrintJob.textQtys)) {
          if (sh.texts[textId]) {
            sh.texts[textId].qty = qty;
          }
        }
      }
      
      saveSheets();
      const undoneSheetId = lastPrintJob.sheetId;
      const undoneName = sh.name;
      lastPrintJob = null; // Clear undo state
      
      // Refresh view
      renderSheetsTab(getDataStats());
      showToast('Print undone â€” positions restored on "' + undoneName + '"', 'success');
    }
  );
}

// Reset all printed positions on a sheet
function resetSheet(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const printedCount = (sh.printed || []).length;
  if (printedCount === 0) {
    showToast('No used labels to reset on "' + sh.name + '"', 'warning');
    return;
  }
  
  showConfirm(
    'Reset "' + sh.name + '" to all labels available?\n\nThis will unmark ' + printedCount + ' used position' + (printedCount !== 1 ? 's' : '') + ' and set all quantities to 0.\n\nThis is useful when you replace the physical sheet with a fresh one.',
    'ðŸ”„ Reset Sheet',
    'Reset All',
    true,
    (confirmed) => {
      if (!confirmed) return;
      
      sh.printed = [];
      
      // Reset all text quantities to 0
      if (sh.texts) {
        for (const entry of Object.values(sh.texts)) {
          entry.qty = 0;
        }
      }
      
      saveSheets();
      lastPrintJob = null; // Undo no longer relevant
      
      const spec = LABEL_TYPES[sh.labelType] || LABEL_TYPES['5160'];
      const total = spec.cols * spec.rows * (sh.sheetCount || 1);
      
      renderSheetsTab(getDataStats());
      showToast('"' + sh.name + '" reset â€” all ' + total + ' labels available', 'success');
    }
  );
}

// Toggle a printed cell back to available (click on printed cell)
function toggleCellPrinted(sheetId, idx) {
  const sh = sheets[sheetId];
  if (!sh || !sh.printed) return;
  
  const pos = sh.printed.indexOf(idx);
  if (pos === -1) return; // Not printed, nothing to do
  
  // Remove from printed array
  sh.printed.splice(pos, 1);
  saveSheets();
  
  renderSheetsTab(getDataStats());
  showToast('Position marked as available', 'success');
}

// ========== SPLIT REMAINING LABELS (ported from v1.2) ==========

// Show the split remaining labels dialog
function showSplitDialog(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  // Count open positions and physical sheets with open spots
  let openCount = 0;
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    let sheetOpen = 0;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (!printed.has(i)) sheetOpen++;
    }
    if (sheetOpen > 0) {
      sheetsWithOpen.push({ physicalSheet: p, open: sheetOpen });
      openCount += sheetOpen;
    }
  }
  
  if (openCount === 0) {
    showToast('No remaining labels to split', 'warning');
    return;
  }
  
  document.getElementById('splitSummary').textContent = openCount + ' open label' + (openCount !== 1 ? 's' : '') + ' across ' + sheetsWithOpen.length + ' physical sheet' + (sheetsWithOpen.length !== 1 ? 's' : '');
  
  // Default name suggestion
  const specName = spec.name.split(' /')[0];
  document.getElementById('splitName').value = 'Leftover ' + specName + ' - ' + new Date().toLocaleDateString('en-US', { month: 'short' });
  
  // If only one physical sheet with open spots, hide split/together choice
  const splitModeGroup = document.getElementById('splitModeGroup');
  if (sheetsWithOpen.length <= 1) {
    splitModeGroup.style.display = 'none';
  } else {
    splitModeGroup.style.display = '';
  }
  
  // Store current sheet ID for execute
  document.getElementById('splitModal').dataset.sheetId = sheetId;
  
  document.getElementById('splitModal').classList.add('visible');
  document.getElementById('splitName').focus();
}

// Execute the split operation
function executeSplit() {
  const sheetId = document.getElementById('splitModal').dataset.sheetId;
  const sh = sheets[sheetId];
  if (!sh) {
    closeSimpleModal('splitModal');
    return;
  }
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const count = sh.sheetCount || 1;
  const printed = new Set(sh.printed || []);
  
  const name = document.getElementById('splitName').value.trim();
  if (!name) {
    document.getElementById('splitName').style.borderColor = 'var(--danger)';
    return;
  }
  
  const splitMode = document.querySelector('input[name="splitMode"]:checked').value;
  const textMode = document.querySelector('input[name="splitTexts"]:checked').value;
  
  // Identify physical sheets with open positions
  const sheetsWithOpen = [];
  for (let p = 0; p < count; p++) {
    const localPrinted = [];
    let hasOpen = false;
    for (let i = p * lps; i < (p + 1) * lps; i++) {
      if (printed.has(i)) {
        localPrinted.push(i % lps); // remap to local index
      } else {
        hasOpen = true;
      }
    }
    if (hasOpen) {
      sheetsWithOpen.push({ physicalSheet: p, localPrinted });
    }
  }
  
  if (sheetsWithOpen.length === 0) {
    closeSimpleModal('splitModal');
    return;
  }
  
  // Build text associations if keeping
  const textsToCarry = {};
  if (textMode === 'keep' && sh.texts) {
    for (const [textId, entry] of Object.entries(sh.texts)) {
      textsToCarry[textId] = { qty: 0, placement: entry.placement || 'next' };
    }
  }
  
  if (splitMode === 'separate' && sheetsWithOpen.length > 1) {
    // Create one new sheet per physical sheet with open spots
    sheetsWithOpen.forEach((info, idx) => {
      const newId = generateId('sheet');
      const suffix = sheetsWithOpen.length > 1 ? ' #' + (idx + 1) : '';
      sheets[newId] = {
        id: newId,
        name: name + suffix,
        printed: [...info.localPrinted],
        labelType: sh.labelType,
        sheetCount: 1,
        texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
        createdAt: Date.now() + idx
      };
    });
  } else {
    // Keep together as one pool
    const newId = generateId('sheet');
    const newCount = sheetsWithOpen.length;
    // Remap printed positions to new contiguous pool
    const newPrinted = [];
    sheetsWithOpen.forEach((info, newPage) => {
      info.localPrinted.forEach(localIdx => {
        newPrinted.push(newPage * lps + localIdx);
      });
    });
    sheets[newId] = {
      id: newId,
      name: name,
      printed: newPrinted,
      labelType: sh.labelType,
      sheetCount: newCount,
      texts: textMode === 'keep' ? JSON.parse(JSON.stringify(textsToCarry)) : {},
      createdAt: Date.now()
    };
  }
  
  // Reduce original sheet or delete it entirely
  const fullyConsumed = count - sheetsWithOpen.length;
  if (fullyConsumed === 0) {
    // All physical sheets had open positions â€” original is now empty, delete it
    delete sheets[sheetId];
    // Switch active sheet to the first newly created one
    const newIds = Object.keys(sheets).filter(id => sheets[id].createdAt >= Date.now() - 1000);
    activeSheetId = newIds.length > 0 ? newIds[0] : Object.keys(sheets)[0] || null;
  } else if (fullyConsumed > 0 && fullyConsumed < count) {
    // Keep only the consumed physical sheets in the original
    sh.sheetCount = fullyConsumed;
    // Remove printed indices that belong to split-off sheets
    const keepRange = fullyConsumed * lps;
    sh.printed = sh.printed.filter(i => i < keepRange);
  }
  
  saveSheets();
  closeSimpleModal('splitModal');
  
  renderSheetsTab(getDataStats());
  showToast('Split remaining labels into new sheet' + (splitMode === 'separate' && sheetsWithOpen.length > 1 ? 's' : ''), 'success');
}

// ========== CLIPBOARD IMPORT (ported from v1.2) ==========

let importRows = [];           // Raw clipboard rows
let importIsTabular = false;   // Tabular mode (tabs + newlines)
let importLinesPerLabel = 1;   // Plain list: lines per label
let importColMap = [];         // Tabular: column â†’ line mapping
let importTemplateTokenMap = []; // Per-column: token name (string) or null (skip)

// Paste data handler - detects images (routes to OCR) or text (opens import modal)
async function pasteData() {
  // Check for clipboard image first â€” route to OCR if found
  try {
    if (navigator.clipboard.read) {
      const clipItems = await navigator.clipboard.read();
      for (const item of clipItems) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            openOcrModal();
            processOcrImage(blob);
            return;
          }
        }
      }
    }
  } catch (e) {
    // Clipboard.read() may fail or not be supported â€” fall through to text paste
  }
  
  // Read clipboard text
  let clipText;
  try {
    clipText = await navigator.clipboard.readText();
  } catch (err) {
    showToast('Unable to read clipboard â€” check browser permissions', 'warning');
    return;
  }
  
  if (!clipText || !clipText.trim()) {
    showToast('Nothing in clipboard', 'warning');
    return;
  }
  
  // Parse clipboard text into rows
  const trimmed = clipText.trim();
  const isTabular = trimmed.includes('\t') && trimmed.includes('\n');
  let rows;
  
  if (trimmed.includes('\n')) {
    rows = trimmed.split(/\r?\n/).map(r => r.trim()).filter(r => r.length > 0);
  } else if (trimmed.includes('\t')) {
    rows = trimmed.split('\t').map(r => r.trim()).filter(r => r.length > 0);
  } else {
    rows = [trimmed];
  }
  
  if (!rows.length) {
    showToast('Unable to process clipboard data', 'warning');
    return;
  }
  
  // If >4 rows or tabular data with multiple rows, open import modal
  if (rows.length > 4 || (isTabular && rows.length > 1)) {
    showImportModal(rows, isTabular);
    return;
  }
  
  // â‰¤4 plain rows: show quick import (create single text from clipboard)
  showQuickImportModal(rows);
}

// Show quick import for small clipboard data (1-4 lines)
function showQuickImportModal(rows) {
  const maxLines = Math.min(rows.length, 4);
  const lines = [];
  for (let i = 0; i < maxLines; i++) {
    lines.push({ text: rows[i], align: 'left', fontSize: 11 });
  }
  
  // Create temporary text for preview
  const previewHtml = renderMiniPreview(lines, false, null);
  
  showConfirm(
    'Import ' + maxLines + ' line' + (maxLines !== 1 ? 's' : '') + ' from clipboard?\n\nPreview:\n' + rows.slice(0, maxLines).join('\n'),
    'ðŸ“‹ Import from Clipboard',
    'Import as New Content',
    false,
    (confirmed) => {
      if (confirmed) {
        // Create new saved text
        const newText = {
          id: generateId('text'),
          name: 'Imported ' + new Date().toLocaleTimeString(),
          text: serializeLines(lines),
          alignV: 'center',
          type: 'text',
          graphics: null,
          createdAt: Date.now()
        };
        savedTexts.push(newText);
        saveTexts();
        showToast('Created "' + newText.name + '" from clipboard', 'success');
        renderSavedTab(getDataStats());
      }
    }
  );
}

// Show full import modal for larger datasets
function showImportModal(rows, isTabular) {
  importRows = rows;
  importIsTabular = isTabular;
  importLinesPerLabel = 1;
  importColMap = [];
  importTemplateTokenMap = [];
  
  // Populate template dropdown
  const tplSelect = document.getElementById('importTemplateSelect');
  let tplOpts = '<option value="">No Template (manual)</option>';
  const templates = getTemplates();
  templates.forEach(t => {
    tplOpts += '<option value="' + t.id + '">' + escapeHtml(t.name) + '</option>';
  });
  tplSelect.innerHTML = tplOpts;
  
  if (isTabular) {
    const parsed = rows.map(r => r.split('\t').map(c => c.trim()));
    const colCount = Math.max(...parsed.map(r => r.length));
    importColMap = new Array(colCount).fill(0);
    
    document.getElementById('importSummary').textContent = parsed.length + ' rows Ã— ' + colCount + ' columns detected';
    document.getElementById('importPlainControls').style.display = 'none';
    document.getElementById('importTabularControls').style.display = '';
    buildImportColMappingUI();
  } else {
    document.getElementById('importSummary').textContent = rows.length + ' lines detected from clipboard';
    document.getElementById('importPlainControls').style.display = '';
    document.getElementById('importTabularControls').style.display = 'none';
    document.getElementById('linesPerLabelVal').textContent = '1';
  }
  
  // Populate sheet dropdown
  const sheetSelect = document.getElementById('importSheetAssign');
  let sheetOpts = '<option value="">â€” Don\'t assign â€”</option>';
  for (const [id, sh] of Object.entries(sheets)) {
    const spec = LABEL_TYPES[sh.labelType];
    const pool = spec.cols * spec.rows * (sh.sheetCount || 1);
    const used = (sh.printed || []).length;
    const assigned = Object.values(sh.texts || {}).reduce((s, t) => s + (t.qty || 0), 0);
    const avail = pool - used - assigned;
    sheetOpts += '<option value="' + id + '">' + escapeHtml(sh.name) + ' (' + avail + ' spots)</option>';
  }
  sheetSelect.innerHTML = sheetOpts;
  if (activeSheetId && sheets[activeSheetId]) sheetSelect.value = activeSheetId;
  
  document.getElementById('importBaseName').value = '';
  updateImportPreview();
  
  document.getElementById('importTextModal').classList.add('visible');
  document.getElementById('importBaseName').focus();
}

// Build column mapping UI for tabular data
function buildImportColMappingUI() {
  if (!importIsTabular) return;
  const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
  const colCount = Math.max(...parsed.map(r => r.length));
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  let mapHtml = '';
  if (tpl && tpl.tokens && tpl.tokens.length) {
    // Template mode: map columns to tokens
    document.getElementById('importColMappingTitle').textContent = 'Map columns to template tokens:';
    const headers = parsed.length > 0 ? parsed[0] : [];
    const autoMap = autoMapColumns(headers.map(h => h || ''), tpl.tokens);
    importTemplateTokenMap = [];
    
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      const autoToken = autoMap[c] || null;
      importTemplateTokenMap.push(autoToken);
      
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportTokenMap(' + c + ', this.value)">';
      mapHtml += '<option value="">Skip</option>';
      tpl.tokens.forEach(t => {
        mapHtml += '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>';
      });
      mapHtml += '</select></div>';
    }
  } else {
    // Manual mode: map columns to line numbers
    document.getElementById('importColMappingTitle').textContent = 'Map columns to label lines:';
    for (let c = 0; c < colCount; c++) {
      const sample = parsed.find(r => r[c] && r[c].length > 0);
      const sampleText = sample ? sample[c] : '(empty)';
      mapHtml += '<div class="import-col-row">';
      mapHtml += '<span style="font-size:12px;font-weight:700;color:var(--text-secondary);min-width:50px">Col ' + (c + 1) + '</span>';
      mapHtml += '<span class="col-sample" title="' + escapeAttr(sampleText) + '">' + escapeHtml(sampleText) + '</span>';
      mapHtml += '<select onchange="updateImportColMap(' + c + ', this.value)">';
      mapHtml += '<option value="0"' + (importColMap[c] === 0 ? ' selected' : '') + '>Skip</option>';
      for (let ln = 1; ln <= 4; ln++) {
        mapHtml += '<option value="' + ln + '"' + (importColMap[c] === ln ? ' selected' : '') + '>â†’ Line ' + ln + '</option>';
      }
      mapHtml += '</select></div>';
    }
  }
  document.getElementById('importColMapping').innerHTML = mapHtml;
}

function onImportTemplateChange() {
  if (importIsTabular) {
    buildImportColMappingUI();
  }
  updateImportPreview();
}

function updateImportTokenMap(colIdx, tokenName) {
  importTemplateTokenMap[colIdx] = tokenName || null;
  updateImportPreview();
}

function stepLinesPerLabel(delta) {
  importLinesPerLabel = Math.max(1, Math.min(4, importLinesPerLabel + delta));
  document.getElementById('linesPerLabelVal').textContent = importLinesPerLabel;
  updateImportPreview();
}

function updateImportColMap(colIdx, val) {
  importColMap[colIdx] = parseInt(val);
  updateImportPreview();
}

// Generate preview records from import data
function getImportRecords() {
  const tplId = document.getElementById('importTemplateSelect').value;
  const tpl = tplId ? (getBuiltinTemplate(tplId) || savedTexts.find(s => s.id === tplId)) : null;
  
  const records = [];
  
  if (importIsTabular) {
    const parsed = importRows.map(r => r.split('\t').map(c => c.trim()));
    
    if (tpl && tpl.tokens && tpl.tokens.length) {
      // Template mode: generate records by filling tokens
      parsed.forEach(row => {
        const tokenValues = {};
        importTemplateTokenMap.forEach((token, colIdx) => {
          if (token && row[colIdx]) {
            tokenValues[token] = row[colIdx];
          }
        });
        if (Object.keys(tokenValues).length > 0) {
          // Apply template
          const filledLines = applyTemplateTokens(tpl, tokenValues);
          records.push({ lines: filledLines, alignV: tpl.alignV || 'center' });
        }
      });
    } else {
      // Manual mode: map columns to lines
      parsed.forEach(row => {
        const lines = [];
        importColMap.forEach((lineNum, colIdx) => {
          if (lineNum > 0 && row[colIdx]) {
            while (lines.length < lineNum) {
              lines.push({ text: '', align: 'left', fontSize: 11 });
            }
            lines[lineNum - 1] = { text: row[colIdx], align: 'left', fontSize: 11 };
          }
        });
        if (lines.some(l => l.text)) {
          records.push({ lines, alignV: 'center' });
        }
      });
    }
  } else {
    // Plain list mode: group by lines per label
    for (let i = 0; i < importRows.length; i += importLinesPerLabel) {
      const lines = [];
      for (let j = 0; j < importLinesPerLabel && i + j < importRows.length; j++) {
        lines.push({ text: importRows[i + j], align: 'left', fontSize: 11 });
      }
      records.push({ lines, alignV: 'center' });
    }
  }
  
  return records;
}

// Apply template tokens to generate lines
function applyTemplateTokens(tpl, tokenValues) {
  const sourceLines = deserializeLines(tpl.text);
  return sourceLines.map(line => {
    let text = line.text;
    for (const [token, value] of Object.entries(tokenValues)) {
      text = text.replace(new RegExp('\\{' + token + '\\}', 'g'), value);
    }
    // Remove any unfilled tokens
    text = text.replace(/\{[^}]+\}/g, '').trim();
    return { ...line, text };
  });
}

function updateImportPreview() {
  const records = getImportRecords();
  const previewArea = document.getElementById('importPreviewArea');
  
  if (records.length === 0) {
    previewArea.innerHTML = '<span style="color:var(--text-muted)">No records to preview</span>';
    document.getElementById('importRecordCount').textContent = '';
    return;
  }
  
  // Show first 3 records
  let html = '';
  for (let i = 0; i < Math.min(3, records.length); i++) {
    html += '<div class="import-preview-label">';
    records[i].lines.forEach(line => {
      if (line.text) {
        html += '<div style="text-align:' + line.align + '">' + escapeHtml(line.text) + '</div>';
      }
    });
    html += '</div>';
  }
  if (records.length > 3) {
    html += '<div style="display:flex;align-items:center;color:var(--text-muted);font-size:12px">+' + (records.length - 3) + ' more</div>';
  }
  previewArea.innerHTML = html;
  
  document.getElementById('importRecordCount').textContent = records.length + ' record' + (records.length !== 1 ? 's' : '');
  
  // Update name preview
  const baseName = document.getElementById('importBaseName').value.trim() || 'Text';
  document.getElementById('importNamePreview').textContent = 'Will create: "' + baseName + ' 1", "' + baseName + ' 2", etc.';
}

// Execute import - create saved texts from parsed data
function executeImport() {
  const records = getImportRecords();
  if (!records.length) {
    closeModal('importTextModal');
    return;
  }
  
  const baseName = document.getElementById('importBaseName').value.trim() || 'Imported';
  const sheetId = document.getElementById('importSheetAssign').value;
  
  // Create saved texts
  const newIds = [];
  records.forEach((rec, idx) => {
    const newText = {
      id: generateId('text'),
      name: baseName + ' ' + (idx + 1),
      text: serializeLines(rec.lines),
      alignV: rec.alignV || 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now() + idx
    };
    savedTexts.push(newText);
    newIds.push(newText.id);
  });
  saveTexts();
  
  // Assign to sheet if selected
  if (sheetId && sheets[sheetId]) {
    const sh = sheets[sheetId];
    if (!sh.texts) sh.texts = {};
    newIds.forEach(id => {
      sh.texts[id] = { qty: 1, placement: 'next' };
    });
    saveSheets();
  }
  
  closeModal('importTextModal');
  
  showToast('Imported ' + records.length + ' text' + (records.length !== 1 ? 's' : ''), 'success');
  
  // Refresh tabs
  renderSavedTab(getDataStats());
  if (sheetId) {
    renderSheetsTab(getDataStats());
  }
}

// Build print HTML for sheet-based printing
function buildSheetPrintHtml(sh, manifest) {
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  const isTentCard = spec.category === 'tent';
  
  // Safari fix: use a wrapper with explicit scaled height
  const safariScale = 1.0;
  
  // Build CSS
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0; }';
  html += 'html, body { margin: 0; padding: 0; }';
  if (isSafari) {
    // Wrapper takes up scaled space (10in), content inside is scaled
    html += '.print-wrapper { width: 8.5in; height: 11in; overflow: hidden; }';
    html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; transform: scale(' + safariScale + '); transform-origin: top left; }';
  } else {
    html += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; }';
  }
  // Label boundary overlay for alignment debugging
  html += '.label-boundary { position:absolute; border: 1px solid #ccc; box-sizing: border-box; pointer-events: none; }';
  html += '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }';
  html += '.print-label-gfx { flex-direction:row; align-items:stretch; }';
  html += '.print-graphic { flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden; }';
  html += '.print-graphic img { max-width:100%; max-height:100%; object-fit:contain; }';
  html += '.print-text-zone { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }';
  html += '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }';
  html += '.print-line.align-left { justify-content:flex-start; text-align:left; }';
  html += '.print-line.align-center { justify-content:center; text-align:center; }';
  html += '.print-line.align-right { justify-content:flex-end; text-align:right; }';
  html += '.print-line.align-split { justify-content:space-between; text-align:left; }';
  html += '.print-line.align-split > span { min-width:0; overflow:hidden; text-overflow:ellipsis; }';
  html += '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }';
  html += '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }';
  html += '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }';
  // Tent card fold line styling
  if (isTentCard) {
    html += '.print-label.tent-card { position:relative; padding:0; }';
    html += '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #ccc; z-index:1; }';
    html += '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }';
    html += '.tent-top { top:0; height:50%; }';
    html += '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }';
  }
  html += '</style></head><body>';
  
  // Group manifest by physical page
  const pages = {};
  manifest.forEach(item => {
    const pageNum = Math.floor(item.idx / lps);
    if (!pages[pageNum]) pages[pageNum] = [];
    pages[pageNum].push(item);
  });
  
  // Helper to get flex alignment string
  function getFlexAlign(alignV) {
    if (alignV === 'top') return 'flex-start';
    if (alignV === 'bottom') return 'flex-end';
    if (alignV === 'spread') return 'space-between';
    return 'center';
  }
  
  // Render each page
  Object.keys(pages).sort((a, b) => parseInt(a) - parseInt(b)).forEach((pageNum, pi, arr) => {
    const breakStyle = pi < arr.length - 1 ? 'page-break-after:always;' : '';
    // Safari needs wrapper div to constrain the scaled content
    if (isSafari) {
      html += '<div class="print-wrapper" style="' + breakStyle + '"><div class="print-sheet">';
    } else {
      html += '<div class="print-sheet" style="' + breakStyle + '">';
    }
    
    // Get manual print offsets from settings only
    const offsetTop = settings.printOffsetTop || 0;
    const offsetLeft = settings.printOffsetLeft || 0;
    
    // Add label boundary overlays for ALL positions (for alignment debugging)
    for (let r = 0; r < spec.rows; r++) {
      for (let c = 0; c < spec.cols; c++) {
        const bTop = spec.topMargin + r * (spec.labelH + spec.vGutter) + offsetTop;
        const bLeft = spec.leftMargin + c * (spec.labelW + spec.hGutter) + offsetLeft;
        html += '<div class="label-boundary" style="top:' + bTop + 'in;left:' + bLeft + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;"></div>';
      }
    }
    
    pages[pageNum].forEach(item => {
      const localIdx = item.idx % lps;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;
      
      const top = spec.topMargin + row * (spec.labelH + spec.vGutter) + offsetTop;
      const left = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
      
      // Use renderPrintLineHtml for each line (same as v1.2)
      const linesHtml = item.lines.map(l => renderPrintLineHtml(l)).join('');
      const gfx = item.graphics;
      const hasGfx = gfx && (gfx.left || gfx.right);
      
      if (isTentCard) {
        // Tent card rendering
        html += '<div class="print-label tent-card" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;">';
        html += '<div class="fold-line"></div>';
        html += '<div class="tent-top"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '<div class="tent-bottom"><div class="print-text-zone">' + linesHtml + '</div></div>';
        html += '</div>';
      } else if (hasGfx) {
        // Graphics layout (same as v1.2)
        const usableW = spec.labelW - 0.24;
        let innerHtml = '';
        if (gfx.left && gfx.left.data) {
          const leftW = (usableW * (gfx.left.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + leftW + 'in;"><img src="' + gfx.left.data + '"></div>';
        }
        innerHtml += '<div class="print-text-zone" style="justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
        if (gfx.right && gfx.right.data) {
          const rightW = (usableW * (gfx.right.widthPct || 20) / 100).toFixed(3);
          innerHtml += '<div class="print-graphic" style="width:' + rightW + 'in;"><img src="' + gfx.right.data + '"></div>';
        }
        html += '<div class="print-label print-label-gfx" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;">' + innerHtml + '</div>';
      } else {
        // Standard label (same as v1.2)
        html += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;justify-content:' + getFlexAlign(item.alignV) + ';">' + linesHtml + '</div>';
      }
    });
    
    // Close print-sheet (and wrapper for Safari)
    html += '</div>';
    if (isSafari) {
      html += '</div>';
    }
  });
  
  html += '</body></html>';
  return html;
}

function renderSavedTab(stats) {
  const panel = document.getElementById('panel-saved');
  const texts = getTexts();
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Content (' + texts.length + ')</div>' +
    '<div class="tab-actions">' +
      '<button class="tab-action-btn" onclick="openFullEditor(null, false)">+ New</button>' +
    '</div>' +
  '</div>';
  
  if (texts.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ’¾</div><div class="panel-placeholder-text">No saved content yet. Create one or save text from the Print workflow.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const t of texts) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 60);
    
    // Find sheets this content is assigned to
    const assignedSheets = Object.values(sheets).filter(sh => sh.texts && sh.texts[t.id]);
    
    // Build clickable sheet links
    let sheetLinksHtml = '';
    if (assignedSheets.length > 0) {
      const links = assignedSheets.map(sh => 
        '<a href="#" onclick="event.stopPropagation(); event.preventDefault(); navigateToSheet(\'' + sh.id + '\');" style="color:var(--accent-text);text-decoration:underline;">' + escapeHtml(sh.name) + '</a>'
      ).join(', ');
      sheetLinksHtml = '<div class="saved-card-sheets" style="font-size:11px;color:var(--text-muted);margin-top:4px;">ðŸ“„ ' + links + '</div>';
    }
    
    html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', false)">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
          '<div class="saved-card-preview">' + escapeHtml(preview) + (preview.length >= 60 ? 'â€¦' : '') + '</div>' +
          sheetLinksHtml +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

function renderTemplatesTab(stats) {
  const panel = document.getElementById('panel-templates');
  const templates = getTemplates();
  const userTemplates = templates.filter(t => !t.builtin);
  const builtinTemplates = templates.filter(t => t.builtin);
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Templates (' + templates.length + ')</div>' +
  '</div>';
  
  html += '<div class="tab-content-list">';
  
  // User templates first
  for (const t of userTemplates) {
    const tokens = t.tokens || [];
    html += '<div class="saved-card" onclick="openFullEditor(\'' + t.id + '\', true)">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + '</div>' +
          '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); cloneSavedText(\'' + t.id + '\')" title="Clone">ðŸ“‹</button>' +
          '<button class="sheet-card-btn danger" onclick="event.stopPropagation(); confirmDeleteSavedText(\'' + t.id + '\')" title="Delete">ðŸ—‘ï¸</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  
  // Built-in templates
  for (const t of builtinTemplates) {
    const tokens = t.tokens || [];
    html += '<div class="saved-card" style="opacity: 0.85; cursor: pointer;" onclick="showBuiltinTemplatePreview(\'' + t.id + '\')">' +
      '<div class="saved-card-header">' +
        '<div>' +
          '<div class="saved-card-name">' + escapeHtml(t.name) + ' <span class="badge">Built-in</span></div>' +
          '<div class="saved-card-preview">' + tokens.map(tk => '{' + tk + '}').join(' ') + '</div>' +
        '</div>' +
        '<div class="saved-card-actions">' +
          '<button class="sheet-card-btn" onclick="event.stopPropagation(); showBatchImportModal(\'' + t.id + '\')" title="Load CSV for Batch Print">ðŸ“Š</button>' +
        '</div>' +
      '</div>' +
    '</div>';
  }
  
  html += '</div>';
  panel.innerHTML = html;
}

function renderInventoryTab(stats) {
  const panel = document.getElementById('panel-inventory');
  const types = Object.keys(inventory);
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Inventory</div>' +
    '<div class="tab-actions"><button class="tab-action-btn" onclick="showAddInventoryModal()">+ Add Label Type</button></div>' +
  '</div>';
  
  if (types.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“¦</div><div class="panel-placeholder-text">Inventory tracking not set up yet.<br>Use the "Set Up Label Sheets" workflow or click "Add Label Type" above.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  html += '<div class="tab-content-list">';
  for (const typeId of types) {
    const spec = LABEL_TYPES[typeId];
    const summary = getInventorySummary(typeId);
    if (!spec || !summary) continue;
    
    const statusClass = summary.stock === 0 && summary.partialSheets === 0 ? 'inv-empty' : summary.isLow ? 'inv-low' : 'inv-ok';
    const statusIcon = summary.stock === 0 && summary.partialSheets === 0 ? 'ðŸ”´' : summary.isLow ? 'ðŸŸ¡' : 'ðŸŸ¢';
    const statusText = summary.stock === 0 && summary.partialSheets === 0 ? 'Out of stock' : summary.isLow ? 'Low stock' : 'In stock';
    
    // Calculate breakdown bar percentages
    const totalSheetCount = summary.stock + summary.assignedUnusedSheets + summary.assignedPartialSheets;
    const shelfPct = totalSheetCount > 0 ? (summary.stock / totalSheetCount * 100) : 0;
    const assignedPct = totalSheetCount > 0 ? (summary.assignedUnusedSheets / totalSheetCount * 100) : 0;
    const partialPct = totalSheetCount > 0 ? (summary.assignedPartialSheets / totalSheetCount * 100) : 0;
    
    html += '<div class="inventory-card">' +
      '<div class="inventory-card-header">' +
        '<div class="inventory-card-type">' +
          '<span class="inventory-card-name">' + typeId + '</span>' +
          '<span class="inventory-card-desc">' + spec.desc + ' Â· ' + spec.sizeDisplay + '</span>' +
        '</div>' +
        '<div class="inventory-card-status ' + statusClass + '">' + statusIcon + ' ' + statusText + '</div>' +
      '</div>' +
      
      // Breakdown bar
      '<div class="inventory-breakdown">' +
        '<div class="inventory-breakdown-bar">' +
          (shelfPct > 0 ? '<div class="inventory-breakdown-segment shelf" style="width:' + shelfPct + '%"></div>' : '') +
          (assignedPct > 0 ? '<div class="inventory-breakdown-segment assigned" style="width:' + assignedPct + '%"></div>' : '') +
          (partialPct > 0 ? '<div class="inventory-breakdown-segment partial" style="width:' + partialPct + '%"></div>' : '') +
        '</div>' +
        '<div class="inventory-breakdown-legend">' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot shelf"></span>' +
            '<span>Shelf stock: <span class="inventory-breakdown-value">' + summary.stock + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot assigned"></span>' +
            '<span>Assigned (unused): <span class="inventory-breakdown-value">' + summary.assignedUnusedSheets + '</span></span>' +
          '</div>' +
          '<div class="inventory-breakdown-item">' +
            '<span class="inventory-breakdown-dot partial"></span>' +
            '<span>Assigned (partial): <span class="inventory-breakdown-value">' + summary.assignedPartialSheets + '</span></span>' +
          '</div>' +
        '</div>' +
      '</div>' +
      
      '<div class="inventory-card-body">' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalSheets + '</div>' +
          '<div class="inventory-stat-label">Total sheets</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.totalLabels + '</div>' +
          '<div class="inventory-stat-label">Available labels</div>' +
        '</div>' +
        '<div class="inventory-stat">' +
          '<div class="inventory-stat-value">' + summary.fullyConsumed + '</div>' +
          '<div class="inventory-stat-label">Consumed sheets</div>' +
        '</div>' +
      '</div>' +
      '<div class="inventory-card-actions">' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', -1)" title="Remove 1 sheet">âˆ’</button>' +
        '<button class="inventory-adjust-btn" onclick="adjustInventory(\'' + typeId + '\', 1)" title="Add 1 sheet">+</button>' +
        '<button class="inventory-adjust-btn wide" onclick="showAdjustInventoryModal(\'' + typeId + '\')">Set Stock</button>' +
        '<button class="inventory-adjust-btn danger" onclick="confirmRemoveInventory(\'' + typeId + '\')" title="Remove from tracking">ðŸ—‘ï¸</button>' +
      '</div>' +
    '</div>';
  }
  html += '</div>';
  panel.innerHTML = html;
}

function renderHistoryTab(stats) {
  const panel = document.getElementById('panel-history');
  
  let html = '<div class="tab-header">' +
    '<div class="tab-title">Print History</div>' +
    (printHistory.length > 0 ? '<div class="tab-actions"><button class="tab-action-btn-secondary tab-action-btn" onclick="confirmClearHistory()">Clear History</button></div>' : '') +
  '</div>';
  
  if (printHistory.length === 0) {
    html += '<div class="panel-placeholder"><div class="panel-placeholder-icon">ðŸ“œ</div><div class="panel-placeholder-text">No print history yet. Print some labels to see them here.</div></div>';
    panel.innerHTML = html;
    return;
  }
  
  // Get unique label types for filter dropdown
  const labelTypes = [...new Set(printHistory.map(e => e.labelType || '5160'))].sort();
  
  // Filters
  html += '<div class="history-filters">' +
    '<input type="text" class="history-search" id="historySearch" placeholder="Search by nameâ€¦" value="' + escapeAttr(historySearchQuery) + '" oninput="updateHistorySearch(this.value)">' +
    '<select class="history-filter-select" id="historyTypeFilter" onchange="updateHistoryTypeFilter(this.value)">' +
      '<option value="all"' + (historyTypeFilter === 'all' ? ' selected' : '') + '>All Types</option>' +
      labelTypes.map(t => '<option value="' + t + '"' + (historyTypeFilter === t ? ' selected' : '') + '>' + t + '</option>').join('') +
    '</select>' +
  '</div>';
  
  // Bulk actions bar (shown when items selected)
  if (historySelectedIds.size > 0) {
    html += '<div class="history-bulk-actions">' +
      '<span class="history-bulk-count">' + historySelectedIds.size + ' selected</span>' +
      '<button class="history-bulk-btn secondary" onclick="clearHistorySelection()">Clear</button>' +
      '<button class="history-bulk-btn" onclick="bulkReprintHistory()">Reprint Selected</button>' +
    '</div>';
  }
  
  // Filter entries
  const filtered = printHistory.filter(entry => {
    if (historyTypeFilter !== 'all' && (entry.labelType || '5160') !== historyTypeFilter) return false;
    if (historySearchQuery) {
      const q = historySearchQuery.toLowerCase();
      const name = (entry.textName || 'Labels').toLowerCase();
      if (!name.includes(q)) return false;
    }
    return true;
  }).slice(0, 100);
  
  if (filtered.length === 0) {
    html += '<div class="history-no-results">No matching entries found</div>';
    panel.innerHTML = html;
    return;
  }
  
  // Group by date
  const groups = {};
  for (const entry of filtered) {
    const date = new Date(entry.timestamp);
    const dateKey = getDateGroupKey(date);
    if (!groups[dateKey]) groups[dateKey] = { label: getDateGroupLabel(date), entries: [] };
    groups[dateKey].entries.push(entry);
  }
  
  // Render groups
  for (const key of Object.keys(groups).sort().reverse()) {
    const group = groups[key];
    html += '<div class="history-date-group">' +
      '<div class="history-date-header">' + escapeHtml(group.label) + '</div>' +
      '<div class="history-group-list">';
    
    for (const entry of group.entries) {
      const date = new Date(entry.timestamp);
      const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      const isSelected = historySelectedIds.has(entry.id);
      
      html += '<div class="history-card">' +
        '<input type="checkbox" class="history-card-checkbox" ' + (isSelected ? 'checked' : '') + ' onchange="toggleHistorySelection(\'' + entry.id + '\', this.checked)">' +
        '<div class="history-card-icon">ðŸ·ï¸</div>' +
        '<div class="history-card-info">' +
          '<div class="history-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
          '<div class="history-card-meta">' + timeStr + ' Â· ' + (entry.count || 1) + ' label' + ((entry.count || 1) !== 1 ? 's' : '') + ' Â· ' + (entry.labelType || '5160') + '</div>' +
        '</div>' +
        '<button class="history-card-action" onclick="reprintFromHistory(\'' + entry.id + '\')">Reprint</button>' +
      '</div>';
    }
    
    html += '</div></div>';
  }
  
  panel.innerHTML = html;
}

// History filter helpers
function getDateGroupKey(date) {
  return date.toISOString().split('T')[0]; // YYYY-MM-DD
}

function getDateGroupLabel(date) {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
  
  if (dateOnly.getTime() === todayOnly.getTime()) return 'Today';
  if (dateOnly.getTime() === yesterdayOnly.getTime()) return 'Yesterday';
  
  // Check if this week
  const weekAgo = new Date(todayOnly);
  weekAgo.setDate(weekAgo.getDate() - 7);
  if (dateOnly > weekAgo) {
    return date.toLocaleDateString('en-US', { weekday: 'long' });
  }
  
  return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
}

function updateHistorySearch(query) {
  historySearchQuery = query;
  renderHistoryTab();
}

function updateHistoryTypeFilter(type) {
  historyTypeFilter = type;
  renderHistoryTab();
}

function toggleHistorySelection(id, checked) {
  if (checked) {
    historySelectedIds.add(id);
  } else {
    historySelectedIds.delete(id);
  }
  renderHistoryTab();
}

function clearHistorySelection() {
  historySelectedIds.clear();
  renderHistoryTab();
}

function bulkReprintHistory() {
  if (historySelectedIds.size === 0) return;
  
  // Get selected entries
  const entries = printHistory.filter(e => historySelectedIds.has(e.id));
  if (entries.length === 0) return;
  
  // For now, just reprint the first one and show a message
  // Future enhancement: batch reprint all selected
  if (entries.length === 1) {
    reprintFromHistory(entries[0].id);
  } else {
    showToast('Reprinting first selected item. Batch reprint coming soon!', 'info');
    reprintFromHistory(entries[0].id);
  }
  
  clearHistorySelection();
}

// ========== WORKFLOWS ==========
function startWorkflow(type) {
  currentWizard = type;
  wizardStep = 1;
  
  if (type === 'print') {
    // Reset wizard state
    resetWizardEditor();
    showWizard('printWizard');
    showWizardStep('printStep1');
  } else if (type === 'mailing') {
    mailingWizardStep = 1;
    mailingCsvData = [];
    mailingCsvColumns = [];
    mailingSelectedTemplate = null;
    mailingColumnMap = {};
    mailingLabelType = settings.lastLabelType || '5160';
    clearMailingFile();
    showWizard('mailingWizard');
    showMailingStep('mailingStep1');
  } else if (type === 'reprint') {
    renderReprintList();
    showWizard('reprintWizard');
  } else if (type === 'setup') {
    setupWizardStep = 1;
    setupLabelType = settings.lastLabelType || '5160';
    setupStock = 10;
    renderSetupTypeGrid();
    showWizard('setupWizard');
    showSetupStep('setupStep1');
  }
}

function showWizard(wizardId) {
  document.getElementById(wizardId).classList.add('visible');
}

function closeWizard(wizardId) {
  document.getElementById(wizardId).classList.remove('visible');
  currentWizard = null;
  wizardStep = 1;
  wizardSelectedTextId = null;
}

function showWizardStep(stepId) {
  const wizard = document.getElementById('printWizard');
  wizard.querySelectorAll('.wizard-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
}

function wizardBack() {
  if (wizardStep === 1) {
    closeWizard('printWizard');
  } else if (wizardStep === 2) {
    wizardStep = 1;
    showWizardStep('printStep1');
  } else if (wizardStep === 3) {
    // Go back to the appropriate step 2
    wizardStep = 2;
    if (wizardSelectedTextId) {
      showWizardStep('printStep2b');
    } else {
      showWizardStep('printStep2a');
    }
  } else if (wizardStep === 4) {
    wizardStep = 3;
    showWizardStep('printStep3');
  } else if (wizardStep === 5) {
    wizardStep = 4;
    showWizardStep('printStep4');
  } else {
    wizardStep--;
  }
}

function printWizardChoice(choice) {
  wizardStep = 2;
  if (choice === 'new') {
    wizardSelectedTextId = null;
    resetWizardEditor();
    showWizardStep('printStep2a');
    // Setup paste detection for AI format
    setTimeout(setupWizardPasteListeners, 50);
  } else if (choice === 'saved') {
    renderSavedPicker();
    showWizardStep('printStep2b');
  }
}

// ========== WIZARD TEXT EDITOR ==========
let wizardLines = [
  { text: '', align: 'left', fontSize: 11 },
  { text: '', align: 'left', fontSize: 11 },
  { text: '', align: 'left', fontSize: 11 },
  { text: '', align: 'left', fontSize: 11 }
];
let wizardSelectedTextId = null;

function resetWizardEditor() {
  wizardLines = [
    { text: '', align: 'left', fontSize: 11 },
    { text: '', align: 'left', fontSize: 11 },
    { text: '', align: 'left', fontSize: 11 },
    { text: '', align: 'left', fontSize: 11 }
  ];
  
  // Clear inputs
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wizLine' + i);
    if (input) input.value = '';
  }
  
  // Reset alignment buttons
  document.querySelectorAll('.editor-align-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === 'left');
  });
  
  // Reset size buttons
  document.querySelectorAll('.editor-size-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.size === '11');
  });
  
  updateWizardPreview();
  updateWizardNextButton();
}

function setWizardAlign(lineNum, align) {
  wizardLines[lineNum - 1].align = align;
  
  // Update button states
  document.querySelectorAll(`.editor-align-btn[data-line="${lineNum}"]`).forEach(btn => {
    btn.classList.toggle('active', btn.dataset.align === align);
  });
  
  updateWizardPreview();
}

function setWizardSize(lineNum, size) {
  wizardLines[lineNum - 1].fontSize = size;
  
  // Update button states
  document.querySelectorAll(`.editor-size-btn[data-line="${lineNum}"]`).forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
  });
  
  updateWizardPreview();
}

function updateWizardPreview() {
  // Get current text values
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wizLine' + i);
    if (input) {
      wizardLines[i - 1].text = input.value;
    }
  }
  
  const previewBox = document.getElementById('wizardPreviewBox');
  if (!previewBox) return;
  
  const nonEmptyLines = wizardLines.filter(l => l.text.trim());
  
  if (nonEmptyLines.length === 0) {
    previewBox.innerHTML = '<div class="preview-line align-left" style="font-size:11px; color:#999;">Your text will appear here</div>';
  } else {
    let html = '';
    for (const line of nonEmptyLines) {
      const fontSize = Math.min(line.fontSize || 11, 14); // Cap preview size
      const align = line.align || 'left';
      const parsed = parseLine(line.text);
      
      if (parsed.type === 'split') {
        html += '<div class="preview-line" style="display:flex;justify-content:space-between;font-size:' + fontSize + 'px;"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
      } else if (parsed.type === 'fill') {
        html += '<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;font-size:' + fontSize + 'px;"><span>' + escapeHtml(parsed.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span>' + (parsed.trailing ? '<span>' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
      } else {
        html += '<div class="preview-line align-' + align + '" style="font-size:' + fontSize + 'px;">' + escapeHtml(parsed.text) + '</div>';
      }
    }
    previewBox.innerHTML = html;
  }
  
  updateWizardNextButton();
}

function updateWizardNextButton() {
  const hasText = wizardLines.some(l => l.text.trim());
  const btn = document.getElementById('wizardNextBtn');
  if (btn) {
    btn.disabled = !hasText;
  }
}

function getWizardLines() {
  return wizardLines.filter(l => l.text.trim()).map(l => ({
    text: l.text.trim(),
    align: l.align,
    fontSize: l.fontSize
  }));
}

/**
 * Handle paste event in wizard editor - detect #LABELKEEPER format
 * If detected, auto-fill fields and optionally skip to preview
 */
function handleWizardPaste(event) {
  const clipboardData = event.clipboardData || window.clipboardData;
  if (!clipboardData) return;
  
  const pastedText = clipboardData.getData('text');
  const parsed = parseLabelKeeperFormat(pastedText);
  
  if (!parsed.valid) {
    // Not our format, let normal paste proceed
    return;
  }
  
  // Prevent default paste behavior - we'll handle it
  event.preventDefault();
  
  // Fill in the lines
  for (let i = 0; i < 4; i++) {
    const input = document.getElementById('wizLine' + (i + 1));
    if (input) {
      input.value = parsed.lines[i] || '';
      wizardLines[i].text = parsed.lines[i] || '';
    }
  }
  
  // Update preview
  updateWizardPreview();
  
  // Store quantity if specified
  if (parsed.qty > 1) {
    wizardQuantity = parsed.qty;
  }
  
  // Store type if specified
  if (parsed.type) {
    wizardLabelType = parsed.type;
    settings.lastLabelType = parsed.type;
    saveSettings();
  }
  
  // Show toast and offer to skip ahead
  showToast('LabelKeeper format detected! Fields populated.', 'success');
  
  // If we have type and qty, offer to skip to preview
  if (parsed.type && parsed.lines.some(l => l.trim())) {
    setTimeout(() => {
      showLabelKeeperFormatConfirm(parsed);
    }, 300);
  }
}

/**
 * Show confirmation dialog for #LABELKEEPER format
 * Offers to skip directly to preview step
 */
function showLabelKeeperFormatConfirm(parsed) {
  const typeInfo = LABEL_TYPES[parsed.type];
  const typeName = typeInfo ? 'Avery ' + parsed.type : 'default type';
  const qtyText = parsed.qty > 1 ? parsed.qty + ' labels' : '1 label';
  
  showConfirm(
    'Ready to print ' + qtyText + ' on ' + typeName + '?\n\nYou can review the text above or skip to preview.',
    'Skip to Preview?',
    'Skip to Preview',
    false,
    (confirmed) => {
      if (confirmed) {
        // Store the lines and skip to step 5 (preview)
        wizardCurrentLines = getWizardLines();
        wizardQuantity = parsed.qty;
        wizardLabelType = parsed.type || settings.lastLabelType || '5160';
        wizardStep = 5;
        renderPrintPreview();
        showWizardStep('printStep5');
      }
      // If not confirmed, user stays on current step with pre-filled data
    }
  );
}

/**
 * Setup paste listeners for wizard editor inputs
 */
function setupWizardPasteListeners() {
  for (let i = 1; i <= 4; i++) {
    const input = document.getElementById('wizLine' + i);
    if (input) {
      input.addEventListener('paste', handleWizardPaste);
    }
  }
}

function wizardToStep3() {
  const lines = getWizardLines();
  if (lines.length === 0) return;
  
  // Store the lines for step 3
  wizardCurrentLines = lines;
  wizardQuantity = 1;
  wizardStep = 3;
  renderQuantityStep();
  showWizardStep('printStep3');
}

let wizardCurrentLines = [];

// ========== SAVED CONTENT PICKER ==========
let savedPickerFilter = '';

function renderSavedPicker() {
  const list = document.getElementById('savedPickerList');
  const texts = getTexts();
  
  // Filter by search
  const filtered = savedPickerFilter 
    ? texts.filter(t => {
        const search = savedPickerFilter.toLowerCase();
        const lines = deserializeLines(t.text);
        const preview = getFlatText(lines).toLowerCase();
        return t.name.toLowerCase().includes(search) || preview.includes(search);
      })
    : texts;
  
  if (texts.length === 0) {
    // No saved content at all
    list.innerHTML = '<div class="saved-picker-empty">' +
      '<div class="saved-picker-empty-icon">ðŸ’¾</div>' +
      '<div class="saved-picker-empty-text">No saved content yet</div>' +
      '<button class="saved-picker-empty-btn" onclick="printWizardChoice(\'new\')">Type new text instead</button>' +
    '</div>';
    return;
  }
  
  if (filtered.length === 0) {
    // Search returned no results
    list.innerHTML = '<div class="saved-picker-empty">' +
      '<div class="saved-picker-empty-icon">ðŸ”</div>' +
      '<div class="saved-picker-empty-text">No matches found</div>' +
    '</div>';
    return;
  }
  
  let html = '';
  for (const t of filtered) {
    const lines = deserializeLines(t.text);
    const preview = getFlatText(lines).substring(0, 60);
    html += '<div class="saved-picker-item" onclick="selectSavedText(\'' + t.id + '\')">' +
      '<div class="saved-picker-item-name">' + escapeHtml(t.name) + '</div>' +
      '<div class="saved-picker-item-preview">' + escapeHtml(preview) + (preview.length >= 60 ? 'â€¦' : '') + '</div>' +
    '</div>';
  }
  list.innerHTML = html;
}

function filterSavedPicker() {
  const input = document.getElementById('savedPickerSearch');
  savedPickerFilter = input ? input.value : '';
  renderSavedPicker();
}

function selectSavedText(textId) {
  const text = getSavedText(textId);
  if (!text) return;
  
  wizardSelectedTextId = textId;
  wizardCurrentLines = deserializeLines(text.text);
  
  // Move to step 3
  wizardStep = 3;
  wizardQuantity = 1;
  renderQuantityStep();
  showWizardStep('printStep3');
}

// ========== QUANTITY STEP ==========
let wizardQuantity = 1;
let wizardLabelType = '5160';
let wizardTargetSheet = null;

function renderQuantityStep() {
  document.getElementById('qtyValue').textContent = wizardQuantity;
  document.getElementById('qtyMinusBtn').disabled = wizardQuantity <= 1;
  
  // Update hint with current type's capacity
  const spec = LABEL_TYPES[wizardLabelType];
  const lps = spec.cols * spec.rows;
  document.getElementById('qtyHint').textContent = 'You can print up to ' + lps + ' labels per sheet';
}

function adjustQuantity(delta) {
  const newQty = wizardQuantity + delta;
  if (newQty < 1) return;
  if (newQty > 999) return; // Reasonable max
  wizardQuantity = newQty;
  renderQuantityStep();
}

function wizardToStep4() {
  wizardStep = 4;
  renderTypePicker();
  showWizardStep('printStep4');
}

// ========== TYPE PICKER STEP ==========
function renderTypePicker() {
  const grid = document.getElementById('typeGrid');
  
  // Use last label type from settings as default
  if (settings.lastLabelType && LABEL_TYPES[settings.lastLabelType]) {
    wizardLabelType = settings.lastLabelType;
  }
  
  let html = '';
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === wizardLabelType;
    // Add category badge for special types
    const categoryBadge = spec.category === 'badge' ? '<span class="type-category-badge">ðŸ·ï¸ Badge</span>' :
                          spec.category === 'tent' ? '<span class="type-category-badge">â›º Tent</span>' : '';
    html += '<div class="type-card' + (selected ? ' selected' : '') + '" data-type="' + typeId + '" onclick="selectLabelType(\'' + typeId + '\')">' +
      '<div class="type-card-name">' + typeId + categoryBadge + '</div>' +
      '<div class="type-card-desc">' + spec.desc + '</div>' +
      '<div class="type-card-details">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet</div>' +
    '</div>';
  }
  grid.innerHTML = html;
}

function selectLabelType(typeId) {
  wizardLabelType = typeId;
  
  // Update visual selection
  document.querySelectorAll('.type-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.type === typeId);
  });
  
  // Save as last used
  settings.lastLabelType = typeId;
  saveSettings();
}

function wizardToStep5() {
  wizardStep = 5;
  renderPrintPreview();
  showWizardStep('printStep5');
}

// ========== PRINT PREVIEW STEP ==========
function renderPrintPreview() {
  const spec = LABEL_TYPES[wizardLabelType];
  const lps = spec.cols * spec.rows;
  
  // Update summary
  const summaryText = 'Print ' + wizardQuantity + ' label' + (wizardQuantity !== 1 ? 's' : '') + ' on Avery ' + wizardLabelType;
  document.getElementById('printSummary').innerHTML = '<div class="print-summary-text">' + summaryText + '</div>';
  
  // Render label preview
  const previewLabel = document.getElementById('printPreviewLabel');
  // Scale preview to approximately match label aspect ratio
  const aspectRatio = spec.labelW / spec.labelH;
  const maxWidth = 280;
  const width = Math.min(maxWidth, spec.labelW * 96); // 96 DPI approx
  const height = width / aspectRatio;
  
  previewLabel.style.width = width + 'px';
  previewLabel.style.minHeight = height + 'px';
  
  let linesHtml = '';
  for (const line of wizardCurrentLines) {
    const style = buildLineStyleStr(line);
    const parsed = parseLine(line.text);
    if (parsed.type === 'split') {
      linesHtml += '<div class="preview-line" style="display:flex;justify-content:space-between;' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
    } else if (parsed.type === 'fill') {
      linesHtml += '<div class="preview-line" style="display:flex;align-items:flex-end;gap:3px;' + style + '"><span>' + escapeHtml(parsed.label) + '</span><span style="flex:1;border-bottom:1px solid #000;margin-bottom:2px;"></span></div>';
    } else {
      const align = line.align === 'center' ? 'center' : line.align === 'right' ? 'right' : 'left';
      linesHtml += '<div class="preview-line" style="text-align:' + align + ';' + style + '">' + escapeHtml(parsed.text) + '</div>';
    }
  }
  previewLabel.innerHTML = linesHtml;
  
  // Determine which sheet to use
  wizardTargetSheet = findOrCreateSheetForPrint();
  
  // Update sheet info
  const sheetInfoText = document.getElementById('sheetInfoText');
  const sheetInfoDetail = document.getElementById('sheetInfoDetail');
  
  if (wizardTargetSheet.isNew) {
    sheetInfoText.textContent = 'Will create new sheet';
    sheetInfoDetail.textContent = spec.name + ' Â· ' + lps + ' labels available';
  } else {
    const sh = sheets[wizardTargetSheet.id];
    const remaining = getRemainingCount(sh);
    sheetInfoText.textContent = 'Using "' + sh.name + '"';
    sheetInfoDetail.textContent = remaining + ' labels remaining on this sheet';
  }
  
  // Show inventory warning if applicable
  const invWarning = document.getElementById('printInventoryWarning');
  if (invWarning) {
    const summary = getInventorySummary(wizardLabelType);
    if (summary && summary.stock === 0 && wizardTargetSheet.isNew) {
      invWarning.innerHTML = '<div class="print-inv-warning error">âš ï¸ No blank sheets in inventory for this label type</div>';
      invWarning.style.display = 'block';
    } else if (summary && summary.isLow) {
      invWarning.innerHTML = '<div class="print-inv-warning warning">âš ï¸ Low stock: Only ' + summary.stock + ' blank sheet' + (summary.stock !== 1 ? 's' : '') + ' remaining</div>';
      invWarning.style.display = 'block';
    } else {
      invWarning.style.display = 'none';
    }
  }
}

function buildLineStyleStr(lineObj) {
  let style = 'font-size:' + (lineObj.fontSize || 11) + 'px';
  if (lineObj.bold) style += ';font-weight:bold';
  if (lineObj.italic) style += ';font-style:italic';
  const deco = lineObj.underline ? 'underline' : lineObj.strikethrough ? 'line-through' : '';
  if (deco) style += ';text-decoration:' + deco;
  if (lineObj.color) style += ';color:' + lineObj.color;
  if (lineObj.fillColor) style += ';background-color:' + lineObj.fillColor;
  return style;
}

function findOrCreateSheetForPrint() {
  // Look for an existing sheet of this type with enough space
  for (const sh of Object.values(sheets)) {
    if (sh.labelType === wizardLabelType) {
      const remaining = getRemainingCount(sh);
      if (remaining >= wizardQuantity) {
        return { isNew: false, id: sh.id };
      }
    }
  }
  
  // Will need to create a new sheet
  return { isNew: true };
}

// ========== EXECUTE PRINT ==========
function executePrint() {
  const spec = LABEL_TYPES[wizardLabelType];
  const lps = spec.cols * spec.rows;
  
  // Create or get sheet
  let sheetId;
  let isNewSheet = wizardTargetSheet.isNew;
  if (isNewSheet) {
    // Generate sheet name
    const existingCount = Object.values(sheets).filter(s => s.labelType === wizardLabelType).length;
    const sheetName = spec.desc + ' #' + (existingCount + 1);
    sheetId = createSheet(sheetName, wizardLabelType, 1);
  } else {
    sheetId = wizardTargetSheet.id;
  }
  
  const sh = sheets[sheetId];
  
  // Find positions to print
  const printed = new Set(sh.printed || []);
  const positions = [];
  for (let i = 0; i < lps && positions.length < wizardQuantity; i++) {
    if (!printed.has(i)) {
      positions.push(i);
    }
  }
  
  // Build print HTML
  const printHtml = buildPrintSheetHtml(sh, positions, wizardCurrentLines);
  
  // Use iframe for printing (like v1.2)
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  // Safari scale fix - use wrapper to constrain scaled content
  const safariScale = 1.0;
  let cssRules = '@page { size: letter; margin: 0 !important; }';
  cssRules += 'html, body { margin: 0 !important; padding: 0 !important; }';
  if (isSafari) {
    cssRules += '.print-wrapper { width: 8.5in; height: 11in; overflow: hidden; }';
    cssRules += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; transform: scale(' + safariScale + '); transform-origin: top left; }';
  } else {
    cssRules += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; box-sizing: border-box; }';
  }
  
  const wrapStart = isSafari ? '<div class="print-wrapper">' : '';
  const wrapEnd = isSafari ? '</div>' : '';
  
  iframeDoc.write('<!DOCTYPE html><html><head><style>' +
    cssRules +
    '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }' +
    '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }' +
    '.print-line.align-left { justify-content:flex-start; text-align:left; }' +
    '.print-line.align-center { justify-content:center; text-align:center; }' +
    '.print-line.align-right { justify-content:flex-end; text-align:right; }' +
    '.print-line.align-split { justify-content:space-between; text-align:left; }' +
    '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }' +
    '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }' +
    '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }' +
    // Tent card styles
    '.print-label.tent-card { position:relative; }' +
    '.fold-line { position:absolute; left:0; right:0; top:50%; border-top:1px dashed #bbb; z-index:1; }' +
    '.tent-top, .tent-bottom { position:absolute; left:0; right:0; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:0.1in; box-sizing:border-box; }' +
    '.tent-top { top:0; height:50%; }' +
    '.tent-bottom { bottom:0; height:50%; transform:rotate(180deg); }' +
  '</style></head><body>' +
    wrapStart + '<div class="print-sheet">' + printHtml + '</div>' + wrapEnd +
  '</body></html>');
  iframeDoc.close();
  
  // Wait for iframe to render, then print
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  // Close wizard first
  closeWizard('printWizard');
  
  // After print dialog closes, ask user to confirm
  const totalLabels = positions.length;
  showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer.\n\nDid the print complete successfully?',
    'ðŸ–¨ï¸ Confirm Print',
    'Yes, printed OK',
    false,
    (confirmed) => {
      if (confirmed) {
        // Decrement inventory when using a new sheet (only on confirmed print)
        if (isNewSheet && inventory[wizardLabelType] && inventory[wizardLabelType].stock > 0) {
          inventory[wizardLabelType].stock--;
          saveInventory();
        }
        
        // Mark positions as printed
        markPositionsPrinted(sheetId, positions);
        
        // Add to print history
        const textName = wizardSelectedTextId ? getSavedText(wizardSelectedTextId)?.name : getFlatText(wizardCurrentLines).substring(0, 30);
        addPrintHistoryEntry({
          textName: textName || 'Custom text',
          count: positions.length,
          labelType: wizardLabelType,
          sheetId: sheetId,
          sheetName: sh.name
        });
        
        // Check if there's room for more prints and offer to link content
        const remaining = getRemainingCount(sheets[sheetId]);
        if (remaining > 0) {
          // Ask if user wants to link content to sheet for future printing
          askToLinkContentToSheet(sheetId, remaining);
        } else {
          showToast('"' + sh.name + '" is now full.', 'success');
        }
      } else {
        // User cancelled - if we created a new sheet, we should delete it
        if (isNewSheet) {
          delete sheets[sheetId];
          saveSheets();
        }
        showToast('Print cancelled â€” no labels marked as used', 'warning');
      }
    }
  );
}

// Ask user if they want to link content to sheet for future printing
function askToLinkContentToSheet(sheetId, remaining) {
  const sh = sheets[sheetId];
  if (!sh) {
    showToast('Printed! ' + remaining + ' spots left.', 'success');
    return;
  }
  
  // Check if content is already linked to this sheet
  if (wizardSelectedTextId && sh.texts && sh.texts[wizardSelectedTextId]) {
    showToast('Printed! ' + remaining + ' spots left on "' + sh.name + '"', 'success');
    return;
  }
  
  showConfirm(
    'Would you like to print this same content from "' + sh.name + '" again later?\n\n' +
    'If yes, the content will be linked to this sheet so you can easily print more from the Sheets tab.',
    'ðŸ”— Link for Future Printing?',
    'Yes, link it',
    false,
    (wantsLink) => {
      if (wantsLink) {
        linkContentToSheet(sheetId);
      } else {
        showToast('Printed! ' + remaining + ' spots left on "' + sh.name + '"', 'success');
      }
    },
    'No thanks'
  );
}

// Link the wizard content to a sheet
function linkContentToSheet(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  let textId = wizardSelectedTextId;
  
  // If content wasn't saved yet, save it first
  if (!textId) {
    // Create new saved text from wizard content
    const flatText = getFlatText(wizardCurrentLines);
    const newText = {
      id: generateId('text'),
      name: flatText.substring(0, 30) || 'Untitled',
      text: serializeLines(wizardCurrentLines.map(l => ({
        text: l.text,
        align: l.align,
        fontSize: l.fontSize,
        bold: false,
        italic: false,
        underline: false,
        strikethrough: false,
        color: '',
        fillColor: '',
        borders: ''
      }))),
      alignV: 'center',
      type: 'text',
      graphics: null,
      createdAt: Date.now()
    };
    savedTexts.push(newText);
    saveTexts();
    textId = newText.id;
  }
  
  // Link to sheet
  if (!sh.texts) sh.texts = {};
  if (!sh.texts[textId]) {
    sh.texts[textId] = { qty: 0, placement: 'next' };
  }
  saveSheets();
  
  const remaining = getRemainingCount(sh);
  const st = getSavedText(textId);
  showToast('Linked! Find "' + (st?.name || 'content') + '" on "' + sh.name + '" in Sheets tab. ' + remaining + ' spots left.', 'success');
}

function buildPrintSheetHtml(sh, positions, lines) {
  const spec = LABEL_TYPES[sh.labelType];
  const isTentCard = spec.category === 'tent';
  let html = '';
  
  // Get manual print offsets only (Safari handled via CSS negative margin in executePrint)
  const offsetTop = settings.printOffsetTop || 0;
  const offsetLeft = settings.printOffsetLeft || 0;
  
  for (const pos of positions) {
    const row = Math.floor(pos / spec.cols);
    const col = pos % spec.cols;
    
    const top = spec.topMargin + row * (spec.labelH + spec.vGutter) + offsetTop;
    const left = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
    
    const alignV = 'center'; // Default vertical alignment
    const justifyContent = alignV === 'top' ? 'flex-start' : alignV === 'bottom' ? 'flex-end' : 'center';
    
    if (isTentCard) {
      // Tent card - render content on both halves
      html += '<div class="print-label tent-card" style="' +
        'top:' + top + 'in;' +
        'left:' + left + 'in;' +
        'width:' + spec.labelW + 'in;' +
        'height:' + spec.labelH + 'in;' +
        'padding:0;">';
      html += '<div class="fold-line"></div>';
      html += '<div class="tent-top" style="justify-content:' + justifyContent + ';">';
      for (const line of lines) {
        html += renderPrintLineHtml(line);
      }
      html += '</div>';
      html += '<div class="tent-bottom" style="justify-content:' + justifyContent + ';">';
      for (const line of lines) {
        html += renderPrintLineHtml(line);
      }
      html += '</div>';
      html += '</div>';
    } else {
      // Standard label
      html += '<div class="print-label" style="' +
        'top:' + top + 'in;' +
        'left:' + left + 'in;' +
        'width:' + spec.labelW + 'in;' +
        'height:' + spec.labelH + 'in;' +
        'padding:0.08in 0.12in;' +
        'justify-content:' + justifyContent + ';">';
    
      for (const line of lines) {
        html += renderPrintLineHtml(line);
      }
    
      html += '</div>';
    }
  }
  
  return html;
}

function renderPrintLineHtml(lineObj) {
  const parsed = parseLine(lineObj.text);
  const style = buildLineStyleStr(lineObj);
  
  if (parsed.type === 'split') {
    return '<div class="print-line align-split" style="' + style + '"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
  }
  if (parsed.type === 'fill') {
    return '<div class="print-line fill-line" style="' + style + '"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
  }
  return '<div class="print-line align-' + lineObj.align + '" style="' + style + '">' + escapeHtml(parsed.text) + '</div>';
}

// ========== PRINT SUCCESS ==========
function showPrintSuccess(count, sheetName) {
  document.getElementById('printSuccessText').textContent = count + ' label' + (count !== 1 ? 's' : '') + ' printed on "' + sheetName + '"';
  document.getElementById('printSuccessOverlay').classList.add('visible');
}

function printMore() {
  document.getElementById('printSuccessOverlay').classList.remove('visible');
  // Go back to step 1
  wizardStep = 1;
  resetWizardEditor();
  showWizardStep('printStep1');
}

function finishPrint() {
  document.getElementById('printSuccessOverlay').classList.remove('visible');
  closeWizard('printWizard');
}

// ============================================================================
// SHEET MODAL HANDLERS
// ============================================================================

let editingSheetId = null;

function openNewSheetModal() {
  editingSheetId = null;
  document.getElementById('sheetModalTitle').textContent = 'New Sheet';
  document.getElementById('sheetNameInput').value = '';
  document.getElementById('sheetNoteInput').value = '';
  document.getElementById('sheetCountInput').value = '1';
  document.getElementById('sheetCountGroup').style.display = 'block';
  
  // Populate type select
  const select = document.getElementById('sheetTypeSelect');
  let options = '';
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === (settings.lastLabelType || '5160') ? ' selected' : '';
    const catHint = spec.category === 'badge' ? ' [Badge]' : spec.category === 'tent' ? ' [Tent]' : '';
    options += '<option value="' + typeId + '"' + selected + '>' + typeId + ' - ' + spec.desc + catHint + ' (' + lps + '/sheet)</option>';
  }
  select.innerHTML = options;
  
  document.getElementById('sheetModal').classList.add('visible');
  document.getElementById('sheetNameInput').focus();
}

function openEditSheetModal(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  editingSheetId = sheetId;
  document.getElementById('sheetModalTitle').textContent = 'Edit Sheet';
  document.getElementById('sheetNameInput').value = sh.name;
  document.getElementById('sheetNoteInput').value = sh.note || '';
  document.getElementById('sheetCountGroup').style.display = 'none'; // Can't change count after creation
  
  // Populate type select (disabled for edit)
  const select = document.getElementById('sheetTypeSelect');
  let options = '';
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === sh.labelType ? ' selected' : '';
    const catHint = spec.category === 'badge' ? ' [Badge]' : spec.category === 'tent' ? ' [Tent]' : '';
    options += '<option value="' + typeId + '"' + selected + '>' + typeId + ' - ' + spec.desc + catHint + ' (' + lps + '/sheet)</option>';
  }
  select.innerHTML = options;
  select.disabled = true;
  
  document.getElementById('sheetModal').classList.add('visible');
  document.getElementById('sheetNameInput').focus();
}

function closeSheetModal() {
  document.getElementById('sheetModal').classList.remove('visible');
  document.getElementById('sheetTypeSelect').disabled = false;
  editingSheetId = null;
}

function saveSheetModal() {
  const name = document.getElementById('sheetNameInput').value.trim();
  if (!name) {
    document.getElementById('sheetNameInput').focus();
    return;
  }
  
  const note = document.getElementById('sheetNoteInput').value.trim();
  
  if (editingSheetId) {
    // Update existing
    sheets[editingSheetId].name = name;
    sheets[editingSheetId].note = note;
    saveSheets();
    showToast('Sheet updated', 'success');
    closeSheetModal();
    renderCurrentTab();
  } else {
    // Create new
    const typeId = document.getElementById('sheetTypeSelect').value;
    const count = parseInt(document.getElementById('sheetCountInput').value) || 1;
    const sheetId = createSheet(name, typeId, Math.max(1, Math.min(20, count)), note);
    settings.lastLabelType = typeId;
    saveSettings();
    
    closeSheetModal();
    renderCurrentTab();
    
    // Offer to print sheet label on back
    offerPrintSheetLabel(sheetId);
  }
}

// Offer to print a label on the back of the sheet for identification
function offerPrintSheetLabel(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  showConfirm(
    'Would you like to print a label on the back of this sheet?\n\n' +
    'This helps identify the sheet in your drawer or stack. ' +
    'Put the sheet in your printer face-down (backwards), then click Print.',
    'ðŸ·ï¸ Print Sheet Label?',
    'Yes, print label',
    false,
    (wantsPrint) => {
      if (wantsPrint) {
        printSheetLabel(sheetId);
      } else {
        showToast('Sheet created', 'success');
      }
    },
    'No thanks'
  );
}

// Print a label on the back of a sheet for identification
async function printSheetLabel(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  const spec = LABEL_TYPES[sh.labelType];
  const lps = spec.cols * spec.rows;
  
  // Generate deep link URL
  const baseUrl = window.location.href.split('#')[0].split('?')[0];
  const deepLink = baseUrl + '?sheet=' + sheetId;
  
  console.log('QR Code deep link:', deepLink);
  
  // Generate QR code as data URL
  const qrDataUrl = await generateQRCode(deepLink);
  
  // Build the label content
  let html = '<!DOCTYPE html><html><head><style>' +
    '@page { size: letter; margin: 0; }' +
    'html, body { margin: 0; padding: 0; }' +
    '.sheet-label { ' +
      'width: 8.5in; height: 11in; ' +
      'display: flex; flex-direction: column; ' +
      'justify-content: center; align-items: center; ' +
      'font-family: Arial, sans-serif; ' +
      'text-align: center; ' +
      'padding: 1in; box-sizing: border-box; ' +
    '}' +
    '.sheet-name { font-size: 28pt; font-weight: bold; margin-bottom: 0.3in; }' +
    '.sheet-type { font-size: 20pt; color: #444; margin-bottom: 0.2in; }' +
    '.sheet-detail { font-size: 14pt; color: #666; margin-bottom: 0.15in; }' +
    '.sheet-note { font-size: 14pt; color: #333; font-style: italic; margin-top: 0.3in; max-width: 6in; }' +
    '.qr-section { margin-top: 0.5in; }' +
    '.qr-code { width: 1.5in; height: 1.5in; }' +
    '.qr-hint { font-size: 10pt; color: #888; margin-top: 0.1in; }' +
    '.qr-url { font-size: 7pt; color: #aaa; margin-top: 0.05in; word-break: break-all; max-width: 4in; }' +
  '</style></head><body>' +
    '<div class="sheet-label">' +
      '<div class="sheet-name">' + escapeHtml(sh.name) + '</div>' +
      '<div class="sheet-type">Avery ' + spec.name + '</div>' +
      '<div class="sheet-detail">' + spec.sizeDisplay + ' Â· ' + lps + ' labels per sheet</div>' +
      '<div class="sheet-detail">' + spec.desc + '</div>' +
      (sh.note ? '<div class="sheet-note">"' + escapeHtml(sh.note) + '"</div>' : '') +
      '<div class="qr-section">' +
        '<div class="qr-code">' + qrDataUrl + '</div>' +
        '<div class="qr-hint">Scan to open in LabelKeeper</div>' +
        '<div class="qr-url">' + escapeHtml(deepLink) + '</div>' +
      '</div>' +
    '</div>' +
  '</body></html>';
  
  // Print using iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(html);
  iframeDoc.close();
  
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  showToast('Sheet label sent to printer.', 'success');
}

// Generate QR Code using qr-creator library (more reliable)
async function generateQRCode(text) {
  // Load library if needed
  if (!window.QrCreator) {
    await loadQRCreatorLib();
  }
  
  // Create canvas
  const canvas = document.createElement('canvas');
  
  // Generate QR code directly onto canvas
  QrCreator.render({
    text: text,
    radius: 0,
    ecLevel: 'M',
    fill: '#000000',
    background: '#ffffff',
    size: 200
  }, canvas);
  
  // Convert to data URL
  const dataUrl = canvas.toDataURL('image/png');
  
  console.log('QR code generated for:', text);
  console.log('Data URL length:', dataUrl.length);
  
  return '<img src="' + dataUrl + '" style="width:100%;height:100%;" alt="QR Code">';
}

// Load QrCreator library
function loadQRCreatorLib() {
  return new Promise((resolve, reject) => {
    if (window.QrCreator) {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/qr-creator@1.0.0/dist/qr-creator.min.js';
    script.onload = () => {
      console.log('QrCreator library loaded');
      resolve();
    };
    script.onerror = () => reject(new Error('Failed to load QrCreator library'));
    document.head.appendChild(script);
  });
}

function confirmDeleteSheet(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  showConfirm('Delete "' + sh.name + '"? This cannot be undone.', 'Delete Sheet', 'Delete', true, (confirmed) => {
    if (confirmed) {
      deleteSheet(sheetId);
      showToast('Sheet deleted', 'success');
      renderCurrentTab();
    }
  });
}

// Clone a sheet
function cloneSheet(sheetId) {
  const sh = sheets[sheetId];
  if (!sh) return;
  
  showPrompt('Name for cloned sheet:', 'Clone Sheet', sh.name + ' (copy)', (newName) => {
    if (!newName || !newName.trim()) return;
    
    const newId = 'sheet_' + Date.now();
    const newSheet = {
      id: newId,
      name: newName.trim(),
      labelType: sh.labelType,
      sheetCount: sh.sheetCount || 1,
      printed: [], // Start fresh - no printed positions
      texts: {}, // Copy text assignments but reset quantities
      createdAt: Date.now()
    };
    
    // Copy text assignments with qty reset to 0
    if (sh.texts) {
      Object.keys(sh.texts).forEach(textId => {
        newSheet.texts[textId] = {
          qty: 0,
          placement: sh.texts[textId].placement || 'next'
        };
      });
    }
    
    sheets[newId] = newSheet;
    activeSheetId = newId;
    saveSheets();
    showToast('Sheet cloned', 'success');
    renderSheetsTab(getDataStats());
  });
}

// Clone saved text/template
function cloneSavedText(textId) {
  const t = getSavedText(textId);
  if (!t) return;
  
  const typeLabel = t.type === 'template' ? 'template' : 'content';
  showPrompt('Name for cloned ' + typeLabel + ':', 'Clone ' + (t.type === 'template' ? 'Template' : 'Content'), t.name + ' (copy)', (newName) => {
    if (!newName || !newName.trim()) return;
    
    const newId = 'text_' + Date.now();
    const newText = {
      id: newId,
      name: newName.trim(),
      text: t.text,
      alignV: t.alignV || 'center',
      type: t.type || 'text',
      graphics: t.graphics ? JSON.parse(JSON.stringify(t.graphics)) : { left: null, right: null },
      tokens: t.tokens ? [...t.tokens] : [],
      labelType: t.labelType,
      createdAt: Date.now()
    };
    
    savedTexts.push(newText);
    saveSavedTexts();
    showToast((t.type === 'template' ? 'Template' : 'Content') + ' cloned', 'success');
    renderCurrentTab();
  });
}

// ============================================================================
// SAVED TEXT MODAL HANDLERS
// ============================================================================

let editingSavedTextId = null;

function openNewSavedTextModal() {
  editingSavedTextId = null;
  document.getElementById('savedTextModalTitle').textContent = 'New Saved Text';
  document.getElementById('savedTextNameInput').value = '';
  document.getElementById('savedTextLine1').value = '';
  document.getElementById('savedTextLine2').value = '';
  document.getElementById('savedTextLine3').value = '';
  document.getElementById('savedTextLine4').value = '';
  
  document.getElementById('savedTextModal').classList.add('visible');
  document.getElementById('savedTextNameInput').focus();
}

function openEditSavedTextModal(textId) {
  const t = getSavedText(textId);
  if (!t || t.builtin) return;
  
  editingSavedTextId = textId;
  document.getElementById('savedTextModalTitle').textContent = 'Edit Saved Text';
  document.getElementById('savedTextNameInput').value = t.name;
  
  const lines = deserializeLines(t.text);
  document.getElementById('savedTextLine1').value = lines[0]?.text || '';
  document.getElementById('savedTextLine2').value = lines[1]?.text || '';
  document.getElementById('savedTextLine3').value = lines[2]?.text || '';
  document.getElementById('savedTextLine4').value = lines[3]?.text || '';
  
  document.getElementById('savedTextModal').classList.add('visible');
  document.getElementById('savedTextNameInput').focus();
}

function closeSavedTextModal() {
  document.getElementById('savedTextModal').classList.remove('visible');
  editingSavedTextId = null;
}

function saveSavedTextModal() {
  const name = document.getElementById('savedTextNameInput').value.trim();
  if (!name) {
    document.getElementById('savedTextNameInput').focus();
    return;
  }
  
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const text = document.getElementById('savedTextLine' + i).value.trim();
    if (text) {
      lines.push({ text, align: 'left', fontSize: 11 });
    }
  }
  
  if (lines.length === 0) {
    document.getElementById('savedTextLine1').focus();
    return;
  }
  
  if (editingSavedTextId) {
    // Update existing
    updateSavedText(editingSavedTextId, { name, text: serializeLines(lines) });
    showToast('Saved text updated', 'success');
  } else {
    // Create new
    createSavedText(name, lines);
    showToast('Saved text created', 'success');
  }
  
  closeSavedTextModal();
  renderCurrentTab();
}

function confirmDeleteSavedText(textId) {
  const t = getSavedText(textId);
  if (!t) return;
  
  showConfirm('Delete "' + t.name + '"? This cannot be undone.', 'Delete Saved Text', 'Delete', true, (confirmed) => {
    if (confirmed) {
      deleteSavedText(textId);
      showToast('Saved text deleted', 'success');
      renderCurrentTab();
    }
  });
}

function printSavedText(textId) {
  const t = getSavedText(textId);
  if (!t) return;
  
  // Start print workflow with this text pre-selected
  wizardSelectedTextId = textId;
  wizardCurrentLines = deserializeLines(t.text);
  wizardQuantity = 1;
  wizardStep = 3;
  
  showWizard('printWizard');
  renderQuantityStep();
  showWizardStep('printStep3');
}

// ============================================================================
// HISTORY HANDLERS
// ============================================================================

function reprintFromHistory(entryId) {
  const entry = printHistory.find(e => e.id === entryId);
  if (!entry) return;
  
  // If we have the lines stored, use them
  if (entry.lines) {
    wizardCurrentLines = entry.lines;
  } else {
    // Otherwise try to reconstruct from textName
    wizardCurrentLines = [{ text: entry.textName || 'Label', align: 'left', fontSize: 11 }];
  }
  
  wizardSelectedTextId = null;
  wizardQuantity = entry.count || 1;
  wizardLabelType = entry.labelType || '5160';
  wizardStep = 3;
  
  showWizard('printWizard');
  renderQuantityStep();
  showWizardStep('printStep3');
}

function renderReprintList() {
  const container = document.getElementById('reprintHistoryList');
  
  if (printHistory.length === 0) {
    container.innerHTML = '<div class="reprint-empty">' +
      '<div class="reprint-empty-icon">ðŸ“œ</div>' +
      '<div class="reprint-empty-text">No print history yet.<br>Print some labels first, then come back to reprint them.</div>' +
      '<button class="reprint-empty-btn" onclick="closeWizard(\'reprintWizard\'); startWorkflow(\'print\')">Print Labels</button>' +
    '</div>';
    return;
  }
  
  let html = '';
  const recent = printHistory.slice(0, 20); // Show last 20
  
  for (const entry of recent) {
    const date = new Date(entry.timestamp);
    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
    const count = entry.count || 1;
    const labelType = entry.labelType || '5160';
    
    html += '<div class="reprint-card" onclick="reprintFromRecentWorkflow(\'' + entry.id + '\')">' +
      '<div class="reprint-card-icon">ðŸ·ï¸</div>' +
      '<div class="reprint-card-info">' +
        '<div class="reprint-card-title">' + escapeHtml(entry.textName || 'Labels') + '</div>' +
        '<div class="reprint-card-meta">' + dateStr + ' at ' + timeStr + ' Â· ' + count + ' label' + (count !== 1 ? 's' : '') + ' Â· ' + labelType + '</div>' +
      '</div>' +
      '<div class="reprint-card-arrow">â†’</div>' +
    '</div>';
  }
  
  container.innerHTML = html;
}

function reprintFromRecentWorkflow(entryId) {
  // Close the reprint wizard first
  closeWizard('reprintWizard');
  // Then use existing reprint function
  reprintFromHistory(entryId);
}

// ============================================================================
// SETUP WIZARD
// ============================================================================

let setupWizardStep = 1;
let setupLabelType = '5160';
let setupStock = 10;

function showSetupStep(stepId) {
  const wizard = document.getElementById('setupWizard');
  wizard.querySelectorAll('.wizard-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
}

function setupWizardBack() {
  if (setupWizardStep === 1) {
    closeWizard('setupWizard');
  } else if (setupWizardStep === 2) {
    setupWizardStep = 1;
    showSetupStep('setupStep1');
  } else if (setupWizardStep === 3) {
    setupWizardStep = 2;
    showSetupStep('setupStep2');
  }
}

function renderSetupTypeGrid() {
  const grid = document.getElementById('setupTypeGrid');
  let html = '';
  
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === setupLabelType;
    const alreadyTracked = inventory[typeId] !== undefined;
    
    html += '<div class="type-card' + (selected ? ' selected' : '') + (alreadyTracked ? ' already-tracked' : '') + '" data-type="' + typeId + '" onclick="selectSetupType(\'' + typeId + '\')">' +
      '<div class="type-card-name">' + typeId + (alreadyTracked ? ' âœ“' : '') + '</div>' +
      '<div class="type-card-desc">' + spec.desc + '</div>' +
      '<div class="type-card-details">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet</div>' +
      (alreadyTracked ? '<div class="type-card-tracked">Already tracking</div>' : '') +
    '</div>';
  }
  grid.innerHTML = html;
}

function selectSetupType(typeId) {
  setupLabelType = typeId;
  
  // Update visual selection
  document.querySelectorAll('#setupTypeGrid .type-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.type === typeId);
  });
}

function setupToStep2() {
  setupWizardStep = 2;
  updateSetupStockInfo();
  showSetupStep('setupStep2');
}

function adjustSetupStock(delta) {
  setupStock = Math.max(0, Math.min(999, setupStock + delta));
  document.getElementById('setupStockValue').textContent = setupStock;
  updateSetupStockInfo();
}

function updateSetupStockInfo() {
  const spec = LABEL_TYPES[setupLabelType];
  const lps = spec.cols * spec.rows;
  const totalLabels = setupStock * lps;
  
  document.getElementById('setupStockValue').textContent = setupStock;
  document.getElementById('setupStockInfo').innerHTML = 
    '<strong>' + totalLabels + ' labels</strong> total (' + lps + ' per sheet)';
}

function setupToStep3() {
  setupWizardStep = 3;
  renderSetupSummary();
  showSetupStep('setupStep3');
}

function renderSetupSummary() {
  const spec = LABEL_TYPES[setupLabelType];
  const lps = spec.cols * spec.rows;
  const totalLabels = setupStock * lps;
  
  document.getElementById('setupSummary').innerHTML = 
    '<div class="setup-summary-item">' +
      '<span class="setup-summary-label">Label Type</span>' +
      '<span class="setup-summary-value">Avery ' + setupLabelType + '</span>' +
    '</div>' +
    '<div class="setup-summary-item">' +
      '<span class="setup-summary-label">Size</span>' +
      '<span class="setup-summary-value">' + spec.sizeDisplay + ' (' + spec.desc + ')</span>' +
    '</div>' +
    '<div class="setup-summary-item">' +
      '<span class="setup-summary-label">Blank Sheets</span>' +
      '<span class="setup-summary-value">' + setupStock + ' sheets</span>' +
    '</div>' +
    '<div class="setup-summary-item">' +
      '<span class="setup-summary-label">Total Labels</span>' +
      '<span class="setup-summary-value">' + totalLabels + ' labels</span>' +
    '</div>';
}

function finishSetup() {
  // Save inventory
  inventory[setupLabelType] = {
    stock: setupStock,
    lowThreshold: DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  
  // Save as last used type
  settings.lastLabelType = setupLabelType;
  saveSettings();
  
  // Optionally create a sheet
  const createSheetChecked = document.getElementById('setupCreateSheet').checked;
  
  closeWizard('setupWizard');
  renderCurrentTab();
  
  if (createSheetChecked) {
    const spec = LABEL_TYPES[setupLabelType];
    const sheetName = spec.desc + ' Sheet';
    const sheetId = createSheet(sheetName, setupLabelType, 1, '');
    
    // Offer to print sheet label
    offerPrintSheetLabel(sheetId);
  } else {
    showToast('Inventory set up for Avery ' + setupLabelType, 'success', 4000);
  }
}

function setupAddAnother() {
  // Save current type to inventory first
  inventory[setupLabelType] = {
    stock: setupStock,
    lowThreshold: DEFAULT_LOW_THRESHOLD
  };
  saveInventory();
  
  // Optionally create a sheet for current type
  const createSheetChecked = document.getElementById('setupCreateSheet').checked;
  if (createSheetChecked) {
    const spec = LABEL_TYPES[setupLabelType];
    const sheetName = spec.desc + ' Sheet';
    createSheet(sheetName, setupLabelType, 1, '');
    // Note: Not offering print label here since user is adding another type
  }
  
  // Show confirmation toast
  const msg = createSheetChecked 
    ? 'Added Avery ' + setupLabelType + ' with sheet'
    : 'Added Avery ' + setupLabelType + ' to inventory';
  showToast(msg, 'success', 2000);
  
  // Reset and go back to step 1
  setupLabelType = null;
  setupStock = 0;
  setupWizardStep = 1;
  
  // Re-render type grid (some types may now be already tracked)
  renderSetupTypeGrid();
  showSetupStep('setupStep1');
}

// ============================================================================
// MAILING LIST WIZARD
// ============================================================================

let mailingWizardStep = 1;
let mailingCsvData = [];
let mailingCsvColumns = [];
let mailingSelectedTemplate = null;
let mailingColumnMap = {};
let mailingLabelType = '5160';

function showMailingStep(stepId) {
  const wizard = document.getElementById('mailingWizard');
  wizard.querySelectorAll('.wizard-step').forEach(step => {
    step.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
}

function mailingWizardBack() {
  if (mailingWizardStep === 1) {
    closeWizard('mailingWizard');
  } else if (mailingWizardStep === 2) {
    mailingWizardStep = 1;
    showMailingStep('mailingStep1');
  } else if (mailingWizardStep === 3) {
    mailingWizardStep = 2;
    showMailingStep('mailingStep2');
  } else if (mailingWizardStep === 4) {
    mailingWizardStep = 3;
    showMailingStep('mailingStep3');
  } else if (mailingWizardStep === 5) {
    mailingWizardStep = 4;
    showMailingStep('mailingStep4');
  }
}

// CSV parsing
function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  if (lines.length < 2) return { columns: [], data: [] };
  
  // Detect delimiter (comma or tab)
  const firstLine = lines[0];
  const delimiter = firstLine.includes('\t') ? '\t' : ',';
  
  // Parse header
  const columns = parseCSVLine(firstLine, delimiter);
  
  // Parse data rows
  const data = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    const values = parseCSVLine(line, delimiter);
    const row = {};
    columns.forEach((col, idx) => {
      row[col.toLowerCase().replace(/\s+/g, '_')] = values[idx] || '';
    });
    data.push(row);
  }
  
  return { columns, data };
}

function parseCSVLine(line, delimiter) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === delimiter && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  result.push(current.trim());
  return result;
}

function handleMailingFile(file) {
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    const parsed = parseCSV(text);
    
    if (parsed.data.length === 0) {
      showToast('No data found in file. Make sure it has a header row and at least one data row.', 'error', 5000);
      return;
    }
    
    mailingCsvData = parsed.data;
    mailingCsvColumns = parsed.columns;
    
    // Update UI
    document.getElementById('mailingUploadArea').style.display = 'none';
    document.getElementById('mailingFileInfo').style.display = 'flex';
    document.getElementById('mailingFileName').textContent = file.name;
    document.getElementById('mailingFileMeta').textContent = parsed.data.length + ' rows, ' + parsed.columns.length + ' columns';
    document.getElementById('mailingStep1Next').disabled = false;
  };
  reader.readAsText(file);
}

function clearMailingFile() {
  mailingCsvData = [];
  mailingCsvColumns = [];
  document.getElementById('mailingUploadArea').style.display = 'block';
  document.getElementById('mailingFileInfo').style.display = 'none';
  document.getElementById('mailingFileInput').value = '';
  document.getElementById('mailingStep1Next').disabled = true;
}

// Step 2: Template selection
function mailingToStep2() {
  mailingWizardStep = 2;
  renderMailingTemplates();
  showMailingStep('mailingStep2');
}

function renderMailingTemplates() {
  const container = document.getElementById('mailingTemplateList');
  const templates = getTemplates();
  
  let html = '';
  for (const t of templates) {
    const tokens = t.tokens || [];
    const selected = mailingSelectedTemplate && mailingSelectedTemplate.id === t.id;
    html += '<div class="mailing-template-card' + (selected ? ' selected' : '') + '" data-id="' + t.id + '" onclick="selectMailingTemplate(\'' + t.id + '\')">' +
      '<div class="mailing-template-name">' + escapeHtml(t.name) + (t.builtin ? ' <span style="color:var(--text-muted);font-weight:normal;font-size:12px;">(built-in)</span>' : '') + '</div>' +
      '<div class="mailing-template-tokens">{' + tokens.join('} {') + '}</div>' +
    '</div>';
  }
  
  if (templates.length === 0) {
    html = '<div style="text-align:center;padding:20px;color:var(--text-muted);">No templates available. Create a template first in the Templates tab.</div>';
  }
  
  container.innerHTML = html;
}

function selectMailingTemplate(templateId) {
  const templates = getTemplates();
  mailingSelectedTemplate = templates.find(t => t.id === templateId);
  
  document.querySelectorAll('.mailing-template-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.id === templateId);
  });
  
  document.getElementById('mailingStep2Next').disabled = !mailingSelectedTemplate;
}

// Step 3: Column mapping
function mailingToStep3() {
  mailingWizardStep = 3;
  
  // Auto-map columns based on TOKEN_ALIASES
  mailingColumnMap = {};
  const tokens = mailingSelectedTemplate.tokens || [];
  
  for (const token of tokens) {
    // Try exact match first
    const exactMatch = mailingCsvColumns.find(col => 
      col.toLowerCase().replace(/\s+/g, '_') === token
    );
    if (exactMatch) {
      mailingColumnMap[token] = exactMatch.toLowerCase().replace(/\s+/g, '_');
      continue;
    }
    
    // Try aliases
    const aliases = TOKEN_ALIASES[token] || [];
    for (const alias of aliases) {
      const aliasMatch = mailingCsvColumns.find(col => 
        col.toLowerCase() === alias.toLowerCase()
      );
      if (aliasMatch) {
        mailingColumnMap[token] = aliasMatch.toLowerCase().replace(/\s+/g, '_');
        break;
      }
    }
  }
  
  renderMailingMapping();
  showMailingStep('mailingStep3');
}

function renderMailingMapping() {
  const container = document.getElementById('mailingMappingList');
  const tokens = mailingSelectedTemplate.tokens || [];
  
  let html = '';
  for (const token of tokens) {
    html += '<div class="mailing-mapping-row">' +
      '<div class="mailing-mapping-token">{' + token + '}</div>' +
      '<div class="mailing-mapping-arrow">â†</div>' +
      '<select class="mailing-mapping-select" data-token="' + token + '" onchange="updateMailingMap(\'' + token + '\', this.value)">' +
        '<option value="">(not mapped)</option>';
    
    for (const col of mailingCsvColumns) {
      const colKey = col.toLowerCase().replace(/\s+/g, '_');
      const selected = mailingColumnMap[token] === colKey;
      html += '<option value="' + colKey + '"' + (selected ? ' selected' : '') + '>' + escapeHtml(col) + '</option>';
    }
    
    html += '</select></div>';
  }
  
  container.innerHTML = html;
}

function updateMailingMap(token, value) {
  if (value) {
    mailingColumnMap[token] = value;
  } else {
    delete mailingColumnMap[token];
  }
}

// Step 4: Label type
function mailingToStep4() {
  mailingWizardStep = 4;
  
  // Use template's label type if specified
  if (mailingSelectedTemplate.labelType && LABEL_TYPES[mailingSelectedTemplate.labelType]) {
    mailingLabelType = mailingSelectedTemplate.labelType;
  }
  
  renderMailingTypeGrid();
  showMailingStep('mailingStep4');
}

function renderMailingTypeGrid() {
  const grid = document.getElementById('mailingTypeGrid');
  let html = '';
  
  for (const typeId of TYPE_ORDER) {
    const spec = LABEL_TYPES[typeId];
    const lps = spec.cols * spec.rows;
    const selected = typeId === mailingLabelType;
    html += '<div class="type-card' + (selected ? ' selected' : '') + '" data-type="' + typeId + '" onclick="selectMailingType(\'' + typeId + '\')">' +
      '<div class="type-card-name">' + typeId + '</div>' +
      '<div class="type-card-desc">' + spec.desc + '</div>' +
      '<div class="type-card-details">' + spec.sizeDisplay + ' Â· ' + lps + '/sheet</div>' +
    '</div>';
  }
  grid.innerHTML = html;
}

function selectMailingType(typeId) {
  mailingLabelType = typeId;
  document.querySelectorAll('#mailingTypeGrid .type-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.type === typeId);
  });
}

// Step 5: Preview & Print
function mailingToStep5() {
  mailingWizardStep = 5;
  renderMailingPreview();
  showMailingStep('mailingStep5');
}

function renderMailingPreview() {
  const spec = LABEL_TYPES[mailingLabelType];
  const lps = spec.cols * spec.rows;
  const count = mailingCsvData.length;
  const sheetsNeeded = Math.ceil(count / lps);
  
  // Summary
  document.getElementById('mailingSummary').innerHTML = 
    '<div class="mailing-summary-count">' + count + ' labels</div>' +
    '<div class="mailing-summary-text">Avery ' + mailingLabelType + ' Â· ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : '') + ' needed</div>';
  
  // Preview first few labels
  const previewContainer = document.getElementById('mailingPreviewScroll');
  let html = '';
  const previewCount = Math.min(5, count);
  
  for (let i = 0; i < previewCount; i++) {
    const record = mailingCsvData[i];
    const labelHtml = renderMailingLabelPreview(record);
    html += '<div class="mailing-preview-label">' + labelHtml + '</div>';
  }
  
  if (count > previewCount) {
    html += '<div class="mailing-preview-more">+' + (count - previewCount) + ' more</div>';
  }
  
  previewContainer.innerHTML = html;
}

function renderMailingLabelPreview(record) {
  const templateText = mailingSelectedTemplate.text;
  const lines = deserializeLines(templateText);
  
  let html = '';
  for (const line of lines) {
    let text = line.text;
    // Replace tokens with record values
    text = text.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, token) => {
      const key = token.toLowerCase();
      const mappedCol = mailingColumnMap[key];
      if (mappedCol && record[mappedCol]) {
        return record[mappedCol];
      }
      return '';
    });
    
    if (text.trim()) {
      const align = line.align || 'left';
      html += '<div style="text-align:' + align + ';">' + escapeHtml(text) + '</div>';
    }
  }
  return html;
}

function executeMailingPrint() {
  const spec = LABEL_TYPES[mailingLabelType];
  const lps = spec.cols * spec.rows;
  const count = mailingCsvData.length;
  
  // Calculate sheets needed
  const sheetsNeeded = Math.ceil(count / lps);
  
  // Create a new sheet for this mailing job
  const sheetName = 'Mailing ' + new Date().toLocaleDateString();
  const sheetId = generateId();
  sheets[sheetId] = {
    id: sheetId,
    name: sheetName,
    labelType: mailingLabelType,
    sheetCount: sheetsNeeded,
    printed: [],
    created: Date.now()
  };
  const sheet = sheets[sheetId];
  activeSheetId = sheetId;
  saveSheets();
  
  // Build print HTML
  const printLabels = [];
  for (let i = 0; i < count; i++) {
    const record = mailingCsvData[i];
    const lines = buildMailingLabelLines(record);
    printLabels.push({ lines, position: i });
  }
  
  // Generate print HTML
  const printHtml = buildBatchPrintHtml(printLabels, spec);
  
  // Use iframe for printing
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);
  
  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(printHtml);
  iframeDoc.close();
  
  iframe.contentWindow.focus();
  iframe.contentWindow.print();
  
  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  
  // Close wizard first
  closeWizard('mailingWizard');
  
  // After print dialog closes, ask user to confirm
  showConfirm(
    count + ' label' + (count !== 1 ? 's' : '') + ' were sent to the printer.\n\nDid the print complete successfully?',
    'ðŸ–¨ï¸ Confirm Print',
    'Yes, printed OK',
    false,
    (confirmed) => {
      if (confirmed) {
        // Mark positions as printed
        for (let i = 0; i < count; i++) {
          sheet.printed.push(i);
        }
        saveSheets();
        
        // Add to history
        printHistory.unshift({
          id: generateId(),
          timestamp: Date.now(),
          sheetId: sheetId,
          textName: 'Mailing List (' + count + ')',
          count: count,
          labelType: mailingLabelType
        });
        savePrintHistory();
        
        showToast('Printed ' + count + ' labels on ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : ''), 'success', 4000);
      } else {
        // User cancelled - delete the sheet we created
        delete sheets[sheetId];
        activeSheetId = null;
        saveSheets();
        showToast('Print cancelled â€” no labels marked as used', 'warning');
      }
      renderCurrentTab();
    }
  );
}

function buildMailingLabelLines(record) {
  const templateText = mailingSelectedTemplate.text;
  const templateLines = deserializeLines(templateText);
  
  const lines = [];
  for (const tl of templateLines) {
    let text = tl.text;
    text = text.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, token) => {
      const key = token.toLowerCase();
      const mappedCol = mailingColumnMap[key];
      if (mappedCol && record[mappedCol]) {
        return record[mappedCol];
      }
      return '';
    });
    
    if (text.trim()) {
      lines.push({ ...tl, text });
    }
  }
  return lines;
}

function buildBatchPrintHtml(labels, spec) {
  const lps = spec.cols * spec.rows;
  
  // Safari scale fix
  const safariScale = 1.0;
  
  let html = '<!DOCTYPE html><html><head><style>';
  html += '@page { size: letter; margin: 0 !important; }';
  html += 'html, body { margin: 0 !important; padding: 0 !important; }';
  if (isSafari) {
    html += '.sheet-wrapper { width: 8.5in; height: 11in; overflow: hidden; page-break-after: always; }';
    html += '.sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; overflow: hidden; transform: scale(' + safariScale + '); transform-origin: top left; }';
  } else {
    html += '.sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; overflow: hidden; page-break-after: always; }';
  }
  html += '.label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; justify-content:center; padding:0.08in 0.12in; box-sizing:border-box; }';
  html += '.label-line { line-height: 1.3; }';
  html += '</style></head><body>';
  
  const sheetsNeeded = Math.ceil(labels.length / lps);
  
  // Get manual print offsets only
  const offsetTop = settings.printOffsetTop || 0;
  const offsetLeft = settings.printOffsetLeft || 0;
  
  for (let s = 0; s < sheetsNeeded; s++) {
    if (isSafari) {
      html += '<div class="sheet-wrapper"><div class="sheet">';
    } else {
      html += '<div class="sheet">';
    }
    
    for (let i = 0; i < lps; i++) {
      const labelIdx = s * lps + i;
      if (labelIdx >= labels.length) break;
      
      const label = labels[labelIdx];
      const row = Math.floor(i / spec.cols);
      const col = i % spec.cols;
      
      const top = spec.topMargin + row * (spec.labelH + spec.vGutter) + offsetTop;
      const left = spec.leftMargin + col * (spec.labelW + spec.hGutter) + offsetLeft;
      
      html += '<div class="label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;">';
      
      for (const line of label.lines) {
        const align = line.align || 'left';
        const fontSize = line.fontSize || 11;
        html += '<div class="label-line" style="text-align:' + align + ';font-size:' + fontSize + 'pt;">' + escapeHtml(line.text) + '</div>';
      }
      
      html += '</div>';
    }
    
    html += '</div>';
    if (isSafari) {
      html += '</div>';
    }
  }
  
  html += '</body></html>';
  return html;
}

// ============================================================================
// BATCH CSV IMPORT (ported from v1.2)
// ============================================================================

function showBatchImportModal(templateId) {
  if (hasActiveJob()) {
    showToast('A batch job is already active. Complete or cancel it before starting a new one.', 'error');
    return;
  }

  const tpl = getBuiltinTemplate(templateId) || savedTexts.find(s => s.id === templateId);
  if (!tpl || tpl.type !== 'template') {
    showToast('Template not found.', 'error');
    return;
  }

  batchTemplateId = templateId;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];

  document.getElementById('batchTemplateName').textContent = tpl.name;
  document.getElementById('batchFileZone').className = 'batch-file-zone';
  document.getElementById('batchFileZone').innerHTML = '<span class="file-icon">ðŸ“„</span><span class="file-prompt">Click to select a CSV file or drag & drop here</span>';
  document.getElementById('batchMappingSection').style.display = 'none';
  document.getElementById('batchCreateBtn').style.display = 'none';
  document.getElementById('batchFileInput').value = '';

  // Set default job name
  const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  document.getElementById('batchJobName').value = tpl.name + ' â€” ' + today;

  document.getElementById('batchImportModal').classList.add('visible');
}

function closeBatchImportModal() {
  document.getElementById('batchImportModal').classList.remove('visible');
  batchTemplateId = null;
  batchCsvData = null;
  batchCsvFileName = null;
  batchColTokenMap = [];
}

// Handle CSV file selection
function handleBatchFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  processBatchFile(file);
}

function processBatchFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    const parsed = parseCSV(text);
    if (!parsed || !parsed.rows.length) {
      showToast('Could not parse CSV file. Please check the format.', 'error');
      return;
    }
    batchCsvData = parsed;
    batchCsvFileName = file.name;

    // Update file zone
    const zone = document.getElementById('batchFileZone');
    zone.className = 'batch-file-zone has-file';
    zone.innerHTML = '<span class="file-name">âœ… ' + escapeHtml(file.name) + '</span>' +
      '<span class="file-info">' + parsed.rows.length + ' rows Ã— ' + parsed.headers.length + ' columns</span>';

    // Build column mapping
    buildBatchColMapping();
    updateBatchSummary();
    updateBatchPreview();

    document.getElementById('batchMappingSection').style.display = '';
    document.getElementById('batchCreateBtn').style.display = '';
  };
  reader.readAsText(file);
}

// Parse CSV text into { headers: [], rows: [[]] }
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim());
  if (lines.length < 2) return null; // Need header + at least 1 row

  // Simple CSV parse (handles quoted fields)
  function parseLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += ch;
      }
    }
    result.push(current.trim());
    return result;
  }

  const headers = parseLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const row = parseLine(lines[i]);
    if (row.some(c => c)) rows.push(row); // Skip empty rows
  }

  return { headers, rows };
}

// Auto-map CSV columns to template tokens
function autoMapColumns(columns, tokens) {
  const mapping = new Array(columns.length).fill(null);
  const usedTokens = new Set();

  for (let c = 0; c < columns.length; c++) {
    const colLower = (columns[c] || '').toLowerCase().trim();
    // Try exact match first
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      if (colLower === token || colLower === token.replace(/_/g, ' ')) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
    if (mapping[c]) continue;
    // Try alias match
    for (const token of tokens) {
      if (usedTokens.has(token)) continue;
      const aliases = TOKEN_ALIASES[token] || [];
      if (aliases.some(a => a === colLower)) {
        mapping[c] = token;
        usedTokens.add(token);
        break;
      }
    }
  }
  return mapping;
}

// Build column-to-token mapping UI
function buildBatchColMapping() {
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl || !batchCsvData) return;

  const tokens = tpl.tokens || [];
  const headers = batchCsvData.headers;

  // Auto-map using existing autoMapColumns
  const autoMap = autoMapColumns(headers, tokens);
  batchColTokenMap = autoMap.slice(); // Copy

  let html = '';
  headers.forEach((header, idx) => {
    const autoToken = autoMap[idx] || '';
    html += '<div class="batch-col-row">' +
      '<span class="batch-col-header">' + escapeHtml(header || '(Column ' + (idx + 1) + ')') + '</span>' +
      '<span class="batch-col-arrow">â†’</span>' +
      '<select class="batch-col-token" onchange="updateBatchColMap(' + idx + ',this.value)">' +
        '<option value="">â€” Skip â€”</option>' +
        tokens.map(t => '<option value="' + escapeAttr(t) + '"' + (autoToken === t ? ' selected' : '') + '>{' + escapeHtml(t) + '}</option>').join('') +
      '</select>' +
    '</div>';
  });

  document.getElementById('batchColMapping').innerHTML = html;
}

function updateBatchColMap(colIdx, tokenName) {
  batchColTokenMap[colIdx] = tokenName || null;
  updateBatchSummary();
  updateBatchPreview();
}

function updateBatchSummary() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  const labelType = tpl?.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const rowCount = batchCsvData.rows.length;
  const sheetsNeeded = Math.ceil(rowCount / lps);
  const remainder = rowCount % lps;
  const unusedOnLast = remainder ? lps - remainder : 0;

  let html = '<div class="batch-summary-row"><span class="label">Records:</span><span class="value">' + rowCount + '</span></div>' +
    '<div class="batch-summary-row"><span class="label">Label type:</span><span class="value">Avery ' + labelType + ' (' + lps + '/sheet)</span></div>' +
    '<div class="batch-summary-row"><span class="label">Sheets needed:</span><span class="value">' + sheetsNeeded + '</span></div>';
  if (unusedOnLast > 0) {
    html += '<div class="batch-summary-row"><span class="label">Unused on last sheet:</span><span class="value">' + unusedOnLast + '</span></div>';
  }
  document.getElementById('batchSummary').innerHTML = html;
}

// Apply a template with record data
function applyTemplate(template, record) {
  const lines = template.text.split('\n');
  return lines.map(line => {
    const colonIdx = line.indexOf(':');
    if (colonIdx === -1) return line;
    const prefix = line.substring(0, colonIdx + 1);
    let content = line.substring(colonIdx + 1);
    // Replace tokens
    content = content.replace(/\{([a-z][a-z0-9_]*)\}/gi, (match, tokenName) => {
      const val = record[tokenName.toLowerCase()];
      return val !== undefined && val !== null ? val : '';
    });
    return prefix + content;
  }).join('\n');
}

function updateBatchPreview() {
  if (!batchCsvData) return;
  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  // Build preview for first 3 records
  const previewRecords = batchCsvData.rows.slice(0, 3);
  const headers = batchCsvData.headers;

  let html = previewRecords.map((row, ridx) => {
    // Build record object
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx]) {
        record[token] = row[cidx];
      }
    });

    // Apply template
    const renderedText = applyTemplate(tpl, record);
    const lines = deserializeLines(renderedText);

    // Render as mini preview
    let previewHtml = lines.map(l => {
      if (!l.text) return '';
      const alignClass = 'align-' + (l.align || 'left');
      return '<div class="preview-line ' + alignClass + '">' + escapeHtml(l.text) + '</div>';
    }).join('');

    return '<div class="batch-preview-card">' + previewHtml + '</div>';
  }).join('');

  if (batchCsvData.rows.length > 3) {
    html += '<div class="batch-preview-more">+' + (batchCsvData.rows.length - 3) + ' more</div>';
  }

  document.getElementById('batchPreviewCards').innerHTML = html;
}

// Create the batch job
async function createBatchJob() {
  if (!batchCsvData || !batchTemplateId) return;

  const tpl = getBuiltinTemplate(batchTemplateId) || savedTexts.find(s => s.id === batchTemplateId);
  if (!tpl) return;

  const jobName = document.getElementById('batchJobName').value.trim() || 'Batch Job';
  const labelType = tpl.labelType || '5160';
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;
  const headers = batchCsvData.headers;

  // Build list data
  const list = batchCsvData.rows.map(row => {
    const record = {};
    headers.forEach((h, cidx) => {
      const token = batchColTokenMap[cidx];
      if (token && row[cidx] !== undefined) {
        record[token] = row[cidx];
      }
    });
    return record;
  });

  const sheetsNeeded = Math.ceil(list.length / lps);

  // Create job object
  const jobId = 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  activeJob = {
    id: jobId,
    templateId: batchTemplateId,
    name: jobName,
    csvFileName: batchCsvFileName || 'unknown.csv',
    list: list,
    labelType: labelType,
    sheetIds: [],
    printedRowIndices: [],
    status: 'active',
    createdAt: Date.now()
  };

  // Create job sheets
  for (let i = 0; i < sheetsNeeded; i++) {
    const sheetId = 'sh_job_' + Date.now() + '_' + i + '_' + Math.random().toString(36).substr(2, 4);
    const rowStart = i * lps;
    const rowEnd = Math.min((i + 1) * lps, list.length);

    sheets[sheetId] = {
      id: sheetId,
      name: jobName + ' #' + (i + 1),
      labelType: labelType,
      sheetCount: 1,
      printed: [],
      texts: {},
      // Job-specific properties
      jobId: jobId,
      jobSheetIndex: i,
      jobRowStart: rowStart,
      jobRowEnd: rowEnd
    };

    activeJob.sheetIds.push(sheetId);

    // Inventory: deduct from stock if tracked
    if (inventory[labelType]) {
      recordInventoryUse(labelType, 1, 'batch');
    }
  }

  saveActiveJob();
  saveSheets();
  closeBatchImportModal();

  // Switch to Sheets tab and select first job sheet
  activeSheetId = activeJob.sheetIds[0];
  sheetGridPages = {};
  switchTab('sheets');
  renderCurrentTab();

  showToast('Job created: ' + list.length + ' labels across ' + sheetsNeeded + ' sheet' + (sheetsNeeded !== 1 ? 's' : ''), 'success');
}

// Render active job banner
function renderJobBanner() {
  const container = document.getElementById('jobBannerArea');
  if (!container) return;

  if (!activeJob) {
    container.innerHTML = '';
    return;
  }

  const totalRows = activeJob.list.length;
  const printedRows = activeJob.printedRowIndices.length;
  const progressPct = totalRows > 0 ? Math.round((printedRows / totalRows) * 100) : 0;

  // Count sheets complete vs pending
  let sheetsComplete = 0;
  activeJob.sheetIds.forEach(shId => {
    const sh = sheets[shId];
    if (!sh) return;
    const rowsOnSheet = sh.jobRowEnd - sh.jobRowStart;
    const printedOnSheet = activeJob.printedRowIndices.filter(i => i >= sh.jobRowStart && i < sh.jobRowEnd).length;
    if (printedOnSheet >= rowsOnSheet) {
      sheetsComplete++;
    }
  });

  const html = '<div class="job-banner">' +
    '<div class="job-banner-header">' +
      '<div class="job-banner-title"><span class="job-icon">ðŸ“¦</span>' + escapeHtml(activeJob.name) + '</div>' +
      '<div class="job-banner-actions">' +
        '<button class="btn btn-primary btn-sm" onclick="printJobAll()">ðŸ–¨ï¸ Print All</button>' +
        '<button class="btn btn-secondary btn-sm" onclick="cancelJob()">Cancel Job</button>' +
      '</div>' +
    '</div>' +
    '<div class="job-banner-progress">' +
      '<div class="job-progress-bar"><div class="job-progress-fill" style="width:' + progressPct + '%"></div></div>' +
      '<div class="job-progress-text">' + printedRows + ' / ' + totalRows + ' labels</div>' +
    '</div>' +
    '<div class="job-banner-info">' +
      '<span>ðŸ“‹ ' + sheetsComplete + ' of ' + activeJob.sheetIds.length + ' sheets complete</span>' +
      '<span>ðŸ·ï¸ Avery ' + activeJob.labelType + '</span>' +
    '</div>' +
  '</div>';

  container.innerHTML = html;
}

// Print all job sheets
async function printJobAll() {
  if (!activeJob) return;

  const tpl = getBuiltinTemplate(activeJob.templateId) || savedTexts.find(s => s.id === activeJob.templateId);
  if (!tpl) {
    showToast('Template not found for this job.', 'error');
    return;
  }

  const labelType = activeJob.labelType;
  const spec = LABEL_TYPES[labelType];
  const lps = spec.cols * spec.rows;

  // Build print map across all job sheets
  const pageSheets = [];

  activeJob.sheetIds.forEach((shId, shIdx) => {
    const sh = sheets[shId];
    if (!sh) return;

    const pageLabels = [];
    for (let rowIdx = sh.jobRowStart; rowIdx < sh.jobRowEnd; rowIdx++) {
      if (activeJob.printedRowIndices.includes(rowIdx)) continue; // Already printed

      const record = activeJob.list[rowIdx];
      const renderedText = applyTemplate(tpl, record);
      const lines = deserializeLines(renderedText);
      const localIdx = rowIdx - sh.jobRowStart;
      const row = Math.floor(localIdx / spec.cols);
      const col = localIdx % spec.cols;

      pageLabels.push({
        row, col,
        data: { lines, alignV: tpl.alignV || 'center', graphics: tpl.graphics },
        rowIdx: rowIdx
      });
    }

    if (pageLabels.length > 0) {
      pageSheets.push({ sheetId: shId, physicalSheet: shIdx, labels: pageLabels });
    }
  });

  if (!pageSheets.length) {
    showToast('All labels have already been printed.', 'success');
    showJobCompleteModal();
    return;
  }

  const totalLabels = pageSheets.reduce((sum, pg) => sum + pg.labels.length, 0);
  const isTentCard = spec.category === 'tent';
  
  // Get manual print offsets only
  const offsetTop = settings.printOffsetTop || 0;
  const offsetLeft = settings.printOffsetLeft || 0;

  // Build iframe content for multi-page print
  let pagesHtml = '';
  pageSheets.forEach((pg, pi) => {
    let pageHtml = '';
    pg.labels.forEach(lbl => {
      const top = spec.topMargin + lbl.row * (spec.labelH + spec.vGutter) + offsetTop;
      const left = spec.leftMargin + lbl.col * (spec.labelW + spec.hGutter) + offsetLeft;
      const linesHtml = lbl.data.lines.map(l => renderPrintLineHtml(l)).join('');
      
      if (isTentCard) {
        // Tent card - render content on both halves
        pageHtml += '<div class="print-label tent-card" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0;">';
        pageHtml += '<div class="fold-line"></div>';
        pageHtml += '<div class="tent-top">' + linesHtml + '</div>';
        pageHtml += '<div class="tent-bottom">' + linesHtml + '</div>';
        pageHtml += '</div>';
      } else {
        pageHtml += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;justify-content:center;">' + linesHtml + '</div>';
      }
    });
    const breakStyle = pi < pageSheets.length - 1 ? 'page-break-after:always;' : '';
    if (isSafari) {
      pagesHtml += '<div class="print-wrapper" style="' + breakStyle + '"><div class="print-sheet">' + pageHtml + '</div></div>';
    } else {
      pagesHtml += '<div class="print-sheet" style="' + breakStyle + '">' + pageHtml + '</div>';
    }
  });

  // Create and print iframe
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);

  // Safari scale fix - wrapper approach
  const safariScale = 1.0;
  let cssRules = '@page { size: letter; margin: 0 !important; }';
  cssRules += 'html, body { margin: 0 !important; padding: 0 !important; }';
  if (isSafari) {
    cssRules += '.print-wrapper { width: 8.5in; height: 11in; overflow: hidden; }';
    cssRules += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; overflow: hidden; transform: scale(' + safariScale + '); transform-origin: top left; }';
  } else {
    cssRules += '.print-sheet { width: 8.5in; height: 11in; margin: 0; padding: 0; position: relative; overflow: hidden; }';
  }

  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write('<!DOCTYPE html><html><head><style>' +
    cssRules +
    '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }' +
    '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; box-sizing:border-box; }' +
    // Tent card styles
    '.print-label.tent-card { position: relative; }' +
    '.fold-line { position: absolute; left: 0; right: 0; top: 50%; border-top: 1px dashed #bbb; z-index: 1; }' +
    '.tent-top, .tent-bottom { position: absolute; left: 0; right: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 0.1in; box-sizing: border-box; }' +
    '.tent-top { top: 0; height: 50%; }' +
    '.tent-bottom { bottom: 0; height: 50%; transform: rotate(180deg); }' +
    '</style></head><body>' + pagesHtml + '</body></html>');
  iframeDoc.close();

  iframe.contentWindow.focus();
  iframe.contentWindow.print();

  // Ask user if print was successful
  setTimeout(async () => {
    const printed = await showConfirmDialog(
      'Did the print complete successfully?',
      'Print ' + totalLabels + ' labels',
      'Yes, printed OK',
      'No, discard'
    );

    if (printed) {
      // Mark all printed rows
      pageSheets.forEach(pg => {
        pg.labels.forEach(lbl => {
          if (!activeJob.printedRowIndices.includes(lbl.rowIdx)) {
            activeJob.printedRowIndices.push(lbl.rowIdx);
          }
          // Mark position on sheet as printed
          const sh = sheets[pg.sheetId];
          if (sh) {
            const localIdx = lbl.rowIdx - sh.jobRowStart;
            if (!sh.printed.includes(localIdx)) {
              sh.printed.push(localIdx);
            }
          }
        });
      });

      saveActiveJob();
      saveSheets();

      // Add to print history
      addPrintHistoryEntry({
        textName: activeJob.name,
        labelType: labelType,
        count: totalLabels,
        type: 'batch'
      });

      renderCurrentTab();
      renderJobBanner();

      // Check if job is complete
      if (activeJob.printedRowIndices.length >= activeJob.list.length) {
        showJobCompleteModal();
      } else {
        showToast('Printed ' + totalLabels + ' labels', 'success');
      }
    }

    document.body.removeChild(iframe);
  }, 500);
}

function showJobCompleteModal() {
  if (!activeJob) return;
  
  const totalPrinted = activeJob.printedRowIndices.length;
  document.getElementById('jobCompleteCount').textContent = totalPrinted;
  
  // Check if there are remainder positions on last sheet
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];
  const spec = LABEL_TYPES[activeJob.labelType];
  const lps = spec.cols * spec.rows;
  const labelsOnLastSheet = lastSheet ? (lastSheet.jobRowEnd - lastSheet.jobRowStart) : lps;
  const hasRemainder = labelsOnLastSheet < lps;
  
  document.getElementById('jobRemainderOptions').style.display = hasRemainder ? '' : 'none';
  document.getElementById('jobCompleteModal').classList.add('visible');
}

function completeJob() {
  if (!activeJob) return;

  const keepRemainder = document.querySelector('input[name="jobRemainder"]:checked')?.value === 'keep';
  const lastSheetId = activeJob.sheetIds[activeJob.sheetIds.length - 1];
  const lastSheet = sheets[lastSheetId];

  // Save to job history
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'completed',
    completedAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  if (jobHistory.length > 50) jobHistory = jobHistory.slice(0, 50);
  saveJobHistory();

  if (keepRemainder && lastSheet) {
    // Convert last job sheet to regular sheet
    delete lastSheet.jobId;
    delete lastSheet.jobSheetIndex;
    delete lastSheet.jobRowStart;
    delete lastSheet.jobRowEnd;
    lastSheet.name = lastSheet.name.replace(/ #\d+$/, ' (partial)');
    // Delete other job sheets
    activeJob.sheetIds.slice(0, -1).forEach(shId => {
      delete sheets[shId];
    });
  } else {
    // Delete all job sheets
    activeJob.sheetIds.forEach(shId => {
      delete sheets[shId];
    });
  }

  // Clear active job
  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Close modal and refresh UI
  document.getElementById('jobCompleteModal').classList.remove('visible');

  // Select a non-job sheet if available
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job completed successfully!', 'success');
}

// Cancel the active job
async function cancelJob() {
  if (!activeJob) return;

  const ok = await showConfirmDialog(
    'Cancel the batch job "' + activeJob.name + '"? This will delete all job sheets and discard the print data.',
    'Cancel Job',
    'Yes, cancel job',
    'Keep job'
  );

  if (!ok) return;

  // Save to history as cancelled
  const historyEntry = {
    id: activeJob.id,
    name: activeJob.name,
    templateId: activeJob.templateId,
    labelType: activeJob.labelType,
    rowCount: activeJob.list.length,
    csvFileName: activeJob.csvFileName || 'unknown.csv',
    status: 'cancelled',
    cancelledAt: Date.now(),
    createdAt: activeJob.createdAt
  };
  jobHistory.unshift(historyEntry);
  saveJobHistory();

  // Delete all job sheets
  activeJob.sheetIds.forEach(shId => {
    // Return inventory stock
    const sh = sheets[shId];
    if (sh && inventory[sh.labelType]) {
      adjustInventory(sh.labelType, 1);
    }
    delete sheets[shId];
  });

  activeJob = null;
  saveActiveJob();
  saveSheets();

  // Select a non-job sheet
  const regularSheetIds = Object.keys(sheets).filter(id => !sheets[id].jobId);
  activeSheetId = regularSheetIds[0] || null;
  sheetGridPages = {};

  renderCurrentTab();
  renderJobBanner();

  showToast('Batch job cancelled', 'info');
}

// Drag and drop for file upload
document.addEventListener('DOMContentLoaded', function() {
  const uploadArea = document.getElementById('mailingUploadArea');
  if (uploadArea) {
    uploadArea.addEventListener('dragover', function(e) {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', function() {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', function(e) {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        handleMailingFile(e.dataTransfer.files[0]);
      }
    });
  }
  
  // Batch file zone drag/drop
  const batchZone = document.getElementById('batchFileZone');
  if (batchZone) {
    batchZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = 'var(--accent)';
        batchZone.style.background = 'var(--accent-bg)';
      }
    });
    batchZone.addEventListener('dragleave', function() {
      if (!batchZone.classList.contains('has-file')) {
        batchZone.style.borderColor = '';
        batchZone.style.background = '';
      }
    });
    batchZone.addEventListener('drop', function(e) {
      e.preventDefault();
      batchZone.style.borderColor = '';
      batchZone.style.background = '';
      if (e.dataTransfer.files.length > 0 && !batchZone.classList.contains('has-file')) {
        processBatchFile(e.dataTransfer.files[0]);
      }
    });
  }
});

function confirmClearHistory() {
  showConfirm('Clear all print history? This cannot be undone.', 'Clear History', 'Clear', true, (confirmed) => {
    if (confirmed) {
      printHistory = [];
      savePrintHistory();
      showToast('History cleared', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// INVENTORY MANAGEMENT
// ============================================================================

let adjustingInventoryType = null;

function adjustInventory(typeId, delta) {
  if (!inventory[typeId]) return;
  inventory[typeId].stock = Math.max(0, (inventory[typeId].stock || 0) + delta);
  saveInventory();
  renderCurrentTab();
}

function showAddInventoryModal() {
  const select = document.getElementById('addInventoryTypeSelect');
  const existingTypes = Object.keys(inventory);
  
  let html = '';
  for (const typeId of TYPE_ORDER) {
    if (existingTypes.includes(typeId)) continue; // Skip types already in inventory
    const spec = LABEL_TYPES[typeId];
    html += '<option value="' + typeId + '">' + typeId + ' â€” ' + spec.desc + ' (' + spec.sizeDisplay + ')</option>';
  }
  
  if (!html) {
    showToast('All label types are already in your inventory', 'info');
    return;
  }
  
  select.innerHTML = html;
  document.getElementById('addInventoryStock').value = 10;
  document.getElementById('addInventoryThreshold').value = DEFAULT_LOW_THRESHOLD;
  document.getElementById('addInventoryModal').classList.add('visible');
}

function closeAddInventoryModal() {
  document.getElementById('addInventoryModal').classList.remove('visible');
}

function saveAddInventory() {
  const typeId = document.getElementById('addInventoryTypeSelect').value;
  const stock = parseInt(document.getElementById('addInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('addInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[typeId] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  
  // Also save as last used type
  settings.lastLabelType = typeId;
  saveSettings();
  
  closeAddInventoryModal();
  showToast('Inventory type added', 'success');
  renderCurrentTab();
}

function showAdjustInventoryModal(typeId) {
  adjustingInventoryType = typeId;
  const inv = inventory[typeId];
  const spec = LABEL_TYPES[typeId];
  
  document.getElementById('adjustInventoryTitle').textContent = 'Adjust Stock â€” ' + typeId;
  document.getElementById('adjustInventoryStock').value = inv ? inv.stock : 0;
  document.getElementById('adjustInventoryThreshold').value = inv ? inv.lowThreshold : DEFAULT_LOW_THRESHOLD;
  document.getElementById('adjustInventoryModal').classList.add('visible');
}

function closeAdjustInventoryModal() {
  document.getElementById('adjustInventoryModal').classList.remove('visible');
  adjustingInventoryType = null;
}

function saveAdjustInventory() {
  if (!adjustingInventoryType) return;
  
  const stock = parseInt(document.getElementById('adjustInventoryStock').value) || 0;
  const threshold = parseInt(document.getElementById('adjustInventoryThreshold').value) || DEFAULT_LOW_THRESHOLD;
  
  inventory[adjustingInventoryType] = {
    stock: Math.max(0, stock),
    lowThreshold: Math.max(0, threshold)
  };
  saveInventory();
  
  closeAdjustInventoryModal();
  showToast('Inventory updated', 'success');
  renderCurrentTab();
}

function confirmRemoveInventory(typeId) {
  const spec = LABEL_TYPES[typeId];
  showConfirm('Remove ' + typeId + ' (' + spec.desc + ') from inventory tracking?', 'Remove from Inventory', 'Remove', true, (confirmed) => {
    if (confirmed) {
      delete inventory[typeId];
      saveInventory();
      showToast('Removed from inventory', 'success');
      renderCurrentTab();
    }
  });
}

// ============================================================================
// CONFIRM DIALOG
// ============================================================================

let confirmCallback = null;

function showConfirm(message, title, okText, isDanger, callback, cancelText) {
  document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
  document.getElementById('confirmModalMessage').textContent = message;
  const okBtn = document.getElementById('confirmModalOkBtn');
  okBtn.textContent = okText || 'OK';
  okBtn.className = 'wizard-btn wizard-btn-primary' + (isDanger ? ' danger' : '');
  const cancelBtn = document.getElementById('confirmModalCancelBtn');
  cancelBtn.textContent = cancelText || 'Cancel';
  confirmCallback = callback;
  document.getElementById('confirmModal').classList.add('visible');
}

// Promise-based confirm dialog
function showConfirmDialog(message, title, okText, cancelText) {
  return new Promise(resolve => {
    document.getElementById('confirmModalTitle').textContent = title || 'Confirm';
    document.getElementById('confirmModalMessage').textContent = message;
    const okBtn = document.getElementById('confirmModalOkBtn');
    okBtn.textContent = okText || 'OK';
    okBtn.className = 'wizard-btn wizard-btn-primary';
    confirmCallback = resolve;
    document.getElementById('confirmModal').classList.add('visible');
  });
}

function closeConfirmModal(result) {
  document.getElementById('confirmModal').classList.remove('visible');
  if (confirmCallback) {
    confirmCallback(result);
    confirmCallback = null;
  }
}

// Generic modal for custom content
function showGenericModal(title, contentHtml, modalId) {
  let modal = document.getElementById(modalId);
  if (!modal) {
    modal = document.createElement('div');
    modal.id = modalId;
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 480px;">
        <div class="modal-header">
          <div class="modal-title" id="${modalId}Title">${escapeHtml(title)}</div>
          <button class="modal-close" onclick="closeGenericModal('${modalId}')">Ã—</button>
        </div>
        <div class="modal-body" id="${modalId}Body"></div>
      </div>
    `;
    document.body.appendChild(modal);
  } else {
    document.getElementById(modalId + 'Title').textContent = title;
  }
  
  document.getElementById(modalId + 'Body').innerHTML = contentHtml;
  modal.classList.add('visible');
}

function closeGenericModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.remove('visible');
  }
}

// Prompt dialog for text input
let promptCallback = null;
function showPrompt(message, title, defaultValue, callback) {
  // Create prompt modal if it doesn't exist
  let modal = document.getElementById('promptModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'promptModal';
    modal.className = 'modal-overlay';
    modal.innerHTML = `
      <div class="modal" style="max-width: 400px;">
        <div class="modal-header">
          <div class="modal-title" id="promptModalTitle">Enter Value</div>
          <button class="modal-close" onclick="closePromptModal(null)">Ã—</button>
        </div>
        <div class="modal-body">
          <div id="promptModalMessage" style="margin-bottom: 12px;"></div>
          <input type="text" id="promptModalInput" class="modal-input" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--input-bg); color: var(--text); font-size: 14px;">
        </div>
        <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 16px;">
          <button class="wizard-btn wizard-btn-secondary" onclick="closePromptModal(null)">Cancel</button>
          <button class="wizard-btn wizard-btn-primary" onclick="closePromptModal(document.getElementById('promptModalInput').value)">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    // Handle Enter key
    document.getElementById('promptModalInput').addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        closePromptModal(document.getElementById('promptModalInput').value);
      }
    });
  }
  
  document.getElementById('promptModalTitle').textContent = title || 'Enter Value';
  document.getElementById('promptModalMessage').textContent = message;
  document.getElementById('promptModalInput').value = defaultValue || '';
  promptCallback = callback;
  modal.classList.add('visible');
  setTimeout(() => document.getElementById('promptModalInput').focus(), 100);
}

function closePromptModal(result) {
  document.getElementById('promptModal').classList.remove('visible');
  if (promptCallback) {
    promptCallback(result);
    promptCallback = null;
  }
}

// ============================================================================
// WELCOME / FIRST RUN
// ============================================================================

function checkFirstRun() {
  const firstRunDone = localStorage.getItem(FIRST_RUN_KEY);
  if (firstRunDone === 'done') {
    return false; // Not first run
  }
  return true;
}

function showWelcome() {
  const stats = getDataStats();
  const hasExistingData = stats.sheets > 0 || stats.savedTexts > 0 || stats.inventory > 0;
  
  // Show data status if there's existing data
  const statusEl = document.getElementById('welcomeDataStatus');
  const itemsEl = document.getElementById('welcomeDataItems');
  const setupBtn = document.getElementById('welcomeSetupBtn');
  
  if (hasExistingData) {
    statusEl.style.display = 'block';
    let html = '';
    if (stats.sheets > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“„ ' + stats.sheets + ' sheet' + (stats.sheets !== 1 ? 's' : '') + '</div>';
    }
    if (stats.savedTexts > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ’¾ ' + stats.savedTexts + ' saved text' + (stats.savedTexts !== 1 ? 's' : '') + '</div>';
    }
    if (stats.templates > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“ ' + stats.templates + ' template' + (stats.templates !== 1 ? 's' : '') + '</div>';
    }
    if (stats.inventory > 0) {
      html += '<div class="welcome-data-item has-data">ðŸ“¦ ' + stats.inventory + ' inventory type' + (stats.inventory !== 1 ? 's' : '') + '</div>';
    }
    itemsEl.innerHTML = html;
    setupBtn.style.display = 'none'; // Already has data
  } else {
    statusEl.style.display = 'none';
    setupBtn.style.display = 'block'; // Offer setup wizard
  }
  
  document.getElementById('welcomeModal').classList.add('visible');
}

function closeWelcome(markComplete) {
  document.getElementById('welcomeModal').classList.remove('visible');
  if (markComplete) {
    localStorage.setItem(FIRST_RUN_KEY, 'done');
  }
}

function showSetupWizardFromWelcome() {
  closeWelcome(true);
  setTimeout(() => {

// Keyboard Shortcuts Modal
function showShortcutsModal() {
  document.getElementById('shortcutsModal').classList.add('visible');
}

function closeShortcutsModal() {
  document.getElementById('shortcutsModal').classList.remove('visible');
}
    openSetupWizard();
  }, 100);
}

// Reset welcome screen (for testing)
function resetWelcome() {
  localStorage.removeItem(FIRST_RUN_KEY);
  showWelcome();
}

// ============================================================================
// TOAST NOTIFICATIONS
// ============================================================================

function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  
  const icons = {
    success: 'âœ“',
    error: 'âœ•',
    warning: 'âš ',
    info: 'â„¹'
  };
  
  toast.innerHTML = '<span class="toast-icon">' + (icons[type] || icons.info) + '</span>' +
                    '<span class="toast-message">' + escapeHtml(message) + '</span>';
  
  container.appendChild(toast);
  
  // Auto remove
  setTimeout(() => {
    toast.classList.add('exiting');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, duration);
  
  return toast;
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

function safeExecute(fn, errorMessage) {
  try {
    return fn();
  } catch (e) {
    console.error(errorMessage || 'Error:', e);
    showToast(errorMessage || 'Something went wrong', 'error');
    return null;
  }
}

// Wrap localStorage operations with error handling
function safeSave(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (e) {
    console.error('Failed to save data:', e);
    if (e.name === 'QuotaExceededError') {
      showToast('Storage is full. Some data may not be saved.', 'error', 5000);
    } else {
      showToast('Failed to save data', 'error');
    }
    return false;
  }
}

function safeLoad(key, defaultValue) {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultValue;
  } catch (e) {
    console.error('Failed to load data:', e);
    return defaultValue;
  }
}

// ============================================================================
// DATA EXPORT / IMPORT
// ============================================================================

function exportAllData() {
  const data = {
    version: '3.3.22',
    exportedAt: new Date().toISOString(),
    settings: settings,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    printHistory: printHistory,
    customTokens: customTokens
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'labelkeeper-backup-' + new Date().toISOString().slice(0, 10) + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  showToast('Data exported successfully', 'success');
}

function importData(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      
      // Validate it's a LabelKeeper backup
      if (!data.version || !data.exportedAt) {
        showToast('Invalid backup file', 'error');
        return;
      }
      
      // Confirm import
      showConfirm(
        'Import will merge with existing data. Continue?',
        'Import Data',
        'Import',
        false,
        (confirmed) => {
          if (confirmed) {
            performImport(data);
          }
        }
      );
    } catch (err) {
      showToast('Failed to read backup file', 'error');
    }
  };
  reader.readAsText(file);
}

function performImport(data) {
  try {
    // Merge sheets
    if (data.sheets) {
      for (const [id, sheet] of Object.entries(data.sheets)) {
        if (!sheets[id]) {
          sheets[id] = sheet;
        }
      }
      saveSheets();
    }
    
    // Merge saved texts (by ID to avoid duplicates)
    if (data.savedTexts) {
      const existingIds = new Set(savedTexts.map(t => t.id));
      for (const text of data.savedTexts) {
        if (!existingIds.has(text.id)) {
          savedTexts.push(text);
        }
      }
      saveSavedTexts();
    }
    
    // Merge inventory
    if (data.inventory) {
      for (const [type, inv] of Object.entries(data.inventory)) {
        if (!inventory[type]) {
          inventory[type] = inv;
        }
      }
      saveInventory();
    }
    
    // Merge print history
    if (data.printHistory) {
      const existingIds = new Set(printHistory.map(p => p.id));
      for (const entry of data.printHistory) {
        if (!existingIds.has(entry.id)) {
          printHistory.push(entry);
        }
      }
      // Sort by timestamp descending
      printHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      savePrintHistory();
    }
    
    showToast('Data imported successfully', 'success');
    renderCurrentTab();
  } catch (err) {
    console.error('Import error:', err);
    showToast('Failed to import data', 'error');
  }
}

// ============================================================================
// DEVICE SYNC (Firebase-based, no auth required)
// ============================================================================

const FIREBASE_SYNC_URL = 'https://word-boxing-default-rtdb.firebaseio.com/labelkeeper_sync';
const SYNC_CODE_LENGTH = 6;
const SYNC_EXPIRY_MS = 5 * 60 * 1000; // 5 minutes

// Generate a random sync code
function generateSyncCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Avoid confusing chars like 0/O, 1/I
  let code = '';
  for (let i = 0; i < SYNC_CODE_LENGTH; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Show sync modal
function showSyncModal(title, content) {
  document.getElementById('syncModalTitle').textContent = title;
  document.getElementById('syncModalBody').innerHTML = content;
  document.getElementById('syncModal').classList.add('visible');
}

function closeSyncModal() {
  document.getElementById('syncModal').classList.remove('visible');
}

// Start sharing data to another device
async function startSyncShare() {
  const code = generateSyncCode();
  
  // Show loading state
  showSyncModal('Share to Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Preparing sync code...</div>
    </div>
  `);
  
  // Prepare data
  const data = {
    version: '3.3.22',
    exportedAt: new Date().toISOString(),
    expiresAt: Date.now() + SYNC_EXPIRY_MS,
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    inventory: inventory,
    customTokens: customTokens
  };
  
  try {
    // Upload to Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload sync data');
    }
    
    // Show the code
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
          Enter this code on your other device:
        </div>
        <div style="font-size: 36px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; color: var(--accent); margin-bottom: 16px;">
          ${code}
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          Code expires in 5 minutes
        </div>
      </div>
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
        <div style="font-size: 13px; color: var(--text-muted); margin-bottom: 12px;">
          <strong>On your other device:</strong><br>
          Settings â†’ Receive from Another Device â†’ Enter code
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Done</button>
      </div>
    `);
    
    // Schedule cleanup after expiry
    setTimeout(() => cleanupSyncCode(code), SYNC_EXPIRY_MS);
    
  } catch (err) {
    console.error('Sync share error:', err);
    showSyncModal('Share to Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">Failed to create sync code. Please try again.</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">${err.message}</div>
      </div>
      <div style="display: flex; justify-content: center; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
      </div>
    `);
  }
}

// Cleanup sync code from Firebase
async function cleanupSyncCode(code) {
  try {
    await fetch(FIREBASE_SYNC_URL + '/' + code + '.json', {
      method: 'DELETE'
    });
  } catch (err) {
    console.log('Cleanup failed (may already be deleted):', err);
  }
}

// Start receiving data from another device
function startSyncReceive() {
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 16px; color: var(--text-muted); margin-bottom: 16px;">
        Enter the code from your other device:
      </div>
      <input type="text" id="syncCodeInput" 
        style="font-size: 28px; font-weight: bold; font-family: var(--mono); letter-spacing: 4px; 
               text-align: center; width: 100%; max-width: 200px; padding: 12px; 
               border: 2px solid var(--border); border-radius: var(--radius-sm);
               background: var(--input-bg); color: var(--text); text-transform: uppercase;"
        maxlength="${SYNC_CODE_LENGTH}" 
        placeholder="${'â€¢'.repeat(SYNC_CODE_LENGTH)}"
        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
        onkeydown="if(event.key === 'Enter') receiveSyncData()">
      <div id="syncReceiveError" style="color: var(--error-text); font-size: 13px; margin-top: 12px; display: none;"></div>
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
      <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
      <button class="wizard-btn wizard-btn-primary" onclick="receiveSyncData()">Receive Data</button>
    </div>
  `);
  
  // Focus the input
  setTimeout(() => {
    const input = document.getElementById('syncCodeInput');
    if (input) input.focus();
  }, 100);
}

// Receive data using the entered code
async function receiveSyncData() {
  const input = document.getElementById('syncCodeInput');
  const errorEl = document.getElementById('syncReceiveError');
  const code = input.value.trim().toUpperCase();
  
  if (code.length !== SYNC_CODE_LENGTH) {
    errorEl.textContent = 'Please enter a ' + SYNC_CODE_LENGTH + '-character code';
    errorEl.style.display = 'block';
    return;
  }
  
  errorEl.style.display = 'none';
  
  // Show loading
  showSyncModal('Receive from Another Device', `
    <div style="text-align: center; padding: 20px;">
      <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
      <div>Fetching data...</div>
    </div>
  `);
  
  try {
    // Fetch from Firebase
    const response = await fetch(FIREBASE_SYNC_URL + '/' + code + '.json');
    
    if (!response.ok) {
      throw new Error('Network error');
    }
    
    const data = await response.json();
    
    if (!data) {
      throw new Error('Invalid or expired code');
    }
    
    // Check expiry
    if (data.expiresAt && Date.now() > data.expiresAt) {
      // Clean up expired data
      cleanupSyncCode(code);
      throw new Error('This code has expired');
    }
    
    // Validate data structure
    if (!data.version || !data.exportedAt) {
      throw new Error('Invalid sync data');
    }
    
    // Show confirmation with stats
    const sheetCount = data.sheets ? Object.keys(data.sheets).length : 0;
    const textCount = data.savedTexts ? data.savedTexts.length : 0;
    
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">ðŸ“¦</div>
        <div style="font-size: 16px; margin-bottom: 16px;">Ready to import:</div>
        <div style="background: var(--surface-alt); padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px;">
          <div style="font-size: 14px;">ðŸ“„ ${sheetCount} sheet${sheetCount !== 1 ? 's' : ''}</div>
          <div style="font-size: 14px;">ðŸ’¾ ${textCount} saved text${textCount !== 1 ? 's' : ''}</div>
        </div>
        <div style="font-size: 13px; color: var(--text-muted);">
          This will merge with your existing data.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Cancel</button>
        <button class="wizard-btn wizard-btn-primary" onclick="confirmSyncImport()">Import Data</button>
      </div>
    `);
    
    // Store data temporarily for confirmation
    window._pendingSyncData = data;
    window._pendingSyncCode = code;
    
  } catch (err) {
    console.error('Sync receive error:', err);
    showSyncModal('Receive from Another Device', `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 12px;">âŒ</div>
        <div style="color: var(--error-text);">${err.message || 'Failed to fetch data'}</div>
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
          Make sure the code is correct and hasn't expired.
        </div>
      </div>
      <div style="display: flex; justify-content: center; gap: 12px; margin-top: 16px;">
        <button class="wizard-btn wizard-btn-secondary" onclick="closeSyncModal()">Close</button>
        <button class="wizard-btn wizard-btn-primary" onclick="startSyncReceive()">Try Again</button>
      </div>
    `);
  }
}

// Confirm and perform the sync import
function confirmSyncImport() {
  const data = window._pendingSyncData;
  const code = window._pendingSyncCode;
  
  if (!data) {
    closeSyncModal();
    return;
  }
  
  // Use existing import logic
  performImport(data);
  
  // Clean up the sync code from Firebase
  cleanupSyncCode(code);
  
  // Clear temp data
  window._pendingSyncData = null;
  window._pendingSyncCode = null;
  
  closeSyncModal();
  showToast('Data synced successfully!', 'success');
}

// ============================================================================
// CLEAR ALL DATA
// ============================================================================

function clearAllData() {
  showConfirm(
    'This will delete ALL your data including sheets, saved texts, and history. This cannot be undone.',
    'Clear All Data',
    'Delete Everything',
    true,
    (confirmed) => {
      if (confirmed) {
        // Clear all storage keys
        localStorage.removeItem(SHEETS_KEY);
        localStorage.removeItem(ACTIVE_KEY);
        localStorage.removeItem(TEXTS_KEY);
        localStorage.removeItem(INVENTORY_KEY);
        localStorage.removeItem(PRINT_HISTORY_KEY);
        localStorage.removeItem(CUSTOM_TOKENS_KEY);
        localStorage.removeItem(ACTIVE_JOB_KEY);
        localStorage.removeItem(JOB_HISTORY_KEY);
        localStorage.removeItem(FIRST_RUN_KEY);
        
        // Reset state
        sheets = {};
        activeSheetId = null;
        savedTexts = [];
        inventory = {};
        printHistory = [];
        customTokens = [];
        
        showToast('All data cleared', 'success');
        renderCurrentTab();
      }
    }
  );
}

// ========== EVENT HANDLERS ==========
document.addEventListener('keydown', e => {
  // Don't trigger shortcuts when typing in input fields
  const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement?.tagName);
  
  if (e.key === 'Escape') {
    closeSettings();
    closeShortcutsModal();
    if (currentWizard) {
      closeWizard(currentWizard + 'Wizard');
    }
    // Close modals on Escape
    if (document.getElementById('splitModal').classList.contains('visible')) {
      closeSimpleModal('splitModal');
    }
    if (document.getElementById('importTextModal').classList.contains('visible')) {
      closeModal('importTextModal');
    }
  }
  
  // ? key shows shortcuts help (when not typing)
  if (e.key === '?' && !isTyping) {
    showShortcutsModal();
  }
});

// Split modal Enter key handler
document.getElementById('splitName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeSplit();
});

// Import modal Enter key handler  
document.getElementById('importBaseName').addEventListener('keydown', e => {
  if (e.key === 'Enter') executeImport();
});
document.getElementById('importBaseName').addEventListener('input', () => updateImportPreview());

document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', e => {
    if (e.target === overlay) {
      overlay.classList.remove('visible');
    }
  });
});

// ============================================================================
// INITIALIZATION
// ============================================================================

function init() {
  // Load all data
  loadSettings();
  loadSheets();
  loadSavedTexts();
  loadInventory();
  loadActiveJob();
  loadJobHistory();
  loadCustomTokens();
  loadPrintHistory();
  
  // Apply UI state
  applyTheme();
  
  // Check for URL parameters (deep linking)
  const urlParams = parseUrlParams();
  if (urlParams.hasParams) {
    // Small delay to let UI render
    setTimeout(() => handleUrlDeepLink(urlParams), 150);
  } else {
    // Check for first run only if not deep linking
    if (checkFirstRun()) {
      // Small delay to let the UI render first
      setTimeout(showWelcome, 100);
    }
  }
  
  // Log stats for debugging
  const stats = getDataStats();
  console.log('LabelKeeper v3.3.22 initialized', stats);
}

/**
 * Handle URL deep link parameters
 * Opens print wizard with pre-filled data or navigates to a sheet
 */
function handleUrlDeepLink(params) {
  console.log('Deep link detected:', params);
  
  // Clear URL params to prevent re-triggering on reload
  if (window.history.replaceState) {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
  
  // Handle sheet deep link (from QR code)
  if (params.action === 'openSheet' && params.sheetId) {
    console.log('Opening sheet:', params.sheetId);
    const sh = sheets[params.sheetId];
    if (sh) {
      // Set active sheet first
      activeSheetId = params.sheetId;
      // Switch to sheets tab (this will render the tab)
      switchTab('sheets');
      // Give DOM more time to render, then scroll to the sheet
      setTimeout(() => {
        const sheetCard = document.querySelector('.sheet-card[data-sheet-id="' + params.sheetId + '"]');
        console.log('Found sheet card:', sheetCard);
        if (sheetCard) {
          sheetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add highlight animation
          sheetCard.style.boxShadow = '0 0 0 3px var(--accent)';
          setTimeout(() => {
            sheetCard.style.boxShadow = '';
          }, 2000);
        }
        showToast('Opened "' + sh.name + '"', 'success');
      }, 300);
    } else {
      console.log('Sheet not found in sheets object:', Object.keys(sheets));
      showToast('Sheet not found on this device. QR codes only work on the device where the sheet was created.', 'warning', 6000);
    }
    return;
  }
  
  // Handle print wizard deep link
  // Open print wizard
  currentWizard = 'print';
  wizardStep = 2;
  wizardSelectedTextId = null;
  
  // Set up the wizard state
  for (let i = 0; i < 4; i++) {
    wizardLines[i] = {
      text: params.lines[i] || '',
      align: 'left',
      fontSize: 11
    };
  }
  
  // Store type and quantity
  if (params.type) {
    wizardLabelType = params.type;
    settings.lastLabelType = params.type;
    saveSettings();
  }
  
  if (params.qty > 1) {
    wizardQuantity = params.qty;
  }
  
  // Show wizard
  showWizard('printWizard');
  
  // If we have all the info, go directly to preview
  if (params.type && params.lines.some(l => l.trim())) {
    // Store lines for printing
    wizardCurrentLines = getWizardLines();
    wizardStep = 5;
    renderPrintPreview();
    showWizardStep('printStep5');
    showToast('Label ready from link', 'success');
  } else {
    // Go to editor step
    showWizardStep('printStep2a');
    
    // Populate the input fields
    for (let i = 1; i <= 4; i++) {
      const input = document.getElementById('wizLine' + i);
      if (input) {
        input.value = params.lines[i - 1] || '';
      }
    }
    
    updateWizardPreview();
    updateWizardNextButton();
    setTimeout(setupWizardPasteListeners, 50);
    showToast('Text loaded from link', 'info');
  }
}

init();
</script>
</body>
</html>
